---
title: 西门子嵌入式学习
date: 2025-06-02 16:00:53
sticky: true
cover: "https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202506021603366.jpg"
tags:
  - 嵌入式基础
  - GD32学习
categories: MCU
---

## 调度器模板

```C
#include "scheduler.h"
// clang-format off
typedef struct
{
	void (*task_func)(void);
	uint32_t rate_ms;
	uint32_t last_ms;
} task_t;

task_t tasks[] = {
};

uint8_t task_count;

void scheduler_init(void)
{
	task_count = sizeof(tasks) / sizeof(task_t);
}

void scheduler_run(void)
{
	uint8_t i;
	for (i = 0; i < task_count; i++)
	{
		uint32_t now_time = HAL_GetTick();
		if ((uint32_t)(now_time - tasks[i].last_ms) >= tasks[i].rate_ms)
		{
			tasks[i].last_ms = now_time;
			tasks[i].task_func();
		}
	}
}

```



## 时钟配置栏

### 模式设置

![image-20250602161506934](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202506021615783.png)

#### 高速时钟HSE

- `Disable`：不启用外部时钟（默认使用内部时钟） <span style="color:#00FFFF;">内部时钟（内部RC（电阻-电容）振荡器）提供了此便捷性 但精度不如外部时钟（外部低速晶振或陶瓷振荡器）</span>

- `BYPASS Clock Source`：旁路模式，允许直接<span style="color:#00FFFF;">从外部导入时钟信号，而不使用外部晶体</span>。这种模式适用于需要从外部系统或其他设备接收时钟信号的情况。

- `Crystal/Ceramic Resonator`：将外部低速晶振或陶瓷谐振器作为时钟源，一般则是板载上的外部晶振

#### 低速时钟LSE

> 参数同上 通常用于<span style="color:#33FFFF;">实时时钟（RTC</span>）等需要低频稳定时钟的应用。LSE的典型频率为32.768kHz

#### **Master Clock Output**

- 配置是否使能主时钟<span style="color:#33FFFF;">输出到MCO引脚</span>，`即可以通过MCO引脚将时钟信号输出到外部，供其他设备使用`

#### **Audio Clock Input (I2S_CKIN)**：

- 此选项用于配置是否从<span style="color:#33FFFF;">特定的引脚（如I2S_CKIN）输入音频时钟</span>。这对于需要精确音频时钟的音频应用非常重要，`例如I2S音频接口`。

### 参数设置

![image-20250602162859501](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202506021629990.png)

- `TIM Prescaler Selection`：定时器预分频选择，`禁用时使用最大分频值。`

- `HSE Startup Timeout Value (ms)`：HSE（高速外部时钟）启动超时时间，设置为100ms。这是外部晶振启动的最长等待时间，如果超出这个时间晶振还未启动，微控制器会认为启动失败。
- `LSE Startup Timeout Value (ms)`：LSE（低速外部时钟）启动超时时间，设置为5000ms。这通常用于RTC的时钟源，如果超出这个时间晶振还未启动，微控制器会认为启动失败。

- `Power Regulator Voltage Scale`：电源调节器电压等级，设置为`Power Regulator Voltage Scale 3`。这通常与微控制器的性能和功耗有关，不同的电压等级可以提供不同的性能和功耗平衡。

- `Power Over Drive`：电源过驱，禁用。这通常用于在需要更高性能时<span style="color:#33FFFF;">临时提高微控制器的电压</span>，以支持更高的时钟频率。

### 在何处选择了HSI以及HSE

![image-20250602181824740](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202506021818291.png)

- 第一个框一定一定要看硬件上的晶振是多少频率，<span style="color:#00FFFF;">一定要严格按照硬件资源给的 （不要无脑用默认的）</span>

  > 否则可能会出现串口数据接收乱码

- 第二个框选择了用`相位锁定环（PLL） 调整外部高速时钟（HSE）还是内部高速时钟（HSI）

- 第三个框框则直接选择是否选择 经过PLL调整后的时钟，也可以选择不经过PLL的原生外部高速时钟（HSE），以及内部高速时钟（HSI）。

## SYS调试接口选择

![image-20250602182759796](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202506021828146.png)

### Serial Wire (SW-DP)

- 串口烧录 仅需要两个引脚
  - `SWCLK`：主机到从机的时钟信号
  - `SWDIO`：双向数据信号

- 这种模式下，ST-Link工作最稳定，占用引脚少，是日常开发的首选。

### JTAG(JTAG-DP)

- J-Link烧录 需要4或5个引脚：
  - **TCK：**测试时钟
  - **TMS：**测试模式选择
  - **TDI：**测试数据输入
  - **TDO：**测试数据输出
  - **TRST：**测试复位（可选，5pin模式才有）
- JTAG适合复杂的调试场景，尤其是在使用J-Link调试器时。

## LED

### 驱动代码

```C
#include "led_app.h"

uint8_t ucLed[6] = {0, 0, 1, 0, 1, 1};

void Led_disp(uint8_t *ucLed)
{
	uint8_t temp = 0x00, i;
	static uint8_t temp_old = 0xff;
	for (i = 0; i < 6; i++)
	{
		if (ucLed[i])
			temp |= (1 << i);
	}
	if (temp != temp_old)
	{
		HAL_GPIO_WritePin(LED1_GPIO_Port, LED1_Pin, (temp & 0x01) ? GPIO_PIN_SET : GPIO_PIN_RESET);
		HAL_GPIO_WritePin(LED2_GPIO_Port, LED2_Pin, (temp & 0x02) ? GPIO_PIN_SET : GPIO_PIN_RESET);
		HAL_GPIO_WritePin(LED3_GPIO_Port, LED3_Pin, (temp & 0x04) ? GPIO_PIN_SET : GPIO_PIN_RESET);
		HAL_GPIO_WritePin(LED4_GPIO_Port, LED4_Pin, (temp & 0x08) ? GPIO_PIN_SET : GPIO_PIN_RESET);
		HAL_GPIO_WritePin(LED5_GPIO_Port, LED5_Pin, (temp & 0x10) ? GPIO_PIN_SET : GPIO_PIN_RESET);
		HAL_GPIO_WritePin(LED6_GPIO_Port, LED6_Pin, (temp & 0x20) ? GPIO_PIN_SET : GPIO_PIN_RESET);
		temp_old = temp;
	}
}

void led_task(void)
{
	Led_disp(ucLed);
}
```

### 软件PWM呼吸灯

```C
void led_task(void)
{
	static uint32_t breath_counter = 0;			// 呼吸效果内部计时器，模拟时间流逝
	static uint8_t pwm_counter = 0;				// PWM内部计时器，用于生成PWM波形
	static uint8_t brightness = 0;				// 当前的亮度值
	static const uint16_t breath_period = 2000; // 呼吸效果周期，单位ms 调小可增加速度
	static const uint16_t pwm_max = 10;			// PWM最大计数值  调大会降低pwm频率

	breath_counter = (++breath_counter) % breath_period;
        //(2.0f * 3.14159f * breath_counter / breath_period) 将结果映射为0到2π
        //sin(2.0f * 3.14159f * breath_counter / breath_period) 将结果映射为-1到1
        //sin(2.0f * 3.14159f * breath_counter / breath_period) + 1.0f 将结果映射为0到2
        //(sin(2.0f * 3.14159f * breath_counter / breath_period) + 1.0f) * pwm_max / 2.0f 将实际亮度计算出来 通过(uint8_t)强制类型转换
	brightness = (uint8_t)((sin(2.0f * 3.14159f * breath_counter / breath_period) + 1.0f) * pwm_max / 2.0f);
	pwm_counter = (++pwm_counter) % pwm_max;
	for (uint8_t i = 0; i < 6; i++)
		ucLed[i] = (pwm_counter < brightness) ? 1 : 0; //将所有LED置为呼吸灯效果
	Led_disp(ucLed);
}
```

> 如果是要实时调光，则直接赋值`brightness`即可 （即<span style="color:#FF3333;">不需要</span>`breath_counter`和`breath_period`）

## 按键

> 常用工程上所用按键对比
>
> github仓库地址：[bobwenstudy/easy_button: 嵌入式按键处理驱动（Button Driver），支持单击、双击、多击、自动消抖、长按、长长按、超长按 | 低功耗支持 | 组合按键支持 | 静态/动态注册支持](https://github.com/bobwenstudy/easy_button)

![image-20250606171853466](https://fastly.jsdelivr.net/gh/2250272571/tuchuang@main/img/202506061718736.png)

> 整体框架：
> easy_button
>  ├── ebtn
>  │   ├── bit_array.h
>  │   ├── ebtn.c
>  │   └── ebtn.h
>  ├── build.mk
>  ├── example_user.c
>  └── example_test.c
>  ├── main.c
>  ├── Makefile
>  └── README.md

### 使用步骤

#### 第一步：新建button_app.c并包含头文件

```C
#include "ebtn.h" // 包含 ebtn 库头文件
// ... 可能还需要包含你的 HAL 库头文件 ...
// #include "stm32xxx_hal.h"
```

#### 第二步：定义参数与按键列表

1. **定义按键参数 (`ebtn_btn_param_t`):** 使用 `EBTN_PARAMS_INIT` 宏设定按键的各种时间阈值和行为。这些参数可以被多个按键共用。`可用默认参数 即如下default_param_normal`
2. **定义按键实例数组 (`ebtn_btn_t`):** 使用 `EBTN_BUTTON_INIT` 宏创建每个物理按键的实例，并指定它的唯一 `key_id` 和使用的参数。
3. **（可不加）定义组合按键实例数组 (`ebtn_btn_combo_t`, 可选):** 使用 `EBTN_BUTTON_COMBO_INIT` 创建组合键实例，同样指定 `key_id` 和参数。

```C
/* 1. 定义按键参数实例 */
// 参数宏: EBTN_PARAMS_INIT(
//     按下消抖时间ms, 释放消抖时间ms,
//     单击有效最短按下时间ms, 单击有效最长按下时间ms,
//     多次单击最大间隔时间ms,
//     长按(KeepAlive)事件周期ms (0禁用),
//     最大连续有效点击次数 (e.g., 1=单击, 2=双击, ...)
// )
const ebtn_btn_param_t default_param_normal = EBTN_PARAMS_INIT(
    20,     // time_debounce: 按下稳定 20ms(消抖)
    20,     // time_debounce_release: 释放稳定 20ms
    50,     // time_click_pressed_min: 最短单击按下 50ms
    500,    // time_click_pressed_max: 最长单击按下 500ms (超过则不算单击)
    300,    // time_click_multi_max: 多次单击最大间隔 300ms (两次点击间隔超过则重新计数)
    500,    // time_keepalive_period: 长按事件周期 500ms (按下超过 500ms 后，每 500ms 触发一次)
    5       // max_consecutive: 最多支持 5 连击
);

/* 2. 定义静态按键列表 */
// 宏: EBTN_BUTTON_INIT(按键ID, 参数指针)
ebtn_btn_t static_buttons[] = {
    EBTN_BUTTON_INIT(1, &default_param_normal), // KEY1, ID=1, 使用 'default_param_normal' 参数
    EBTN_BUTTON_INIT(2, &default_param_normal), // KEY2, ID=2, 也使用 'default_param_normal' 参数
};

/* 3. 定义静态组合按键列表 (可选) */
// 宏: EBTN_BUTTON_COMBO_INIT(按键ID, 参数指针)
ebtn_btn_combo_t static_combos[] = {
    // 假设 KEY1+KEY2 组合键
    EBTN_BUTTON_COMBO_INIT(101, &default_param_normal), // 组合键, ID=101 (必须与普通按键ID不同)
};

```

#### 第三步：编写回调函数

你需要提供两个函数给 `ebtn` 库，告诉它如何与你的硬件交互以及如何通知你事件：

- **`get_state_fn` (状态获取):** 这个函数被 `ebtn` 调用，用于读取指定按键当前的物理电平。
- **`evt_fn` (事件处理):** 当 `ebtn` 检测到一个有效的按键事件（按下、释放、单击、长按）时，会调用这个函数，并传入触发事件的按键信息和事件类型。

```C
/* 1. 实现获取按键状态的回调函数 */
// 函数原型: uint8_t (*ebtn_get_state_fn)(struct ebtn_btn *btn);
uint8_t my_get_key_state(struct ebtn_btn *btn) {
    // 根据传入的按钮实例中的 key_id 判断是哪个物理按键
    switch (btn->key_id) {
        case 1: // 请求读取 KEY1 的状态
            // 假设 KEY1 接在 PB0，按下为低电平 (返回 1 代表按下)
            return (HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_0) == GPIO_PIN_RESET);
        case 2: // 请求读取 KEY2 的状态
            // 假设 KEY2 接在 PB1，按下为低电平
            return (HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_1) == GPIO_PIN_RESET);
        // ... 可以添加更多按键的读取逻辑 ...
        default:
            // 对于库内部处理组合键等情况，或者未知的 key_id，安全起见返回 0 (未按下)
            return 0;
    }
    // 注意：返回值 1 表示 "活动/按下"，0 表示 "非活动/释放"
}

/* 2. 实现处理按键事件的回调函数 */
// 函数原型: void (*ebtn_evt_fn)(struct ebtn_btn *btn, ebtn_evt_t evt);
void my_handle_key_event(struct ebtn_btn *btn, ebtn_evt_t evt) {
    uint16_t key_id = btn->key_id;                 // 获取触发事件的按键 ID
    uint16_t click_cnt = ebtn_click_get_count(btn); // 获取连击次数 (仅在 ONCLICK 事件时有意义)
    // uint16_t kalive_cnt = ebtn_keepalive_get_count(btn); // 获取长按计数 (仅在 KEEPALIVE 事件时有意义)

    // 调试打印 (可选)
    // printf("Key ID: %d, Event: %d", key_id, evt);

    // 根据事件类型进行处理
    switch (evt) {
        case EBTN_EVT_ONPRESS: // 按下事件 (消抖成功后触发一次)
            // printf(" - Pressed\n");
            // 可以在这里处理按下即触发的操作，比如点亮提示灯
            if (key_id == 1) { /* Do something for KEY1 press */ }
            break;

        case EBTN_EVT_ONRELEASE: // 释放事件 (消抖成功后触发一次)
            // printf(" - Released\n");
            // 可以在这里处理释放时触发的操作
             if (key_id == 1) { /* Do something for KEY1 release */ }
            break;

        case EBTN_EVT_ONCLICK: // 单击/连击事件 (在释放后，或达到最大连击数，或超时后触发)
            // printf(" - Clicked (%d times)\n", click_cnt);
            // --- 根据 key_id 和 click_cnt 执行不同操作 ---
            if (key_id == 1) { // 如果是 KEY1 触发的 CLICK
                if (click_cnt == 1) {
                    // KEY1 单击
                    // printf("  Action: KEY1 Single Click - Toggle LED1\n");
                    // HAL_GPIO_TogglePin(LED1_GPIO_Port, LED1_Pin);
                } else if (click_cnt == 2) {
                    // KEY1 双击
                    // printf("  Action: KEY1 Double Click - Switch Mode\n");
                }
                // ... 可以继续判断 3击, 4击 ...
            } else if (key_id == 2) { // 如果是 KEY2 触发的 CLICK
                 if (click_cnt == 1) {
                    // KEY2 单击
                    // printf("  Action: KEY2 Single Click - Toggle LED2\n");
                 }
            } else if (key_id == 101) { // 如果是组合键 (KEY1+KEY2) 触发的 CLICK
                if (click_cnt == 1) {
                     // 组合键单击
                     // printf("  Action: Combo Key 101 Single Click - Reset System\n");
                }
            }
            break;

        case EBTN_EVT_KEEPALIVE: // 保持活动/长按事件 (按下持续时间超过阈值后，按周期触发)
            // printf(" - Keep Alive (Long Press, Count: %d)\n", kalive_cnt);
            if (key_id == 1) {
                // KEY1 长按
                // printf("  Action: KEY1 Long Press - Increase Volume\n");
            }
            break;

        default: // 未知事件 (理论上不应发生)
            // printf(" - Unknown Event\n");
            break;
    }
}
```

#### 第四步：初始化 ebtn 库

在系统启动的初始化阶段（例如 `main` 函数开始处，或专门的初始化函数中），调用 `ebtn_init` 函数，将之前准备好的按键列表和回调函数"注册"给 `ebtn` 库。

如果使用了组合按键，还需要在 `ebtn_init` **之后**，调用相关函数将普通按键绑定到组合键上。

```C
void button_init(void)
{
    ebtn_init(
        static_buttons,                 // 静态按键数组的指针
        EBTN_ARRAY_SIZE(static_buttons), // 静态按键数量 (用宏计算)
        static_combos,                  // 静态组合按键数组的指针 (如果没有，传 NULL, 0)
        EBTN_ARRAY_SIZE(static_combos), // 静态组合按键数量 (如果没有，传 0)
        my_get_key_state,               // 你的状态获取回调函数
        my_handle_key_event             // 你的事件处理回调函数
    );
}
//下面这个函数可以在调度器中每5秒调用
void button_task(void)
{
    ebtn_process(uwTick);
}
```

## SD+FATFS

### CubeMX配置

![image-20250923205942773](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509232059309.png)

![image-20250923210029131](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509232100265.png)

![image-20250928114434875](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509281144270.png)

> 注意：如果TF-CARD上的CD引脚有接入gpio的话 可以将platform设置为该引脚 即检测SD卡引脚
>
> - 当该引脚为低电平时，则检测到sd卡
>
> - 没有接gpio的话，platform不要设置 不然会读取不到卡
>
>   ![image-20250923210313143](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509232103277.png)
>
>   正点原子探索者v3没有设计该引脚 所以留空即可
>
>   ![image-20250923210355410](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509232103527.png)

### 使用步骤

#### 初始化

```C
 SD_Driver.disk_initialize(0); // SD_Driver已经被声明在FATFS/Target/sd_diskio.c
```

