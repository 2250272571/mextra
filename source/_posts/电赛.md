---
title: 电赛
date: 2025-06-08 13:22:05
cover: "https://fastly.jsdelivr.net/gh/2250272571/tuchuang@main/img/202506081324376.png"
tags:
  - 电赛准备
---

## PID

![image-20250608132624784](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202506081334606.png)

- 其中 e 为误差
- P：正比  即控制摆动
- I：积分 积累误差，可用来消除稳定误差 （比如无人机中，向下吹的风刚好是1米，但p中最后上升也是1米 即形成一种稳态）
- D：微分 速度控制 可用来让系统快速停下来

## 编码器

### CubeMX配置

![image-20250612212624882](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202506122126276.png)

#### 参数解析

1. Encoder Mode

- `Encoder Mode TI1` ：只保留A相，滤除B相数据

- `Encoder Mode TI2` ：只保留B相，滤除A相数据

- `Encoder Mode TI1 and TI2`：A、B相都保留，数据波长会是第一、二模式的两倍

  > 一般用于高精度场合 如小车

### 代码编写

#### 初始化

```C
  HAL_TIM_Encoder_Start(&htim3, TIM_CHANNEL_1); // 开启编码器A
  HAL_TIM_Encoder_Start(&htim3, TIM_CHANNEL_2); // 开启编码器A
```

#### 获取编码器值

> 记得先接上编码器的电源 他与电机是分开的电源  工作电压为3.3V~5V

```C
g_nMotor_Lef_Pulse = (short)(__HAL_TIM_GET_COUNTER(&htim3)); // 获取计数器值
__HAL_TIM_SET_COUNTER(&htim3, 0);							 // 左编码器TIM3计数器清零
```

## 超声波

### CubeMX配置

![image-20250612213408605](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202506122134910.png)

![image-20250612214851115](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202506122148018.png)

### 初始化

```C
Hcsr04Init(&htim11, TIM_CHANNEL_1); //  超声波模块初始化
```

### 注册回调函数与绑定定时器溢出回调函数

```C
void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim)
{
	if (htim->Instance == TIM11)
		Hcsr04TimIcIsr(&htim11);
}

void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
{
  if (htim->Instance == TIM11)
  {
    Hcsr04TimOverflowIsr(&htim11);
  }
}
```

### 获取距离值

```C
Hcsr04Start();
printf("distance:%.1f cm\r\n", Hcsr04Read());
HAL_Delay(300); // 可适当加些延时
```

## JY60陀螺仪

### CubeMX配置

![image-20250612215946547](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202506122159648.png)

![image-20250612220017334](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202506122200718.png)

### 初始化

- 引入官方sdk `wit_c_sdk.h与wit_c_sdk.c`
- 新建驱动文件 `jy60.c`与 `jy60.h`

```C
jy60_init();
/*
void jy60_init(void)
{
		WitInit(WIT_PROTOCOL_NORMAL, 0x50);
		WitSerialWriteRegister(SensorUartSend);
		WitRegisterCallBack(SensorDataUpdata);
		WitDelayMsRegister(Delayms);
		HAL_Delay(100);
}
*/
```

### 获取加速度、角速度、姿态角

```C
jy60_read();
/*
void jy60_read(void)
{
		if(s_cDataUpdate)
		{
			for(uint8_t i = 0; i < 3; i++)
			{
				fAcc[i] = sReg[AX+i] / 32768.0f * 16.0f;
				fGyro[i] = sReg[GX+i] / 32768.0f * 2000.0f;
				fAngle[i] = sReg[Roll+i] / 32768.0f * 180.0f;
			}
//			uint8_t strff[21];
//			
//			sprintf(strff,"%.2f",fAngle[2]);
//			
//			OLED_ShowStr(0,3,strff,1);
			if(s_cDataUpdate & ACC_UPDATE)
			{
//				printf("acc:%.3f %.3f %.3f\r\n", fAcc[0], fAcc[1], fAcc[2]);
				s_cDataUpdate &= ~ACC_UPDATE;
			}
			if(s_cDataUpdate & GYRO_UPDATE)
			{
//				printf("gyro:%.3f %.3f %.3f\r\n", fGyro[0], fGyro[1], fGyro[2]);
				s_cDataUpdate &= ~GYRO_UPDATE;
			}
			if(s_cDataUpdate & ANGLE_UPDATE)
			{
				printf("angle:%.3f %.3f %.3f\r\n", fAngle[0], fAngle[1], fAngle[2]);
				s_cDataUpdate &= ~ANGLE_UPDATE;
			}
			if(s_cDataUpdate & MAG_UPDATE)
			{
				//printf("mag:%d %d %d\r\n", sReg[HX], sReg[HY], sReg[HZ]);
				s_cDataUpdate &= ~MAG_UPDATE;
			}
		}
		
}
*/
```

| 变量名   | 含义                    | 单位            | 来源寄存器             |
| -------- | ----------------------- | --------------- | ---------------------- |
| `fAcc`   | 加速度（Accelerometer） | M/s²            | `AX`、`AY`、`AZ`       |
| `fGyro`  | 角速度（Gyroscope）     | °/s（角度每秒） | `GX`、`GY`、`GZ`       |
| `fAngle` | 姿态角（Angle）         | °（角度）       | `Roll`、`Pitch`、`Yaw` |

| 下标 | fAcc       | fGyro      | fAngle          |
| ---- | ---------- | ---------- | --------------- |
| [0]  | X 轴加速度 | X 轴角速度 | 横滚角（Roll）  |
| [1]  | Y 轴加速度 | Y 轴角速度 | 俯仰角（Pitch） |
| [2]  | Z 轴加速度 | Z 轴角速度 | 偏航角（Yaw）   |

### 数据分析

```C
fAcc[i] = sReg[AX+i] / 32768.0f * 16.0f;
fGyro[i] = sReg[GX+i] / 32768.0f * 2000.0f;
fAngle[i] = sReg[Roll+i] / 32768.0f * 180.0f;
/*以上数据均来源于这里*/
//后面的 * 16.0f 表示限幅 即 加速度范围为 ± 16M/s²
```

