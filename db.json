{"meta":{"version":1,"warehouse":"5.0.1"},"models":{"Asset":[{"_id":"themes/reimu/source/css/fontawesome.styl","path":"css/fontawesome.styl","modified":1,"renderable":1},{"_id":"themes/reimu/source/css/heat-map.styl","path":"css/heat-map.styl","modified":1,"renderable":1},{"_id":"themes/reimu/source/css/loader.styl","path":"css/loader.styl","modified":1,"renderable":1},{"_id":"themes/reimu/source/css/iconfont.styl","path":"css/iconfont.styl","modified":1,"renderable":1},{"_id":"themes/reimu/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/reimu/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":1,"renderable":1},{"_id":"themes/reimu/source/images/banner-600w.webp","path":"images/banner-600w.webp","modified":1,"renderable":1},{"_id":"themes/reimu/source/images/banner-800w.webp","path":"images/banner-800w.webp","modified":1,"renderable":1},{"_id":"themes/reimu/source/images/banner.png","path":"images/banner.png","modified":1,"renderable":1},{"_id":"themes/reimu/source/images/banner.webp","path":"images/banner.webp","modified":1,"renderable":1},{"_id":"themes/reimu/source/images/header.jpg","path":"images/header.jpg","modified":1,"renderable":1},{"_id":"themes/reimu/source/images/favicon.ico","path":"images/favicon.ico","modified":1,"renderable":1},{"_id":"themes/reimu/source/images/reimu.png","path":"images/reimu.png","modified":1,"renderable":1},{"_id":"themes/reimu/source/images/taichi-fill.png","path":"images/taichi-fill.png","modified":1,"renderable":1},{"_id":"themes/reimu/source/images/taichi.png","path":"images/taichi.png","modified":1,"renderable":1},{"_id":"themes/reimu/source/images/taichi-fill.svg","path":"images/taichi-fill.svg","modified":1,"renderable":1},{"_id":"themes/reimu/source/images/taichi.svg","path":"images/taichi.svg","modified":1,"renderable":1},{"_id":"themes/reimu/source/js/algolia_search.js","path":"js/algolia_search.js","modified":1,"renderable":1},{"_id":"themes/reimu/source/js/generator_search.js","path":"js/generator_search.js","modified":1,"renderable":1},{"_id":"themes/reimu/source/js/aos.js","path":"js/aos.js","modified":1,"renderable":1},{"_id":"themes/reimu/source/js/heat_map.js","path":"js/heat_map.js","modified":1,"renderable":1},{"_id":"themes/reimu/source/js/pjax.js","path":"js/pjax.js","modified":1,"renderable":1},{"_id":"themes/reimu/source/js/insert_highlight.js","path":"js/insert_highlight.js","modified":1,"renderable":1},{"_id":"themes/reimu/source/js/pjax_script.js","path":"js/pjax_script.js","modified":1,"renderable":1},{"_id":"themes/reimu/source/js/script.js","path":"js/script.js","modified":1,"renderable":1},{"_id":"themes/reimu/source/js/service_worker.js","path":"js/service_worker.js","modified":1,"renderable":1},{"_id":"themes/reimu/source/js/sw.js","path":"js/sw.js","modified":1,"renderable":1},{"_id":"themes/reimu/source/images/cursor/reimu-cursor-default.png","path":"images/cursor/reimu-cursor-default.png","modified":1,"renderable":1},{"_id":"themes/reimu/source/images/cursor/reimu-cursor-text.png","path":"images/cursor/reimu-cursor-text.png","modified":1,"renderable":1},{"_id":"themes/reimu/source/images/cursor/reimu-cursor-pointer.png","path":"images/cursor/reimu-cursor-pointer.png","modified":1,"renderable":1},{"_id":"source/download/Deepseek参会人员座位表.xlsx","path":"download/Deepseek参会人员座位表.xlsx","modified":1,"renderable":0},{"_id":"source/download/Deepseek工作总结表.docx","path":"download/Deepseek工作总结表.docx","modified":1,"renderable":0},{"_id":"source/music/Cry.mp3","path":"music/Cry.mp3","modified":1,"renderable":0},{"_id":"source/music/倒带.mp3","path":"music/倒带.mp3","modified":1,"renderable":0},{"_id":"source/music/借口.mp3","path":"music/借口.mp3","modified":1,"renderable":0},{"_id":"source/music/借过.mp3","path":"music/借过.mp3","modified":1,"renderable":0},{"_id":"source/music/几分之几.mp3","path":"music/几分之几.mp3","modified":1,"renderable":0},{"_id":"source/music/匿名的好友.mp3","path":"music/匿名的好友.mp3","modified":1,"renderable":0},{"_id":"source/music/千年泪.mp3","path":"music/千年泪.mp3","modified":1,"renderable":0},{"_id":"source/music/囍帖街.mp3","path":"music/囍帖街.mp3","modified":1,"renderable":0},{"_id":"source/music/好想大声说爱你.mp3","path":"music/好想大声说爱你.mp3","modified":1,"renderable":0},{"_id":"source/music/慢慢.mp3","path":"music/慢慢.mp3","modified":1,"renderable":0},{"_id":"source/music/我只能离开.mp3","path":"music/我只能离开.mp3","modified":1,"renderable":0},{"_id":"source/music/有些.mp3","path":"music/有些.mp3","modified":1,"renderable":0},{"_id":"source/music/枫.mp3","path":"music/枫.mp3","modified":1,"renderable":0},{"_id":"source/music/火花.mp3","path":"music/火花.mp3","modified":1,"renderable":0},{"_id":"source/music/直到世界尽头.mp3","path":"music/直到世界尽头.mp3","modified":1,"renderable":0},{"_id":"source/music/空白格.mp3","path":"music/空白格.mp3","modified":1,"renderable":0},{"_id":"source/music/等你下课.mp3","path":"music/等你下课.mp3","modified":1,"renderable":0},{"_id":"source/music/绊.mp3","path":"music/绊.mp3","modified":1,"renderable":0},{"_id":"source/music/赛勒斯的爱.mp3","path":"music/赛勒斯的爱.mp3","modified":1,"renderable":0},{"_id":"source/music_cover/Cry.jpg","path":"music_cover/Cry.jpg","modified":1,"renderable":0},{"_id":"source/music_cover/倒带.jpg","path":"music_cover/倒带.jpg","modified":1,"renderable":0},{"_id":"source/music_cover/借口.jpg","path":"music_cover/借口.jpg","modified":1,"renderable":0},{"_id":"source/music_cover/借过.jpg","path":"music_cover/借过.jpg","modified":1,"renderable":0},{"_id":"source/music_cover/几分之几.jpg","path":"music_cover/几分之几.jpg","modified":1,"renderable":0},{"_id":"source/music_cover/匿名的好友.jpg","path":"music_cover/匿名的好友.jpg","modified":1,"renderable":0},{"_id":"source/music_cover/千年泪.jpg","path":"music_cover/千年泪.jpg","modified":1,"renderable":0},{"_id":"source/music_cover/囍帖街.jpg","path":"music_cover/囍帖街.jpg","modified":1,"renderable":0},{"_id":"source/music_cover/好想大声说爱你.jpg","path":"music_cover/好想大声说爱你.jpg","modified":1,"renderable":0},{"_id":"source/music_cover/慢慢.jpg","path":"music_cover/慢慢.jpg","modified":1,"renderable":0},{"_id":"source/music_cover/我只能离开.jpg","path":"music_cover/我只能离开.jpg","modified":1,"renderable":0},{"_id":"source/music_cover/有些.jpg","path":"music_cover/有些.jpg","modified":1,"renderable":0},{"_id":"source/music_cover/枫.png","path":"music_cover/枫.png","modified":1,"renderable":0},{"_id":"source/music_cover/火花.jpg","path":"music_cover/火花.jpg","modified":1,"renderable":0},{"_id":"source/music_cover/直到世界尽头.jpg","path":"music_cover/直到世界尽头.jpg","modified":1,"renderable":0},{"_id":"source/music_cover/空白格.jpg","path":"music_cover/空白格.jpg","modified":1,"renderable":0},{"_id":"source/music_cover/等你下课.jpg","path":"music_cover/等你下课.jpg","modified":1,"renderable":0},{"_id":"source/music_cover/绊.jpg","path":"music_cover/绊.jpg","modified":1,"renderable":0},{"_id":"source/music_cover/赛勒斯的爱.jpg","path":"music_cover/赛勒斯的爱.jpg","modified":1,"renderable":0},{"_id":"source/lrc/Cry.lrc","path":"lrc/Cry.lrc","modified":1,"renderable":0},{"_id":"source/lrc/スパークル (movie ver.) - RADWIMPS.lrc","path":"lrc/スパークル (movie ver.) - RADWIMPS.lrc","modified":1,"renderable":0},{"_id":"source/lrc/世界が終るまでは…-WANDS.lrc","path":"lrc/世界が終るまでは…-WANDS.lrc","modified":1,"renderable":0},{"_id":"source/lrc/倒带(Live)-周杰伦.lrc","path":"lrc/倒带(Live)-周杰伦.lrc","modified":1,"renderable":0},{"_id":"source/lrc/借口-周杰伦.lrc","path":"lrc/借口-周杰伦.lrc","modified":1,"renderable":0},{"_id":"source/lrc/借过.lrc","path":"lrc/借过.lrc","modified":1,"renderable":0},{"_id":"source/lrc/匿名的好友 - 杨丞琳.lrc","path":"lrc/匿名的好友 - 杨丞琳.lrc","modified":1,"renderable":0},{"_id":"source/lrc/几分之几 (You Complete Me) - 卢广仲.lrc","path":"lrc/几分之几 (You Complete Me) - 卢广仲.lrc","modified":1,"renderable":0},{"_id":"source/lrc/千年泪 - 曹雨航.lrc","path":"lrc/千年泪 - 曹雨航.lrc","modified":1,"renderable":0},{"_id":"source/lrc/君が好きだと叫びたい-Baad.lrc","path":"lrc/君が好きだと叫びたい-Baad.lrc","modified":1,"renderable":0},{"_id":"source/lrc/喜帖街 - 谢安琪.lrc","path":"lrc/喜帖街 - 谢安琪.lrc","modified":1,"renderable":0},{"_id":"source/lrc/慢慢-颜人中.lrc","path":"lrc/慢慢-颜人中.lrc","modified":1,"renderable":0},{"_id":"source/lrc/我只能离开-颜人中.lrc","path":"lrc/我只能离开-颜人中.lrc","modified":1,"renderable":0},{"_id":"source/lrc/有些-颜人中.lrc","path":"lrc/有些-颜人中.lrc","modified":1,"renderable":0},{"_id":"source/lrc/枫-周杰伦.lrc","path":"lrc/枫-周杰伦.lrc","modified":1,"renderable":0},{"_id":"source/lrc/空白格-蔡健雅.lrc","path":"lrc/空白格-蔡健雅.lrc","modified":1,"renderable":0},{"_id":"source/lrc/等你下课(with 杨瑞代)-周杰伦.lrc","path":"lrc/等你下课(with 杨瑞代)-周杰伦.lrc","modified":1,"renderable":0},{"_id":"source/lrc/絆-miu-clips.lrc","path":"lrc/絆-miu-clips.lrc","modified":1,"renderable":0},{"_id":"source/lrc/赛勒斯的爱-张敬轩.lrc","path":"lrc/赛勒斯的爱-张敬轩.lrc","modified":1,"renderable":0},{"_id":"source/photo/RT-Thread.png","path":"photo/RT-Thread.png","modified":1,"renderable":0},{"_id":"source/photo/ble.jpg","path":"photo/ble.jpg","modified":1,"renderable":0},{"_id":"source/photo/const-logo.png","path":"photo/const-logo.png","modified":1,"renderable":0},{"_id":"source/photo/freertos-logo-1f2c2b10db17ff7350f71b4ac56d11ff.png","path":"photo/freertos-logo-1f2c2b10db17ff7350f71b4ac56d11ff.png","modified":1,"renderable":0},{"_id":"source/photo/hexo.jpg","path":"photo/hexo.jpg","modified":1,"renderable":0},{"_id":"source/photo/logo-colored.png","path":"photo/logo-colored.png","modified":1,"renderable":0},{"_id":"source/photo/wallhaven-02.jpg","path":"photo/wallhaven-02.jpg","modified":1,"renderable":0},{"_id":"source/photo/电赛.png","path":"photo/电赛.png","modified":1,"renderable":0},{"_id":"source/photo/嵌入式.jpg","path":"photo/嵌入式.jpg","modified":1,"renderable":0},{"_id":"source/photo/音响.png","path":"photo/音响.png","modified":1,"renderable":0},{"_id":"source/about/index.assets/00AD4F6E.gif","path":"about/index.assets/00AD4F6E.gif","modified":1,"renderable":0},{"_id":"source/about/index.assets/00ADEA47.gif","path":"about/index.assets/00ADEA47.gif","modified":1,"renderable":0},{"_id":"source/download/ESP32/wsl-usb-manager.exe","path":"download/ESP32/wsl-usb-manager.exe","modified":1,"renderable":0}],"Cache":[{"_id":"source/_data/covers.yml","hash":"2755f6d2594b5b16ea07461852360198dd92c947","modified":1747726218000},{"_id":"source/download/Deepseek工作总结表.docx","hash":"0a684059bcc1a1fdb7b0f6ae41cb52f5fa03292d","modified":1748588130000},{"_id":"source/download/Deepseek参会人员座位表.xlsx","hash":"62604f3e5730d693a7489dfb811084cb19117506","modified":1748590776000},{"_id":"source/_posts/C语言高级.md","hash":"902719254b491469b7052ca417529d9461fae65c","modified":1759065424000},{"_id":"source/about/index.md","hash":"80d7a9707a6bf304b5914618807c82c62446b893","modified":1747803506000},{"_id":"source/_posts/ESP32学习.md","hash":"d5e73b1061f7307f74edc7bf84b267563f00ef02","modified":1758082294000},{"_id":"source/_posts/LVGL学习之旅-DESKTOP-40.md","hash":"1c5eb1543e636d95536c43ab0254269e877bf8db","modified":1768066228000},{"_id":"source/_posts/RT-Thread.md","hash":"dd97cc6b2f80012a6e33a7fad0503c8b7c7c53fd","modified":1758082336000},{"_id":"source/_posts/LVGL学习之旅.md","hash":"f3273b2e0790b9eff9dc00a8c345881b828c2ba6","modified":1758082332000},{"_id":"source/_posts/ble基础.md","hash":"9533222320d95c1ae168eec0ac11c4fa95d02e79","modified":1768066310000},{"_id":"source/_posts/hexo命令.md","hash":"f4f1dc9e33aab0780ad13e061e6ef128324e0f0b","modified":1768073324000},{"_id":"source/_posts/TI.md","hash":"ffe6c48efb47c78a1dadbb87b881456058b8bb63","modified":1758082344000},{"_id":"source/_posts/电赛.md","hash":"e69200c4752f0d9644cc3c4a1b514c7b785da6ef","modified":1749737856000},{"_id":"source/_posts/linux.md","hash":"c9aea4b021da0a64ce11a7bdc4fc5f3b037c8a00","modified":1758629838000},{"_id":"source/_posts/西门子.md","hash":"399266909bd2c12aa7860f7c13938a837b0a4169","modified":1759044262000},{"_id":"source/_posts/音响实习.md","hash":"a46291ca09b5c68284b06e0699baa9586c5eee86","modified":1758082916000},{"_id":"source/music_cover/Cry.jpg","hash":"e36221902df61defab33dec079d3c2b618ca58ad","modified":1759033000000},{"_id":"source/music_cover/借过.jpg","hash":"b3a2d16756916a9a403c01bb408fd6f0b2c1759b","modified":1759032832000},{"_id":"source/music_cover/几分之几.jpg","hash":"946b735a9448a6bd8d96843ce8ff4f3a3df699b0","modified":1759032100000},{"_id":"source/music_cover/囍帖街.jpg","hash":"da5a4625bd8071498d3c91d56a71085c0c61afa3","modified":1759032686000},{"_id":"source/music_cover/我只能离开.jpg","hash":"93911d2ced7818102ebe61b99a1712d8fb46cafb","modified":1759032602000},{"_id":"source/music_cover/火花.jpg","hash":"c5901e92eeb8dcb5d44d4e441ca2534275b0deaa","modified":1759032482000},{"_id":"source/friend/_data.yml","hash":"d2c42e306d61ca58523251ad38d9867f12924969","modified":1749314400000},{"_id":"source/music_cover/赛勒斯的爱.jpg","hash":"3b948ac9b439e0933dc3df2bee70bd49a879c393","modified":1759036068000},{"_id":"source/friend/index.md","hash":"570d5244394fd87caafd62a3426362fe05c089e1","modified":1747665804000},{"_id":"source/lrc/Cry.lrc","hash":"cfbfd360cc4aff6e98b4d45cbd946e9287b6dfcb","modified":1747812548000},{"_id":"source/lrc/スパークル (movie ver.) - RADWIMPS.lrc","hash":"7c4ed210d39e157770bc91a42930a2fbe55054ae","modified":1747914616000},{"_id":"source/lrc/世界が終るまでは…-WANDS.lrc","hash":"c2b38e799250d37895678be05a928b990493621d","modified":1747811032000},{"_id":"source/lrc/倒带(Live)-周杰伦.lrc","hash":"4cd41992250aaf8891df40391a4b9fc8de3e053d","modified":1747809848000},{"_id":"source/lrc/借口-周杰伦.lrc","hash":"b36830c79067f9fd854c1fc5906ca9f0f3c65389","modified":1747800326000},{"_id":"source/lrc/借过.lrc","hash":"829fa5a77729e5f8c38da2ce15cf6a26fa8fe448","modified":1759032856000},{"_id":"source/lrc/匿名的好友 - 杨丞琳.lrc","hash":"17b5b46a47ecf89b694096edde58cfac0dbd394a","modified":1759032744000},{"_id":"source/lrc/几分之几 (You Complete Me) - 卢广仲.lrc","hash":"5e7baad76dd56bb0975a135371125ca398af8843","modified":1759031984000},{"_id":"source/lrc/千年泪 - 曹雨航.lrc","hash":"6aed0e4ae1d2a7a82552e4f72568a1479887b92c","modified":1759033166000},{"_id":"source/lrc/君が好きだと叫びたい-Baad.lrc","hash":"811479f8092309d55013219b7d1ef4471f00f246","modified":1747811282000},{"_id":"source/lrc/喜帖街 - 谢安琪.lrc","hash":"767a78a5bc2c4e786a73a28054dc02387bc975d8","modified":1759032668000},{"_id":"source/lrc/我只能离开-颜人中.lrc","hash":"cdedb6d91fc820622ef340f5c44e0119aec686c8","modified":1747800068000},{"_id":"source/lrc/慢慢-颜人中.lrc","hash":"84c8cc826269d081bef243d66ac2d93728ec36ec","modified":1747800104000},{"_id":"source/lrc/有些-颜人中.lrc","hash":"46c5be1956d8a5714fdbbaa7109331eeac326f4a","modified":1747799986000},{"_id":"source/lrc/枫-周杰伦.lrc","hash":"e2626df7d9e20bddb3b1eb9234dea000672e051e","modified":1747810352000},{"_id":"source/lrc/等你下课(with 杨瑞代)-周杰伦.lrc","hash":"d4670ac64892f9610f3467111c151cc4284bc016","modified":1747799796000},{"_id":"source/lrc/空白格-蔡健雅.lrc","hash":"70a6a0b08015297419c9e181e456a45d6238009c","modified":1747810480000},{"_id":"source/lrc/絆-miu-clips.lrc","hash":"0effffb4bb87718aad7582d05b3d99fc82fb4286","modified":1747810768000},{"_id":"source/lrc/赛勒斯的爱-张敬轩.lrc","hash":"7dd3d2bdbff66a9c2a84ba27be172eea22926c2e","modified":1759036052000},{"_id":"source/photo/logo-colored.png","hash":"8cd0f874ba6909ecea6f93cf597921d6d7247334","modified":1757229250000},{"_id":"source/photo/hexo.jpg","hash":"ae9da14439b1863866e0f322cde5746eecdda61f","modified":1768069696000},{"_id":"source/search/index.md","hash":"d755a58db7153cd64b3b5bb2ddbdf6180d8a23e8","modified":1747750976000},{"_id":"source/_data/avatar/avatar.webp","hash":"427278caef0a47f8d0de7dabd51625856cd55a67","modified":1747645494000},{"_id":"source/about/index.assets/00AD4F6E.gif","hash":"beb4aea652f255acd7a54dee73603e3ce47b003a","modified":1747803000000},{"_id":"source/_data/avatar/writer.jpg","hash":"3b6f19b9626d4fc8e8cec19fbaf78fb6c972b611","modified":1747645848000},{"_id":"source/_posts/RT-Thread.assets/image-20250521203425658.png","hash":"20ee1f3d010314437ca82ea4d223315cd8e2c530","modified":1747830866000},{"_id":"source/_posts/RT-Thread.assets/image-20250522203011255.png","hash":"99d81c58749b8fe53cce8e50b1d8e81a26db1d5a","modified":1747917012000},{"_id":"source/_posts/RT-Thread.assets/image-20250522214349807.png","hash":"6301c6feb7b5bdcc452c14e5ba7b59b2a310c5d7","modified":1747921430000},{"_id":"source/_posts/RT-Thread.assets/image-20250522214536841.png","hash":"b153d5f06dea73e08ae78124055848b7d59a48d6","modified":1747921536000},{"_id":"source/_posts/RT-Thread.assets/image-20250522214705123.png","hash":"58ff719a89d86e5b94ecf59fa6b9b66a67a51a90","modified":1747921626000},{"_id":"source/_posts/RT-Thread.assets/image-20250522214840651.png","hash":"418f3b77a4f901306fd22ca7631b7139a33bdb34","modified":1747921720000},{"_id":"source/_posts/RT-Thread.assets/image-20250522214917115.png","hash":"0282d7201ca650e935bcf065b5ccbd481e0181bc","modified":1747921758000},{"_id":"source/_posts/RT-Thread.assets/image-20250522214947877.png","hash":"d7feacdae47fd5c3187630e4a130ed152b3b9d93","modified":1747921788000},{"_id":"source/_posts/RT-Thread.assets/image-20250522215015453.png","hash":"203486309549df2ea085cf514108e39c74155468","modified":1747921816000},{"_id":"source/_posts/RT-Thread.assets/image-20250522215146162.png","hash":"52f6d97690cdfbb2faf045bbd347a060ff2bdf61","modified":1747921906000},{"_id":"source/_posts/RT-Thread.assets/image-20250522220417747.png","hash":"e3bea3bd9d4178c5cfe4e91e392db87cb1e370b8","modified":1747922658000},{"_id":"source/_posts/RT-Thread.assets/image-20250522220447380.png","hash":"e82ad946dc6145ccdf6b167da9c5fb9d6d95c1ab","modified":1747922688000},{"_id":"source/_posts/gd32.assets/image-20250602161506934.png","hash":"c15fb94e096b4c143c758b5d0a222944982e2c78","modified":1748852108000},{"_id":"source/_posts/gd32.assets/image-20250602162859501.png","hash":"d4cb3a4108a1e3ad92d260e486cc70b7a2af06d2","modified":1748852940000},{"_id":"source/_posts/gd32.assets/image-20250602182759796.png","hash":"357c67270504d6a25d3d06d945185e83c1ec2240","modified":1748860080000},{"_id":"source/_posts/page.assets/065C4EAE.gif","hash":"623404570b1b3f6904a50e9cc4970612a1cd6768","modified":1747738942000},{"_id":"source/_posts/freertos.assets/image1.png","hash":"d099b8475b667d6795acd93a47ebecc1b19d65f6","modified":1757065396000},{"_id":"source/_posts/page.assets/065D558E.gif","hash":"623404570b1b3f6904a50e9cc4970612a1cd6768","modified":1747739010000},{"_id":"source/_posts/page.assets/202505201902782.gif","hash":"623404570b1b3f6904a50e9cc4970612a1cd6768","modified":1747738976000},{"_id":"source/_posts/page.assets/image-20250519134520820.png","hash":"299d988794f41e4fc568090c1ca90abb2271601f","modified":1747633520000},{"_id":"source/_posts/page.assets/image-20250519134715303.png","hash":"8522de42ce82038d19ee7f3f15490e1fca0d7334","modified":1747633636000},{"_id":"source/_posts/page.assets/image-20250519174120453.png","hash":"7c1d7975c325c65aaf955d6887515b4f80d004ed","modified":1747647680000},{"_id":"source/_posts/电赛.assets/image-20250612212043991.png","hash":"dcae555c9de04a05cfd94558a1cddfd0a5c8fcf3","modified":1749734444000},{"_id":"source/_posts/电赛.assets/image-20250612212624882.png","hash":"e8ce873f0656342ed65d18bd6ae2f30f0f631705","modified":1749734784000},{"_id":"source/_posts/电赛.assets/image-20250612214821660.png","hash":"778ffb591c0a61002bfef0c2b314c1eeb1f352ac","modified":1749736102000},{"_id":"source/_posts/电赛.assets/image-20250612214851115.png","hash":"70e2a77daa7ca997995cbfad291bec1ec80004a5","modified":1749736132000},{"_id":"source/_posts/电赛.assets/image-20250612220017334.png","hash":"9681bf58961e014f3d5d12a3d7cbb88173a1a5a5","modified":1749736818000},{"_id":"source/_posts/电赛.assets/image-20250612215946547.png","hash":"3b2239d11b3010ba4b4d667a9276cda2d21566cf","modified":1749736786000},{"_id":"source/_posts/freertos.md","hash":"0b17aff2db32424c09063d42614a9e323ed230cd","modified":1758252058000},{"_id":"source/music_cover/借口.jpg","hash":"306cf12609c52ac7b1b001ea6e67a1d84160aa3a","modified":1759032516000},{"_id":"source/music_cover/千年泪.jpg","hash":"4b4a867f058da377a0ec8fe1ef19c4ecb5429bc3","modified":1759033154000},{"_id":"source/music_cover/慢慢.jpg","hash":"566f2b99b4590b4fb3e941aa5ebdc51a0cf3a767","modified":1759032560000},{"_id":"source/music_cover/直到世界尽头.jpg","hash":"13d4e6fb64feefcb131f5576c27c9a59a462b3f6","modified":1759032952000},{"_id":"source/music_cover/空白格.jpg","hash":"06bb5f7960b8711ac216734df38b14f8c1664c4e","modified":1759032532000},{"_id":"source/photo/ble.jpg","hash":"214f263be757b74677febe82f6707e09b53a95fb","modified":1768065804000},{"_id":"source/photo/电赛.png","hash":"0801133a780eb7e69b8ac285043d82c01ed7b511","modified":1749360270000},{"_id":"source/about/index.assets/00ADEA47.gif","hash":"35a80a356147aaf3baa4474fb5bfafe7e2f1d337","modified":1747803040000},{"_id":"source/_posts/ble基础.assets/image-20260111012740722.png","hash":"1ebd322d0628a7fa198d7e017f4f167c9d0a1cf3","modified":1768066062000},{"_id":"source/_posts/RT-Thread.assets/image-20250521205640868.png","hash":"fe7aa3dcbcffbdbfbda9559c9021bfa61d94c6a9","modified":1747832200000},{"_id":"source/_posts/RT-Thread.assets/image-20250521221429133.png","hash":"68a453abffa5ad1657ca6e28edef79d89318c76f","modified":1747836870000},{"_id":"source/_posts/RT-Thread.assets/image-20250521221525259.png","hash":"1be2d03140673bd1976493a3e305c706b61ea380","modified":1747836926000},{"_id":"source/_posts/RT-Thread.assets/image-20250522214557996.png","hash":"28bed0b8f960fd61b01f07bbc27ff782378f6b30","modified":1747921558000},{"_id":"source/_posts/RT-Thread.assets/image-20250522214626232.png","hash":"25515ccd1c4011c2fd6bc32b9b2ca6a1b265c61f","modified":1747921586000},{"_id":"source/_posts/RT-Thread.assets/image-20250522214859546.png","hash":"cfe2f58e14e217408a3e1eba65894303583fee16","modified":1747921740000},{"_id":"source/_posts/RT-Thread.assets/image-20250522214750185.png","hash":"e78154172a6f3fe4365d5fca51205ffb85190bca","modified":1747921670000},{"_id":"source/_posts/RT-Thread.assets/image-20250522215207600.png","hash":"84b7427a60c240e6905c76fe91b8df79a901e95b","modified":1747921928000},{"_id":"source/_posts/RT-Thread.assets/image-20250522215247412.png","hash":"8caec5fd5c096d867b3f050041c8a5a7f674a76c","modified":1747921968000},{"_id":"source/_posts/RT-Thread.assets/image-20250522220342327.png","hash":"2c2ed7c6d25f4be83ee40d47f9cff81835ec3975","modified":1747922622000},{"_id":"source/_posts/RT-Thread.assets/image-20250522220235080.png","hash":"6b5a0ca915bbe52fd889e635b0fd3bc0cca2ddf3","modified":1747922556000},{"_id":"source/_posts/gd32.assets/image-20250602181824740.png","hash":"a357ac05994a5e5f66e29c20359f31c37ffaa254","modified":1748859504000},{"_id":"source/_posts/gd32.assets/image-20250602180416500.png","hash":"6986b9694d513f32b96a7ca7d9cce62f447cfca0","modified":1748858656000},{"_id":"source/_posts/gd32.assets/image-20250606171853466.png","hash":"82cbd5e008726ebd7c10747aedc875c7e62eba61","modified":1749201534000},{"_id":"source/_posts/page.assets/06778F3E.gif","hash":"6c000965acff795307d9127fb5f3dfa059cd8462","modified":1747740728000},{"_id":"source/_posts/page.assets/202505201934458.gif","hash":"20d5cc09622d8dbe253df8b1d3dc6f4b137087a5","modified":1747740940000},{"_id":"source/_posts/page.assets/0679D9F9.gif","hash":"20d5cc09622d8dbe253df8b1d3dc6f4b137087a5","modified":1747740878000},{"_id":"source/_posts/page.assets/image-20250519134539985.png","hash":"9a96711f512f99ab147ae92030094dcfbb8817af","modified":1747633540000},{"_id":"source/_posts/电赛.assets/image-20250608132624784.png","hash":"b8e88f864c0f9cd4d372621ad2130200d5e14249","modified":1749360384000},{"_id":"source/_posts/电赛.assets/image-20250612211722492.png","hash":"cc022f779b6774f9371983e1c038570f784a034d","modified":1749734242000},{"_id":"source/_posts/电赛.assets/image-20250612213408605.png","hash":"901d238f7f3a4f431a3fe88da20a4864363ec5f2","modified":1749735248000},{"_id":"source/music_cover/倒带.jpg","hash":"9816ef170c1964f2b4f185e939bfe62d38433470","modified":1759032234000},{"_id":"source/music_cover/好想大声说爱你.jpg","hash":"7e56de3b52878667eaae52bbeb23b031af873166","modified":1759033040000},{"_id":"source/music_cover/有些.jpg","hash":"cc5755ac510e378c1c90a060499f98510345bb98","modified":1759032920000},{"_id":"source/music_cover/绊.jpg","hash":"4f88ec19b221577bfffcb99e9b876a5ff2a581a4","modified":1759032146000},{"_id":"source/photo/RT-Thread.png","hash":"32e7a0dc5a68b4effaf2cddb07f68fb593283b0c","modified":1747830614000},{"_id":"source/photo/const-logo.png","hash":"e96b8bccb8a560daa18db57f7d098071346714e7","modified":1758083130000},{"_id":"source/photo/嵌入式.jpg","hash":"5a6d73450ab54f3c15188d316aeb0356fc262952","modified":1748851370000},{"_id":"source/music_cover/匿名的好友.jpg","hash":"fc5b858aa7f84633c082e9d50a486571284d6aa0","modified":1759032730000},{"_id":"source/_posts/gd32.assets/image-20250602225501522.png","hash":"52092e9d5040a70d4509ccdcdb1c785ac6fec22e","modified":1748876102000},{"_id":"source/_posts/page.assets/067E4DAE.gif","hash":"100d723cc1fe49d3c16dd156332ecbc2b33ad684","modified":1747741170000},{"_id":"source/_posts/page.assets/202505201939395.gif","hash":"100d723cc1fe49d3c16dd156332ecbc2b33ad684","modified":1747741192000},{"_id":"source/photo/freertos-logo-1f2c2b10db17ff7350f71b4ac56d11ff.png","hash":"d422841eee543e328f81b9753b55567be80ec23b","modified":1757228382000},{"_id":"themes/reimu/.gitignore","hash":"e0cbdc1c23982ece467ae62cddb4714dc795c357","modified":1747645494000},{"_id":"themes/reimu/LICENSE","hash":"d1d333fe4c40d865a03210a8168c4132ec703669","modified":1747645494000},{"_id":"themes/reimu/CODE_OF_CONDUCT.md","hash":"903677e2a799099daae8cbb72cecabaa684b466c","modified":1747645494000},{"_id":"themes/reimu/README.md","hash":"18ed4a49be4efec8eb16176691b66e195ab34417","modified":1747645494000},{"_id":"themes/reimu/README.en.md","hash":"ebcb468d33fe2a8ddff6039bed7b7c622b2c59c7","modified":1747645494000},{"_id":"themes/reimu/package.json","hash":"48029a1b59eeaa847ecce853df278f033867f722","modified":1747645494000},{"_id":"themes/reimu/languages/en.yml","hash":"958196cc0c1a2326205f66cee07f7e4064ac3672","modified":1747645494000},{"_id":"themes/reimu/_config.yml","hash":"dd2fb365624068bfd01f8bb7d5bab3d45c6997bf","modified":1759036402000},{"_id":"themes/reimu/languages/ja.yml","hash":"61c95cad64bb0ab39f6fde81275edf853f32d862","modified":1747645494000},{"_id":"themes/reimu/layout/404.ejs","hash":"17e9dc22d272968b0a4f74d0e1ae268a0a73ea25","modified":1747645494000},{"_id":"themes/reimu/layout/archive.ejs","hash":"3d992398c570ff9870d3797c31fefb3fa2d02e4f","modified":1747645494000},{"_id":"themes/reimu/languages/zh-CN.yml","hash":"083fb3c73cb2ea358ae21441633d04acbf708b6f","modified":1747645494000},{"_id":"themes/reimu/languages/zh-TW.yml","hash":"34bbb57f5dbd6860bb2ea259c3b301b9a209b16a","modified":1747645494000},{"_id":"themes/reimu/layout/layout.ejs","hash":"8e53ab68c6b751f28695f075cb19c13affc05a99","modified":1747751120000},{"_id":"themes/reimu/layout/category.ejs","hash":"3d992398c570ff9870d3797c31fefb3fa2d02e4f","modified":1747645494000},{"_id":"themes/reimu/layout/index.ejs","hash":"a51e8ad60f3b607100b56d75bb0238ae741564df","modified":1747645494000},{"_id":"themes/reimu/layout/post.ejs","hash":"ba3f390db72a343c0b1f7faa715020129df80928","modified":1747645494000},{"_id":"themes/reimu/.github/ISSUE_TEMPLATE/BUG_REPORT.yml","hash":"b0cc58fda3f5a34660ef874ef322caa332bfd865","modified":1747645494000},{"_id":"themes/reimu/layout/tag.ejs","hash":"3d992398c570ff9870d3797c31fefb3fa2d02e4f","modified":1747645494000},{"_id":"themes/reimu/layout/page.ejs","hash":"ba3f390db72a343c0b1f7faa715020129df80928","modified":1747645494000},{"_id":"themes/reimu/.github/ISSUE_TEMPLATE/FEAT_REQUEST_EN.yml","hash":"d072f9b0d4edc0ed4d340b202868a756468fff8b","modified":1747645494000},{"_id":"themes/reimu/.github/ISSUE_TEMPLATE/BUG_REPORT_EN.yml","hash":"842b247c1378c5cf90edd86f8659ef7161cb508f","modified":1747645494000},{"_id":"themes/reimu/.github/ISSUE_TEMPLATE/config.yml","hash":"bb7c99b10868fc52eabba1e1cdfa938679882b02","modified":1747645494000},{"_id":"themes/reimu/.github/ISSUE_TEMPLATE/FEAT_REQUEST.yml","hash":"7339758b06021ca8578d680331d1ae66fa14aa16","modified":1747645494000},{"_id":"themes/reimu/_example/_data/covers.yml","hash":"2755f6d2594b5b16ea07461852360198dd92c947","modified":1747645494000},{"_id":"themes/reimu/.github/workflows/bench.yml","hash":"6d4c2ed55d4aef1f6b0726de38e63b7ca36c1fbe","modified":1747645494000},{"_id":"themes/reimu/_example/_posts/hello-world.md","hash":"ec1532ddb6288f811eb1dd599ab829e4812a2132","modified":1747645494000},{"_id":"themes/reimu/_example/about/index.md","hash":"38210826fb70b9405a189d2952c355a16949c7e3","modified":1747645494000},{"_id":"themes/reimu/_example/friend/_data.yml","hash":"afb0ba205d1f0712c9be338e801350ec0f1f8cd5","modified":1747663154000},{"_id":"themes/reimu/_example/friend/index.md","hash":"340a95ff1a5f1cb1cbd72aaae6df92fb6b099521","modified":1747645494000},{"_id":"themes/reimu/source/css/_animation.styl","hash":"befe096e99f3fa971d8048b89499019af7293522","modified":1747645494000},{"_id":"themes/reimu/source/css/fontawesome.styl","hash":"e20fe2a188aa886e8b38baf8a9b4f4747bb470e7","modified":1747645494000},{"_id":"themes/reimu/source/css/heat-map.styl","hash":"f7a3fead744c457ef9ec97541338fac736c47ffd","modified":1747645494000},{"_id":"themes/reimu/source/css/_variables.styl","hash":"857792c9b105d55c3cbddcd29b694c8d79f52de9","modified":1747645494000},{"_id":"themes/reimu/source/css/_extend.styl","hash":"5bb717cb9402222955524b28684575b3dde43b80","modified":1747645494000},{"_id":"themes/reimu/source/css/style.styl","hash":"3103c43aa8dec9c184c28752aee9d047655f26b9","modified":1747747094000},{"_id":"themes/reimu/layout/_partial/after-footer.ejs","hash":"6da20957ada2382dacb87bd3e414ac3244555bf5","modified":1747645494000},{"_id":"themes/reimu/source/css/iconfont.styl","hash":"3e2e75ed03ea242cad9425888fa1eca02038fcaf","modified":1747645494000},{"_id":"themes/reimu/source/css/loader.styl","hash":"be3628d3c3bf55f731ca8f4663923597a6129894","modified":1747645494000},{"_id":"themes/reimu/layout/_partial/archive-post.ejs","hash":"28ea04cee6438849b92dd2e24a5ed11fbc874d10","modified":1747645494000},{"_id":"themes/reimu/layout/_partial/archive.ejs","hash":"2d69dec457c467b7b956717fcc5a31a7fdd39b0f","modified":1747645494000},{"_id":"themes/reimu/layout/_partial/header.ejs","hash":"d633b1e00e8c44f8b1d811c9c350aaa20fd6a391","modified":1747645494000},{"_id":"themes/reimu/layout/_partial/head.ejs","hash":"25ac65ccc2baedc75bd14e0458200095acb077d5","modified":1747645494000},{"_id":"themes/reimu/layout/_partial/article.ejs","hash":"d848b9047f3d2d1ccab0ba5c9d4f6154de2ef393","modified":1747645494000},{"_id":"themes/reimu/layout/_partial/footer.ejs","hash":"8d301c033db59d00eed73b1b90cf26c128a5259a","modified":1747645494000},{"_id":"themes/reimu/layout/_partial/loader.ejs","hash":"e8be4d3f6993dfd2aa019c7d7d58388218ded8de","modified":1747645494000},{"_id":"themes/reimu/layout/_partial/mobile-nav.ejs","hash":"6ca594c9847ae5b361bb7b14975c8ca8499ae7dc","modified":1747645494000},{"_id":"themes/reimu/layout/_widget/archive.ejs","hash":"3905c02306127b823abd991482cc78df075f1c35","modified":1747645494000},{"_id":"themes/reimu/layout/_partial/post.ejs","hash":"607317345e7151e78e643b6bd27a4047db33a8de","modified":1747645494000},{"_id":"themes/reimu/layout/_partial/sidebar.ejs","hash":"21b1debbcdb10307dd540733c23c392960a0d46b","modified":1747645494000},{"_id":"themes/reimu/layout/_widget/tagcloud.ejs","hash":"20941f4e8b4f302e84893e97efb6090eb871dcdf","modified":1747645494000},{"_id":"themes/reimu/layout/_widget/category.ejs","hash":"d2ba6832288b461fe6a8c77cee250d19563dacb6","modified":1747645494000},{"_id":"themes/reimu/layout/_widget/tag.ejs","hash":"866704743c105439cad8cbc290571f4fa5f2e124","modified":1747645494000},{"_id":"themes/reimu/layout/_widget/recent_posts.ejs","hash":"119825bb8e906803b14448e68e85f35e7bd55e6b","modified":1747645494000},{"_id":"themes/reimu/source/images/algolia_logo.svg","hash":"6ddea54d87cc9dc2abf77bb22b615e5cb8e322b3","modified":1747645494000},{"_id":"themes/reimu/source/images/banner-600w.webp","hash":"21a2f645b88e10b3bcbddc617142820897087b9c","modified":1747645494000},{"_id":"themes/reimu/source/images/banner-800w.webp","hash":"b6816d3aff990eb6776c1257ef4489a9a75e9a1d","modified":1747645494000},{"_id":"themes/reimu/source/images/favicon.ico","hash":"71abb7df9c06622a19baf55841dc36ac0b965a6f","modified":1747645494000},{"_id":"themes/reimu/source/images/reimu.png","hash":"7bbaba99fda7b420759e169d72d226e4c4e9e665","modified":1747645494000},{"_id":"themes/reimu/source/images/taichi-fill.png","hash":"1b1411207fc92903e76d414ebe6f4f32267de991","modified":1747645494000},{"_id":"themes/reimu/source/images/taichi.png","hash":"297865b94e16a14c14447f6265d850cdbbb31852","modified":1747645494000},{"_id":"themes/reimu/source/js/algolia_search.js","hash":"ffb48c9141f8e0fffbbb6c68c3de20a4fb1b6e02","modified":1747645494000},{"_id":"themes/reimu/source/images/taichi-fill.svg","hash":"bd2598a12c1ad5f17d6ebdb635c192e2365ec156","modified":1747645494000},{"_id":"themes/reimu/source/images/taichi.svg","hash":"d6d0ab8bc997a416d63b0257d6c2530e792c91ed","modified":1747645494000},{"_id":"themes/reimu/source/js/generator_search.js","hash":"97feb51461c4a75fb74eb028dc02146a2ba99313","modified":1747645494000},{"_id":"themes/reimu/source/js/aos.js","hash":"6c991e83a0809f8fe596a8617df11987a8430ca7","modified":1747645494000},{"_id":"themes/reimu/source/js/heat_map.js","hash":"c3b638320895871fedea89e3b640fed2a3587617","modified":1747645494000},{"_id":"themes/reimu/source/js/pjax.js","hash":"e098cdeb99ba42fd2a9a605e8cbbe81d579eca33","modified":1747645494000},{"_id":"themes/reimu/source/js/insert_highlight.js","hash":"3b4c5a136c254684c3571a2da11d8019c78e10c9","modified":1747645494000},{"_id":"themes/reimu/source/js/pjax_script.js","hash":"85750936e5af4c11f169c146628e3e05579f3d4e","modified":1747645494000},{"_id":"themes/reimu/source/js/script.js","hash":"987185e8424392ed1855b2ee8b82264c72882432","modified":1747645494000},{"_id":"themes/reimu/source/js/service_worker.js","hash":"58032e1ee76b190fecca2f2bfef17a780fca90bd","modified":1747645494000},{"_id":"themes/reimu/source/js/sw.js","hash":"2c1053d196e88243eb246e40f47fe7aa1464823b","modified":1747645494000},{"_id":"themes/reimu/scripts/generator/404.js","hash":"c0171ae967b7da451626ad275447fb9cee42abeb","modified":1747645494000},{"_id":"themes/reimu/scripts/generator/i18n.js","hash":"0b16e757da365cae10e826b10d8f63e72fa3f256","modified":1747645494000},{"_id":"themes/reimu/scripts/generator/images.js","hash":"b225bea93234f9cdd0d89840617574665301269a","modified":1747645494000},{"_id":"themes/reimu/scripts/generator/override.js","hash":"e069daca4e92d40529509ba80f22b1258d0b8a9c","modified":1747645494000},{"_id":"themes/reimu/scripts/generator/search.js","hash":"a629600225d37114bf1cd03f8a8c29a81527e716","modified":1747645494000},{"_id":"themes/reimu/scripts/helper/articleCopyright.js","hash":"348f6bf61f635bf26ac2268bac42fe711e8a5068","modified":1747645494000},{"_id":"themes/reimu/scripts/util/checkVersion.js","hash":"e766e3c4b223f81ccea317cc30ad4c327a9241c5","modified":1747645494000},{"_id":"themes/reimu/scripts/generator/servicework.js","hash":"9345cc71791d81b4f41592dbfad4fa8dd23408e9","modified":1747645494000},{"_id":"themes/reimu/scripts/util/checkConfig.js","hash":"b5ef0b52fa5c2678b60c4bed93a260d24160fd6d","modified":1747645494000},{"_id":"themes/reimu/scripts/filter/stylus.js","hash":"9a3270f79bb98d113f4af43877961aaed0b10afa","modified":1747645494000},{"_id":"themes/reimu/scripts/helper/cache.js","hash":"09ab4e101051aa56c67d2f2a78df01eb99b17d59","modified":1747645494000},{"_id":"themes/reimu/scripts/helper/copyright.js","hash":"1d6061b32464458bc061ebc7d661511d72cef859","modified":1747645494000},{"_id":"themes/reimu/scripts/helper/i18n.js","hash":"56e2706f58aac22e5e0ac4c79d6c61f475d60272","modified":1747645494000},{"_id":"themes/reimu/scripts/helper/asyncCss.js","hash":"cc27c977e9b2809beec12296aca6c60a31663f74","modified":1747645494000},{"_id":"themes/reimu/scripts/helper/config.js","hash":"293e6ee501e5f1c08fcf4714a59216a39ac964e4","modified":1747645494000},{"_id":"themes/reimu/scripts/helper/listCategories.js","hash":"f11e863ce77dc98b40aea291c7fa628b565c02d3","modified":1747645494000},{"_id":"themes/reimu/scripts/helper/listTags.js","hash":"255255fff3533cdba9f72f72279d9002f72e2983","modified":1747645494000},{"_id":"themes/reimu/scripts/helper/override.js","hash":"62814f721fb2fcb7b2f0a5fe95ca5b12390b9a1a","modified":1747645494000},{"_id":"themes/reimu/scripts/helper/parseHomeCategories.js","hash":"8f08c8dedb21f1ac0ebadce65e612330e0626161","modified":1747645494000},{"_id":"themes/reimu/scripts/helper/outdate.js","hash":"01274c2684333f87fea4aabbffbcabc2fcf46e6e","modified":1747645494000},{"_id":"themes/reimu/scripts/helper/partialLang.js","hash":"ac549bc4468d9318e8eefff07d9c405f2a2742d5","modified":1747645494000},{"_id":"themes/reimu/scripts/helper/shareLink.js","hash":"67f3c723aafd48031b3dfd56fa4ef94cddb12a08","modified":1747645494000},{"_id":"themes/reimu/scripts/helper/stripHtml.js","hash":"e3d44bf009ac84e0e559ac092039a4b1dcbb4b69","modified":1747645494000},{"_id":"themes/reimu/scripts/helper/vendorFont.js","hash":"c81f898395b1790d7bc81767849ba22a9805ac8e","modified":1747645494000},{"_id":"themes/reimu/scripts/helper/randomCover.js","hash":"946332072fa73527ec74b4ef6ec5206556261a4d","modified":1747645494000},{"_id":"themes/reimu/scripts/helper/vendorCdn.js","hash":"1fd3f6d4df5d82aa085ccced56f79b34a11dc844","modified":1747645494000},{"_id":"themes/reimu/scripts/helper/wordCount.js","hash":"c68ccc8d36bda73d3b10254ba44abc2d74fb8539","modified":1747645494000},{"_id":"themes/reimu/scripts/tag/friendLink.js","hash":"9dfead4e7c81cda878077ba2057266b892b02483","modified":1747645494000},{"_id":"themes/reimu/scripts/tag/externalLinkCard.js","hash":"79c042e6ff5dc0a5a28d467a8d8f64db3d3d3b01","modified":1747645494000},{"_id":"themes/reimu/scripts/tag/postLinkCard.js","hash":"c36148a0e58cacae8b06c0b51a8ca75464e66c81","modified":1747645494000},{"_id":"themes/reimu/_example/_data/avatar/avatar.webp","hash":"427278caef0a47f8d0de7dabd51625856cd55a67","modified":1747645494000},{"_id":"themes/reimu/layout/_partial/analytics/clarity.ejs","hash":"60e452804d7b49bfecb638bf844727f8b4757346","modified":1747645494000},{"_id":"themes/reimu/scripts/tag/heatMapCard.js","hash":"3ae859a624dfef7968a2d9b09e1f38a7fa79ea03","modified":1747645494000},{"_id":"themes/reimu/_example/_data/avatar/writer.jpg","hash":"3b6f19b9626d4fc8e8cec19fbaf78fb6c972b611","modified":1747645848000},{"_id":"themes/reimu/layout/_partial/analytics/baidu-analytics.ejs","hash":"96aefe07308920ce06598a3448799d3907b3a124","modified":1747645494000},{"_id":"themes/reimu/layout/_partial/analytics/google-analytics.ejs","hash":"6c17a970259117736b84ece6087264db1d338d73","modified":1747645494000},{"_id":"themes/reimu/layout/_partial/post/category.ejs","hash":"c5aaef1f7b4e981280d88e03a48085e158e12ba9","modified":1747645494000},{"_id":"themes/reimu/layout/_partial/post/archives.ejs","hash":"8a90a823155c28cddc407a185d9e3bf5b3c0243c","modified":1747645494000},{"_id":"themes/reimu/layout/_partial/post/comment.ejs","hash":"7d5dc9c9e1a125c29c0530240ac9bb782d373446","modified":1747645494000},{"_id":"themes/reimu/layout/_partial/post/date.ejs","hash":"9f7df51264aafe5bcca109096ad4d6cc71cfa5bc","modified":1747645494000},{"_id":"themes/reimu/layout/_partial/post/nav.ejs","hash":"7c152026cf5ecad45b1e1ee9f360063e28ea75a4","modified":1747645494000},{"_id":"themes/reimu/layout/_partial/post/tag.ejs","hash":"0ee784b4fd9ac4d1610803eb9e8a9bb4fe87ac62","modified":1747645494000},{"_id":"themes/reimu/layout/_partial/post/gallery.ejs","hash":"6969c136df8473c186b05ff986cc048bcebce2eb","modified":1747645494000},{"_id":"themes/reimu/layout/_partial/post/sponsor.ejs","hash":"4e1526a5883a4c14b9377858e559f24ef78e99fd","modified":1747645494000},{"_id":"themes/reimu/layout/_partial/post/share.ejs","hash":"49b480d50e2653623bca4544a584c4e32dbf4640","modified":1747645494000},{"_id":"themes/reimu/source/css/_partial/aplayer.styl","hash":"4141cf8473a95ab6931a2cc59e89b9dd110ddd15","modified":1747645494000},{"_id":"themes/reimu/source/css/_partial/card.styl","hash":"a28ef1727015399821e2ff3753a63ac7e1abf991","modified":1747645494000},{"_id":"themes/reimu/source/css/_partial/article.styl","hash":"17c57801cd78a819e0c6570d832d0b400f5bafd2","modified":1747645494000},{"_id":"themes/reimu/source/css/_partial/archive.styl","hash":"d28c8fa934224c3b62ffe55c6b16d2c1cde37348","modified":1747645494000},{"_id":"themes/reimu/source/css/_partial/comment.styl","hash":"4197bda178fc797bdeff14289889059b0de75429","modified":1747645494000},{"_id":"themes/reimu/source/css/_partial/footer.styl","hash":"6158f3bb8ef2aba6b36b83aa2c510a0435d0b266","modified":1747645494000},{"_id":"themes/reimu/source/css/_partial/container.styl","hash":"0d1a478585e0c5f7c181083a6de30d52d03c65a1","modified":1747645494000},{"_id":"themes/reimu/source/css/_partial/highlight.styl","hash":"922dbec4be9b875d8058b8f95853e946a74b950a","modified":1747645494000},{"_id":"themes/reimu/source/css/_partial/friend.styl","hash":"080b4a91b151b324944b9e69168a0b78a97fd7cf","modified":1747645494000},{"_id":"themes/reimu/source/css/_partial/header.styl","hash":"dc744c1e9cc0f7c4e6633d27fa1a26bc7c948a8e","modified":1747645494000},{"_id":"themes/reimu/source/css/_partial/live2d_widgets.styl","hash":"894812732770b597e464f0abb35166213000f1f1","modified":1747645494000},{"_id":"themes/reimu/source/css/_partial/notification.styl","hash":"e6d49c6b033fd46a5202558d0aa0d88a7544524f","modified":1747645494000},{"_id":"themes/reimu/source/css/_partial/live2d.styl","hash":"1222f53d2fe4c95d786dabaac399a043a10d2aa7","modified":1747645494000},{"_id":"themes/reimu/source/css/_partial/mobile.styl","hash":"638f045874b30d2b6d3efe93eeeec22238b3d007","modified":1747645494000},{"_id":"themes/reimu/source/css/_partial/post.styl","hash":"8ffc57b2dde8043e0d53cf5a3d0fd73f1c863aae","modified":1747645494000},{"_id":"themes/reimu/source/css/_partial/search.styl","hash":"166646f6384814c657f0f6292790ee5bb969ae08","modified":1747748890000},{"_id":"themes/reimu/source/css/_partial/top.styl","hash":"31d5fbea55c778f3ab2e4512b338fa547fd49e51","modified":1747645494000},{"_id":"themes/reimu/source/css/_partial/share.styl","hash":"430d3b45b5a22ad3e564492c7ff078641ac9aec3","modified":1747645494000},{"_id":"themes/reimu/source/css/_partial/sponsor.styl","hash":"016fddfe629bce1b8479dfe35ea4fb4423b9498b","modified":1747645494000},{"_id":"themes/reimu/source/css/_partial/sidebar.styl","hash":"b9fb28b653713e94bb4a67d8762cd0448465ccb9","modified":1747645494000},{"_id":"themes/reimu/source/images/cursor/reimu-cursor-default.png","hash":"f2346c0da25f0657641de8d37ad2236fcd73580e","modified":1747645494000},{"_id":"themes/reimu/layout/_partial/sidebar/common-sidebar.ejs","hash":"06574e5d0602a5bb66475b4c7701da488b6fc8ae","modified":1747645494000},{"_id":"themes/reimu/source/css/_partial/widget.styl","hash":"502b70f3f0b23d73de0bc69bbc50fce081b516ca","modified":1747645494000},{"_id":"themes/reimu/layout/_partial/sidebar/toc-sidebar.ejs","hash":"40c94c9ce15a3671ab8768f45d54c308f0ad363b","modified":1747645494000},{"_id":"themes/reimu/source/images/cursor/reimu-cursor-text.png","hash":"c9fb0e6ed0e35033ea77544ff64531a6e0ac4e03","modified":1747645494000},{"_id":"themes/reimu/source/images/cursor/reimu-cursor-pointer.png","hash":"e5e8ec35303257face7e9ddca0a17e45a33c19c8","modified":1747645494000},{"_id":"themes/reimu/source/images/banner.webp","hash":"3ce4678c7510496b551672808b95dc21c4709eb7","modified":1747645494000},{"_id":"source/photo/音响.png","hash":"57d8cdca4a090cb222b7ee5ca74e273c5f3f2e2d","modified":1747749372000},{"_id":"themes/reimu/source/images/header.jpg","hash":"dab7e8a68850e8e7c7665de27a526e5253b9f415","modified":1747727252000},{"_id":"source/music_cover/等你下课.jpg","hash":"606be88b4de7068d70dd85136591b84b6f171c1a","modified":1759032296000},{"_id":"source/download/ESP32/wsl-usb-manager.exe","hash":"b9953c2ef6c32572b30abc05fdae7f8d6bfa66ea","modified":1757385794000},{"_id":"themes/reimu/_screenshot/Reimu_dark.png","hash":"b4be72f2d941333575d7dd0083052193fb818cc2","modified":1747645494000},{"_id":"themes/reimu/source/images/banner.png","hash":"74b7747a8e48c2e53f7d2e80059aa40afe29b3a0","modified":1747645494000},{"_id":"source/music_cover/枫.png","hash":"07e750cdf725c78251b7775a04aa6d17b99dd116","modified":1759032394000},{"_id":"source/music/慢慢.mp3","hash":"32a4f65279698ea2b0ef2fc7f0a5271f4a7553d4","modified":1747809512000},{"_id":"source/photo/wallhaven-02.jpg","hash":"b188afd262d28a357d83ed998f76474799fb51a8","modified":1758082166000},{"_id":"source/music/我只能离开.mp3","hash":"9b09bc090e59aed9f4d89ef7c32e11ac7933022b","modified":1747807460000},{"_id":"source/music/有些.mp3","hash":"03f1d5ee22ddb809a6c97326244ab7273696c5d7","modified":1747807540000},{"_id":"source/music/好想大声说爱你.mp3","hash":"70ee12b0134c7c3b576eeb98e6769ae5101dda52","modified":1747811306000},{"_id":"source/music/空白格.mp3","hash":"85d769a7b3c223217f2c6085d85a1e3d89b5436b","modified":1747810472000},{"_id":"source/music/借口.mp3","hash":"b484d2e7a9e11790bafdd5be2e2f0e5cdc052738","modified":1747808448000},{"_id":"source/music/等你下课.mp3","hash":"c9e672e8b5f0cb876f15f6954261264944616b13","modified":1747809654000},{"_id":"source/music/Cry.mp3","hash":"97656b828b0fd45a3b523d3d935d26823e55ac05","modified":1747811604000},{"_id":"source/music/绊.mp3","hash":"af841442324aa497aa136650544c39d9dec0ec9d","modified":1747810756000},{"_id":"source/music/倒带.mp3","hash":"015832271d1c51c5b81696eb1f4e697fb94b1265","modified":1747809558000},{"_id":"source/music/枫.mp3","hash":"5274f999c201b22a41df2cb0f2f59fa5c52357fe","modified":1747810340000},{"_id":"source/music/直到世界尽头.mp3","hash":"a4873261e08c4f177ee8f81bc22b828cd653c2fe","modified":1747811020000},{"_id":"source/music/火花.mp3","hash":"5b7b70ba360ffe99501ccf7700a5e462bcaf5a5b","modified":1747914598000},{"_id":"source/music/囍帖街.mp3","hash":"d72375669755f53fbfb5ae4442540734799805b8","modified":1759031778000},{"_id":"source/music/几分之几.mp3","hash":"5e9177a06c5e4fce9d9655369cecf86f4383db19","modified":1759031840000},{"_id":"source/music/借过.mp3","hash":"a5ed326c4f6898872cdb2771902d08733540b3fa","modified":1759031704000},{"_id":"source/music/赛勒斯的爱.mp3","hash":"bb752254394404ed2fb9e0772e05b3d80030f404","modified":1759036092000},{"_id":"source/music/千年泪.mp3","hash":"19763776dee39dac4aba3853cfa52e1e2503bbdf","modified":1759031654000},{"_id":"source/music/匿名的好友.mp3","hash":"892c184b1368270b7013e85d6e7d4ec3a075477c","modified":1759031808000},{"_id":"public/content.json","hash":"a85e9a234696a9ebfb21689b6b7e57b8c5446afb","modified":1768073731237},{"_id":"public/search.xml","hash":"084b602ca6a19665b189a6f42edd06ba493c0ca4","modified":1768073731237},{"_id":"public/search.json","hash":"3831ace75b1713fee5ba8bdc42ff77cad105cf48","modified":1768073731237},{"_id":"public/sw.js","hash":"a3d89796f3a1d5d7c1aa6462c46e5b414f02c85e","modified":1768073731237},{"_id":"public/404.html","hash":"e203b8f9e50ac6cce58ba66b5e98b3e040440632","modified":1768073731237},{"_id":"public/about/index.html","hash":"705845d20f06606c156379b83aa55c717f58a0d4","modified":1768073731237},{"_id":"public/search/index.html","hash":"97505c029fb0a01951e55b0d1f32b3320be26103","modified":1768073731237},{"_id":"public/friend/index.html","hash":"dba138514462bf239633e11680f232226eac8f6a","modified":1768073731237},{"_id":"public/2026/01/11/ble基础/index.html","hash":"13fdc8a162f39481ac3341b6347007986b220546","modified":1768073731237},{"_id":"public/2025/09/23/linux/index.html","hash":"5f9475671d70168e6d65e77dc165d2ec32820e35","modified":1768073731237},{"_id":"public/2025/09/09/ESP32学习/index.html","hash":"2bca835da0c2d46b277dc5a5706109d2cb518bbe","modified":1768073731237},{"_id":"public/2025/09/07/LVGL学习之旅-DESKTOP-40/index.html","hash":"b507f1dc63f5ee0d8f1aa81fcfea92b13fb5482d","modified":1768073731237},{"_id":"public/2025/09/07/LVGL学习之旅/index.html","hash":"58abde666b991bc2cd8555df2f779315416e0604","modified":1768073731237},{"_id":"public/2025/09/05/freertos/index.html","hash":"43784456ef0d8201405d91e064f5f9f5829c706d","modified":1768073731237},{"_id":"public/2025/09/02/C语言高级/index.html","hash":"dfb460b1bb54ad427cc82c12b79edbc39ea47998","modified":1768073731237},{"_id":"public/2025/06/08/电赛/index.html","hash":"b8656dd02b65af4e0ecded9e18168caf4e828182","modified":1768073731237},{"_id":"public/2025/06/02/西门子/index.html","hash":"d07f35c800733fc20df47ccc14bb16a467174730","modified":1768073731237},{"_id":"public/2025/05/28/TI/index.html","hash":"d7f856ca32a8c0cdfca898107669e913be3a437a","modified":1768073731237},{"_id":"public/2025/05/21/RT-Thread/index.html","hash":"7f96d68ba1e1093ec4e74fd8631bfb21064008d0","modified":1768073731237},{"_id":"public/2025/05/20/hexo命令/index.html","hash":"e95a29f138e8d3b6b34b2556e0a001aace7f1565","modified":1768073731237},{"_id":"public/2025/05/19/音响实习/index.html","hash":"e6b1331d2fd390ad2b6dcb4d64560eb43f0d1339","modified":1768073731237},{"_id":"public/categories/MCU/index.html","hash":"b582861a219e9f52903b0c02c03482c744f2d27d","modified":1768073731237},{"_id":"public/categories/实习知识/index.html","hash":"3073ea86b9aca4c708563ae12131580e903b4933","modified":1768073731237},{"_id":"public/archives/index.html","hash":"17d5078b8457c690487a372412605e5ac0c04b17","modified":1768073731237},{"_id":"public/archives/page/2/index.html","hash":"6cccb0cb5ab646cc7b37679fa21106614748c567","modified":1768073731237},{"_id":"public/archives/2025/index.html","hash":"cdd4d8e3f99457dc8c23fd402b4703464009e63c","modified":1768073731237},{"_id":"public/archives/2025/page/2/index.html","hash":"63b12dfd01d1e5e66631bef41d0dab2d0046841a","modified":1768073731237},{"_id":"public/archives/2025/05/index.html","hash":"e6c9919a5807ee0a63f39171b5458f1e0477fa81","modified":1768073731237},{"_id":"public/archives/2025/06/index.html","hash":"5e9ce28d0570aaef6fc3bd4145b455892f12ddcf","modified":1768073731237},{"_id":"public/archives/2025/09/index.html","hash":"c3b81ec886fc6fb218b0cf018e3db35f33594bf3","modified":1768073731237},{"_id":"public/archives/2026/index.html","hash":"7a4db71861fcf90acbf7d9facfd952b62e4dd6d7","modified":1768073731237},{"_id":"public/archives/2026/01/index.html","hash":"3336fd0dcabcebf528c5486f32784a5ee79f1de8","modified":1768073731237},{"_id":"public/index.html","hash":"c5c689de1ea86ed5ba7accbaed654b69627ada01","modified":1768073731237},{"_id":"public/page/2/index.html","hash":"9823c78b4d1d44fcb92a399505800fd4e5db3174","modified":1768073731237},{"_id":"public/tags/嵌入式基础/index.html","hash":"17ac5390d4a13abb275be565b3fba73daf96bc10","modified":1768073731237},{"_id":"public/tags/C语言高级/index.html","hash":"a3e194a34375faa91fe7d1a0b283223c5374be7b","modified":1768073731237},{"_id":"public/tags/LVGL-v8-2/index.html","hash":"bafe707fdf7b874c814a089b988b5b21c465b0ab","modified":1768073731237},{"_id":"public/tags/RTOS/index.html","hash":"519f301db2d35cac10c0d2f92e733248465c913a","modified":1768073731237},{"_id":"public/tags/蓝牙相关/index.html","hash":"453a9d5670a488c5f6fbb48e19d47f771f6bad65","modified":1768073731237},{"_id":"public/tags/BLE学习/index.html","hash":"233d3d8d4116733d50964031039e785583c2a442","modified":1768073731237},{"_id":"public/tags/ESP32/index.html","hash":"c95f38b9298611e008466cbf877897240ac56a9e","modified":1768073731237},{"_id":"public/tags/TI/index.html","hash":"0ea1161f229cb338e2d8b870f2ff00756e86b9d0","modified":1768073731237},{"_id":"public/tags/git/index.html","hash":"f8bd12a63de9a4e603f290354a51fb78286f85f5","modified":1768073731237},{"_id":"public/tags/实时操作系统/index.html","hash":"7ccf854f68b185fa0fb1602d3d30841c3012f3a6","modified":1768073731237},{"_id":"public/tags/RT-Thread/index.html","hash":"a6a95a9e3a661c8d14c2aacaca48b1ac9d6dfa2c","modified":1768073731237},{"_id":"public/tags/电赛准备/index.html","hash":"66ea362f6cef9344913ce11696d0915b4bba44c6","modified":1768073731237},{"_id":"public/tags/FreeRTOS/index.html","hash":"72bcb52c852ff2bfb23443057dadf2df6f0999bd","modified":1768073731237},{"_id":"public/tags/音响/index.html","hash":"3ae82e8335e931fe7b65b57d1c4448128695a927","modified":1768073731237},{"_id":"public/tags/实习/index.html","hash":"a45814adb1f3cce87e1c9c6365ae8b54c08c893d","modified":1768073731237},{"_id":"public/tags/音频技术/index.html","hash":"48cdc132c58179561da28d128acd7fca73c1b229","modified":1768073731237},{"_id":"public/tags/GD32学习/index.html","hash":"34919880dc06408a27312dbe71f7625d8668a05b","modified":1768073731237},{"_id":"public/images/algolia_logo.svg","hash":"6ddea54d87cc9dc2abf77bb22b615e5cb8e322b3","modified":1768073731237},{"_id":"public/images/banner-600w.webp","hash":"21a2f645b88e10b3bcbddc617142820897087b9c","modified":1768073731237},{"_id":"public/images/banner-800w.webp","hash":"b6816d3aff990eb6776c1257ef4489a9a75e9a1d","modified":1768073731237},{"_id":"public/images/favicon.ico","hash":"71abb7df9c06622a19baf55841dc36ac0b965a6f","modified":1768073731237},{"_id":"public/images/reimu.png","hash":"7bbaba99fda7b420759e169d72d226e4c4e9e665","modified":1768073731237},{"_id":"public/images/taichi-fill.png","hash":"1b1411207fc92903e76d414ebe6f4f32267de991","modified":1768073731237},{"_id":"public/images/taichi.png","hash":"297865b94e16a14c14447f6265d850cdbbb31852","modified":1768073731237},{"_id":"public/images/taichi-fill.svg","hash":"bd2598a12c1ad5f17d6ebdb635c192e2365ec156","modified":1768073731237},{"_id":"public/images/taichi.svg","hash":"d6d0ab8bc997a416d63b0257d6c2530e792c91ed","modified":1768073731237},{"_id":"public/images/cursor/reimu-cursor-default.png","hash":"f2346c0da25f0657641de8d37ad2236fcd73580e","modified":1768073731237},{"_id":"public/images/cursor/reimu-cursor-text.png","hash":"c9fb0e6ed0e35033ea77544ff64531a6e0ac4e03","modified":1768073731237},{"_id":"public/images/cursor/reimu-cursor-pointer.png","hash":"e5e8ec35303257face7e9ddca0a17e45a33c19c8","modified":1768073731237},{"_id":"public/download/Deepseek参会人员座位表.xlsx","hash":"62604f3e5730d693a7489dfb811084cb19117506","modified":1768073731237},{"_id":"public/download/Deepseek工作总结表.docx","hash":"0a684059bcc1a1fdb7b0f6ae41cb52f5fa03292d","modified":1768073731237},{"_id":"public/music_cover/Cry.jpg","hash":"e36221902df61defab33dec079d3c2b618ca58ad","modified":1768073731237},{"_id":"public/music_cover/几分之几.jpg","hash":"946b735a9448a6bd8d96843ce8ff4f3a3df699b0","modified":1768073731237},{"_id":"public/music_cover/借过.jpg","hash":"b3a2d16756916a9a403c01bb408fd6f0b2c1759b","modified":1768073731237},{"_id":"public/music_cover/囍帖街.jpg","hash":"da5a4625bd8071498d3c91d56a71085c0c61afa3","modified":1768073731237},{"_id":"public/music_cover/我只能离开.jpg","hash":"93911d2ced7818102ebe61b99a1712d8fb46cafb","modified":1768073731237},{"_id":"public/music_cover/火花.jpg","hash":"c5901e92eeb8dcb5d44d4e441ca2534275b0deaa","modified":1768073731237},{"_id":"public/music_cover/赛勒斯的爱.jpg","hash":"3b948ac9b439e0933dc3df2bee70bd49a879c393","modified":1768073731237},{"_id":"public/lrc/Cry.lrc","hash":"cfbfd360cc4aff6e98b4d45cbd946e9287b6dfcb","modified":1768073731237},{"_id":"public/lrc/スパークル (movie ver.) - RADWIMPS.lrc","hash":"7c4ed210d39e157770bc91a42930a2fbe55054ae","modified":1768073731237},{"_id":"public/lrc/倒带(Live)-周杰伦.lrc","hash":"4cd41992250aaf8891df40391a4b9fc8de3e053d","modified":1768073731237},{"_id":"public/lrc/世界が終るまでは…-WANDS.lrc","hash":"c2b38e799250d37895678be05a928b990493621d","modified":1768073731237},{"_id":"public/lrc/借口-周杰伦.lrc","hash":"b36830c79067f9fd854c1fc5906ca9f0f3c65389","modified":1768073731237},{"_id":"public/lrc/借过.lrc","hash":"829fa5a77729e5f8c38da2ce15cf6a26fa8fe448","modified":1768073731237},{"_id":"public/lrc/匿名的好友 - 杨丞琳.lrc","hash":"17b5b46a47ecf89b694096edde58cfac0dbd394a","modified":1768073731237},{"_id":"public/lrc/几分之几 (You Complete Me) - 卢广仲.lrc","hash":"5e7baad76dd56bb0975a135371125ca398af8843","modified":1768073731237},{"_id":"public/lrc/君が好きだと叫びたい-Baad.lrc","hash":"811479f8092309d55013219b7d1ef4471f00f246","modified":1768073731237},{"_id":"public/lrc/千年泪 - 曹雨航.lrc","hash":"6aed0e4ae1d2a7a82552e4f72568a1479887b92c","modified":1768073731237},{"_id":"public/lrc/慢慢-颜人中.lrc","hash":"84c8cc826269d081bef243d66ac2d93728ec36ec","modified":1768073731237},{"_id":"public/lrc/喜帖街 - 谢安琪.lrc","hash":"767a78a5bc2c4e786a73a28054dc02387bc975d8","modified":1768073731237},{"_id":"public/lrc/有些-颜人中.lrc","hash":"46c5be1956d8a5714fdbbaa7109331eeac326f4a","modified":1768073731237},{"_id":"public/lrc/我只能离开-颜人中.lrc","hash":"cdedb6d91fc820622ef340f5c44e0119aec686c8","modified":1768073731237},{"_id":"public/lrc/枫-周杰伦.lrc","hash":"e2626df7d9e20bddb3b1eb9234dea000672e051e","modified":1768073731237},{"_id":"public/lrc/空白格-蔡健雅.lrc","hash":"70a6a0b08015297419c9e181e456a45d6238009c","modified":1768073731237},{"_id":"public/lrc/等你下课(with 杨瑞代)-周杰伦.lrc","hash":"d4670ac64892f9610f3467111c151cc4284bc016","modified":1768073731237},{"_id":"public/lrc/絆-miu-clips.lrc","hash":"0effffb4bb87718aad7582d05b3d99fc82fb4286","modified":1768073731237},{"_id":"public/lrc/赛勒斯的爱-张敬轩.lrc","hash":"7dd3d2bdbff66a9c2a84ba27be172eea22926c2e","modified":1768073731237},{"_id":"public/photo/hexo.jpg","hash":"ae9da14439b1863866e0f322cde5746eecdda61f","modified":1768073731237},{"_id":"public/photo/logo-colored.png","hash":"8cd0f874ba6909ecea6f93cf597921d6d7247334","modified":1768073731237},{"_id":"public/about/index.assets/00AD4F6E.gif","hash":"beb4aea652f255acd7a54dee73603e3ce47b003a","modified":1768073731237},{"_id":"public/avatar/avatar.webp","hash":"427278caef0a47f8d0de7dabd51625856cd55a67","modified":1768073731237},{"_id":"public/avatar/writer.jpg","hash":"3b6f19b9626d4fc8e8cec19fbaf78fb6c972b611","modified":1768073731237},{"_id":"public/images/banner.webp","hash":"3ce4678c7510496b551672808b95dc21c4709eb7","modified":1768073731237},{"_id":"public/music_cover/借口.jpg","hash":"306cf12609c52ac7b1b001ea6e67a1d84160aa3a","modified":1768073731237},{"_id":"public/music_cover/千年泪.jpg","hash":"4b4a867f058da377a0ec8fe1ef19c4ecb5429bc3","modified":1768073731237},{"_id":"public/music_cover/慢慢.jpg","hash":"566f2b99b4590b4fb3e941aa5ebdc51a0cf3a767","modified":1768073731237},{"_id":"public/music_cover/空白格.jpg","hash":"06bb5f7960b8711ac216734df38b14f8c1664c4e","modified":1768073731237},{"_id":"public/music_cover/直到世界尽头.jpg","hash":"13d4e6fb64feefcb131f5576c27c9a59a462b3f6","modified":1768073731237},{"_id":"public/photo/ble.jpg","hash":"214f263be757b74677febe82f6707e09b53a95fb","modified":1768073731237},{"_id":"public/photo/电赛.png","hash":"0801133a780eb7e69b8ac285043d82c01ed7b511","modified":1768073731237},{"_id":"public/about/index.assets/00ADEA47.gif","hash":"35a80a356147aaf3baa4474fb5bfafe7e2f1d337","modified":1768073731237},{"_id":"public/css/heat-map.css","hash":"f0b8699c20c9969d06df26d6faba14f8e83e2fbb","modified":1768073731237},{"_id":"public/css/loader.css","hash":"15b83dc02ae09aebfac432324adaea29d8e28921","modified":1768073731237},{"_id":"public/css/fontawesome.css","hash":"200a66f87757288cb9e60afda6ea07070bde7fdc","modified":1768073731237},{"_id":"public/css/iconfont.css","hash":"374b597de6c7796193267369a5dfa46b89aeaaaf","modified":1768073731237},{"_id":"public/css/style.css","hash":"f3bd4e4dab2124db09ce155d03e5a18e5bc1036e","modified":1768073731237},{"_id":"public/js/generator_search.js","hash":"672bf9f15d0eb32145a8786d4c1b2b4724c162f3","modified":1768073731237},{"_id":"public/js/pjax.js","hash":"9eba500d50e8adca7f30908c37f3cca1f199ac8a","modified":1768073731237},{"_id":"public/js/heat_map.js","hash":"efd23574ad977f2b6ef5c9c0e6595f4d47df0a9d","modified":1768073731237},{"_id":"public/js/insert_highlight.js","hash":"2fcb5828e3d40e3c254081bf0c162a941c851532","modified":1768073731237},{"_id":"public/js/aos.js","hash":"703e8ed1163f299905a81721ebdef0f74ae77353","modified":1768073731237},{"_id":"public/js/pjax_script.js","hash":"362526fb785844d3f82289d9954bb48c526e7e89","modified":1768073731237},{"_id":"public/js/service_worker.js","hash":"578892dc37035e5d75623061daab284a55d580ce","modified":1768073731237},{"_id":"public/js/script.js","hash":"067a123933be9126f42b4e434185aa39eb7e888c","modified":1768073731237},{"_id":"public/js/algolia_search.js","hash":"b01c5d9d443f4a073a24212fcf536fb5ce593c94","modified":1768073731237},{"_id":"public/js/sw.js","hash":"72a5e8709e5d1087f74a42eb0287398d3ed7a6a0","modified":1768073731237},{"_id":"public/music_cover/倒带.jpg","hash":"9816ef170c1964f2b4f185e939bfe62d38433470","modified":1768073731237},{"_id":"public/music_cover/好想大声说爱你.jpg","hash":"7e56de3b52878667eaae52bbeb23b031af873166","modified":1768073731237},{"_id":"public/music_cover/绊.jpg","hash":"4f88ec19b221577bfffcb99e9b876a5ff2a581a4","modified":1768073731237},{"_id":"public/music_cover/有些.jpg","hash":"cc5755ac510e378c1c90a060499f98510345bb98","modified":1768073731237},{"_id":"public/photo/RT-Thread.png","hash":"32e7a0dc5a68b4effaf2cddb07f68fb593283b0c","modified":1768073731237},{"_id":"public/photo/const-logo.png","hash":"e96b8bccb8a560daa18db57f7d098071346714e7","modified":1768073731237},{"_id":"public/photo/嵌入式.jpg","hash":"5a6d73450ab54f3c15188d316aeb0356fc262952","modified":1768073731237},{"_id":"public/music_cover/匿名的好友.jpg","hash":"fc5b858aa7f84633c082e9d50a486571284d6aa0","modified":1768073731237},{"_id":"public/images/header.jpg","hash":"dab7e8a68850e8e7c7665de27a526e5253b9f415","modified":1768073731237},{"_id":"public/photo/freertos-logo-1f2c2b10db17ff7350f71b4ac56d11ff.png","hash":"d422841eee543e328f81b9753b55567be80ec23b","modified":1768073731237},{"_id":"public/images/banner.png","hash":"74b7747a8e48c2e53f7d2e80059aa40afe29b3a0","modified":1768073731237},{"_id":"public/photo/音响.png","hash":"57d8cdca4a090cb222b7ee5ca74e273c5f3f2e2d","modified":1768073731237},{"_id":"public/music_cover/等你下课.jpg","hash":"606be88b4de7068d70dd85136591b84b6f171c1a","modified":1768073731237},{"_id":"public/download/ESP32/wsl-usb-manager.exe","hash":"b9953c2ef6c32572b30abc05fdae7f8d6bfa66ea","modified":1768073731237},{"_id":"public/music_cover/枫.png","hash":"07e750cdf725c78251b7775a04aa6d17b99dd116","modified":1768073731237},{"_id":"public/music/慢慢.mp3","hash":"32a4f65279698ea2b0ef2fc7f0a5271f4a7553d4","modified":1768073731237},{"_id":"public/photo/wallhaven-02.jpg","hash":"b188afd262d28a357d83ed998f76474799fb51a8","modified":1768073731237},{"_id":"public/music/我只能离开.mp3","hash":"9b09bc090e59aed9f4d89ef7c32e11ac7933022b","modified":1768073731237},{"_id":"public/music/好想大声说爱你.mp3","hash":"70ee12b0134c7c3b576eeb98e6769ae5101dda52","modified":1768073731237},{"_id":"public/music/有些.mp3","hash":"03f1d5ee22ddb809a6c97326244ab7273696c5d7","modified":1768073731237},{"_id":"public/music/空白格.mp3","hash":"85d769a7b3c223217f2c6085d85a1e3d89b5436b","modified":1768073731237},{"_id":"public/music/借口.mp3","hash":"b484d2e7a9e11790bafdd5be2e2f0e5cdc052738","modified":1768073731237},{"_id":"public/music/等你下课.mp3","hash":"c9e672e8b5f0cb876f15f6954261264944616b13","modified":1768073731237},{"_id":"public/music/Cry.mp3","hash":"97656b828b0fd45a3b523d3d935d26823e55ac05","modified":1768073731237},{"_id":"public/music/绊.mp3","hash":"af841442324aa497aa136650544c39d9dec0ec9d","modified":1768073731237},{"_id":"public/music/倒带.mp3","hash":"015832271d1c51c5b81696eb1f4e697fb94b1265","modified":1768073731237},{"_id":"public/music/枫.mp3","hash":"5274f999c201b22a41df2cb0f2f59fa5c52357fe","modified":1768073731237},{"_id":"public/music/直到世界尽头.mp3","hash":"a4873261e08c4f177ee8f81bc22b828cd653c2fe","modified":1768073731237},{"_id":"public/music/火花.mp3","hash":"5b7b70ba360ffe99501ccf7700a5e462bcaf5a5b","modified":1768073731237},{"_id":"public/music/囍帖街.mp3","hash":"d72375669755f53fbfb5ae4442540734799805b8","modified":1768073731237},{"_id":"public/music/几分之几.mp3","hash":"5e9177a06c5e4fce9d9655369cecf86f4383db19","modified":1768073731237},{"_id":"public/music/借过.mp3","hash":"a5ed326c4f6898872cdb2771902d08733540b3fa","modified":1768073731237},{"_id":"public/music/赛勒斯的爱.mp3","hash":"bb752254394404ed2fb9e0772e05b3d80030f404","modified":1768073731237},{"_id":"public/music/千年泪.mp3","hash":"19763776dee39dac4aba3853cfa52e1e2503bbdf","modified":1768073731237},{"_id":"public/music/匿名的好友.mp3","hash":"892c184b1368270b7013e85d6e7d4ec3a075477c","modified":1768073731237}],"Category":[{"name":"MCU","_id":"cmk8pg6xh00076sk9h0gc321f"},{"name":"实习知识","_id":"cmk8pg6xp00186sk97vjyehyh"}],"Data":[{"_id":"covers","data":["https://d-sketon.top/img/backimg/bg1.jpg"]},{"_id":"avatar/avatar","data":"RIFF��\u0000\u0000WEBPVP8X\n\u0000\u0000\u0000,\u0000\u0000\u0000�\u0000\u0000�\u0000\u0000ICCPH\f\u0000\u0000\u0000\u0000\fHLino\u0002\u0010\u0000\u0000mntrRGB XYZ \u0007�\u0000\u0002\u0000\t\u0000\u0006\u00001\u0000\u0000acspMSFT\u0000\u0000\u0000\u0000IEC sRGB\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000��\u0000\u0001\u0000\u0000\u0000\u0000�-HP  \u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0011cprt\u0000\u0000\u0001P\u0000\u0000\u00003desc\u0000\u0000\u0001�\u0000\u0000\u0000lwtpt\u0000\u0000\u0001�\u0000\u0000\u0000\u0014bkpt\u0000\u0000\u0002\u0004\u0000\u0000\u0000\u0014rXYZ\u0000\u0000\u0002\u0018\u0000\u0000\u0000\u0014gXYZ\u0000\u0000\u0002,\u0000\u0000\u0000\u0014bXYZ\u0000\u0000\u0002@\u0000\u0000\u0000\u0014dmnd\u0000\u0000\u0002T\u0000\u0000\u0000pdmdd\u0000\u0000\u0002�\u0000\u0000\u0000�vued\u0000\u0000\u0003L\u0000\u0000\u0000�view\u0000\u0000\u0003�\u0000\u0000\u0000$lumi\u0000\u0000\u0003�\u0000\u0000\u0000\u0014meas\u0000\u0000\u0004\f\u0000\u0000\u0000$tech\u0000\u0000\u00040\u0000\u0000\u0000\frTRC\u0000\u0000\u0004<\u0000\u0000\b\fgTRC\u0000\u0000\u0004<\u0000\u0000\b\fbTRC\u0000\u0000\u0004<\u0000\u0000\b\ftext\u0000\u0000\u0000\u0000Copyright (c) 1998 Hewlett-Packard Company\u0000\u0000desc\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0012sRGB IEC61966-2.1\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0012sRGB IEC61966-2.1\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000XYZ \u0000\u0000\u0000\u0000\u0000\u0000�Q\u0000\u0001\u0000\u0000\u0000\u0001\u0016�XYZ \u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000XYZ \u0000\u0000\u0000\u0000\u0000\u0000o�\u0000\u00008�\u0000\u0000\u0003�XYZ \u0000\u0000\u0000\u0000\u0000\u0000b�\u0000\u0000��\u0000\u0000\u0018�XYZ \u0000\u0000\u0000\u0000\u0000\u0000$�\u0000\u0000\u000f�\u0000\u0000��desc\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0016IEC http://www.iec.ch\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0016IEC http://www.iec.ch\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000desc\u0000\u0000\u0000\u0000\u0000\u0000\u0000.IEC 61966-2.1 Default RGB colour space - sRGB\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000.IEC 61966-2.1 Default RGB colour space - sRGB\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000desc\u0000\u0000\u0000\u0000\u0000\u0000\u0000,Reference Viewing Condition in IEC61966-2.1\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000,Reference Viewing Condition in IEC61966-2.1\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000view\u0000\u0000\u0000\u0000\u0000\u0013��\u0000\u0014_.\u0000\u0010�\u0014\u0000\u0003��\u0000\u0004\u0013\u000b\u0000\u0003\\�\u0000\u0000\u0000\u0001XYZ \u0000\u0000\u0000\u0000\u0000L\tV\u0000P\u0000\u0000\u0000W\u001f�meas\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0001\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0002�\u0000\u0000\u0000\u0002sig \u0000\u0000\u0000\u0000CRT curv\u0000\u0000\u0000\u0000\u0000\u0000\u0004\u0000\u0000\u0000\u0000\u0005\u0000\n\u0000\u000f\u0000\u0014\u0000\u0019\u0000\u001e\u0000#\u0000(\u0000-\u00002\u00007\u0000;\u0000@\u0000E\u0000J\u0000O\u0000T\u0000Y\u0000^\u0000c\u0000h\u0000m\u0000r\u0000w\u0000|\u0000�\u0000�\u0000�\u0000�\u0000�\u0000�\u0000�\u0000�\u0000�\u0000�\u0000�\u0000�\u0000�\u0000�\u0000�\u0000�\u0000�\u0000�\u0000�\u0000�\u0000�\u0000�\u0000�\u0000�\u0000�\u0001\u0001\u0001\u0007\u0001\r\u0001\u0013\u0001\u0019\u0001\u001f\u0001%\u0001+\u00012\u00018\u0001>\u0001E\u0001L\u0001R\u0001Y\u0001`\u0001g\u0001n\u0001u\u0001|\u0001�\u0001�\u0001�\u0001�\u0001�\u0001�\u0001�\u0001�\u0001�\u0001�\u0001�\u0001�\u0001�\u0001�\u0001�\u0001�\u0002\u0003\u0002\f\u0002\u0014\u0002\u001d\u0002&\u0002/\u00028\u0002A\u0002K\u0002T\u0002]\u0002g\u0002q\u0002z\u0002�\u0002�\u0002�\u0002�\u0002�\u0002�\u0002�\u0002�\u0002�\u0002�\u0002�\u0002�\u0003\u0000\u0003\u000b\u0003\u0016\u0003!\u0003-\u00038\u0003C\u0003O\u0003Z\u0003f\u0003r\u0003~\u0003�\u0003�\u0003�\u0003�\u0003�\u0003�\u0003�\u0003�\u0003�\u0003�\u0004\u0006\u0004\u0013\u0004 \u0004-\u0004;\u0004H\u0004U\u0004c\u0004q\u0004~\u0004�\u0004�\u0004�\u0004�\u0004�\u0004�\u0004�\u0004�\u0004�\u0005\r\u0005\u001c\u0005+\u0005:\u0005I\u0005X\u0005g\u0005w\u0005�\u0005�\u0005�\u0005�\u0005�\u0005�\u0005�\u0005�\u0006\u0006\u0006\u0016\u0006'\u00067\u0006H\u0006Y\u0006j\u0006{\u0006�\u0006�\u0006�\u0006�\u0006�\u0006�\u0006�\u0007\u0007\u0007\u0019\u0007+\u0007=\u0007O\u0007a\u0007t\u0007�\u0007�\u0007�\u0007�\u0007�\u0007�\u0007�\b\u000b\b\u001f\b2\bF\bZ\bn\b�\b�\b�\b�\b�\b�\b�\t\u0010\t%\t:\tO\td\ty\t�\t�\t�\t�\t�\t�\n\u0011\n'\n=\nT\nj\n�\n�\n�\n�\n�\n�\u000b\u000b\u000b\"\u000b9\u000bQ\u000bi\u000b�\u000b�\u000b�\u000b�\u000b�\u000b�\f\u0012\f*\fC\f\\\fu\f�\f�\f�\f�\f�\r\r\r&\r@\rZ\rt\r�\r�\r�\r�\r�\u000e\u0013\u000e.\u000eI\u000ed\u000e\u000e�\u000e�\u000e�\u000e�\u000f\t\u000f%\u000fA\u000f^\u000fz\u000f�\u000f�\u000f�\u000f�\u0010\t\u0010&\u0010C\u0010a\u0010~\u0010�\u0010�\u0010�\u0010�\u0011\u0013\u00111\u0011O\u0011m\u0011�\u0011�\u0011�\u0011�\u0012\u0007\u0012&\u0012E\u0012d\u0012�\u0012�\u0012�\u0012�\u0013\u0003\u0013#\u0013C\u0013c\u0013�\u0013�\u0013�\u0013�\u0014\u0006\u0014'\u0014I\u0014j\u0014�\u0014�\u0014�\u0014�\u0015\u0012\u00154\u0015V\u0015x\u0015�\u0015�\u0015�\u0016\u0003\u0016&\u0016I\u0016l\u0016�\u0016�\u0016�\u0016�\u0017\u001d\u0017A\u0017e\u0017�\u0017�\u0017�\u0017�\u0018\u001b\u0018@\u0018e\u0018�\u0018�\u0018�\u0018�\u0019 \u0019E\u0019k\u0019�\u0019�\u0019�\u001a\u0004\u001a*\u001aQ\u001aw\u001a�\u001a�\u001a�\u001b\u0014\u001b;\u001bc\u001b�\u001b�\u001b�\u001c\u0002\u001c*\u001cR\u001c{\u001c�\u001c�\u001c�\u001d\u001e\u001dG\u001dp\u001d�\u001d�\u001d�\u001e\u0016\u001e@\u001ej\u001e�\u001e�\u001e�\u001f\u0013\u001f>\u001fi\u001f�\u001f�\u001f� \u0015 A l � � �!\u001c!H!u!�!�!�\"'\"U\"�\"�\"�#\n#8#f#�#�#�$\u001f$M$|$�$�%\t%8%h%�%�%�&'&W&�&�&�'\u0018'I'z'�'�(\r(?(q(�(�)\u0006)8)k)�)�*\u0002*5*h*�*�+\u0002+6+i+�+�,\u0005,9,n,�,�-\f-A-v-�-�.\u0016.L.�.�.�/$/Z/�/�/�050l0�0�1\u00121J1�1�1�2*2c2�2�3\r3F33�3�4+4e4�4�5\u00135M5�5�5�676r6�6�7$7`7�7�8\u00148P8�8�9\u00059B99�9�:6:t:�:�;-;k;�;�<'<e<�<�=\"=a=�=�> >`>�>�?!?a?�?�@#@d@�@�A)AjA�A�B0BrB�B�C:C}C�D\u0003DGD�D�E\u0012EUE�E�F\"FgF�F�G5G{G�H\u0005HKH�H�I\u001dIcI�I�J7J}J�K\fKSK�K�L*LrL�M\u0002MJM�M�N%NnN�O\u0000OIO�O�P'PqP�Q\u0006QPQ�Q�R1R|R�S\u0013S_S�S�TBT�T�U(UuU�V\u000fV\\V�V�WDW�W�X/X}X�Y\u001aYiY�Z\u0007ZVZ�Z�[E[�[�\\5\\�\\�]']x]�^\u001a^l^�_\u000f_a_�`\u0005`W`�`�aOa�a�bIb�b�cCc�c�d@d�d�e=e�e�f=f�f�g=g�g�h?h�h�iCi�i�jHj�j�kOk�k�lWl�m\bm`m�n\u0012nkn�o\u001eoxo�p+p�p�q:q�q�rKr�s\u0001s]s�t\u0014tpt�u(u�u�v>v�v�wVw�x\u0011xnx�y*y�y�zFz�{\u0004{c{�|!|�|�}A}�~\u0001~b~�#��G���\n�k�͂0����W���\u001d����G���\u000e�r�ׇ;���\u0004�i�Ή3�����d�ʋ0�����c�ʍ1�����f�Ώ6���\u0006�n�֑?���\u0011�z��M��� �����_�ɖ4���\n�u���L���$�����h�՛B���\u001c�����d�Ҟ@���\u001d�����i�ءG���&���\u0006�v��V�ǥ8���\u001a�����n��R�ĩ7���\u001c���\u0002�u��\\�ЭD���-���\u0016���\u0000�u��`�ֲK�³8���%���\u0013���\u0001�y��h��Y�ѹJ�º;���.���!���\u0015���\n�����z���p���g���_���X���Q���K���F���Aǿ�=ȼ�:ɹ�8ʷ�6˶�5̵�5͵�6ζ�7ϸ�9к�<Ѿ�?���D���I���N���U���\\���d���l���v��ۀ�\u0005܊�\u0010ݖ�\u001cޢ�)߯�6��D���S���c���s����\r��\u001f��2��F���[���p����\u0011��(��@���X���r����\u0019��4���P���m�����\u0019���8���W���w�\u0007���)���K���m��VP8 ��\u0000\u0000��\u0000�\u0001*�\u0000�\u0000>\u0004\u0001[\u0000\u0000\b�w\u000f@o��y![\u00144�\"\t�n�?�y\u0002uw2��?�z\u0014������\\���v������Y�\u0000�ca;��\u0007HM\u0013���o�����;�c��m��������Q������\u0004|��?�\u000fxnJ�!�\u0013�������>����'���S����?\u0000?���?���G�����O��?����\r�����g�\u001f�\u001f��������S���O��������\u0001�c�w�������q\u000f����}�����=�;�_�/�����?��������o�Ϡ��_ٿ��f��������\u0001�s�\u0003rg�_�? ?]�G�\u0003�\u001f��1�����O��\u001f���|��?�?�z���������{�����O�?��\u001e�,}��+�'�c�\u000b�_�?��~�j�����\u0006����\u0002���\u001f���~�t�������?�~e�����\u001f�_�\u001f@\u001f�������\u001f�O�\u001f��8��\u001b�����\u001f�\u001fҿ���?�������\u001fe�����_�+������\u0006�g�;�7���o��޿����\u0004�[�\u0013�\u001f�O�?�������%���\u001f�����\u000f�?��M�X?��s2\u0017�*'�'F�B�mhU]�$�O\u0003�\u001c\u0015;���(�s\u000eW�8\rΟ\u0013���Iy��xS@j��\u000e�\u001f��\u0013�KGʛ�[�/�\t��o�����3���:�\u0019h>�{q\u00190��m�5���7����U;\u001dE��,���\u0000\u0013����_v���;x\rT�\u000f\u001a]\u000e\u0007.�)&�N\u0007��F]>�(r��\u0001�־c�7nO\u000b)�=!�\u0019���f\u0002�Jw��)�c�20k\u0011✖�{�D��gcnַH6���t��\u0004\u0014-l\u00112_��;�V\u001b�1�\u0016?���2�\u001f�ݠ��b&.h\u000e\u0013[�.��̷������si�r��~U\u0002��E�\u0012�rQ8�\t��G�\u0007��U�N�q���oj���=���;z��|�ý���E\u0017�Ϊ!\f�\u0017$\u000e��҇\u0016u['��\u000e������F��\u0011���\u001d�T6�\u0019�U\u0001 ���\\�����G��%���t�~�!\u0015M��ǊUչTԴ\u0007E\f�I�f}����{�\u001e�e߻��z�\u0000\u001b�\f:A�lǧ}�|��\"���/jB\u0002W�F \u0005��C�.�D�NP�~�+�9��-�v�O��ڢ�z\u0000z�?�w�5u;_�\u0018/�\u0015�{܍?�ʺ��\u001f�ߖ3��\u001a�l�lA?� �\u000ed�G7Y���-�E.\n�6�A4�!��\b�C�\nWi\u0019Y~m�$j����:\u0004m�����U�R���\u001b\u0006gAyb�R�XY�����ro\u001bY\b!x��e��µJ����R\u0012_i�z\u0004Z�*�C�\u001c���,��\u0018�X�m.�\u0012J����͚�.��|3��پmp���-#��\u0003\u0015ޫ�\u0010�D�>�L��\b;,�$�]\b���\u0001�ӝ���,��\u001fjW�є�~�.Ѱo;�\u000f�D�V�e�\r\u0000ZaԧN�9`�}�\t��倅��\u00108D�f���5\u0019�M���\u001da�V\f��\b�W��>[Azq��Jﭳϣ�N\u0016�~��N���\u001f\n���i~��\u0004N���jT@�������n�L�5\u0010g�M�c\u0014\"�;nm��8�����\u001dآ�������]��&}�~��\t ��ڟ�%�\u0014Ԅk�s�\u0001�AvI\u001c�\u0010aE������T\u001a��!��@D��{*�w��@�D��]�\u0011=\u0000�\u0003���4�\u0015�\u0018�9k=(=M�#W��\f� �-���\u000es\u001fZ\u0018d��uƦ���ٯ�\\ʧ�\r�\u0011M�p�挅I<�8���\u000fO\u0003\u001e؝F6�V?�\u0007�즖}�\u0004���_\f��[ �\u0016��;a}\u0015��}��yL���p\u0010?�#��o\u001e�Jy\u00052O�;���ҙ\u000e�\u0003���ڪ�!\u000bQ�Y@Ѓ�l`|5G�@�������grŜi=�\u0002i��)wc���NK0S�z�u��%Xsϗ��w\u0017����\u001b۴�n^��'ݒ\u0005��\u0012ţ��nDG?�V;0\u0001�M\u001aw\u0019\u000fuh�����I�\u0013��7ͱ�Q�X�\u000e�\\x\f�μ\u0002��\u0019��*,��6�؋�\u0000\u0000���F�U��4��Z�s�ŭIa�rU��\u0001r��A9aT�\u0014$4\n�g�\u001f��V��O�ߢ`v�\u001d?����Jp�\u0018��4�\b�r��`x���\u0004���,�(��\u0018����t]ʼ._�\u0018j��\u0000��\"#=�݉ګ\u001d\f\u0015#m�@��{��8�~��J�ֵ8�\rN��\u000b�\u0019p��z \u000b;ҁ��¼�J�G[.a蕓�-wAt��=�!K�\u001esL�j�t�\u0005�l�JH�S\u000fE�W|��\t\u0006r��\\\f��s�~�8\n�W\u001f�\u000e\u0000\u001f󢍘\u0007�q�\u0000?\t��\u0010K��G��D��\u001crnc�\u001e��\r�\u0015�'�\t����,,B�>�d3��^s\u000f۲��\u000b��\u0013�\u0015|϶\rx\u0010�����t���0���B\u0007Ye|��L\u0003�[����\u0019^�N݃�\u0012Bq��d���tK���Ht�\u001a�\f�����$�P�\r�\r)���Qd��\u0018\u000bLy�\u0016�M8�זJδ\u0004\u000f\u0012�%؉!��S_�d�!�I��\nՃ\f��\u0019\u0007�{�0yc�I�y|�反*\u001f�.�Ia�Z�5�+�\u001bRf\u0000��w]��>ҮΫ\u001em�g#џ\u0017�\u0000�B���® ��yJ\u001dP�LP\u0012�\u000f\b�\u0010�Q��\u0016\nӰ�w�\r��4��i����h��\u0013\u0018�'f��z\u0005x����V�<~��9��Hc幵�-�!\u0002�*^2{[9V�K�}e\u0006N��S%��X#\u0017E�hQ;@�\u000f\u0000�v�\t�œ��Kw�疦��6��nj���\u0002��\"?���,!V@�\u0018\u001bd\u000b�\u0012QW��1ě�\u0012g�)ы�\u0007\u001fS\u0017��\u001ff������*9�m\u0005-}X�\u0010\u0005\u0002�q���\u001d��D���\\\"�/��k��M����\u0015u���Z@�uʬT�q\u001c���\u0000�D\f�n�q���Wo�~�\u000f�2\u0017��ւqO\b��1��|Z�~��P)l}�6p�V���|@Ľ\u0019��\u0016�rW+?�y\u0004[z�\u0016C\u0002gw�r����q������4M�\u0005�Ϳ؛\u0019JW^\u001d?8r\\+nTK٪zn\u0014V\\�{��\n�w�zH�EԻ\u001f\u0019pdK\u001fetb؟�o\"\bD�U\u001b��\u0007!HdX#� \u001b�X����SL\"�wM��\u0018~ܻbU,}�y���1�yJ���*�p@\u0005�'B�I*vrJ��YQ/�4\fVeDf����\u0007%�#��ܵ�U��(�Ë�\u001c��?�s\u0014\u0015\u001e�v4P�\n⅓\u0002b��5���/y�Վ��o\"����\u0015�S��zW��`���\rWË�\u001e�u)�\u0013�b�4�ι,\u0004�9�W�q\u0000�L���a�w��\"H��s����׷��ǲY�7�����!�E\u001f\u000f'b�Yw��2\n\u001bNLW�4]�\u0011�i�wT/\u000e�o�\n�\tl����F\t���\u000f!\u0006UҭxT����ab�W��e�F�r�\u001bP�g�\u0003�7�P\u0019�\u0018�t<�ҭd�u�X���S��\u001c\f��\bs̐���&\u0016d\u0005ᦜ7�I��7�5�1%8�U�ғ\u0001h���A3��h\u0000��VB�\u001e>�ݿ\fr��@�\u000f|�\rT�Ǥ�܌��&��~ퟡ\u0015X2�q�ix(����V�/< *Tq8�p��L/��\u0002�%.9�\u0001��\u0018ᅋ�j\u0012��\u001a��_\u001eV��:�e&H}\r��{�,��\u001eH#\u0005fbln�v���jƠ\b�\u000e�J�����\u0016�\rP\u0017\f�?��\u001e%=E4\u001d\u0015%�\\�BY;9�A�<\u0015����\u001co\u0011�|�_�n\u0003\b��\u0019�W�\u00169p�\u0007�PV[\b@I��T\u000e��\u0012�\u0000K\u0006;\u0000�-�9xpI�\u0007%\u0013j,Q���K�'�c_�\u0017���E�\u0010�n\f9cݴ�-���\\C9$2��J�Ҧ7g�`�%�\u000e�$Nu�J'�\t�|R����\b'���>0����Q��\u001d�\u0013�H�����/�#d���b�nV툟�.8�\u0003�|\\)i�\u0012��\u0013m\u0019�q\u000f���|����+�[>Y�}�Z,\u0011\u001cR�޺a��ғ�U�\u001aBu�~°���\u0000a��&</��w�h��u\u0004j}�B�D��C��\u0016��0�ȠNEP�K��u��<�\u0010�'B\u001b&�\u001c۽ɕ\u0000\n�\u000bB~ s�\u0002�vT\r\u0014�_Quvf����%4��=;����f)Tx�S\r8�4��Ww&L���w\tv\"�\u0017d+T�\u00028\u0019t\\^G,2���\u0014�9\u001c\u0013z�=�\u0012ֵ,�\u000e��\u00018����f{h�Y����\u000e�X\u001f��ۊ�OyF��O��\u0018�Ĕ%��)'�l��:Z�\u0014���\r\u000e\b�Q��6���F�E<��i�7z���\u001f�V�o]\u0014\r�4y\t�\u0013�\u0015�� ���D���@�u8%_�@�Q`i uѵ`�\u0001\"cH�J�U�3����g\u000f��Ta��3� �6\u001c��*�F�|'��I�䁤I�()o,\\�.�\u001fd=�9�\u001dƘ\u001a�!\u001d%�@˞�\u0002��;\t����7�0ֽ\u0001\u00026���Ozl�U�\u0018v@�ϙ\u0010� J�|�\u001dS?9yXn&���|\u0011劻mk,\u001eϕB��B�q5;fs��mɦ\"��z�?Q�\u001f^���u6�y5\\\\(\u0018�K�\u0002�c\f\u001a7za�>\r�o��o.\u0002\u001e\u0007����ZeW^\u001b4sah��0��F�Ĵ���X��\u0012�!\u0002���m��\u000bDݶZ��>+9�H�#Fs�N\u001b\u0004ɼ\u0003*5�l�-0���\u0006\u0013lqq\u0003����?\u0011�6)S�?��G->fۃ_�\u0011�a2��%���\u0003}Я[�ze��X7\b��ȼ\u0010i���ߡ\u0002���l��\u0005�5:\u0000����$�-��>�����\u0015B���e�\u000bǇZ��\u0001�5� ZXH���\nz(c�W\u0004o�|sO ����w�\r\u001db�K�W�\u0015� ��\u001c��J\b�LX�y\u000e�\u000e��]\u0011\ff%\u0002�ܭ���\u000bSy��kĭ�(�\u000b�\u0013v4�A��3X*�WvZ�`��L?=���p�>�g�>��l�CnL��W\u001a���8�b�Q\u0016u\t:I\u0018N�ј?�\u0013����\u000e*�\u001eہ�m�c���\u0007m��ō\u0003��;�(��\u001f���db\n����\u0010��g߳���\u0017\u0018>�J�Zs�X��K��E��D��.��\u0015��wr�@UD}/k�qOg\u0018J\u001d\u0010\u0003�\u001b+�Q뛩��\u0014\u001d$Ye_06�\u0011-K��\u0019���<]B\u0015B]�+�\u0003S�������&�'�T8u��^���l�#7\rU>\u0000�x�y��-9�\u0011�?�\f�0�nfۥz���c$��d�ڥ��\u001c�X\u000e\u001ex\n\u0016��6\b�0u���\u0003c���g\n��O/!\u0013�9\u0012Σ$���e���\u000bb�w�i�\r��\bQ-+i����f�W�b�-�R[8������\u0017�܈9G���~%���\u000b)(<���3�����\u0010���\u001e�f.��]<T(�\u0018�&�H3\u001b��[B��e��(�fx\u0003�sFG�\u0000%\u001a#(lĹ4f�r�����j\u0004\"\u0013���;���\u0005?�\u0015\u001a�n?HB�1R�F�|�vi�`�ԐF>�(m\u001bN�^TY����.p!�j�)E�v���\u0014/�}�uldG�Z\u0014�\u0011�Y�\u0005����\u00198��9��:[[v!W\u0016�����/�8팵�\u0014!\u0014�V�iP�#�7r\u0017\u0015\u0004C\u001e\u0010�1�\u0004��0�u�Z`Z0����L��l� �\b'q\t^M4h�\u0012^��\u0010����y�Ĝ\u000bR�\u0001I\u0007|�Y�vҍ�{&�6ul�\u001bK�V�>ŗ���RR�!�D��id�'�\u001e��77����W\u0006[E�Q�1\u0004�����;�\u0000\\��D�\r��y\u0000V�\\#*��\u000enͲ/Z��.�ߞx�@�4��7#\u0006�̜����lٛ��e����)\\�=4��b\r\u0017]\u001eg\u000bMr��kV�N�\u0011?\u0015o���5\u0013h��_xj�� z}��}��J\t�!���T���\u0017}\n(��\u00122�\u001dU �\u00026����j��\f\u001cC����\u001bu�/@\u0010&�pGup�I�v��E��?����\t�&u:���X�\u0001��\\v\u000eW�\u001d�\\�n\u001b�n�@UΘ�����ō�Ǝ!���V�ٞ�i�fߴJ]�4�*�T�5�`�3t�B4�B#5�5l\u0015��\u0003\u000e�؝������2��R\u0005t`\u0016�jd\u0006�x�V\u0017�Q�\u000e��哙l|S�\u000bq�\u001f����X\u0000�\u0004]�6�V��\u0017���I�T�K\u0005?�ب��CW��7뚚0�\u0007+\u0017�O�#�X(�\u0013�����`\u0004;�t�Sͫ\u001d������ ���Qd=�c+��\u0005�Zx�5�zP\u0010\\��ݠ���.\nŔ-��`GMC\u0011�U��ی�DC��\r\u000f\u000f\fA�6}��t�p�\u0010r:�:5C�9�\u0005�!z\u0016Y�/\u0007y���\u0014�6�\u0011�\u001dh�y��Q�@<��Mx<3@,W\u000enP39E���\u0016k9نߛ�\\�^>�5��\\�^o\f�}�\"�Q8\b\u0005WA�N\u0006V�SOc\u001f\r\u0007�|�\u0004�\u0017��9���-\u0006��\u0010\u0003��ɴ�Ĵl�%�Dx3۟o\u0005v\u0011)�fq���0�HX/�r\u0001��\u0013k�V��gb�ک5#�St��JԈڈ��]�f\\\u001d�}��\t\u001f�:�V�w\u0002��\u0014|p6���\u0018u<4���%���Ah\u000b�]\u000fը�ۙ\u0004��qճ��|\\��@\u0005�[������Zi=l\u0000�я\u0000�o�0�Ec��^L:�l\"�)�s\u0018�\u0012�*\u0015�ˎ��\u0000lw1��\u000f�%_j!�d�^���^s���us�{~�ԵE\u00064@j_�ƫ��/�h�jH!�_�����\u0015��0\u000b�\u0003Ab\u001e��3�7Bn�A��00M\u0012)L\u0017�RE?ڬ'�T��#\u001c�\u0006��}�?:��d��H��}z ���Hq�r��j���\u0005���3\u001cv\u0014Bs�\u0016e\u001a����\u0001|\u0014�kMh��\u001d�5U\u000b�/$��\u000f�y��v�1j�]\u000eN��D��eu��\u001cu�=�D_\u0002�Rl�V����|&Aj�\u000b�\u0006e\u000be+�K�$�}A�}8;Q\u0005LoF��\t!�Ⱦ�޷m\u001d��?�m�|\u0002�\u0017\u001alY?�_�\u001f�~��M�G���5�\rCm'�����\n����/��6{\u0005~�\u001bx�}��F\\ߦN\u001e*X�O\u0012�\u0014\f�}׈�`��_�o�z����\u0019c�eH��%��\u0017��o�O\tT6U�\u0001\u0015dwT\u0014�\u0007�Q�u��ɜ���Y�h����\u0002\u0005V�a3v�a-sl\u0013�f4\u0002��P��\u0001���Cm�\u000b\u0018�� ��\u00033��\n\u0003w?m��\u000f��P#n�A���2دr�\u001f{��@�з;�\u0014�\u0001��I�*������X0\u0014�\u001bݫC@$\fXO�9T�\u0005\u001e���\u001a�ׇ�ɞ*\b�\u001an3���R�7�\u001aT���\u0001���E\t.G�yru��x��*��Q<\u0012�\u0007̕�E9����`���^ˋ�%\u0017��l�\u0003���2��\u0013f�Ŕ�\u0010(��Y�2.\u000b_��.IG\u001f\u0003�{s��(���u#3���K�w�~Т\u0017�ԑ�1�l�\u001e�e�X%�锎���t�����D}k���;�6���\tM-���\u001c����\u0011+iy�fC��]J��\u0013#��I}�l)m�+�A\u001cbN��l��ƹ`�8���d\u0011\"*��縈�#���!��'{3���r��\u001a5���qoױ��|\u001400Z;\rx�]�ʟ����l <��\b\u0003�֜�\f\u0019��p��0\u001f�o6{Y��0\f�yb�f���w�!��\u0015�(!�*�`��;�%@h\u0006������%�\f��\u001c���$b����\b述ָ��\u0019>�>��j��⟄;iA1\u001ca#\u0005�=��XOӬ�jp\t�lK\"J[\u0010�\u0000�~�P�f@y2�,h�����\u000b6\u0019��M���ܒ��G\b\"8���\u0018%\u0017@���\u00136 W�i�O<�2\f��X%rgA�*U#�C�a�z.\u001d�\u001f%c�o|\u0018J�T�l�%\u001a_\"� A�1���*N�g\u001a��\r�v\u0007�h�\u001e��홹#Է�\u000e֨{\\0�)0Cl$\u0016欤�\u0005�W�:\u000b��נs=�Af�j�RpF�X,�\u0011Ɲ\u001a��W�.X*#)*\u0016�-�\u0006<�\u0010\u001b�,j�\u000e&S��\u0000\u0007\u0014\u0000�Wt\u0011�w�\u0017��b��OMu�s\u0016P��$�^\u0019�\u0019a,a:�@4n��*\"��\u0012\u0004�05o�\u001f�\u0006��U�^��EE�\f�ĩ\b` �\"����x��Ƌ�p˸|\u0019��NJM�\u0011�֖��s�x��Ԩۀ���|�\u0001ȩ3�6�%���\u0001�b\u0013����/M\u001b�\bNW��\u001f\u0003�&'0�{�t�y��p��x+��Z�\u0000��;k�'����3�0r�ٖ�-*R�\u0003�q�%�f�=�\b�f\\:��\u0012��˚����Z��hh�\u000f��\u0001�Qn?\u001f��\u0017�\u0010��NI9��N/��T�hth�ϔ\u0002C�OR�-�P��HuO~���RS�蔷�{�\u0010�խTM��\u0015i\u0011nb�*n�\tF��c\u001cR[t��i�mbX�\u0002�\u0019�0\t�g���\u0007̠]d����j��r:��\b��E��+�U`�r�Ю`\t�wר��\u0000\u0014\u0010�\u0017g+c&\u0002�\u0000cv�(\u001b��$Si�f���X��\u000eqbA;\u0017���&�g��S�=n�\u0006ɓ\u0017�n�D��\"]���\u0014��\u0015�t�7\u0014;�[��Բk�U\u0012�b2�|�`{��+D�-6��M���=c�aa\u0001\"G���|��|��=f6\u0003}\u000f�c�D\u0004\u0002�S�e��[����p�Y>�s���ίʀ��\u0017x˙�M�\u0003rn2ru�\u0016\\�p��:%e�\n�C@���\u001b\u001d�\u0001�9� n�p</�\u0007\u00165\u001c�\u001e��'yt�\u0010���B�ަ\u0000\n�ޥ��'�� H���\u0001\u0017\u001c\f�I�y��\b0�K�Q�'�� ǪQf�1�E���6��R�`S�2�G݃��wy���<�^b��ւ5��G�+3�$\u0016�����\u0016o\u001ePBf�\u0002���(�=H�t+~�g/�W=0�P�����\u0018�&��ą�+��k\u001aﲞ\\=�c�z\u001cy�΄�M\u001ay�w\u001a�%5\u001d*q_��Y\u0014Y\u0000L\u0003�4铣�@�;=��G�M�\u0007mkfi'\f�%hЃ �\u0017&�\u000e\b\u0012\u0010�!\u000e�#�$d�w�\u001d���f2`�Xp^?\u001c&u<��k�Hd�t�b\u0012�d\u0000t��]x�P�H��dl��͵\u001a��8�Z1z���2d�B��B��X��7�ݴw�W|\u0013A�:؍݋%��\u0011��]\u0014@�n�Y����s_\b*Vn\u0002fbBQ\u0019�0�\r����'w��LI��%�=�^��\u0005EP*�8^E��{�\u0014$ƽ�c�J�w�xʂ��\u0015�Q|���\u0015\u0001$��\u0015|�َ�����r����\u001a�˭\u000b�����m�jT�\u000e�e�Wb&�6��p��dj�9\u001al~��\u001aA��lO�����\u0019�I��{�����!\u0000��۫G\u0001Gh�|\\\u00037�1�\t5B�3\u001f���\u0003�fM�\u001d@m��*W,\\1�ec�ڬ��YfN����R��\u001fm�ޚ�\u0019���3�^\u0016d��7e\n�\u0018�L�[�R�����{y�S�A��>�\u001f�IF.��B\u0015Ƴ�Dx��Q�Β�:?���y��ĩ|)^R܈F\u0019a�8Gn�w\u0010�\u0002��ԉ�N=%�����y7��@��r\u0014疥\u0007*�^�燶\u0006y�C��iƂ �\\{ڛ����DX�\u001e����}(���`�h\u0017���G�m���<��G\u0001�]�����\u000f{W�\u0005\u0017\u0019�]Q]\u0005�G\u0005V�'D˼��a��ꠓB��\u0000�K�K�\u00051��Z��\u0001\u0017?���Ws\u0016G�\u001f��oLb\\����u-\f�Z'��a(��w\u0003|�_\u001d�\u0015u_��1��r�b#\u0011�2�Ȣ ��{eY]4�=��M;�\u001czܿ��\t��\u0017�bA��RJ\u001e��E�\u0016�e�՘fl\u000e}0�\u000f�lonpG\\M�_\"�^a���\u0014 <Y��f\u001a9�YiF��\n��}88��a�5\u0019��h.1�\t�\u00129Bg��8�\r\u000bI�=\u0000��\u0006���4�\b\u000eE��jO����\u0014RmL?��\u0001�ņ=]\u0012J�B�ܠ�\u001f�\u0014q\u0011r��\"&}��Qv+�U\u001d�)��\u0002��\n\u0016ֱ�\u0018�>��\u0017�5\u0002�d��\u0017���?�y`�\u000bb!\u0015�\u0002ұB١:\u000b:�U\u000b5���!@\u001cܼdR�`\n�W5�o%%ͪY�_�Ttq�X���͚��R�^�x�~�5vN2o8\u0003��wJ \t�@��\u0002Պy�����\u0012�4�In��\r�\u001e�h\"\u0019��:Qt� =���x�\u001bi���E�pF���3a��7�(��Đ\u0015��\u0004o�t�l���)����_�sg\u0001T��\u0010*�ߡv����@g��弾 J��8M�j�*�\u0013�\u001a���\u0002r�����i4˘̨�\u0017�`gw��\u0015\u0013%ϕK�K�\u000e\u000b�zǞ渌t\u0019�\u0001~^\u0014\u0002<\u0011H�(�'�\\�\\�,GM(\r��@{�����\fKg�V�֑���\b��c!V\u000b�\u0003�m0��3մ\u0000�y\u0019�`\b��q�u�\f�z\u0007\u0000,�MC��d�Z=\u001dTR���Y��;\b�;�F�w�\u0019S�ǁ_��{����$\u0019v��d�X�1^�IYFP�8�t��u�*OO+sV7\u0013�&KP)���aq�w{�������yC\u0014[G�\u001b\u0002�/I5�;J>��(\u0013�H\f(�\u001d�\u001bp�\u000f=�(�|�4\u0003�秦�Kˬ���:�����#q_2�4x�f����o��ܻ#�\u0013.��������\u0015�g�\u001c�P�Y\r�\u0007*�辶;�Z�\u001a����园(z�V����)�\b���\u0015\b\u001c�E�l��\u0004:\f���\u0016z���7\\0�\u0003����6r���D\u000f�H����:{\"4!\u0016j�\u0019�D��s|M\u0010\u000b^�%�o�OpY�\b�|���n��h��8�w�+�ꓲf]W\u0000G��*\t��\u0001pM����0�p$o�A�\u0002nBf_�\bT\u0012:���\u0010�=\u0013x;�ʗ j�\u001b>�+��Et\u0005I{��Dw�4d�\u0016��:XH���:��\u0004a\t7��\u001c��{\u0004�˺�t2�c+�t�n�~�H۩���^�\u0003\u001e�$\u001b|\u001f���\u000b�a�VG\u000269�i\u0005\u0017�ư\n����\u000bDȭ�\u001d\b�d�\u0002�\u0006DR\u0015\u0004+)\u0003d�d��k��!A�\"�q\u0000P�H��@_X\f~\\W^\u000f\u000b�\u000bJ\u0017�\u0014J�!�n\u0016&I\u0012�\u0007\u0019�d��+J�Êݫ)���Z\u0013��\u001b]���fȵ:�r}Z8vk3لD�~Z_����6U���MI�`���\\�c�\f�LC��\"@?C����`��t�\u0006��<�\u0011\u0011W�w�\n��\u0014\u0006]���M_��E�1�>��\u0011j��?��`@����iL\u001f�^�\u001a\u0001u\u0018f\u0017'^._��P�\u0005I�אt\b�n\u0016��H0�}��\u001a��(�����{6�\u0003�?x�A-\u0012XE�0��\u000e�\r$\u0010{�\u001f\u001a\u00075[3�3㋗u+���Bl��/�B6٥%�9EK�1�U��=����Ѭ\u00063��~ؿu��7�\u0003%^K�X\u0016���l�氜K\u000eMv�֨\r��\u0014�H]��j��E�\u001c���$ާ�?���66v\t\rݵ��P�|��\f��mR\u0010H2������\u0011l\b\u001daO����\\0���4�8t\u001d��5�\u0016=�0\u001f\u001b%־�,W@�\u0010#\u0010�$���������q�Ciw_U§HB\u0002\u001b����6\u0001l�\u0014��cT/2K\u00033C\u000f\nΚL��\u0016�$�y\u0016�xf�ְ�V{#��)R�$\u001a���?F�i�l41>%i\u001a�\u0002�F�o��J\u0013���[@x��\\b��\u0011>�P�\u0006LP\\�)-��B;���\u0003��?��!ؗn>\u001c+�\u001a���d\u0007QQh���Y\u0014��wB ��\n\u0013���AP\u0012��w\u00060bb\u0000g�Փ��mL\n�k�y�Y�\u001d��)��$����g\u0005>�@Q���������NB\u000e�4d��\tV�f�R5>��\u0012\u0007LR��Q/����� ��d�w��\u0005\u0007���<�Z0\"���w�\u0000p������s!\u0005�g�\u0006R�G'E��t��\u001d�!X���\u00159{>�\u0004CG\u001aHj�e�(Ay�\\�!c���i;�%�;���.a@���ih�\"�ňW�_nƳ���\u001a��Z�V�̄�V����ߚ�t+�:�k�:7�N�v��y:��\u0003C�[Vǋ�\u0005�\u00193��\u001e�q��(֓\u0004�R7�,\u000b\t#|�gu��ٖ�N8��\u000b� \u001bd\u001f����>mҮ\t��2N.�\u001f���y\f,�\u00171_�3��\u001b�Rrd�\u0007 P�\u0006��=caaU�\u0018> R<�\u000f͟\tQˮ�\u0016���\u0016`�&���O�덞՞�UUx�J(��?�S_(bw�\u001d'�g���i�Z�ٯ�o����я�3�%g�>I����\u0003,aS�\u001f���WK\u0014�דּ8�{p�zP�� 唷2�H1,v�Д(�_Tڤ��AdzZ��=��ɸ\\/v�>L�\t6ަ*!?��\u0013[��\u00154\u0016z�9y�w�ʽ���|\u0004f���'�YR�M��M�����[�>\u0010�\f����\u0000@��̋�Zn���t� �\u000e������=Pb�H���sV3�(�+���\u00107\u001b��\u001fQ�m��\"��Y~��iWD\u0013�v�w�33>�깑\u0019�j��5\u000b��D\u001d�>^+���¯(�\u0014T팓\u0014i�� ^-����y���}�C�>��q`E\u0010��g��\b��K\u0010@��$\"�\u000e���Ÿ)\t� �c�*`^aIZ�F�~�a5����U�4&�n��yO�QG@|k;Ibo��\t0{&\u0012���Tvbԓn���p F��S�\u000f`\u0013���\u0012\rD��\u001b(ʁB\u000b�I\u0016\"\u0013\n�\u001a��Xe4��;�S?'60�hR��E�c�\u000f���7e�\u001d5��}8\u0012\u0015\\H����u�\u0014��{/�S�B�\u000f���%\u0013;\\��s�3\u0019�\u000e$̎n�E\u001f\u0002N\u0003�R7�\u000b\u0001����)7���/��,!\u001f?���)�9EkZSӻ�\u0019��\u00180/y_�4\u000bK�'���~Z�5=�gX*E�\b]�A\t\u001b6��q�v%?�\u0002Q��e�\bi�.e\r�zFL\u001b\"�U�2\nO!\u000fp\f��=�,<�\f�\u000e�?����zr]q֞.�\u0012�4T��\\�\u00012�������8\u001eHK9׭ݛ�KKT\u0017�\u0017�PH{ϲ�z�Lhi2�}ԟ��\t\u0003�m��G.���\u0003XR\u0007t�:d,\u0007\u000f��\u001c��\u00079ŵoA��|���<�kI��\u0014@'���E��\n�Q�Ѕ~�g\u0012\u001dйF}\u0012�����=��g��,��L�B�\u0014�Ȳ��L\u0012�$�\u0019��\u0004�^\u0012�L�Ү�ٚ�;��T�:,-Da��S���l�\u001a[�\u001dN��|�hϪ���j��q�v�x\u0003v�\rA�J��d򊝫�\fz ���\u0012\bA��1�h{�$\u001aC�戇\u001e�ɺ��H\u000e@i�͏\t픋@��%��E�\u001e}\tbRo����\u0017\u001aid�U��ŏ�g��T\u0004N�,��*��\u0018ʰ\u0007�נ���DO}��\u001e�2#��B�I�/42L�\u0006&��'�l�ߗ\u0007V~��Sq\u0004��R�\nia|'�*{{�L�m�|a��+\u001f�\u0010�kD�g����X��޵��q�B�'f��\u0005����ʗ��.,v�*�HG\t�HJ���7�\u0005A1��&\u000b\u0017uq�b\u0015$�Ó�\u001e�<T䚯\u0013c윓c�\u0017�m\u0010��e��b\u0004۱Ȯ\\!�l��\u001d��\\R�\u0002^�t��3̈́[\u000f��\u001e8�X�]&؟\u001c:6ȱH��ᇷu�Ǭ�7��Pt\u0003�庠��O�)gX\u0006<j�«u^�5�FJ��\n�#�<�\"�d4x�q\u001cTL��4�\u001d�\u0002��\\\u0003n��\u0003�\"=��\u000f-��gm|���\u0014$�\u001d7s�-\u001e\u0003�xm�%d3��M�|?��ſ�a��\u0011tFS�g\u0019�\u0019�䁩o|�hޕ��\u0002��c\u000e����Qݒ+ʾĺ�3��Z��\b�!r�%\u0016��\u0003\u0015�ZюMZ�\u0007\u001ah,N���\u0010� \u0010e�Q&t��\u0004�<�s,�^l�qC\bPt����3Y9�P��ga�\u0001s�I&\u0007�ԇn��\u0018�k���\u0010��߬��-f�����]�Q\t5\u001fYe�G:��o%X@���\u0004��\u0007�\"���m+a+5Sߜ��\\����^��5����`}E�d���\u000e<-/b,5\u0019�'�pj�w�mǶ�#Jpߙ�<�Hn@���:J$/\t �xJ\u0001�f]\u001c\u0013\u0007���s����Y�jᏍ3�,���l�a��\"�&)���\u001cr����#��\u0010\u0012�F4S�\u0005�\u0002�G��ץ\u001e�\u0004�ݮ��;��\n�q3�\u0001���\u0011\"jt\u0017%i\u0006ӪU\u0018\u0017 |,�o8\u001e��а��\u0016�R���\"�\u0006h�����-�?�o��g}z����\u001d�k)WZy)S���H����ݯ�U�P�XYrv|\u0007F&�&9��`� �D�_\u0005�T��n���\u0012\u0013.k��L�\"R\u001bH\u0002���%.I��^y�=\u000f\u0012:$L��ywS؎V_v�\u0013�\u001f>�Ř�Wk�o�ϖQ��G���\u001c3Ґ_\u001aw��+�#�i�\u0014�\u0003��\u0014��p�e0o˴Y��f�*\u0016�/�/�\u000f���Q\u0000彿� ��}��\b�\"Be����xհ�>\u0017�\u001a\u0014馁��\\�\u000f3��{#�I����\u0004�&�3���\u000f�p��7jir\u0012�OT*d{�\u0001��m�i\rm z_��T��������f�V�p[;�0\u0012%�c�\u0005�bzCcmT����\u000b�_c\u001f�V%\u0002m��Z�O�\u0001�~@S�M�X�H����j�^�{!P��g-\u0004�~���IrE ��\u0017�t|\f�Pe&:\u0013�?ڔ��\u0004\u00140G\u0017��hg�غ\\8!���u���h��T��Oc�A�{��u\r\u0007�;9xK�'�C*\"\u000f�ؖ�5���\u0007\u001a���o\u0000��\u0005�����\u0015�wc��\u0007K\u001f5\u0011�(�n�(���P�I#�\r�JJ\"�܋|C�6��\u0010k�\u0005\u0006x��iMZ�����V���0�Z>�\u0007����f�v��/����L�\u0003�\u0016T�$��L\t���\u0000P{'$��\u0002�ܨd�Y`��\u001a�-�\bɗ�6Lz\u001e��b׈�h\b��yy�P\u0010��ɘ��[���G�B�c�����I�\r:(KdY~�X�\t1։*)\f\u001eSSy�e\u0011B\u0002��\t���3��\u0005U\u000bF\u0007�!�O#>`���k�|J��\n�\u001d��E��*��F$�1����t��;.\u0011D'�s\u001c�ƪ��\u0010\u0007r��v\u0003\u0012xOo���-�p�Y��\u0004�\n��n���y�\u0015������-\u001f��H����8�\u0003�W�84S�.\bA��Ae�\u001fx����{%׾�:�-f<\u000b�d%�8�\u001f�\u0000�-��x�?��>\u001dL���9E��FӠWZ��:��e�>��Q\u0005��=UG�_*&��\u001a\b\u000eU}�C\u000b��;W�2��o�=\u000f��\r]<�;W,مQ^\n���άF��j\u0015>/d��솂�\u000f{��od.So���9s\tm}M���7�{\u001d��v�U��F�\u0012��E��KCA\u001d���͙t��\u0011�B7~Z\u0005\u001f���6#'�R\u001d<ѕ����W��)��U�+&�Fj�6=��$\u0010�3+�\u0005��\u001c}�E�� y�\b�^\r\u0015��ǰ�yс��)\t��[s+z�:((��NO:\u0014�׺�\f��cC�1�J\\���@�\u000f��\u0012t; �=�<Φ�U_ʟN<�|z��N�\"XU\b\u0016g\u0005�������@\u001fpi�'��N����\u001eJ�\n��Ov��XӮX\u0007�\u0012An���RV\u0004\u0019&��O�f�D���U\u001c]<��\u0014�[ugU�E�2\"�\f\u0011��\u0016\"\\�\u0019�y��?ZRʅ\u0014�r�\u000f7��I\u0003\u001b\u001b�\u001a[)+d1n`<*-\u0016M�\u0003hZ�\u0003��l���� \u0012s��~\u0010𜙙���\u001c�n>�<��]���>Z�\u0018���o)z\u0000\u0012\u001e��q�U�j�q \u0000�,:�\\,e�̖�� u?Bi.���[�\u000f\u001a�.=��h�C�^��V���\u000e��>�ة\bɿ�\u001d�\t�.K<$�z���b5&�+�R�gަ���c�L/P�O<+���n+\u0018��`Td��ѥ�m�G�.����ۍ.�;߭��8��8��\u000f9�yD��)Hl�ʷ(W*�\u001d�R\u001d���9�@\u001b�/x6�'&��~��u�T�^3\b����KtAx���|\u0018�2����\u0017fp�x�\u0016��\u0004h\u0016�g�;LC5���<Ј�1���\u0004%0�T��7�n�:��]\u001d�\u001c��\\���ۓ��m��\u0015�Ɏ\u000e\"_��<\u000e�O]9�\u0012�<\u000b!��?\r\rDQ�;\f���\u000b�W��OY� �mi����N�4��\u001fTi\rJy���(xE��x#�y�.�h1�\u000e�����\u0007��HFSOl&�<Y������O�$�3Rԟ\u0002\n�]X���\t��8a��^h�k��\n���ɮ��\u00186Z����jB�gA|=\u0006�\u0014Fh7�\u001a\u001f��\u001c�[��H\\z�Z������B��\u0000(���$�\u0011,��s��\u0000��\r\t[\u000b���W��G�^+XS\r�s|�o>ܓe�Y�p���\n��oß�\u0010�]�%�6\u001e\u0000;K-e�p��{\u0014�-\u0006~���v�J\u0011\u0007���us�L�\u0019�<�3\u000e� ����Ȭl�[\u0003�%]�cيҼ�O�z8��|zXW�I\t\u000f�c\u000b\u0002�聑�4��[��Y)�Q�;�/I�!/�L\u0017w^�)\u0018��85hS�1+�wM��G|\u00002�Ћ�[^��Z�\u0013��&�u��z��x���\u00010�\u001e�ߢ>�\u0001���C\u0016u{f���_�t�����LL�\u0001�\u0013�u\"Ǌ\b�x���l�-m~Ο9O��W�\u0004W�![4�X�����;6Z�\u0002�\u0011�/2\u0013������Gڭ�\u0012���9i�Ոm���4Z�H�D�\u0003֝�M^��1�)�p�\u0012b\u001cݗ��ւ��~#KN��Z\u0006o�8aH+V\u0004)L��U�-q0���ߙ]\u000f�JO�R:ry\"\u001d�i���ƈB�E�P��o&�\u000e�\u0018\u001b���nlCSlt��qs�\u001d�e߅S�\u0011����'���\u0018�\u0010l���d�E����lA�D�Y�[���4�᯦�d\u0000vXT!��M�;��\u0016�6=evy�\t2(���R�cC\u0013�/7�\u0013P\u0007Lٝ��BƏ�k���V �\f�a���L\u001f���9L\u000f \u0015fN�\u001b�__\u000fω�`=dc�b��u\u0019�\u0011�����k�\u0017��\u001b\u001d��ݐ��¶�mA�v�\t�'��\u000b���\u0006��ZC�q\u001cx�\u001c����Σ7��kE=\f�٨p���\n�zgDNk�2Ԭm�\u0012N����\\Vٮ�\u0000�\u000b�űS��l��\u001c�\u000f͘�\u001b�KE�\n�2l\u0012�k��!���j0\u001dN�\t�8�ES�/\u001cBJ�@�:\bu�^E�q\u001c0\u001c���؟�-�Y�~W\u0006#���w�ƞ\u001a������\u001e=z�w>q�\u0005x\u0017�5�ﱭ����[�!�D�e8\u0002#��\u001d�=��l$�K�Eh}��=��O�aEs��p*p݉��\u0015w�����8��c�\fd�lW��}6�\u0013�θa}7�i�\u0002��nȵg�Qc�|���Am\u0019�|0\u00137=p�����9���$�j0)�ޚ�\tsԆё�r�\u001da\u0003�b�z\u0010���d���\u000bCy����+W�4���r�\u001eZ��\u0018R\u000e�����E\u0002���]�e�\u0014��\u0011�\u0013-K���\u0010\u0019v\u0007���B;��`���ar2Uh��\r����t�H���I&_��+��\u001b�.�o\u001f\n\fa��qc�����\u0003�/�ZB\u0013/|hEuU�%��x�څ�|mA-*�z}\u0003�\r�\u0000�\u001f����� ��*�\u0010�/\r5���r�����\u0002��m�\u0012�T',�R�SQ��9������\u0010VzjT~wY�\u0007�6�\u0007�e��Y\\�U�\u00130�΅F\u001d���, \u0013/`����\u001dmx6�a)\u0006�^�%*\u001f����&\u0014x�y��\u001cN�Tq���\u0010�b���_��ќ\"�^}�*/\u0012\u0017H̸2�b�p�u7�\u0015���r\u0016b�L\u001czV+�s$\r��M\u000e\f�|�rjF�\u0000�Y�b�V��\u001d{��g���x�&�{#�Z���x���˗p�\n\u000f���\u0017g�9l$:�>?W\u001e\u0004\u00044K�H�cЗ\u0004��\u000e\t\u0015z�ᗈZ�GY�U�(\u0007N�\u0015d\t��\u001cY�D\r�C��H#P�4�\u0006��X\u0015�k�`�\u0004���]4�3�\u0007�*��bÌɍ��Yf�WCS�ۀ�(HbDH4>��ȿi�7��m���,)8\u001a(V�e�?f�&\u0006�84\u001e84���6\u0019aF��]��� ��cT$�p�\u001c.�Y�\u001d��\u0014\u000e�ƀX��j\u0001�B�=����=��?�!\\!�C�\u001f�R��*\n��\u001a !_��ב\nҝ�\u000eԒ4�ڸ��+\u0002�\t��\nq�9\u000e\u0013\u0003F0�5�y΂�/��r��H�y`���� _���\u0004\nl���\u0001�Ī\"����\u0019�\u0012;��ҕ\u0004\"�\u000f[�\u0015�c4\u0018�\u001fr\u0011��-@C��%��G\u0019�h\u0005�T���Ǽ��U|g�\n�I�P7�1�\"V\u0015��\u000fWhN\r\u0002�\u0010޼M�Ltuc�p�#�.A��yf\u0007��uu�3�\u0016�ঀ\u001f�'!\u001f�-�\u0002]�\u0017��%Pg�Q�W\u0000nוE�*��8\u001f��$ͯ��\u000e�-�㞐%\u0002��<\u0007$pt�t��\b\u0000ܕ+\u001b!��\u001e�b��3����_(J\u0000�0\u0005�\u0003��\u0014\u0014b \u0019�`a��VԼc���7e\u001d�*�V��\u000e>�Ŵ�\u001dg��^7�����3v^>�\re�h�09��&�\u001b�[��#2�O�N[}K/\u001b��4\u0004\u0019\u000f�\u000b��s#\u0000\u0011���\u0010{?�M܈7+\fh%w��l\u0018\b�\u0012���\u000bVm\t-\u0003�x�\u0002'���z�)�) \u0014P'�\u001b_Զ�;�\u001fw��\\�\b�E\"*�\u0002X.E0V��օ����{\u001e_n3���5fٶ\u0003�%�\r�O��:�S\u0019.�\u001d�)\u0005o<v��L��E�Ia}���C���\n\u001c���`e)��4��\u001eyU\u0017��<\t�&�0Vv���g�P�\u001aDnHB�W�T�\u0002�9��l��?I�mV���\u0003�7\u001ek�\u0013噫f\u001e�VH�v�+\u001dg+���@+\u001eN1���\u0019�,Z\u0019.jy\u0010)h�|�1gW�94��X\u0006�*�\u000e�/\u0012�#Av\u000e�P��'ۂ���^v[��Q�h�hl%BL�\f\u0005�8$\u0004�9�\u0018���-%��̯��J\u0011���6i8\u0016:�\u0015^\u0003��\u0017c\u0014�y�\u0006��ǀ��\u0010˛C�U�\u001c��7����x�\u0003K�{k���b��G\"\u0012�\u0018�\u0016-~\u0013��}P�&�/3�a�<��\u0011\u001d8y�vE\u0004W\t����a�\\\r�Z[\u0017���A8��\u0019\u0002�\\�!�\u001en5?���q��*��/�E���\f�&\u0003~�o;�V\u0003�%�l������ӌ�\\�\u000f\u001d�Ra�w�q��N\u0014��D�&�w5�i��\u001f'��\u0014�e0\u0000K�톁�\u0001\u0007\u00022d�y\u000b\u0003�w��@|B�/aKC`���F7�\u001em�V1[�tJ� J�\u0017Lf�\u0003�\u001c1�r�#�\u001fg���n�\to\u001bN\u0017V�}���C�K����J0\u0016߁A'�T?s�m7\r��&�nK�|���ҫ\u0007Y�\b�)\r���1Uyԏ���Q\u0018T���\u0003����$��y5\b��\t� ��ɐn%fثu�0V�Cъ^D�և]�>��Zp�ܓ�B\u0004��\u0018���\u0001\b�L�Rs�M�\u001dau�<;�'��_\u000e~�,\t.׶�x�g`�\u0007��t�^�\u0019�1lΰ���޾Uv����\u000e\u0001l�y&\u001a1�ɕz��m���ꯞ�<U\u000b�Ef*1��+]X\u001b�\u0016��\r9X�I�u\u0007��\\\u0019���!8�ݹ��\u0005\u0004��\u0014\u0004@�\u0019��g7I\u001eG�>�(��\tm+|�~+eAq��&��)\u0017\u000bt#���Z\u0014�&ը��3�v��\u0005\u0016�����p��[�\u0019�8\u001bA0\u001b���䃄kZ\u0002\u000f��Ғ�z���\u0014`\t?)u�)r���l���Mn��m>�vh��a͹�q�\u0017\"�;�\f�Vq��m��j��-s�~�]c�����FD<�\u0002]�Y����\u0004���\u0006r[�\u0010���%�8\\��\u0014T-L*8�\u001d)C�J;\u0003>�O8�J/�,�'�O���\"o)X^��w�k�A\u0013�f��8n�6�_R��Q3�t\u0000Bg\u000b\u0017\u0015��y�(%\u0005}�A�D/�\u001b\t.v��CmR�\u0011P�#=XlQr\u000e���hG�*�*>#�\u001eq\u0006� \u0007��N��dd;��A[?,��:���3\f�� x�ă_\u001f3���\u001d���| \u0011��\u001cicS6�;�_\u001b#��:[\u001eUw}-MPz!\"��\nL'��@��R���\u001c]$\n���5Q�)\u000b\n�\u001d^O�%�}^�{���)YP��E��\u0011q��2��)���W\u000f2;�\r�m��$ht��6\u0014_kv�\u0017\u0014�;�\u000f�\u0015�,��\u0006;s^\u0005�?�e\u0019};�\f?����\u0000�\bR��{�oΗ>����g�\u0006\u0003Tk\r.O�\b�W\u0010|�x\u0002�\b[��V\u001f��\u001f�xm_�X�5�\u0015��G��\u000f�ut�\u0006\u0000SA�l|(�\b( hq��� �\u0017\u0006\u0004��\t�\u0014D�\u001a�k�a\u0004�[(������W\bߤ�\u0012��\u001e\u0000\u0007���\f7T�ˋ;�#��k?\\�V/)U�E+\u0013I�;�\u0007�$w��`��$w�^�*��R��C#ϼl�[ʪ���l���\u0010�}�s\u0007V�G��c�h���\t4�����9�<\u00046��<��$\u000b�\u0007;wt^�Bp������q#4�T�\u0004��F��h��8g\u001f�^�oD:�2��Ȏf�\u000e+��xQ�E\u0003�n�p�,\u0012�7��I�Ƣ�ǎ t�oX\u001cnˌ\r:%@\u001d&�?/�.<\u0018�]�`����׶�7�\\)��gB�̹s\"���Q?\u0012�&�S�_��\u0016�`\u001dvk��},�A���gQ�%�@��@H�,�\u001e��N�D�\u0018��O�<��\r�\t\u001b�\u001b�u�%�|v�{��/\u0014����\u000f\u0012=�\u0015\u000b�2;P���\u0007�����\u0007Y\n�#�^\u0003�\u0011\bp1�/Z`1g[5c@\u0015HQ��H� ľ��B�=�j��ݪ\u001f\u0003\u0005�ʝڪ�Mv3���K��ʥBC��s�r�its��\n���S�\u001fB4z��6�^Z'\f���t�8�\u0012���䬙��3�E��\u0015�tt�^se�~��Q\u001aP�Y��F�xRVI���3�-�(��\tvv�|C�V�l#�΄�,�x\u001a�@\u0002n��v�,�B��e�e\u000b��d��yyX�d^�\n��`��CQq��\u001d\u001eW��v'�o[T0L���\f )M�mJm$��q�XҪR�b\u0004V�꥽U���x;\u0003�Ug��e\u0018�ɵ��6*�H\u001f���3��n�\t��p���f��~��\u0012�����k\u0002=.�Be+�R#�-ȥ����=�#U\f�(h=����H�0kV5�Q.l�}a�\u00182r�,^���\b�\u0010v٠dS�*�\u0012\u0015Z�T��o�Y�������������^��^GJl%���{���IW���V�����q�,\u0006c��\u0018\u001c���u]�/��h�9|+���$/-�u'K\u000f8��!\u0003���\u0016���HA|=9jሠ�\u001f��|��lڝ�\u0011h{@#T�1�-\u0012�7J�\u001e?�\u0018�\u001a�C\u001db5��=�Za\u0019�j\u0012�\u000f\u0005�\u0012�]�\u0015<J�_)m�%�\u0015S3��\u0000�\u000et �ֲ��l.͋�\u0014��-,_�;\u0013�ۂF��\u0001���\u001e�Q�kq�a]֛h�M����\u0019�y��AE��\u0005r=V�S�{�\u0000�\u001a�\u0010\u000eS�!c��Y�\u001d憵\u0015=~\u001f{{j1\u0003�\u0000 �&������\u000b\u001b� h,G��D�\u001f�wA�춞�qB\\P�B\u0002\b�v$�\u0015���=ȵ�|\u0012 \f.z\u0000O\u0005��9z\u001a\u001eLT\u000f\u0000�\u0006Ȅk\rZ�aHC\u001f\n�7w���\u00002�1\u0019D蟄�\u0000�\u001a��\u0002���m��q\u001bf\u001c\u0003�\u0001:\u0019̬OS�\u000e&M\u0003�=��\u0014���7�\u001d\u0012tNf4���\rW�Vkl�\f�Y.\u0012�Z�^�)�K�Ŧ\u0001w\u001aZ���#F�����!��|7m\u0017$\u000f\u0012��*��P��FDǋ���oޤ���_\b������\tn�?��yv\u0012\fW�h��C�вT4dV\u001e�[�t2]\u0015�w�\u0018�\u0016�Xc{�$�0(_��\u0002�I\u0011+\u0001������1Α�'�\n\u0013-\u001dcO\u0016�����\f�k�h���'�>����d�^�O�W��\u0015�0Gi:W����\u001f�z̚��\np�k�\u0016_�\u0015Q4��$\u0000@1�*���\u0018)��'ƀ�$Q!\u0011\u0015�@SyG�url 3:ɤ��T�BӦ\"��]��)B��C��h!\u0011ʣ���D����p���\"߈�\u0018�+o3\u001d�ӵ�}�{_�\n���Җ��mz#�\u001f�I�P96�:Ì�V��Y�h\u0010ڿI\u00027QZ]�\u00196�\\�_LG��%����ƾ\u0005?�\u0014O\u0012\u0014Ux\u000e���9��h2B\u001b���#�4\u0002c1ܘ_\u0000��4��\u0006�+��i!<`��9w�T6\u0013��\u0010� �w\b@_�ɒ=�/!\u0014ؽ�\u0018ϳ<ݕ0\u0004�\n\u000f\u0011�\u000b�ڏ\u0018W������qo3x\u000e�� ���)l8)KdALa�@�qr���ϕ��j�\u001e@��\u001aLA\u000b��=\u0004��;\t�p\"�\u000bڲPZ�^`�R\u0016�^\b�ɽ�MF���\u0017i�\u0004|��\\���[��B���� \u001d�\u001f\\m����^\u0005`�������U*}��K��FG\u0003K`�\u0002ꉀd/���F���y\u001f�MfF�u\u001c���ꍠ�0q\u0017�\f��\u0014\u0004���tJ\u0016<��@S'Z\u0012��3*\b�nx\u0000G&�L��\u001b�;�\b���N0��\u001e�r�*H\u000eE(�9���\u000f�I�7�d���XE��Y\nv���R���1\u001b��Y\u0017������k~ڨ���\u0016f\u0000\nݺ�b�g\u000e`���o�`�,\u0001��?H�\u001c�M�\u000b\u000eڙ69י���Azv2�&\u001d~��\bNF�ٺ���uN�\u0015��r0\u0006|�jPc�H\u0018{0J\u000b\u0004��x�\r\u0004\t\u001b��Ge\u0006��{r��?�ՙE��o���\u001c�y\u0016!W���\u0005��\u0004!k�؝�gD7�Y�_fur�\u0014�KY2yj�ѷ��O\u001cD�&x����6�\u001d�+%�}�\u001eB?�~�6\b��\"����5�h����{Ns���.7\u0017��\u001ef\u0005#��j\u0016\rQh��|��\u000b�]���U�\u0000��~�=L����\tZ�����O\u0002_XC׹,)FK���A����Z��\u0005\u001b�-�Q\u001fы=�a�f����P3���)៱8�$�\u000f���y�\u000f��` `b\u0016i�\u0011r��Nu�N�*՗�N\u0018�^��*\u0014���\u001eb-ٿ_H\f%6\u0004u������꠩]\fB\u0005�\f+�0=S��+S\u0007_��VU�\u0011�q\\��\u0018�a��&ݷ�y\u001b\u0005����t�24�\u0017���4x��9?Zd�\u000blN\f�.\u0019�A! ��wd�bN�d��\u0015v֩��Ɏ�8��`W��:��D�\u0006�v��:I�]\u0004�(*\u0007`��\t�\u0016x�*A5^�tf�\t���\u0000|�K�T�\u0004k��J�\r�{\u0015Y�M{�\n�=�:�ʫ�r���Ƀ�-C�H��HB�^J� \u0019�\u0013*-uh\u001d1�\u0010\u0004!�(+w���S/p���\" !������\u000el��nw��m̨�hTB��No^��n�Lܡz��׻u\u001e\u00027S�Y_�ů�Q�ʉ��4���c�'[E�x\u0015z���{�\u0016t�|�Y\u0012\u0004�}������܀~�Jy�\u001e�,���\u0019Q��t�f�\u001d�C�\u0018��1��=�����5�:\u001a\u0019�wD��!'�(�l\f:S\r�����\u0000��y5�\r��8N�0\u0017b\fa���-��\u0014'��{��\u0018\u0014\u001b��ps\u0001�+5\u0017��\u001b��t��Y\u0016�>H��\u0003�\u0019�ۈ\t����~�b\"]<Hi�m�$�Z�6\u0014č9\u001en���H\u0007A�K����M�\t�摝$4c�X��t�\u000f7k_]N\u0002\u0004�\u0016����o\tzw��B�����N�t���8�#Y.�x�o |j�x��5X�O�:��\u001c���\u0013^�o��>\u0006\u001f`�\u0007\u0006�\u001eV\u0018�|M����;�z��+\u000e�o���SH�� \u001e�ylI�xB'l�5��K;��+�\u0004�8���Xe����O�.���N�\u0013�5��z���Q���Sw]6\b\u0007w�u2�2�v� R:J��\r\u0007�k- =:�$�W��\u0002މN��\u0001-���B�8��oScsG0vd�K\u0000�O\u0019�\u0002�4��|^ֵ����\u000fWi:�\u0010\f�0K��L�\u0015yW�\u001e\u000b3�u�\\֕:��٦C��Qr�\na^�C�To�F�&�f^:%��J�\u0000�K\u0010�A�X�\n_Δ\u001c4��Ϳ6?��s�͑\u0017�º�v�Ս\u001f�\u000f��v\u0001�]���\u001a��`�UQ�\bm\bvߔΤ',�\t��vӲ��@���L\u0017�z\\�n\t��ю��\u0002�aթ��\u001c�ɻ9���O.����1��o\u0003�$�U\u0019���#��\u00116��WR�\u0007�r�\u0016��J��3D�>ά����\u0012cT���%�\u001a�Q��ܨ ִL�T5\u0014�\u0010���騅Ց��\u000f3��\u0015�#\"���=6�\u001b\u001c��\u0010F�\u0016\u0002�Sx��*m��xw��N�b���R����`\u0001#|k�a˃�Z_� �퍰�89��K6#\u001a�a\u001e\u0010�:��v=\u001ce�H�1����b@1$��:䐶}y\u0005\u0018}���85\u0002��P\u0007��9-<��Ƀm[��\b\u0010E�a{�JP,t�e�,s𰥪b��¨\fj�8Nb��$�K�\u001e\u0018(��H�r3>�5T;�a�.\u0019\u0006IJ_�ZDb(4*�\u0011n�\u0004��\t�\u0002\u0012&�(�\u0002a�\u0018u\u001d\t���9���\u0002g6�\u0004 \bѥ�q�kw��'\u0010��D�W�\n�'��.��c:\u0016\u001e9�y�@�XM\u0018ԧ+��\u0005\u0007�x��ZӉ�\u0012�HɎ=ziNT�g\u0000V�㬎8\u0005:\u001c\\��(i�v\u0019<�6+�:�g-��\u001e<t�\u0018�:�i�%\r�� P|\u0006{�ߘ�\u0005���}���N�k\u0012\u000f3K�S\u000b&��\u0013���_dA%t�YK��\u0004�F^��hu��ni\u001b���\u0002�C��<�Z4dz@O�\u0017j���Q�kb�n�E\"\\�)}���8/�xv�Au ���/��=�XV\u0019��W��<�x,�e0��ݒP�F*�}��n�Y���\u001fg��~�9�ڑD�G�WM%�F�\u0004�\u0015n�\u000b�m���\u001e�\t�u�Y%��\u001c����2a��\u0018k5HeM�r��V3�l�H\u0003RΧ�0wO�P�$�9w��\u001a�,�\u0017肉�f`OYGh��i3�k��i�!��AY\u0012N�\u0005�)��2�� 1�?\bև�FgH3�\u001c�\u0010�ա�tjX��3ql\u0004�!�@�E\u0010��8*͓7��,uĔt@̤\u0018M�\u001a$q!�Y�+�x7�Uhc�1c\u000fX\u0007o\"���B���\t�2\u0006�k\u000f�L�O\u001d��J͢ϼɱ(Y���U��&��茹�m�28S�!\u0002�Tu7?,q&M\u0014�J�Z:��Fxt��#g�{�\f�ײ@p���K��=\rwшT+�q\u0019���v�\u0007�-��\u0002b*\u0001b���f\u000f@Z��0\u0006�\u0019{ TO}׳ N\u0015t��IB?��p�?���o �\u0014rX���Z;�a!\u001f�L���J\u0017�\u0013m���(\u0004O{�c_�\u0017=�p\u0010\u000e�\u001d��qt��,��g�mA�sc��\u001a�p�%V\u000fb�c�Õm�H���\\T��\u000b��\u0002��\u0004�l\u0005�Y����I�>Wkt��󇹇�j2XLqﬡ�mr��%ڣ��\u0011J�,A�\f\u0004\"��?���Y����p2P��^b��cU\u0019�!��S-�\u001cL:N�\u001b�dǩ�ET��\n��\nt�\ts�樟K�\u0019Ǳf�^i��\u0010�\u0006\u0019�9c\u0007��y̎R7-\u001d��\u001cI�W�\u000e���=U)6[�-w�fz�\u0003a'\u0010K�:w{�\u001c�/��YΌ��\"^H�\u001b~���\b�e\u001f�+ݖv����:�ϴu��V���s����Pk#��\u0000�J�(�*�\u0015?���a:�F�~+\u001fE\u0005�c�\t^\n�C\u000e~\u0018P�L����}6\u0007�,�*\u0006[\u001c��\u000b�\u0012^-%m6@\u0019\u0000�M3V�.!��\t���x\u0012��9�aL��)��iA�\f�JL� b{\u001d�\u0018�\u0002:�I\u001f\t�٬�+NU��us\tr�啾�\u0011�o��=�%ꑵ�\u0013\n�\u0012Ov��\t�\u001a��^K'�j�(�\b�v��g�v�)���q�����8�weG{��=M�{6eg[$!\u0017\u0010Eb��չ<�[�̳�_�\u0011\u0015�\u001d;O�$��3\u0016��c�����s\"���\u0007\u0018�GU\u00011�ͫ��){�74�\u0000�.yVwU&e��{�\u001e\u0018d�x(�y\u0016���c\u000f�\b\u0014�+�&\t��KG�f\u0012��4�2�\u0012���\b\u0010�\u001c\u000e�,�\u0015\bt\u001f-C��po\n`���ϲ�\u001e�ҳ&��@/�j��!2wX������H1K��>s\u000b�3���lvZ�\"\u001c�\\�UL�E4�cS\u0005�q2/��\u001ci�\u0000��\u0019B\u0007\u0001�J\u000f�_�u�\u0004��ػ���6���<\u0017��\u0016v\u0006�=�44���s17��L%X����⅞\u001f�sJ\u001f/hI�+Ũ�Y���4\u00172l�\u000f~Z\u0019�$+D����\u001f_\u0017��#���sZ�X\u001c�Mo%A�~\u0017�Q\u0014��8C\rc�v��}/\u0017���E�\u001d�e:�VU�^\u0000#����\r:��ܕ��4kc�\f�saH�txl++�r�$\u001a�c�y�Ndq9i��я6�\\���\u001a\b�\u0002�S�?@��\u001d8|-\rpY�\u000b,�<v2���\u000f��mL\u0016���֗S�s�j�;Ap������0RC�8�\u000e\u0003d&\u0002\u0012������\u0013�\u0006���\u000b�h\u0007��$\u001b8�\u0019\nȶ�����|\tJΟ�zٶ��-�y����\u001c\u0018\u001dc>�l�?`\u0015\u0003�\u001c������?z�\u0018\u001d�ُ�~��T\u0019�o\u0005lw\u000emņ-�7n���y�-/\b�����щx��/\u0012�2�c�\u001e\u0000a\"\\��i�>;1ӈi�$t���]{�5\u0006�\u000f��C������y�\u0019`r���~�f R]L�\u0014\u00130�){A>qDܐ�ob�(DԢFhv��S\"Κm\u0014K�EqkS�\u00106�[>\u001b��\u0011\u0005F�2@eB�\u0010��M`6nOsr�f,$m��\u0013E��o�H|�rKX<֣��C�顪Į�B��d9�}\\�7�h(\bH�/t�&���_��`�ڋL������v}�\u0012,9>�\u0007��l:|ނ�!3�����\r\u001c\u0011��+���_��#X�u�*\u0014!��p�\u001c�.{7^��èaM)�WJ�\u0012\u0015�T=�|<%�V�/��\u0002K�{B5\b1ٝ`*�\u0012pO�.9\f\u0014�\u001d�8ek�\b*}�ޱ�>{r½|!f�`}B\u001c�\u00158pE���s�\u0007A@^\u0003��cV\u001a�uJ�\u0000D1�G�L�iGn��u.��\u0015Ӵ�r�Heg�\u0006f\u0017]\u0004K\fȍ��Ѣ#\u0001j�c�+�BEپ7�\r$-+#�炭\u0017��h0�\u0007\u0010p^^�\u0005�Z�z\u0003�bl�o�Om�\u0011H�p�y���r���y�\n!/\u001dju��i���h,P\u0017���[8�\u0011L��&���w\u000f_+䠿�L�n|�\u0002�t��iN>�@�BI\u001e,\u0018���g�? r�V�:���k\r�4�H\u0007W\u001a��Eܸ6�)� �P��Fs1߬\u00191�[��,N�Fox�([8�\u000e��\u000b�K֯�M�,A��\u001e|N^�Ul�$CU�#n��݂�Ve\u0001v�\u0002�c\u001b�xw�\u0018Bj�(�S�\u0015\f\u0004CҪ�!�\u001e���Q\u0012=�B9�E\t��\f�\"�A��^n����-ʂ�z���\u0019T¦X|t����\tz&�h{7��W��d�{Q>���f�$\\kS�!b�\u0000�wzk=��7�\f�ٻ\u000f|\u0007�����?��b\u001f�62�\u001e�@{\u0006g\u0013WUY��D)\u001c�\u0017�춡\u0016�t����t򮭰\u000b�8\u0006��\u000e2\u000f�?~�{�`Wu��U\u0013-{,\u0001z�\n�0�+���kGin�M�\u0015�|�>��\u001bӂpK;�G2?\u0016�\u001e��?`�{�h\u0000p��o\u001f.��Ū����M�}�\u0003\u001f{�\u001bb\u001b�#<�\u0000e(08��k[�u\u00003&��r\\�U��\u001b\u0017an\"�{{����Dϼ\u000b(½(���fހ0�\u001d�2j0@�:f\f��$�\u0002�>M�.��\u0019`�{��\b�o�f�\u0018\u001c\u000b�6��/Y2�)>\u001e���Yu���\u001eI�JKӛ��9ʉS�+\u00152�\u001d<�X����6�\u000e�\u0004�\r\u001e}L6�\u0018���-\u0011\u0002o�ut�\t]o�\u00005_�*a�2���0^-\u0007M�\tw\\��\u000f\u0002\u0015�����\u0010�{�A\\\u0018�x����ό�bi\u000eǧb���\u000b\u000f�\f��;��\u0013�&Փ�9��O3�G��aWGSp6�l�w\u0001��Dډ��F�rN�����\u001c�����f�2#�]bT�V@C�_�Z����H��\u0014�@�UZ�E�\u000b\u0016����S�\u0007�;ӬJ\u000e\u001d��\u0014�\u001aSfCW���f\u0011�\u001d ��\u001aD�\b��mQ��o�z����\u0012�-w�2h�V_�F\"t�\u0003Wa�$ƥ�B�r��OE\u001aw��9�fz�8;\u00039�zA��3���X�\u0007�\u000e�\u0019�cT��ཱྀ5�K<!�$�\u0000\tp}\u0007�\u0000�U}�p����j��'��ܐ�J;iǐ\u0005�[RF\u0001\u0015�7�q�=�\u001a��#ݸv�Y�\u001b,��H#�E<��f�=���B;��\r�c��3�\u0004\rˊ\u0005\u0016���(\u001dEk.'�\u00138s��\ngq\u0013�\u000b\u001e7\u0004K\u001f�s��1��5Y��pf�-稽\u0000�֊|�=�I\u0012�,\u000f�����ޠ\u0003� \t�\u0010ҩ�\u0012��``����\u000f+�ə��K@�)��'�\u001c�\u0019S��gS��*��KlJU���L=���6@>٧6!\u0003\\{\u000eM�|\u001ee{����&��� -.\u001cͿ�)��o�?��`��'m!n\u001aW��\u0002�i$�����-�\u0001y�8�o���dbmf���1��j�7����\u001b\t\u0019\u001d�<P�\b�基%gO�k\u000f~\t9\u0004˕\u0019�(�p�;��-7�\u0002\u0018���>䆴�( |N�k����f�\u000b���\u0016Ĕm�h6�K@\u0015F�8ѵ\u0001U�\"���a�[Y\u001a\u0019�|�2���0\u00182�f���R1��cA�\f�n�\u0016�YĐ@<y���*\u0013\u0015\u001c�ebǕY\u0003>��Չ-��\u0006�c�޽�B%�$�\u0002T=�\u0017�\u0019y8߄C\u0003���B\u0005�M\r5L5��! ��52�ݑR\"jI�ʿE����v\\��\u000e\u0000�\u0006\u00010<V\u00004}���\u0003� \u001a\"!�'�\u0017�U~�\u0016\u0004OA�uAu/\u001e'^��O^���¦e5r��>�YK1Q�M������2a\u001d�?���|x^\u0007��i\u0019��j��m�I\u001c*�b���8�\u0005���\u000e����ww���\u0004\u001c�G�#��j����?���|��\fk�}X���\u001eD��\u0007a\u001f4\u000f$�٠��x\u0002\r\u0012�ې\u0014���R����\u000f�G�Cn�\u00142��F�����©\u000b\u0012˩�z� JD�r���#�\u001c2�n]�}h�~.��B9\t�`�؅M4����\u0002pB�oʋ��\u0011�@H���@���Y5hf3����N*S��'d�\u0011�tm �E��#��\tqi8/2Vl�Qd��5�C;��\u001f��\u0014�i�\u001b���\u0018<���[��t:|S�\u0001��oi�\f\u0000�����\u001aX�zF��{�]M�zu�-Ծ\u0019��d\tЧ�ÿ�4����1\u0003n_\u0000d����\u001f\u000f ͵��\f�A\n�\u001bO{V�\u000bP8\u001a���r��q\u001b��)ʏ�\u0000��\u001bl��kښ�YM��\t��\u0015��Q�A\u0003Nn7\f�/\u0017��/,�'F\u0012���c\u001e�]ǿѶ���a}Ã�GH(3<'Q\u0007u�\u0011\fu�d!�G����b����X\u001d��\tA8�.�\u0016�\u0004\u0017��\u001avc�%����6\u0018�\u0013��\u000f\u0006,$��5�b�BQ�\u0001�I(�a��Wbi`���\u0015(=M\u0019�v���\u000e��\u0006\u0014����<t\ni�'2�\u0017B=\u0015��q+�K�^y��ߒ��F+�\"U�\f8٫�]Ăo\u0011���Ӛ�;�ۊ˴�\u001a�U\u0005����ϔHA\u000fF��n]�\u001d�\u0014�O�\u0010�9q���\u0018B\r�!.\u001a�\"����\\^R�ы���]�a\u001f�\u001d�C��S�C���\n Y�2A\r�<Qt������\u000e��\t}ܺ]\r<�������Z��݆�?<z00��T��*,a�\u0011m��~&��\n\u0011\u0016���A�\u0011��Ev�K�(1S�\t�N�\u0000\u000b�7�\fzx�㊅M�Y�\u000fư~p�|�À\u001eO(a_é:��\u0010$�D\"�ˀPW�\u0014�#+���G���yq�om<\u0002Pӑ7�܆�p\u0003�\u0014�^x�u0Kɢ<���f2*\fw�ن������\u000bA\t�G��ˍ�s�X��\u000b�k��,�`Rv�\u0018�=\u0000�\u001c�y\u0017 }Ԩ��Smˏl}�nHև��W��<�f�m������^�\u0018�.]\u0011�xn6���ZV\u0019����2\u0013pbM\u000b��1J@�������@lk��F�n�N�\u0018̼��݊MHF��Ӛו��3\f��=�\u0001\u0017 �0�ᐅ9K\u0018�ބ �n2����H��3OGr�mc�H�G�ތ&�^\u0011���?]ڇ���1��\u001a�����FlM�6��Uїi6Ja`}�o���e\"�1QRh�X\u0010L9\u0005\u0005\u0013w\\�02�[ү��2�\u0013�y�Y\u0010gV���̷R{����flZ����1�0��&�Ԣ4�v-�X�Q��@��Xkz�X�\u001df2�������o0@����v�\u0001b��f��mi�\u001a\te\u0003g0�_�al��\r�H���A��A=�,RF[\u0010A�`J��\u0010b\u0018��q\u0010D\u0015\u0013���t�s층�d\\�P�+�\u000b�X9c���|Q9����\r�����z���s7���zr\b\u000f6~4��F\t��'�]\tQ���S>��ȣ�\r�\t�4�Eŀ�D�\u0016�,KϲO�)�\u0000V���k\u0014�ʻ\"g�\u0015\u000f���w��3\u000b\u0015��)4\b\u001b#s�B���\u001a\u000b��Yσ\u0016C��b��)���W�\u0018\u0004!X{3��\u0014�����\u001aWj�Kr�^L�\u0014�`�ȳ�0�Y�41X>k��wu��9vq���J�ꐗ�m%\u0019�n�v c�&c�߮�Ʃ')�1N\u0000\u0005�.W�W[�Ɇ%M3C)ꀿ\u001by����'�j�\f���ܨ>��AŁJ9m���\b�Q��I/с\u0003��E0Ds.K.�\u0005��\u0003�\u0001ڊP4���Ұ�x뵧�4'uF��?V&�I���p�I�j�_f�v�D;!R\u000bX�%�I\u0015d\u0013�I���dL\u0014j~���\"�\u000bv�l\u00010̓s�%J��\u0017���ۣ+%L\\oY�o�m�V�\b���8�!�є_j$NU�C���f��{!��Hn]�l�Ƣ�-\u001bq�r_µ�\u0005\u0013�H\u000e�\\�������!��d�ܗg}�p4J;�=�}���!@�\n�\u000fq�\"�=,Q�����'a8\u0003$\u0007�f�4�y=r_\u0015t+��o^`�Z\"\t��\u000f�.*6\b�-\f)�\"�\u0019a����3\u0005O���:O�s�CP\u0018�.o�c�\u0000'T���II~\u001b��\u0006��\u0000�����ŤM�\u000f�M��\u0001ݗ����ެd\u0006�Pw�\u0003��\"����E�2.B����+}��\u0005�\u000b���@�%>8�I(��FvH\u000b�0\u0006�\u0000[\\i\u0015�ct�_�Se\t��}3�<z�F�,\"�.x�r��y��\u0017����en\u0015ـ~�\u0000�cZ�9z/��v\u000eU6��@\u0018\u0010��\u0007UӟZ�]�U\u001b�\u001bi��2�/Ǳ�\u0019�G��\u0019��T\u0016ߞ�H�L�\u001e~�\u001fַ*hz.���\u001a'��/�¶T\n�B&\r��\u0019G�A�0#�\u0019ą^l��{�A]S@\u0017(P�������jH֚!��\r]�B��\u0003ɔ\u0012�\u0003���%�����^4�D�d\u0000`\u0003l�d�Y�>^\u0000����_\u0000�\b��R���\u0014��\u0004�\u000e'��\u00145�J\"�\u001aJl\u001eŀ&�G�\f�\u001d\b�7��<!��Х�#wtZZ��Q�\u001a��1Ͽ�d�D>�t��Φ%>\u0016e\u001b�\u001e7J��?~��II�`�*~=�\u00039X\rʬ��m�UP�n��\u001c��wnʾ\u0011�*���in�.\u0004�\u0015^\u001a7U��O\u00175�p\nN}��9PDR\u0010]^�f��Y\u0000X\u0012�2\u0016�\"�H�\u000eU\n\u001ap��S�4jG��ֹ{���u\u0012�s�\r�i<�%���>�/�\u0018�c�\u0013�\u0007�6��#\by_�\u0000�\u0016��6e97�����j���r���%ՠw��\u0018��\u0005�T�C�t<�!��ԬK<#�Hh�Gf26�=e\u001fq�9�˛�J���*H�tl���!y&CE\b����i\\&\u001aմ�A�o�8�\u0011pO�'8zd�U�~\u0012-�U\u001e�e0�\u0000v��\u001bP�\u000e�zWY��V�&�M�+7��&�M \u0017\u0006B\u0019!7r\u0006\u0001�����\u0016tR�l���x�_<�M�?S����Ļ\u0005\u001e�T�K;{!I��D�\u0013\u001e��$�\\<(�D5���'�P\u0013o25a��ʚAs;�[�5L��ya��>!wo�E7XE��;\u0015��=.��W4%9��hH�\u001b\u0015|�us�%\t2�Ө=�؆��0�\u000e���J^�\u0016H�O��x/�p~�t�I@\u001b�@\"�<ʔc�ǝ9f\u001c��g�\u0012\u001aEA���m��^_~#�S�MH��X,��Q�\u0004�(�\u001e\u001a2�a\u0015�܎\u0011�\u001d���?$���!\u0017��<}�K��\u0012\u0006��\u0001�\\�����@\b�#c�O��pV\u001d��\u0019�9�1�u����.��.#\f�G���o��p��\"�,�CZ�U����\u0004\u0013\u001f�T\r7�W,�6�\u0010��O�J��D�5�N����U��\u0016\u0004;�W�\u0016]ͻk�y�\u0015�~0�i\u001c{����\u0015F���(���Hq�֔\u0019o(\"G)�\u001bw��,&�\u000fݳ��1���u>��E\u0010r��(I�3��\\,|�\u0005��;q�\u0014G{D���c\u001b@\u0015df��44�\u0017F8�\u0014R� �Xi�|`�J��eo�hQ/-�\u0003_�\u001d�1�g�R(�z2�2�� �������g�\u0010���S�\u001bЍ��� ��َT\u0004\u000f����r�ώc���yƎ\u0002�Ӝ�\u0003�գ\u000f� �e����-ϔx��\"\u0017~��\u0001\u0000\u0003F$�캔\t�$X��\u0005\u0002\u000e-RH�Ap�|���j�j���5m^O�6%C\u000f���Y��=�\u0003\u0006�(Z]\u0011\u0018@����/i@9�c\u0003�ZU$[\u0006�3�\u0000�\u001a��~���\u0006j�.����TƈǋNĪ�\u0001PF~7����\u000f�@��St\n\u001c���\u0006���^���f\u0002ڽ�#�Q:&\u0017J\u001bM\u0006�8=�Dy\u0010u��RU|�l�vو\b���`�r��\nvIv@�?�\u0010X��0�\u0016?#���\u001f�\u0017A\u001bDeZ&Q�\f\u001a��\u00047�r�e\u0003��#�A�\b�(\u0007�L\b�Y\u000f�8\u0019,e�ާ�������S�\u0013P56���.�\u0010�\u000e>\u001dG�\u0001c,�ʀ�k��k�H��i�\u001b[v��E�p���i�r���|���\"�;\u0013\u0019���\u0013Ւb��3\u000f�)���`��u|\u0011�Oˆ��ⴆ���܎�\u0011��M�SپZ���ғ\u001e�,ݰ�S\u000b\u000eU\u0010;\u0019��\b��:)/�@� P�n;\u0019���X3�n7�@�>3��]\u0002��\t!(R\u0011\u0002r�)�]\u0010�m`�o��7rpX\u0012�D�Uc���I��m�\"B�!s�\u0010\u000f�\nI��&;U1Ppb�h\u000f�+u@Z�\u001cE����&\u00102\u001bP�/\\H���Y�7�\r\u001d�T�4o��^�\u0003\u0006Ç\u0019\f�\u000bTm��{#R�\u0007$h�\u0012���~9rl�j��0��\u001b���\u0018i\u0001b�\u0018��)\u000f�\"�\u000e\u0013:T�]g\u001d�y��H�G�x�&�\"�'`\u0019/�\u0014�\u0007W������)�� X�bE�u�O1��s\u0011y%��rx�I�-o)7�ZԨs33���{4�,?\u0011P��t�\u0000N�]�\u0015\u0014#�\u001e\r���4�,\u0015\r\u001f�~�u\f�\"\r��^r\u0000w�\u0004'�0�V��.�QU%\u000f\"*\u0004\u001f/<��*1\u001f�����]XS�K0\u001e'+m#O=7>'&m\u001d���]\u0005�\u000e&\u000b��\u0015���_\u0000W2�@+�;m�b�c�3\n��\u0014\u000f<���?�_\u0007��>�y���ޏ�^����X�$1�ݓpt\u0007���\u001b��\u001b\u0004s�ڧQ�\u0004sϔ�\u0004�R&��Y!�bm\u0004\u0015\u0012��\u001dϢք�Z�r��R��W��\u0014��v\u0001�\u001d�t���\u0019m@�3\fʟ)�D2[�\u000em�R�M��tK�V<,�����Nݲ6KUe��V��\u0001�*6W\u001f�_M\\�\u0018����Z�<\u0013\u0006Bq�I����[��%�a\u001e\n\u000f\n���#�@LR����g�\u0004+�ڸ\u001d��\u000e\u001d��ve�>�g~��\u00177è�z���\u0019���\u001fdܟ���\u001eI�.�\u0000�;�\u0017��3\tm��3�hm���G��5�Jv\"�f�_��*�U=|�\u0006�횅7��r��Z������͙�H?T|�\u0002�6�\u0011x\u001c�k\u0010�m���$\u0006��tq\u000f'*�0Ģi���67��/!\u000fO�*?Υ�b��e��C\u0002��y\b\u0001�Mt�v\f\u0018\u0016��l����J\n��#f���Ɋ��f����\u0001\b(G��jm/P1��5��\u001c�i�Wo\u0012)���sR���=�\u001bY踿Nbӈ��\u0018����\u0011�\u001e�\u0001�\u0013\u001b8�\u0004�E}�D)E�\u0019=���[7\u0019�B1�s\u000f'�\u000e�\u0000X0=\u0017\u0019$!��qOϲf�i �p�h\u0016�.�B;?�#r\u0017 gA��!�\u0000��*ɿ���\u0013�Q\u000e��P�\t9\u001d5��'Ls�!�}$�.��m��-Q���~÷�:\u0001�N��=����K/&}m9�����]����Q�RH\t��`�'�B�9V�[�\u0010Z���A��6�<�\u0015`#\fK�\r鋢X��!�����j����MT1˂}��.�%��LE5$_�]�����sgv�,�\u0019�K��vT�[��W\u0015���}U\u0001\u0018\u001eL\u0014�\u0019�s�\u0000���4�_�L�\\�9��B�\u0010\u0017Yl��h���U�6�34;W\u001b|\u001a4Z����pC\u001cU��Q��49\u000eC\u000e�(�1�15C6����2�J�x3�5�?�g�\"=�\u0002,�-���\u0014ۨ�k\"�w`�>\u000e\"�ԓ[I��-�yh/x�0�=�\u0006K�\u001b\u000b�\u0015]�Bn�l\t~�ص\u0018�\u0004IU�\u0010]�\u001df��\u000173�;���zbC�04ǌb�1�(�ߊo�E\"(�,mj�C�ˀ���\u0002��Yl\rd��\t\u0015k�*ɏ4\u0007 ��Se�\u0005\u001dch�$9]#|�4l����h������\u0003�Ҽ>7��xxCF�RX\"�-�,]\u0000�LM�\u0003�o���\fk{�\b�\u0015\u000e�Y���L�\"ؼ�9(~��ށ\u0018\b|.���\u0002g�Dx�\u0002�U�\u0015D�+t��c4�G��Ȥ\u0003}�9ej����D\u001a��]�W��U\\՝\u0013�Ӈ�\u0005E��xʥ���\u001co��m�x�rNT��P\u0015l�^��س��9*\f��_�{\u001e�;�c\u0013��SJZce\u00163d<\u0018�߫w�3�x\u0019P�l0�Z�\r8`�n����,�x�XZ\but��\u000el�8H\u00000�,b\n�}\u0005�\"m^r�r�#�I��1�X4T�h�k��)�2��d۬\u001c���w\u001f`uˉL\u001b\tOQ�RX�����2I+�_n�h*�cy�\u0017��\fo.�8\u001c�#�w}\u0003̋)�!D�Pu1.h�\u0010\u0018O��f���-x���h�Zt�����V�k�3��\u0003͆�AԂH�p�̋W���E=\u001a�����=_84\u00034q��@\u0004�1?pOb��ho\t���_\u0012)�F�̳�\u0001jl�����A��H�㣵�X�'B�S\u001d�\u001cX@\u001e�\u0004\u000f\u0017�%�i݉Lr%�7?%�~\b�d\u0002݊d~�'k6�>E�5_\u00164'\u001a��u��z6D\u0011]r\t1\u000b��K5\u0011T���Ҽ\u0018x��~\u0013h\u001a%]�B��uY���\u001e�\u001bm��A��\u0003\u0000���xѩ\u0002��\u00054N��ݹ\u0005�B*�/\u001dѶP]孀mg�\u000e�'T��'7\u000f��\u001d.�u��j~nN[^\n��G���t\t�����h�[bؾ8�)\bo&��6�\u001d��l�g�Y\u0002~&\b38\b*\u0014;�\u00077h��PK7\u0002�)(\u0002�>rۡ�\u0003ɠy\u0017��tu��Zh��\u0018&?�\u000e����˄J/�\n�\u0018�2&j\tR�ώ\u001d��^J\u000e�\u001d��A�V\u0011\n5nq\u0016�\n�H�E�&���K�Ӎ1do+M-�'�����;x�0r���8����D'A�HS�oQ�7Of�4\u001f\u0011���`�2\u0019qf\u001c�'\u0017e(]M���>�����\u0015Ŏ�g�ɣ\u001b�c��UH�\u0006xѰMqg�\\�Q,jz��L\u001b4�2�Д�\u001cS�\u001fE�\r�u�G;SUE؃\u0017��}�mI-�\\��I�\u0006���~� f��\u001b�QKUl=�J\u0019�l\"͠2u%q�@����E�'�\fSXL�h{C�n��x]V\tS��+f��4Q�\u0014�ᦠ�kW�\u0013L�&k�0m]\u0002�s�\u0016\u001b��?�]�р2΃����8w\u000eZ�\f�I\u001a�_k9�X�\u0000�ȡ\u001f���(��n\u0011!\r�z�\n\u0010*��\"v�S)�Ѩ�JL��UŌ}�\u000e\u001b�\u0001�YJ��lE�2\n,p3J�j\u0013�6�jY\u000esG�僟h��\u0016���Q|r���Q��bW��_\u0001�\\���+g�l�Rh��(Z�z਋0|�⼇}��{�2ụ�w��&8u?�v\b\u001f\r�8\u0017�{3k1��~)\b���H���:@\u0016�7'\u000f�\t�i\tf���벲��B,b&2x���\u0006��\t5��?�\\7m�.�$�\u0016m6�s\"�\u0014��(5٢\r\u0010��ú\b�~h@\u0017����u\u00044��\"�8��)S���\u000fD3�9؍\u00039���˂\u000f�%����\f\u0014�\b\u001d\u0003z��~4\u000e0��F:YV��m�\n/(��F\u0015&\u0016\u0019\u0013��\u001b�\u000b��\u001cg��\u0018:&cgw\u0014��G-OI��C�3!뮞]w,��t\u001ca\u0011��Nޙ�\u001f�m\fɿCȓ�*��t�\u0007=�k\u000b������\u0017H���p���z>�3\"Ƌ\u000e\u001e]�� �̊�yn�^߻������\u000b�\u00032��4�[�zu��q�������Ԙ�\t�^!��\u0014K�j�\u001a�p�O҇\u0005\u0016\u0015�.c$�釵\u001b�Ů�\u001a$ߒ�h3ª[��*3$�t\f\u0004�F�(�4��%fY�Q\u0010s,�\u0000��\u0004\u000e�I�l�(�\u0002\u0003�~�\u0011�7�`����ڷ��h����1�[d��r����[\\��>4�s�\u0007�p\u001f�Y\u0005\t�!.ಙ��o���B[\r'��c���^}�^�\fo�\r{��v\u0002�����1\b6�1�3��\u001d8\u0006�\u0018�\u0011c�Z���\u001c\u0005�C�C�l���#�R!\u001fQ֍��M?�C�\u0013\u0004����P\u0017W\u0003��N�\u0003��\u0018�\u0001�v�\b��3�O8\u0014�\u0003�wV���V͉��Lg\u0018v���\n�\u0010F\u0004�e*�\u0015 t\u001b�^/�\u0018�\u001bqwq�\u0001\u000e����\u0006�u��\u0017.i\u0014%i�t�eF;V������f�7<���6���%��^4�*Ń��0�\u00167�M`\u000e�\u001c�5X��R�΃@�9R0\u0014d��c\u0010��Z?B��\u0000�iN�\u001c�IZ���t-M��{\t��S)i �~Yd��sk*�y�\u001b�y���\f1Nq!�m�n�\\)!�\u001c�pǑ1�f�3��5Z�G�a}hG�.���/-)6�Q�d��1���\u0011;b�鼄W��i����zSK&�P�\n�\u001e��w�:��E���l�f`\n\u0018\u0010�s�m\u0019\u0004\b\u0019��kz���V�S9�r�X�:\u001d\n����\u0002��r��\u0007ӯrnE����\u0012\u0017L]\t\r�\u0018�P��N\u000b\u000b�=��d\u0013A=�+����C�7��g\u0004].L-��N��0�&�\u0018Y&=t\\g]3���o��\u001aBҹ!\u0013H\u0015\u001e,�\u000f\u000b��&:\u0010Txj��)�A�@��h۔�8*##24]��=؃�&�DE\u0011�;\u0006�H�\u000f}�N\u0006�DJ�-Zt����Sh0ޔa�hm�\u0018��K�X\n�[O��^Yt_3�U��œ\u0013�gw<��n���S�P�9O�cl�\u0000��������m��3��(�7\u00154�����\u001e\u0011H,K�C��N:��\u0018�z�h5������\u0004)P�Tܸ�@\u0004�I0��N\u0019�W/\u0014z��J�V��\u001dV\r��\n+�:�I�8h�@�\u0011��]9偕UM--�\u0019����T�\u0015~��\u0012%l�3�\u0010A\u0018\tv\fF&�\u0010�<Y�l]�V�#��S�π�\u000fU�.2���Uxv;��R�\u0016*����L��C���m��\u0000�\b\u0002\u0013\u0016ȥ\u001a ��Q��\u000f�>�J�-ڶ��\u0005�X���o\u0017D��5����v+ܕ�C���ӿ�����^\u0001�Գ\u0011�\u001c\u001e�>\u0005-�5���\u001c�z\u0002��6�\u0019�t�O�%$\u0011d5Y\u0003UԤ=�~� ̨����=#�K��\u0010���y��\"`8\u0002Oi�\u0000xN��Q?�]��ac�0\u000f`/7\"��\tg��C\u0007��v�O�l8Ey|it��vM+U��'.���I\n��%\u0015*y�(��\u000f}\r\u0011)'Z��b��{��=j��\u001cBxڣ>�\t��G��!\u0007�E\u0003=��\u0013�\u0006�0�\t�ߞХ\u001e�u\u0004�p��PxYȬ�H����Z?\n<(�6?��$ߵ\u0004���7v���\u0013FO�\u0005��5f�J�ӝ��l�.&���0�t����~����E\u0015��\\\u000b\f��R��Zn�\u0015��\u001eh��=R\u0010�1��'�[:':�43=5\u001eE�Fh�\u0005\u0015�DD�S\u001bEjܻ.�\u0015\f�N�)\u001d�\u001c\u0003Ĳ��h�[���\f\u0002q\\c���s� \u0003\u0016�Jb{0\u00146\\\u001e���\u001c�핃��~)��A]��W���\u0003�R�\n[loP�\u001f�DlS\u0016���{!�����\u000eF�?i\u001f8\u0005���P�c�\u000eqx\n�EiR�w��I�\u0016�}�\u0016M\u0010M�2�N\u0013����u�{\u001e�\"\u0019�v�\u0014U\\�\u0000�����+��s�42\n�)r���x\u001eű�\u001co\u001b\"\u0010����\u0010��dy00$�!�\\\u0014 d@�\nk��\bY�~\u000b��G7E��ʦ�Q|8�D���w�Ƅh���\u0007@�gS\u0007�\f�.M��\nA�\u000eZ�@3�d���yȂ�g\u001c ���2&�\u001eI�?�|dy\u0003���>��\n\r�o`�]��2�)k�T��\u0000\u0015\u0007�G(_W\u001f�#m��SX�e�v������\u001e\b���;\u001eZ'�{�+���\u0007W�\u0003+�R&�\u001d<b�4\u0011e��V�޶��FԋWL�\r�[!uy��Dx���s\nm�!�p\u0005/�\u0006�M�\u000e�مN�\u001f�\u0005�ٚv��|�c�QN��\u0016_�\u0018���\u0004�6~;4�B�Nй���@�k�6��T�r��G?�I�\u0006�E�\nyB�?\u0018�\u000bL9��=�\u000b��3��Nm)�Dn���\u001e�R�\u0005\u0012��� �\"��\u0007x�.\u0006��X��ԯK\u0019Z}k�\u0010E�����+Ő\\ldû��9�\u0017%��n��D&��;�X��\u0007DĤ�-l\f4�=��̚\u001b\u0011oqg�G\t�۪\u000e�\u0001�y1���kHqz����\u000fFI~\u000f���}\r7Q| \u0014b*qO2�\u0017%�+Kup�����=�L\u000f��\u0011�1�)�%��e\u0019��X#�My��=j\u0016,|g����E\f�L����ʹJ(v�j�+���=�&�p[u\u0012,#\u00139�;�H�aEqLH���0)!�N�@)��!��%����V��hֈϋ��V�^c%�\u0012\u001d�Ҋ�\u00028��}d\u0001�u8�NO�}�Xq+`�=�y�7��\u0019\u0018D�Js@.��\u001c\u0005����\u0006��\u000ey��\u0013�\u001d�\u0012I�J��P�S\t#�\u0018]˅�u8<��R*s��\u0003��`)���dE��?�\u0005-s����'2�Q9�\u001d�⢉�\u0005\u0017�\u001f���M\u0016ظ\u000b9R�J�����\u0003TuC��S�����\u000e�Qѯt�b/��'L!�h�L�����,X/���ϋ�\u0001n�P\u0003E�\"\u0004`\f�~MD��lU?�љE�E�y�J���@�K2\u001f�\u0018\b�G�e�O\u0004�\u0007<_h�\u001djh���\u001569��\u001f��� _�Z��E�E��?�\u0013�(��֒y�|\u0005�\u00069�\fm\u0007�=lMf\u00006{�Q�4��#����U�y9�\u0018Ё�Z����5\u0016\u0017v�P\u0014�\u0019�\rB.�E\u0003���ثI@�M&�^\u0017K�o�>`���[#j\rY �~:\u0019f�(�c0\u001d�[f\fp��P4�N����vx��7�\u0018�L��L������ř!�G�\u0019\u0015NX�\u001fD\u0014��9?�.M��>b\\+x\u0006\t#ʨ\u0012�z>r�\\��?K��\u0016bn�Kr\u000b\u0018�\u0012�մ�.JJ���\u000bo\u001d�\u0006\t���h�̟�S\u0005`\u001d\"Od��5�3�\u0016����)?ǈ6'\r\u0013;L��\u0002�Pe\u0010��@\u0001\t��y�4&���A*D\"*�p7ha�<y�)���\u0014�m��ޔz\u0000 �٭e�=�)X\\�$\u000b\n�\"�Y`f�[_��\u001e�.�\u0001&\\x�~��r��x[|\u001f��\u001f\u000e-�I��Ȱ(J�#P\u0005C��2�lgI�}\u0001��B������\u0017h��Z�?4N�Z��\u0000\u0002�����IpP\u0000\u0000\u0000\u0000EXIF]-\u0000\u0000MM\u0000*\u0000\u0000\u0000\b\u0000\f\u0001\u0000\u0000\u0003\u0000\u0000\u0000\u0001\u0001�\u0000\u0000\u0001\u0001\u0000\u0003\u0000\u0000\u0000\u0001\u0000�\u0000\u0000\u0001\u0002\u0000\u0003\u0000\u0000\u0000\u0003\u0000\u0000\u0000�\u0001\u0006\u0000\u0003\u0000\u0000\u0000\u0001\u0000\u0002\u0000\u0000\u0001\u0012\u0000\u0003\u0000\u0000\u0000\u0001\u0000\u0001\u0000\u0000\u0001\u0015\u0000\u0003\u0000\u0000\u0000\u0001\u0000\u0003\u0000\u0000\u0001\u001a\u0000\u0005\u0000\u0000\u0000\u0001\u0000\u0000\u0000�\u0001\u001b\u0000\u0005\u0000\u0000\u0000\u0001\u0000\u0000\u0000�\u0001(\u0000\u0003\u0000\u0000\u0000\u0001\u0000\u0002\u0000\u0000\u00011\u0000\u0002\u0000\u0000\u0000\u001e\u0000\u0000\u0000�\u00012\u0000\u0002\u0000\u0000\u0000\u0014\u0000\u0000\u0000҇i\u0000\u0004\u0000\u0000\u0000\u0001\u0000\u0000\u0000�\u0000\u0000\u0001 \u0000\b\u0000\b\u0000\b\u0000\u0000\u0000H\u0000\u0000\u0000\u0001\u0000\u0000\u0000H\u0000\u0000\u0000\u0001Adobe Photoshop CS6 (Windows)\u00002020:04:06 12:00:18\u0000\u0000\u0000\u0000\u0004�\u0000\u0000\u0007\u0000\u0000\u0000\u00040221�\u0001\u0000\u0003\u0000\u0000\u0000\u0001\u0000\u0001\u0000\u0000�\u0002\u0000\u0004\u0000\u0000\u0000\u0001\u0000\u0000\u0000��\u0003\u0000\u0004\u0000\u0000\u0000\u0001\u0000\u0000\u0000�\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0006\u0001\u0003\u0000\u0003\u0000\u0000\u0000\u0001\u0000\u0006\u0000\u0000\u0001\u001a\u0000\u0005\u0000\u0000\u0000\u0001\u0000\u0000\u0001n\u0001\u001b\u0000\u0005\u0000\u0000\u0000\u0001\u0000\u0000\u0001v\u0001(\u0000\u0003\u0000\u0000\u0000\u0001\u0000\u0002\u0000\u0000\u0002\u0001\u0000\u0004\u0000\u0000\u0000\u0001\u0000\u0000\u0001~\u0002\u0002\u0000\u0004\u0000\u0000\u0000\u0001\u0000\u0000+�\u0000\u0000\u0000\u0000\u0000\u0000\u0000H\u0000\u0000\u0000\u0001\u0000\u0000\u0000H\u0000\u0000\u0000\u0001����\fXICC_PROFILE\u0000\u0001\u0001\u0000\u0000\fHLino\u0002\u0010\u0000\u0000mntrRGB XYZ \u0007�\u0000\u0002\u0000\t\u0000\u0006\u00001\u0000\u0000acspMSFT\u0000\u0000\u0000\u0000IEC sRGB\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000��\u0000\u0001\u0000\u0000\u0000\u0000�-HP  \u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0011cprt\u0000\u0000\u0001P\u0000\u0000\u00003desc\u0000\u0000\u0001�\u0000\u0000\u0000lwtpt\u0000\u0000\u0001�\u0000\u0000\u0000\u0014bkpt\u0000\u0000\u0002\u0004\u0000\u0000\u0000\u0014rXYZ\u0000\u0000\u0002\u0018\u0000\u0000\u0000\u0014gXYZ\u0000\u0000\u0002,\u0000\u0000\u0000\u0014bXYZ\u0000\u0000\u0002@\u0000\u0000\u0000\u0014dmnd\u0000\u0000\u0002T\u0000\u0000\u0000pdmdd\u0000\u0000\u0002�\u0000\u0000\u0000�vued\u0000\u0000\u0003L\u0000\u0000\u0000�view\u0000\u0000\u0003�\u0000\u0000\u0000$lumi\u0000\u0000\u0003�\u0000\u0000\u0000\u0014meas\u0000\u0000\u0004\f\u0000\u0000\u0000$tech\u0000\u0000\u00040\u0000\u0000\u0000\frTRC\u0000\u0000\u0004<\u0000\u0000\b\fgTRC\u0000\u0000\u0004<\u0000\u0000\b\fbTRC\u0000\u0000\u0004<\u0000\u0000\b\ftext\u0000\u0000\u0000\u0000Copyright (c) 1998 Hewlett-Packard Company\u0000\u0000desc\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0012sRGB IEC61966-2.1\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0012sRGB IEC61966-2.1\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000XYZ \u0000\u0000\u0000\u0000\u0000\u0000�Q\u0000\u0001\u0000\u0000\u0000\u0001\u0016�XYZ \u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000XYZ \u0000\u0000\u0000\u0000\u0000\u0000o�\u0000\u00008�\u0000\u0000\u0003�XYZ \u0000\u0000\u0000\u0000\u0000\u0000b�\u0000\u0000��\u0000\u0000\u0018�XYZ \u0000\u0000\u0000\u0000\u0000\u0000$�\u0000\u0000\u000f�\u0000\u0000��desc\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0016IEC http://www.iec.ch\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0016IEC http://www.iec.ch\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000desc\u0000\u0000\u0000\u0000\u0000\u0000\u0000.IEC 61966-2.1 Default RGB colour space - sRGB\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000.IEC 61966-2.1 Default RGB colour space - sRGB\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000desc\u0000\u0000\u0000\u0000\u0000\u0000\u0000,Reference Viewing Condition in IEC61966-2.1\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000,Reference Viewing Condition in IEC61966-2.1\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000view\u0000\u0000\u0000\u0000\u0000\u0013��\u0000\u0014_.\u0000\u0010�\u0014\u0000\u0003��\u0000\u0004\u0013\u000b\u0000\u0003\\�\u0000\u0000\u0000\u0001XYZ \u0000\u0000\u0000\u0000\u0000L\tV\u0000P\u0000\u0000\u0000W\u001f�meas\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0001\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0002�\u0000\u0000\u0000\u0002sig \u0000\u0000\u0000\u0000CRT curv\u0000\u0000\u0000\u0000\u0000\u0000\u0004\u0000\u0000\u0000\u0000\u0005\u0000\n\u0000\u000f\u0000\u0014\u0000\u0019\u0000\u001e\u0000#\u0000(\u0000-\u00002\u00007\u0000;\u0000@\u0000E\u0000J\u0000O\u0000T\u0000Y\u0000^\u0000c\u0000h\u0000m\u0000r\u0000w\u0000|\u0000�\u0000�\u0000�\u0000�\u0000�\u0000�\u0000�\u0000�\u0000�\u0000�\u0000�\u0000�\u0000�\u0000�\u0000�\u0000�\u0000�\u0000�\u0000�\u0000�\u0000�\u0000�\u0000�\u0000�\u0000�\u0001\u0001\u0001\u0007\u0001\r\u0001\u0013\u0001\u0019\u0001\u001f\u0001%\u0001+\u00012\u00018\u0001>\u0001E\u0001L\u0001R\u0001Y\u0001`\u0001g\u0001n\u0001u\u0001|\u0001�\u0001�\u0001�\u0001�\u0001�\u0001�\u0001�\u0001�\u0001�\u0001�\u0001�\u0001�\u0001�\u0001�\u0001�\u0001�\u0002\u0003\u0002\f\u0002\u0014\u0002\u001d\u0002&\u0002/\u00028\u0002A\u0002K\u0002T\u0002]\u0002g\u0002q\u0002z\u0002�\u0002�\u0002�\u0002�\u0002�\u0002�\u0002�\u0002�\u0002�\u0002�\u0002�\u0002�\u0003\u0000\u0003\u000b\u0003\u0016\u0003!\u0003-\u00038\u0003C\u0003O\u0003Z\u0003f\u0003r\u0003~\u0003�\u0003�\u0003�\u0003�\u0003�\u0003�\u0003�\u0003�\u0003�\u0003�\u0004\u0006\u0004\u0013\u0004 \u0004-\u0004;\u0004H\u0004U\u0004c\u0004q\u0004~\u0004�\u0004�\u0004�\u0004�\u0004�\u0004�\u0004�\u0004�\u0004�\u0005\r\u0005\u001c\u0005+\u0005:\u0005I\u0005X\u0005g\u0005w\u0005�\u0005�\u0005�\u0005�\u0005�\u0005�\u0005�\u0005�\u0006\u0006\u0006\u0016\u0006'\u00067\u0006H\u0006Y\u0006j\u0006{\u0006�\u0006�\u0006�\u0006�\u0006�\u0006�\u0006�\u0007\u0007\u0007\u0019\u0007+\u0007=\u0007O\u0007a\u0007t\u0007�\u0007�\u0007�\u0007�\u0007�\u0007�\u0007�\b\u000b\b\u001f\b2\bF\bZ\bn\b�\b�\b�\b�\b�\b�\b�\t\u0010\t%\t:\tO\td\ty\t�\t�\t�\t�\t�\t�\n\u0011\n'\n=\nT\nj\n�\n�\n�\n�\n�\n�\u000b\u000b\u000b\"\u000b9\u000bQ\u000bi\u000b�\u000b�\u000b�\u000b�\u000b�\u000b�\f\u0012\f*\fC\f\\\fu\f�\f�\f�\f�\f�\r\r\r&\r@\rZ\rt\r�\r�\r�\r�\r�\u000e\u0013\u000e.\u000eI\u000ed\u000e\u000e�\u000e�\u000e�\u000e�\u000f\t\u000f%\u000fA\u000f^\u000fz\u000f�\u000f�\u000f�\u000f�\u0010\t\u0010&\u0010C\u0010a\u0010~\u0010�\u0010�\u0010�\u0010�\u0011\u0013\u00111\u0011O\u0011m\u0011�\u0011�\u0011�\u0011�\u0012\u0007\u0012&\u0012E\u0012d\u0012�\u0012�\u0012�\u0012�\u0013\u0003\u0013#\u0013C\u0013c\u0013�\u0013�\u0013�\u0013�\u0014\u0006\u0014'\u0014I\u0014j\u0014�\u0014�\u0014�\u0014�\u0015\u0012\u00154\u0015V\u0015x\u0015�\u0015�\u0015�\u0016\u0003\u0016&\u0016I\u0016l\u0016�\u0016�\u0016�\u0016�\u0017\u001d\u0017A\u0017e\u0017�\u0017�\u0017�\u0017�\u0018\u001b\u0018@\u0018e\u0018�\u0018�\u0018�\u0018�\u0019 \u0019E\u0019k\u0019�\u0019�\u0019�\u001a\u0004\u001a*\u001aQ\u001aw\u001a�\u001a�\u001a�\u001b\u0014\u001b;\u001bc\u001b�\u001b�\u001b�\u001c\u0002\u001c*\u001cR\u001c{\u001c�\u001c�\u001c�\u001d\u001e\u001dG\u001dp\u001d�\u001d�\u001d�\u001e\u0016\u001e@\u001ej\u001e�\u001e�\u001e�\u001f\u0013\u001f>\u001fi\u001f�\u001f�\u001f� \u0015 A l � � �!\u001c!H!u!�!�!�\"'\"U\"�\"�\"�#\n#8#f#�#�#�$\u001f$M$|$�$�%\t%8%h%�%�%�&'&W&�&�&�'\u0018'I'z'�'�(\r(?(q(�(�)\u0006)8)k)�)�*\u0002*5*h*�*�+\u0002+6+i+�+�,\u0005,9,n,�,�-\f-A-v-�-�.\u0016.L.�.�.�/$/Z/�/�/�050l0�0�1\u00121J1�1�1�2*2c2�2�3\r3F33�3�4+4e4�4�5\u00135M5�5�5�676r6�6�7$7`7�7�8\u00148P8�8�9\u00059B99�9�:6:t:�:�;-;k;�;�<'<e<�<�=\"=a=�=�> >`>�>�?!?a?�?�@#@d@�@�A)AjA�A�B0BrB�B�C:C}C�D\u0003DGD�D�E\u0012EUE�E�F\"FgF�F�G5G{G�H\u0005HKH�H�I\u001dIcI�I�J7J}J�K\fKSK�K�L*LrL�M\u0002MJM�M�N%NnN�O\u0000OIO�O�P'PqP�Q\u0006QPQ�Q�R1R|R�S\u0013S_S�S�TBT�T�U(UuU�V\u000fV\\V�V�WDW�W�X/X}X�Y\u001aYiY�Z\u0007ZVZ�Z�[E[�[�\\5\\�\\�]']x]�^\u001a^l^�_\u000f_a_�`\u0005`W`�`�aOa�a�bIb�b�cCc�c�d@d�d�e=e�e�f=f�f�g=g�g�h?h�h�iCi�i�jHj�j�kOk�k�lWl�m\bm`m�n\u0012nkn�o\u001eoxo�p+p�p�q:q�q�rKr�s\u0001s]s�t\u0014tpt�u(u�u�v>v�v�wVw�x\u0011xnx�y*y�y�zFz�{\u0004{c{�|!|�|�}A}�~\u0001~b~�#��G���\n�k�͂0����W���\u001d����G���\u000e�r�ׇ;���\u0004�i�Ή3�����d�ʋ0�����c�ʍ1�����f�Ώ6���\u0006�n�֑?���\u0011�z��M��� �����_�ɖ4���\n�u���L���$�����h�՛B���\u001c�����d�Ҟ@���\u001d�����i�ءG���&���\u0006�v��V�ǥ8���\u001a�����n��R�ĩ7���\u001c���\u0002�u��\\�ЭD���-���\u0016���\u0000�u��`�ֲK�³8���%���\u0013���\u0001�y��h��Y�ѹJ�º;���.���!���\u0015���\n�����z���p���g���_���X���Q���K���F���Aǿ�=ȼ�:ɹ�8ʷ�6˶�5̵�5͵�6ζ�7ϸ�9к�<Ѿ�?���D���I���N���U���\\���d���l���v��ۀ�\u0005܊�\u0010ݖ�\u001cޢ�)߯�6��D���S���c���s����\r��\u001f��2��F���[���p����\u0011��(��@���X���r����\u0019��4���P���m�����\u0019���8���W���w�\u0007���)���K���m����\u0000\fAdobe_CM\u0000\u0001��\u0000\u000eAdobe\u0000d�\u0000\u0000\u0000\u0001��\u0000�\u0000\f\b\b\b\t\b\f\t\t\f\u0011\u000b\n\u000b\u0011\u0015\u000f\f\f\u000f\u0015\u0018\u0013\u0013\u0015\u0013\u0013\u0018\u0011\f\f\f\f\f\f\u0011\f\f\f\f\f\f\f\f\f\f\f\f\f\f\f\f\f\f\f\f\f\f\f\f\f\f\f\f\u0001\r\u000b\u000b\r\u000e\r\u0010\u000e\u000e\u0010\u0014\u000e\u000e\u000e\u0014\u0014\u000e\u000e\u000e\u000e\u0014\u0011\f\f\f\f\f\u0011\u0011\f\f\f\f\f\f\u0011\f\f\f\f\f\f\f\f\f\f\f\f\f\f\f\f\f\f\f\f\f\f\f\f\f\f\f\f��\u0000\u0011\b\u0000�\u0000�\u0003\u0001\"\u0000\u0002\u0011\u0001\u0003\u0011\u0001��\u0000\u0004\u0000\n��\u0001?\u0000\u0000\u0001\u0005\u0001\u0001\u0001\u0001\u0001\u0001\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0003\u0000\u0001\u0002\u0004\u0005\u0006\u0007\b\t\n\u000b\u0001\u0000\u0001\u0005\u0001\u0001\u0001\u0001\u0001\u0001\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0001\u0000\u0002\u0003\u0004\u0005\u0006\u0007\b\t\n\u000b\u0010\u0000\u0001\u0004\u0001\u0003\u0002\u0004\u0002\u0005\u0007\u0006\b\u0005\u0003\f3\u0001\u0000\u0002\u0011\u0003\u0004!\u00121\u0005AQa\u0013\"q�2\u0006\u0014���B#$\u0015R�b34r��C\u0007%�S���cs5\u0016���&D�TdE£t6\u0017�U�e���u��F'���������������Vfv��������7GWgw��������\u0011\u0000\u0002\u0002\u0001\u0002\u0004\u0004\u0003\u0004\u0005\u0006\u0007\u0007\u0006\u00055\u0001\u0000\u0002\u0011\u0003!1\u0012\u0004AQaq\"\u0013\u00052��\u0014��B#�R��3$b�r��CS\u0015cs4�%\u0006\u0016���\u0007&5��D�T�\u0017dEU6te����u��F���������������Vfv��������'7GWgw�������\u0000\f\u0003\u0001\u0000\u0002\u0011\u0003\u0011\u0000?\u0000�I$�=j�I$��\u0004���M\u0001\u001bb�\u0005؀\u001d������T�)\u0002�nH\u001e��'��*��\u001cd���X�����&8O��c_���O\u001f��\u001b��#��čF��ȵ�\u0019�\u0006aڣ�����O\t���\u001b2���p���?\u0004�i���2�����\r'\u001d�\u001c\u0007�c���Gw���_Y/iٛ��\u001a9k�\u0015�V��5���\u001c\u001e+�� \u001b�A�3��Ҋ\u0004��;���H`}�\u0013)�\u0006=��\u0013��,�W�,d�C�W�\u0006�0fP5�(\u001e��V9��\u0000�^�\u0006\u0004x�q|K\u0004�J��|��9)��N��\\�}\u00131��#�G�4n��A��\b5�+Q9����#��z�OO�m\u0007#\u000f�\u001c��\u001f�]����\u0007�?��Y����@�\u0016�mGMÐr�\u001fuo�C�\u0000������1_��=�V<\u000f̵���\u0000W_�\"%ݧ�|<J�C�\u001f�/��J�M�X�K\u001bף�����eո�k�y��\u0000\u0005o�i�I\u0004\u001a\"��ЊIJ��z>oV�f8�CL[��,o�[�}k���\u0000\\U�'@�9s��\u000e9ʣ����i\u0012\u0007(\u000f�hуq�����+\u0014t��mvmQ�s�\\�CvX�~���>�Ob�s�2�vS�3\u0019���\t\u0000�\u0002�}\u0017���5H1���9�%�%�����\u0000�\u001c���\u000f�g]c�Z\\N�~\u001e\n\t'���9r\u001b����J�N��pD��\bL��$�H�JA����h�Ö�\u0000���:�3-��^=Ϩ7y����h��\u0000Snͪ�_V���\u0003���A�e|�\\�܂���6\f\u0018 �j\bZ�\u0017�'T�\u000emt8ߊ\u000e�v\u0012[\u001f�]�����~��\tC�}]�=6�ۗ���sen\u000fcI�6����;ۻ���굎\u0004?c�d\u0010��\u0004pZD9�jHо�h�_[�\u001d���\u0000C:�k�\u0000X�G�����+?q�\u0000�ͫ������v.[6\\�Gv��6ʟ����\u0000V+=#�\u0006.VU#;!��V�f7Wf��\t���+\u001b[}/�;��\u0000��?�]�V�\u0018�[\u0010S�=;[��j��\u001f��{?}��\u0010�m��楂c��)�\u0000�\u0017�RD����ɳ\u0013%�n�ã�\u000f̲��\u0000\u0007b\u001a����1�H\t��d�\u0013/#\u000b%�8��kt ��4�*�o�V���Χ����Ԃ�0��K���?�u��\u001d��E�����nV3�X�\b:����o�V�A���y1��\r2�����\u0000|�\u0000�ѯ}½\u001a=�/5�}V����z5Xy����m��\u0006\u001e\u000b����1�w��3���9��.<��@��ϐ噑\u0015g@:=?�_�.�ۋ���Ǯ���-}����a�\u0014�����������w������~V]����08ѭ\rnֵ��J\u0012H��\u0002��A��:\u0002\u001a'̏��b`��9�ĥ��bmx��\bݺ럶����]\u0013>�t�:{z�T�>���[E-�\\\u0012��1ޯ�e��>��ZI�>����gf��\u0010@��� �/\u0000�Ks���۱��B�\u0013&�\u001d[Y\u0006��\\�+c5��{m�]>�����9��6��hs\u001e�$�:E���8�\u0000�[6UR꾸}_m���b��YߑX��?�\u0006�\u0000�c��\u0000��'�4�*#�q\u001d:�\u001fc�c�б��f�oQ,l�X2ʷIk�fFG�e����W\u001dY��t\nD3��\u000e��P�\u0000kզŊ�\u0016<8��}�ˇ\u0004�fǖ�\u001c|\u000f\t�H��L��]{.���$3\u001e�\u0006��Ɔ��\u0000�e�}]�}�If\u0006\b\u0005����^\u001aHhw�i�\u000fQS�\u0017����G�$U\u001e˷+2�\u001f���f;�m����e�ҝ���\u001dB�����S\u0007���-\u0000�g���\u0016�Z�\u0000�h'�=�R�����X�\u0000В�}�_T��\r���\u0000Vk=+mf]\u0004˨˭�1��~����*��\u000f�ޑ�]8��\u001c�*f3�� C\u001b�n�{q���ל�\"D~M\u000f�\u0015� ���\u001a\u0007Rɻ\r�����݆\u001b��q]�57q�z�5��\u0000����U{�(�\u000748j\n|����Y��c���&\u0006\u001bۣ��9��3�n�c�o���\u0013;(e���\n��sG�6��-�~c.w�}?�vz�9�\u0017���vc\t�g�ɷ��\u0000�%�p~=����Uc-�ŖV��8r\u001c\f��ë����W\u001cu��\u0000��\u0000\t��� ���1���+D��Q[�������ٽ�Q@k�\u0018��\u001fW*�v����춪�\u0000�*>�Ѷ�h����E\u000bg��U�X+��}��,\u0003S�¿Sz&\u0013'*z�Y\u001f����Z��&SK,��\u0017�\u0007�}T^wT��\u0000q%�]t�*\t �s�q䞜:gNǧ\u0003\u0013k��W�ǿ~�R-����˻�\u0015a�����a#sݫ���;ܦ}�\u0006�s���>�6\u0015\u0017g�׈�\u001fe�\fc�ػ��?3����\u0000�m�\u0016P\"�\u0002\b j\u000f</X�\u0006� H<p����f}a\r�c\u001fnN�CL��ߵ�\\��}-�ѝ���P�;&_�/��b郦�Kh`�]\u000f���Ճ�\u001e���J��k��\u0011\u0005u�_1����\u0003V��8�\u0011�����>��\u001a���\u0000\u000e��i�ev\u0006���I\u0019X\u001fb��\u0011cIN�\u0016������\u001b\u001b\u001e�mcZ!�xc\u0001伝�\u0011�w'\u001d�\u0011�M�Ch���?�{�s{�\u001c[\u001f�Uqi75��6`\u000e\u0000���0��i��\u0005�\\\u001a��p����y\u001f�nm�\u001d\u0007��Ժ�t8m�{��\u0007�\u001fOh��?�bm�eq�V���L�g��ۋh�\u0002X��;��j��>�c�]|X�\u001fhmv@�M���`;�;�O�F&�>\u000bK6;e{�z��\u0003܉@�{�8�\u001f\u000e��J\u0013�c\u0019�W��}\u001f�!\u001b\u0019�˱����S�K���$v>+�ˆq?�c&�>\u000e\u0006gP��įxi��t����\u001b�E��}S¥۳^췏��n��\u001a}K?�b�kZ�6��\u0019[4k\u001a\u0003Z?���Tb=���&M�1����_�ӣ��;\u0007\u001fI�f?�Jv��\u0000������\u0004\u0003<�*$�%J�\u0007;ݣ\u001b�ϗ�d��{��\u0007�&\u0000��8ؙ\u0019�3\u0013\r���\u0000�����\u0016�k\u0012%@\u001d�\u001d�٠�8�\u0007a��u]\b����dg�\u000fQ ��0\u0017���f�eW�����\u001a�\u0000G��PoH��Χ�c\u0010��f�\u0016�mR7m���2��_s[�/��\u0000J�F}U�/\u0005�ٌ���X\u0005�\r\u0003�L\u0006�D�mf��}T��\u001e\t<#sf]�c�Y�\u001b��u����\u0000��4��w:�������=�C�5t�V��y�\u0015�#�a�٧!�m����]\u0016m��t���og�r�}w#�\u000fk11�CN�K1�1\u001amq������mn�X�=*��\u0017�Q���[]�00Y<�н�\u001b���\u001b�4%\u001d\ndw��7~�QfGImU5�Z��\u0015��I.\u00163���+�}^Χ�aa�S��79���pc���\u000f�1�m~��k�L�\u0013 \u0000�y�?������pi�\u0005�ͮ.s\u0018O�n�\u001a�I��\u0000��\u0000�\u0015���{'\u001f�S��,����p��o������u�v}\u001d��K�Y�Z3��� ���2\u000f�׷B7�{���w��6'BD�U\t\u0010��.��:%���/.�[�>��V�vC=����͞�ҩQ�:\u001fWi=\u00172�2���\u001f#��oo���[��z��gu|,|S��=\u0018&�d�\u001b��~��u�\u0000#޲�0�k��qe�8\u0016��w��\u0000�c>�-(H鮿���o�&�U�Z~ۂ�Y{���}�=�{lٹ�.�\u0000\u000b��\u0000�޲�����\u0012\u0000.tj`{��\u0000Ev�\u0000Y髪�\u001a:�\f��^�Z5>���Vt�}�����о����m����\r�\u001c\u0001���zi~�};}��\u000f��\u0005h\u0010d(\u0013�hc�g�{��\\t$���z\u000e\u000b����pÖXO�\u0019���\u0000��T�8��~ эt�y�\u0011��?ɯ�Qv�\u000f����b5�֗^�����c��is\u0012'D�V{�g]|S$�1k�Ԡ\u001au��\u0013��'���N֓k�\u0004}\u0010e��\u001c� \u001d9��N�������I���j�\u0014i�Z�Ze5���.��4z�\u000fk�\b�4T�,V;\u001b��gQ��ƺ�GYS�G���\u000f�9�{k�ԯm,�?B����e5�\u000e�����2&V7�:�r�{ƞ��1$k��\u00169����zАб�Dʏ�S�M\u0006������*�0\u0013�O�l^���\u0000� u�y�;��lv�j��L��\r��km�\u0006�\u0000ѷg�w�E��{\u000e�\u001e���{};�\\�ɘ{����\u001f�r㾲��?�F���r!�w��*�\u0000�c\u001c�� �N]{<�E���Y�q�m�.{��\u0013��)�NSZܪ�-i���ii�?�pޭ����\u001d�7�&C�0��+��52I �����H/\u0003W�Ǽd�Ւ�\u0002�6�9��>?\u0014E[�c�\u0017�b�?��K\u0018��\u0001��\u0000����r�,?�XϿ�9�\u0012q�m���\u000e����=�pr�Uؙ�9�=�8�o��N�:\t�����14mO�da?#\u001f\u001a�Q�6��ك?��\u0000I\u001a����\\��X�y۷�+��\u0003������f�=�ր\\��\u0000&�3���\u0000³�v�\u0000��at��֬c\rG\u0017\u0016e����\u0003��I��;�+g�uO}�i��/Dg���g�>���\u001a�\u001ba�~��tN�OL����Rݹ]:ϳ�\u0000�Ƒ�c}���Yv���z�ֵo���f\r\u001607\u001e����KX\u00043��,?���5����n4��W��\\I��<>~�vR�����M�\u001c@,\u0003��|��S��\f\u001bz�.wR��*�����k�\u001c#�Ǿ�J��)��7m޵���\u000b{\u00177\u0017:�v-���#G\u0002�1��iyy�Iv��3��Zx\u0007��g�u1Cُ��'B�[\u001e����絶V�Q��?���m8���A�@�\u0012I����e�\u001d�Z��\u001f\u0016�njt�?���LxN�����c�â̗�\u000b�M.�\u000f�����2�\u0006'^��Ū���)��h݋�o��\u0006�\u0015������1+���z,�+\f�_�E��9�\u0017�\u001aGsv��}�����\u00001�\u0000�X�\u0007��\u001fP�F'T6bg�\u001aʫ\u000fk\\74ۻ��z��\u0005/�}/�`u+\u001b���9`�\u001a�\u0007\r��q\u001e���f�k���OF��Mc\u0013kD�Q?�w���\u0018�x�dRI��,q\u001a����\u001f�[��U:�\u000fGꕊ3���S]k,i�1���;ps=79��?��\u0000����e=\u001b��n��\u0006����N�mi���������Y�[��k�O��m��@�ƴo���\u000f_�9L�\u0000L��!c�Lq�l\u0012?�\u001f�ز�����m[\\���l5��\u001d��ݵ�\u0000]kt﫸\u0018�7\"�\u001d���\u001e�Y\u001bY$첺\u0006��G�o��\u0016c\r����xnCFNU@\u0012�bV\\�,-�鳭ݑ�\u0016�,~\u0016\u000eNnS�^U��d��{Y�ET{\u001c�=�����\u001f����\u0013e#��Zut\u0012\\�[2\u0005>��u\u00175�V���pk�YE��s]�����+~��9���\u0018���Z\u000bG�)n��\u0000��hn@��PÐ�\u0004\t�F�\u0017���kZ6�\u0006�&\u001a\u0000\u0012u<.*�����n\u0019[\u0007fR\u0018��\u0000I��\u0000��Y����\u0001�\u000b#�մ���\n�x����d<�j�\u0011����NVWW�#$Wk��\\6}�-��Cwz\u0014�\u0000m�u���\u00175�������n�uNy!���X\r�l^\u001c������K����:.\b56�\\ʬ���\u0000v�q��-�7{���{m�e�\u0012�JCrc���l,��/G^\u001dԺ�\u001f�C#����N?�n�g�S���V.O��ߕ��4\u0006ܖ��|gG�\n7m�\u0000�Z��\u0018���-.��ev<\u0012 �G�i���Y���n�+��5�7Y�XN��\u001a��\fc\u0018�\u0012%1F�0��Ug\u0016�\u0016��+'Ԯ�����v9�{61�o�\u001f_��\u0016�V��F��c`�����EF�8\u0006���\\�������\u0018���c�o��\fu�@\u001d�{��?���e`l�1�/}в�߫��ku�\u001f{\u001c��~�8��g�G1����mj�eWT˩x��Z\u001f]�2\u001cӫ\\�G��=>��G.��\u0000���\u0000�\u0015_�^�d�.��+��}�\t�\u0018�����ɮ�����5����7U������l\u001bl�]Ba�[ȥ��\u0002��[�����\u0000�ڳ����T3\u001e��1�d��A�'�>�S�ˬw�����A:\u000eN��Pe��b˯�\u0016Q�ϴ�]��w�$}/Z}M���ﱎ\u0016��.k�F<�;��\u001a�O�\"-����5�6~\u0000��T6\u0000�m��@��jAt�����zl^�_W��܏�65���\u0016�\u001a�75�4{�?�{�߸�F�Lo��{\\m�-��\u001eD\u001b�O����[���\u0000G�����:��~\u001e]9L�t�<\u0003�ӻi�\u0000�^��԰2�\u0006m70c�.s�\u001b��\u0016�?�sTY.�\n\u0004�+�%\u0018���]Sa׿Ե��.�ѯ�[\u0016o֛\u001cΓ鏣}�V���ާ�/M_��nv+r�\u0011]��y�{���ҵ��\u0007]�~gHɦ�6��j\u0003��\"��{v(�ꘚ�'�\u0016�e�/�\u0003x\u0010\u001d�\nu\u001a�m����\u0017�RUM�zh�:���#� �\u000fb�I%���[\u0018�Zv\u0006\u0002�\u0003�\u000f\u0005�t�\u001d��p��e,�\u000fbF�7�;�/���R�\fŉǤ�s\u001d�h3]\u001fֹ����\u0013&Ou>1Q����9��A)������K7��F�ޜ����\u0017\u0003^8�${���\fv�\u0000��j}[�����^w��5c�Ý��\u001f�U¹y�T�=K%���'@��Z�ͮ��mm�\u0000�?=M\b\u0013�F���\u0000}��\\�\u001a$;M�Ć�\u0010\u000f�}dj�s;\u001e����\\����\u0006\u0001�|�?z�@��s\u0013��\\Z\u000e>=�2�L4�\u0001?H�����×M�G�ߏE��\r��\u001bKO;\u0001��5�m��C��z��\u0007�W����ik�^w��&��\r�k����޶I$�Ԧ\u0012�w\u001b�����E����\u0000Ǵ�\u0000��?�\u0016�q�p�\u0002\f��f���,�\u0004\u0010\t����\u000b�\u000e�3�$C��d6��]�\u0000�rI�N����\u000f?��g�?;�*�\r8\u0007.��}8�?�!��Ѯ�n�7w�~b���^�\u0006<\f\u0010�\u001e���F�_K���zu�n��F�\u0000�����\u001f��\u0005|A$\u0000\u000f\u0011�>��f%���\u000b�f=m\fg�C�ִCY�����7�澭}_�x&���\b\u000fs\u001e�l�߸�I�E߿o��U����ѯ�;9�t��g�s*\u000f5��\u00005^E��gw�o��K���E\u0011�w\u0005a��v�Љ\nju��4]fgLg�M�}�m��q�Vc~�]��c}�\u001eK^�M�X\u000b\\>-]��\u0000�\u001b�Lq?�P��^�\u001e��x\u001e�U��\u001f͟�QJ1��^�\u00175�\u0018�%\u001f�<\u001b�q\u0000�t\u001f\u00005*�\u0017I��H�J�bc;���:?��n�\u0000��\u0000�[x\u0018�W)��k0p��i��ӌ^�9���1϶�mo{����X�n��:�zS:���.mV�[]~���[*�k\u001b��;�ާ��\u0000�'�\u0011\u001a��\u0000{�2\u001ek.K�j4\f�]#\u0017u�\u001d\u0007��?�}v��\\�ϩs����c�[c\u0016'R��k�������C���{���\u0000\u0007X}S�u>���ʈd�mn��?q���~��\n��@nuj\u0013��gu�_c����2�8�I�s���\u0006�\u000f\u001d>���-�ɯ\u001e����1���\u0000�\u001b�G�쁩F\u0018\u001bk[t���{�`9w�3��K�Ŷ��i�\u0010��l\u0018��UX�7��KТXK\u0018�T\u0003Yc���h���wvSL&�}��$�)����S���T�jh~���+=�\u001b�\u0000\u0007g���\u0007����\u0003\u0005M\u001b��^ͣ��k�\u0000﫻I�\u000ek�xp-0`�\u0010u\n;,��[�\u0007\u001e�2�\u00144��;c\u0003\u0001;��\u001f�nB{\u001cǖ8C�`����>���Da㲒D\u0017�_\u001f��u���u_��#-�gd����d=�m!�s�-x;_����\u0012M\u0017��t�ْϷ\u00173\u0010�m�0Ih!���Ko��\u0000ѮߣuL>���'��XY��-�O�����Y�7c�����YO�\u0016_�v��F��e�X���:��\u000e��;s\u0015����Qe`_Ӫu��\u0018�Ȧ�\u0000����T��e�j�z��~�w�W���8�g�/�ᜣr�2=1\u001d\u000f�E�����Ռ���<���VK����\u0000isZݿ���r�N����='��p�ڮ��,ž\u000b_<��;�s����\u001a���Y�\u000e5�uJ\u001f��X\f�)��\u000b\u001a�����Vl�W���\"��_�uZ�wF�ed�ka\u0016ծ�]N�R���\u001e\u001fbܒ\u0012��\u0000�$=>�G�N�c�M�a�.�I�k��J\u0007�,�Ƞ�W;�M\r�\u0000Ag�?q\u0012οӿfdu\fk�o��.���?�����\u0000�3u�k~���߭\u001fWK\u0005�\u0001���k\u000fx���;Z۶�Vݭ��Ѭg�u�_m��̃`���\u0019p;�o����m6B7{'\u001f-<�)\u0019?�\u000fү���z���s��`�o��\\A�\u0011e�ٓ�o�\u001bs߳�-���S�I%��Yf*`w��a���\u001e�m��u���^\t��]B쮹����Z�\u0017^gkq�����kY�W�n��\u0000\u001c�u���s��>����X��SF�.�h_}����U\u001f�w�\u0000\"��w�x��D\u0011\u001ff\u0000�壖U���\u001cx���z�\\���\u0017YI�\u0006��n\u0005N�˭w蝙p�u���}����\u0000��s\u0017�[[+�0�v�\fthK\u000e�?�w�Z\u0019�ё�u�R�jlw��`\u0000\u0006�kw5����O��]\u000fD��u\u001f�'\u0019�c�{_M�\t�֟�[��6�}i�z�f�,\u0018�+\u0012��'�\u001c.��_+�T2\u001e�M\u0004��<\u0013�w4�ݾ���{�Z�:_E��m&�l��k�|n��c[쪿��\u0000m\u0013��?3\u001bu�\u0015eP�FUC�mg����o�i�\u0000�V�%�OM��t�!I$�\n��\u0000XMP \u0010\u000f\u0000\u0000<?xpacket begin=\"﻿\" id=\"W5M0MpCehiHzreSzNTczkc9d\"?> <x:xmpmeta xmlns:x=\"adobe:ns:meta/\" x:xmptk=\"Adobe XMP Core 5.3-c011 66.145661, 2012/02/06-14:56:27        \"> <rdf:RDF xmlns:rdf=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\"> <rdf:Description rdf:about=\"\" xmlns:xmp=\"http://ns.adobe.com/xap/1.0/\" xmlns:dc=\"http://purl.org/dc/elements/1.1/\" xmlns:photoshop=\"http://ns.adobe.com/photoshop/1.0/\" xmlns:xmpMM=\"http://ns.adobe.com/xap/1.0/mm/\" xmlns:stEvt=\"http://ns.adobe.com/xap/1.0/sType/ResourceEvent#\" xmp:CreatorTool=\"Adobe Photoshop CS6 (Windows)\" xmp:CreateDate=\"2020-04-06T11:53:06+08:00\" xmp:ModifyDate=\"2020-04-06T12:00:18+08:00\" xmp:MetadataDate=\"2020-04-06T12:00:18+08:00\" dc:format=\"image/jpeg\" photoshop:LegacyIPTCDigest=\"00000000000000000000000000000001\" photoshop:ColorMode=\"3\" photoshop:ICCProfile=\"sRGB IEC61966-2.1\" xmpMM:InstanceID=\"xmp.iid:5283F520BB77EA11BF41ABA6057D8756\" xmpMM:DocumentID=\"xmp.did:A911914CBA77EA1183B2BFB6EE77FE80\" xmpMM:OriginalDocumentID=\"xmp.did:A911914CBA77EA1183B2BFB6EE77FE80\"> <xmpMM:History> <rdf:Seq> <rdf:li stEvt:action=\"created\" stEvt:instanceID=\"xmp.iid:A911914CBA77EA1183B2BFB6EE77FE80\" stEvt:when=\"2020-04-06T11:53:06+08:00\" stEvt:softwareAgent=\"Adobe Photoshop CS6 (Windows)\"/> <rdf:li stEvt:action=\"converted\" stEvt:parameters=\"from image/gif to image/jpeg\"/> <rdf:li stEvt:action=\"saved\" stEvt:instanceID=\"xmp.iid:AA11914CBA77EA1183B2BFB6EE77FE80\" stEvt:when=\"2020-04-06T11:54:22+08:00\" stEvt:softwareAgent=\"Adobe Photoshop CS6 (Windows)\" stEvt:changed=\"/\"/> <rdf:li stEvt:action=\"saved\" stEvt:instanceID=\"xmp.iid:5283F520BB77EA11BF41ABA6057D8756\" stEvt:when=\"2020-04-06T12:00:18+08:00\" stEvt:softwareAgent=\"Adobe Photoshop CS6 (Windows)\" stEvt:changed=\"/\"/> </rdf:Seq> </xmpMM:History> </rdf:Description> </rdf:RDF> </x:xmpmeta>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 <?xpacket end=\"w\"?>"},{"_id":"avatar/writer","data":"����\u0000\u0010JFIF\u0000\u0001\u0001\u0000\u0000\u0001\u0000\u0001\u0000\u0000��\u0001�ICC_PROFILE\u0000\u0001\u0001\u0000\u0000\u0001�\u0000\u0000\u0000\u0000\u00040\u0000\u0000mntrRGB XYZ \u0007�\u0000\u0001\u0000\u0001\u0000\u0000\u0000\u0000\u0000\u0000acsp\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0001\u0000\u0000��\u0000\u0001\u0000\u0000\u0000\u0000�-\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\tdesc\u0000\u0000\u0000�\u0000\u0000\u0000$rXYZ\u0000\u0000\u0001\u0014\u0000\u0000\u0000\u0014gXYZ\u0000\u0000\u0001(\u0000\u0000\u0000\u0014bXYZ\u0000\u0000\u0001<\u0000\u0000\u0000\u0014wtpt\u0000\u0000\u0001P\u0000\u0000\u0000\u0014rTRC\u0000\u0000\u0001d\u0000\u0000\u0000(gTRC\u0000\u0000\u0001d\u0000\u0000\u0000(bTRC\u0000\u0000\u0001d\u0000\u0000\u0000(cprt\u0000\u0000\u0001�\u0000\u0000\u0000<mluc\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0001\u0000\u0000\u0000\fenUS\u0000\u0000\u0000\b\u0000\u0000\u0000\u001c\u0000s\u0000R\u0000G\u0000BXYZ \u0000\u0000\u0000\u0000\u0000\u0000o�\u0000\u00008�\u0000\u0000\u0003�XYZ \u0000\u0000\u0000\u0000\u0000\u0000b�\u0000\u0000��\u0000\u0000\u0018�XYZ \u0000\u0000\u0000\u0000\u0000\u0000$�\u0000\u0000\u000f�\u0000\u0000��XYZ \u0000\u0000\u0000\u0000\u0000\u0000��\u0000\u0001\u0000\u0000\u0000\u0000�-para\u0000\u0000\u0000\u0000\u0000\u0004\u0000\u0000\u0000\u0002ff\u0000\u0000�\u0000\u0000\rY\u0000\u0000\u0013�\u0000\u0000\n[\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000mluc\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0001\u0000\u0000\u0000\fenUS\u0000\u0000\u0000 \u0000\u0000\u0000\u001c\u0000G\u0000o\u0000o\u0000g\u0000l\u0000e\u0000 \u0000I\u0000n\u0000c\u0000.\u0000 \u00002\u00000\u00001\u00006��\u0000C\u0000\u0003\u0002\u0002\u0003\u0002\u0002\u0003\u0003\u0003\u0003\u0004\u0003\u0003\u0004\u0005\b\u0005\u0005\u0004\u0004\u0005\n\u0007\u0007\u0006\b\f\n\f\f\u000b\n\u000b\u000b\r\u000e\u0012\u0010\r\u000e\u0011\u000e\u000b\u000b\u0010\u0016\u0010\u0011\u0013\u0014\u0015\u0015\u0015\f\u000f\u0017\u0018\u0016\u0014\u0018\u0012\u0014\u0015\u0014��\u0000C\u0001\u0003\u0004\u0004\u0005\u0004\u0005\t\u0005\u0005\t\u0014\r\u000b\r\u0014\u0014\u0014\u0014\u0014\u0014\u0014\u0014\u0014\u0014\u0014\u0014\u0014\u0014\u0014\u0014\u0014\u0014\u0014\u0014\u0014\u0014\u0014\u0014\u0014\u0014\u0014\u0014\u0014\u0014\u0014\u0014\u0014\u0014\u0014\u0014\u0014\u0014\u0014\u0014\u0014\u0014\u0014\u0014\u0014\u0014\u0014\u0014\u0014\u0014��\u0000\u0011\b\u0001�\u0001�\u0003\u0001\"\u0000\u0002\u0011\u0001\u0003\u0011\u0001��\u0000\u001e\u0000\u0000\u0001\u0004\u0003\u0001\u0001\u0001\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0005\u0003\u0004\u0006\u0007\u0000\u0002\b\u0001\t\n��\u0000M\u0010\u0000\u0001\u0003\u0003\u0002\u0003\u0004\u0006\b\u0003\u0007\u0003\u0002\u0004\u0006\u0003\u0002\u0001\u0003\u0004\u0000\u0005\u0011\u0006\u0012\u0013!1\u0007\"AQ\u00142Baq�\b\u0015#R����b��\u0016$3r���\tC�\u0017%4DS�\u00185Ts�����\u0000\u001b\u0001\u0000\u0002\u0003\u0001\u0001\u0001\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0002\u0003\u0000\u0001\u0004\u0005\u0006\u0007��\u0000(\u0011\u0000\u0002\u0002\u0003\u0000\u0002\u0002\u0002\u0002\u0002\u0003\u0001\u0000\u0000\u0000\u0000\u0000\u0001\u0002\u0011\u0003\u0012!\u00041\u0013A\"Q\u00052\u0014a3Bq#��\u0000\f\u0003\u0001\u0000\u0002\u0011\u0003\u0011\u0000?\u0000��:�\u0005�\u000b���ѧ:�{����j�\"/\u0016T\u0005U*q\n\u001c`\r�dc�\\c�=�<�+j\\��m�^�6�Ŝ\r\u0010������\r3jT-Ј�\u0000��rD��\u0018�\b\u0013�V��`���N����Rދ�\r��~�T��ds�9��W�\u00109�Ay�\u0014��*��o�K4E�q\u0019\u001d�\u0005���,��\u0007;#�\u0019��Sb�+0\u00152����[�1��\b��isu<\u0003�\u0000\u001a���\u0011D�Iz&�\u001b�\n*���N{\u0018t��[����}�Kdg�\u001dp\u0014[�i�QI����S\tڊp��d�.��/��7\u0002a�����i�$���\u0000��\\{��W�����EO�\\�u�Cqj\u0010Q\u001d��\u0000�W𤙅9��-\u0002��-)�d�Upʔ���3Lc��ƪ�h���q�ƛHӲd8�n4\u0019�X�\u0012G?\n\u0015rvF�AUOzU�K�*�u��R�cv0\n,�Q�QN��8��i��2���W�VC�����I��=��X�\u001a_mf=�d�\u0012n��g/8_\u0015D�\\�Bm�579�n�H\u0015=�\u0000*з���֡\r�\u000e\u0007\u0015O%��y�0<ʵD�T�GP��\n\bn��/*i*Lh�����K\t\u001a'�4q�u��ή*�`]Y\u001c�!��B$���M��\u0013\u0014�!�%:�е\u001bq����\u0007$�q�E?ZJ�(ǉ�D�H*�+\u0019P]��\u0000ʇR\u0005\u0006y���\f���!w�u$^��U�UR\\�Q$C_��\u001c��:)��/<S#V\u0007�渤VC|\"�&(�%�C�\\\u001c�<RD�.���0\u0011\u0017�~5㓛ة���Ԟ� ���\u0015Q\u0016�����CF{I�u��\u0014\\�_ƕD\t\t��Z�} 3���S\u001e��c��c\t�ը�\u0007RILv��R@�r��I\r�(�G�=<�~4�\u001e\u0014�?�;Z�\nhDJ���S\u0016\u001eS\u0015\\sO}&�\u000f}\u000bE�\tDqK���1[�ƾ��\b��Z3E�NT�\b�2�K(E�A�ʮi/F\u000f*g)�\u0003%�i\u0002t�9�>+��\u0005�q�I��\u0017�\u0004)F�*\"��M\u001f�\u001fw$��ίR\u0007\u001eu\u00012���\u0015AT�S\u0014\rٮ���T��\u000fJp�\n��\u0003�.뀹�S\u0007�\u0001:\u001c㤞4�A�6��T!$�r�\u001b�g3��cj�Z�8�/\u0006�\\��Z�\r%<cj[c�'td\u000e:��M\u0011\u0011\u0004Q\u0013ʗ5���i���3ϫ��QKk�&B��6�s\u001a�X�r>��\u0011�ڄ�F�����-\u0012�߄�M��Ɲ�\u0003�&�耢�Tk^Șݠ^�D\u000e��Y\u0015�VOa&\u0018�n�nϺ���2�q��!�R2D�V���G.&��E�\u001d��\u0012���S����xb�_�[u>�\u000b�6I&FUG�GZ����\u0019qQW��b��[\u000fωC�,n!0hD�*|��>\u0014\u0002\u001d�\u001f5\u0010pIG�L���5K;\\��S\f�2��:Ҡ��K9Ͻ�W�sq\u0011z�5\u000b�\u000f\u0018�m\u0015\u0012�_Y���Ot|W�!%\u0011�ΰ�>ꌕ��\u001c).+\u0012cŜ��U��$�;|+Cm�!nTU�s��L{�}i�N�e7Pj@�J�\u0006ݙ�敍�\u0006�\u0014z~u\u001bU\\�r��4�v3��\u000b��T�zn�7�w�\u0014��������O��3ϭ:�\u001e\\w���(8N����i���\\]蘭�\u0012#�Ln�l�\u000bL���9[�{�W\t�u$�\u0001\u001f\fТ>I^8��8�\u0016�\u001b/�\u000bس:�D3z�Ӌ!��\n\bC��j���\u001d�L�d.L�oC��U�\u0000M^=�[�\u0003�+:�<6���*�ٜfj�\u001e\u0003��\u001euC\u0012��.NO��,���W3�ⶢ��\u001a\u001c��\u0014W�t�o����Y#�'\u0019�H�)��Tv~\u0015*ҝ���\u0000�8�D�i�$Š\"u��x�^\u0014��<[ÙZ�.#eG�Kd�Ҏ�hE\u000bIM�\nnSA^'{\t�T�\u0000�_�\r�J�B�l���U\r���@�=�\n)��>|��[+�םx���G�\u0012��!!��\u0019\u001b;��Q1G\u0006\b�\\^Oih�@�\f�8ʥG֎�xF\nsZ6@q�q\u000b\u0002T�n*���%7n9c\n��`>\u0011��k�j*���0�sdY�Af�$�\"���[ႦsL$�.8�\u00159VA�\"�$�*\"�i�q\u0013\u001cAJ�!�U��C�\u0006�9E��q����x�=\u0000�7 �\u001e��W�^�N��t��,���f��\f�жA��J�U�I\u000fZ*v�\u0001UR$��\"�K��A�\u0006�t�P�)GCh�:Sq<f�\u0000Z\u0003��U���^\u0018f��\u000b�ZYS�K�J�Bp�lW=�NZuPQ);xng?Ś\\�\b�//֭ n�\u0012y���ʚ���Bc�\u000f�����{�L!��\u0011���$�C�\u001dA�i'\u001b\r��z��!\u001c�\u0013TU�)2�kR\u0005\u0004D�Su^�\b\u0003;y/���򢘷��m��=�>qe6�u\u0001#2��U\u000e{rY�+��,Ռ�4\u001b^C�\b\u0005�s����5D�e����C�\u001fh�te降8�<��T�\u0018�5j�w*\u000f$��j`\u001fG�0�&7TsBv�eֱG�$\u0019���r�K�T�J�\u0003\u001b��k,�\fHm�i\u0017 ���\r\u0013n1҉�\u001b)H�nQl���1�i��*D�\u0014X�\u0011�3B�b�\"�DD��\u0007]}'�\u0015���\u0014�\u001c3����|�(�%��ƕi'&[d�\u0002mw�\u00078�꼹[��|~\"@u������j��*��\u0015�\u0019f3^�.Ř���x���C�K�\u0012\\�$�3��EAB>�y���VlYjI\u001e���\u00078\u0014���\u0011\u0019\u0015A\u001e/�D�\u0001\u001c�)\u0016\r0T\\#�\".1��(���QR��\u001c0��Y�r��ݏ5�@B6���\rI9'Z21Г\u001b\u0003�U�P�s\nB��\u0005�\u0014�D%�ҥ\u000fp`>ta�M&{�갍r\u001a�����g���\"�s�E\u0003je\u0015qLZ�\u0012\u001d�]�\u0000*/i1f9 �\\x�Y���5%�\u0016cu򠗢\u001e=\u000b��\u0017��ʔ�\u0019\u0000�\u0007�\u0019���,nx�\u000bj/��Q\r�\u0002l�����TUK�\u0005�\u0011D�{���\u0004Uڵ\u0011*���f�Fd\u001fl\u0015S�\fO�Sn���\u0000_�x\u0016�,\u0003��1��)\u0014�\u001d=��b�[m\u0002%G�\u0004\u0011\u0007���3�dnG[Ǭ��iݢ�.蔀ȉp%d7\u000e{�����|\u0016G�w\n�x�R\r2��v�\u001a��[m��\u001b�ȋ�r����=sV�\u0016mg\u000f\u001bYT�\u001f]�*(�\tc\u0007��p8H�k�s�\t�����i.��a?�\u000e\u0012�y:s�\t�}��\\���\t�I\u0014�[\u001e7\t��\u0000�[�A\f�5}��\u0011�Za�x���3�׼E��'����C'gZy֞%G�<���?��#��w���/�ڋ���j��\u0011\u000b.�kN�:͚K\"����!p}_���K�~��$��/\u0016�H�h�n��\u000e�\u0004�t?ں>�5'��L�\tWr�\u0018�.\\\u0006��4\u0005�`�3Q2\u001f7�[����.q\u001d�!\u0011\u0015A�/�\u0010��p�9/»w�NǴ�iW\u0007$\\ �Km��\u0013N�m�V1~�\u000f��{�~Pq���&�C�֞�\u000ets\b�ʒ��\u0011����:���\u0019ul�\u0001?��F�T'}_��\u0017~õ6��\u0015�b-�T8�\"*d\b\u0017Ɔ�B\u0014i�*9p,�I�\u0012���1խ�==�\f��k�4�T'�\u0017���[u�l�F�\u0000\u0015\u0018d�S��$\b\"\u0019��\u0011tU�\u001a((&��\u0003�`�<��\u0016ل�E��\u0016\u0015v�ݩ<�-x��Y\u0012-SZ���+�\u0018%\u0007�C\u0002J�K\u0014�^��[��>M�K0�?�0�V�K-�QM�[|7$��\u00049�TU�\f�H�sʕWw'�#>\u0014�|�b�d�y�J%�E���E�-Cq�\u001d��^ے6\u001aS\u001a�\u0011I/�\u0014Qr�H6�\u0012��w�}A����\n�b9�u�0\u0001\u001e��J\u0016ޛ�ʺ9mf\u001b�&�D��\u001d��:\u0014@<�va)�<��TB�h�\u001d�a�R\u0001���p�\u0000*�ˢ5\u0015����$�xU\u0012��E�\u0000:�yk�*ꠊ�ZV�nz]Yf�\u0010���o\u0011/\u0014����\u0011\\f��\u0016��U[a2�y��Xl�d#$�\nK�\t[���5\u0005Z����\u0004���%�\u0016�˔��ˋO \u000f���\u0001\n/,R\u000f\u0017Q��Ϧ)�\u0006|(V�\u001a����.\u0012�s�L�^td\u00122�\u000e�����\r\u0004UW)r�\b\u0012V��j�� 1�@,g4���`��}\u001d�-���pwի�.�SFh�\u0014�2]ȋV�7ۜ�:�!\n�B'EY��a�4D��<��\u001c\"\u0016\u0007?\fU�Z�\u0005�\u0004%;�5�ʃ�\u0012fIn\u001cg�9�kj�#�\r\u000b���)Y�X�v����\u001fL^^;N��+��\u0003ќ4r#˴�\u001e�T�>���b+\u0015��h�X�*s`?\n\u0006�����}���Y\u0011\u0019N\u001a�VU��f���`���ʲ�v�x�oy�K�hܖBTg\u00194EC\r����2�-b����U��.QV��>������me��M��`\u0007ke��Z�7y?J��U��q�$�O�o���Y\f�Es��k��{@�盃��ŚL��N@\u0010QqH,�\u001a�d�֭7g4\\|kd\u001eiI��δYB�\b?D�V�\u001a&2�ى���\u001aI� ������w�U)���\\��oIA�L�\u000e�5�>=*Xcb-�{O��&8�Qa{jt��9[A��~uMY\t\u0007\u0018<�V�ǅ\nl�H���s\u0005�t�2\u0004��\u0014Lx��ӛ�\u000f�*n�s�0�I\u0002a\u0013+�j� ?�W\u001fѴ�6�zb��a�\ty\u001f>UK�f��蛧ڝ�5\f�\r�wSϭ\\�\u000boO\\���2iy���\u0013��ߝ{�3\"�>�Ʀ:\u0016�\u001c�]��\u000e<���Գ@�Z�Ѩc�L�)+���&�N�HMm\"ͥ�V�x�U\"w�>��JW�\u0018�[4����\t�R\u0014ϫ�Z9��?gZYm,�bmF�\u0012\\\u0012\\n��Jݯqm�[=�\u0004am�\u0017a 'q�/ߺ��\u0006v���r{F\r2ڢ���p�\u0016ru.�A{M�����\u00186�\u000f�^�\u0017����o�1�\t\u0013i�Q��v��\\�#w��\u001e3�g\u000f\u0002~�\u0000�R�\u0004i[\u000b�ƒs�$��8R\u001bq9�){\u0019�.�OlW��Ox�\t�m�d��8��Z{��\u0016!G&�\u0001�\u001d���\u0005�ƒ�ZCN[�u�\u0003I �!'�<�A%a�SE��S��\u0011��o+�;��*%�%��\u0019~�Y���}�G4m�eZ���!p�R�_}\u0016ŎgG7%4C�&�cȹW�68͡�}�y濿u+h��N�*B�Í�K���+.�i-��\u0013\u000e\u000e�t)�\u0003�\fH�\u001b\u0000�,1�\u000b�t6�k\u001bT���6��\u001f\r}n���:�0d\u0012�6�.yxV��������\u0011*�\t+\u0004;Q���j�\u0017\u0015\b���S\u001b噫���e\u001f�%0�/��E�_H�M�\u0017-)w1��kƤq�+[q�\u001c�\u0000�D���\u0014�B�Q���\u0013j\u0002�ڵ\u0016��l�5\u001c�`��\u0000�M�\u000bI����V|Qs,�3���9��ǌҦ\bW�j�\u0010���])�-�'ʄ��\t'��<R݅�*w��q z=���aPvcʧzz�Z~�ګB�Nw@��h*i�{X\u0014��Ⱥ��/q\u0013\u0019O�\u000e�\u0000�\u0003����m�[c#\u00123�G�|\u0017��^�\u0005eD;��\u0003!q\"U'DSr�MJKz�4²)�-ۃ�_rV�]��\u0003z\t*\t�.��j�\be\u001e�\u0005g�G����.��\u001e�Z>طm�!�\u001b\u0010p\u0017\bH�i���\u001b�%��G�ޞ\u0014�.\f�s�c��D�~57\u0007S�;p�&�{m\"�� �J���\u0000���H]\fUx\u0002*���5{k��Z�\u000b��\\�'\u0017���K��>\u0002��U���J\\[\u001c#b���t��\u0019.�)-\u0003�� T�8�\f �sLۼ��\u0013�\tO�e\u001a\\+�\u001c{9�y����?֙�ӯX�k�hbiȅ:-Y���\"t/�*�k��s\\e��*\u0004���6E�qMU|�\u0012qk\u001c-�KL�h�B��'UZM����z�fx�V�/��\u0013ʼa���!\u0016>U���S���[;�\u0014�6�\u00006�\u0019`Z\u0014��c\u0015'�ډ�k�\f�ZU���9ҭ��u\b]�X�y�/�|���\u0000*%\u001a(�\u0014�U6��\u000eZd\"nUiz�Բ\u0016��u'[��\u0010�D�\"xRڱ��\\�f)+h�Of�B�KT��1�A\u000e���6\u0006@l\u0007<��(#���cPy�B�ܫY�VN���-�\u0003�ެ���r��ȫ(l�E|\\\u00140Z����TE�\u0012&3�P(K�\u0014\u001e�^�0��\n�s�O�D�^\u0014&�d�b�*5F\b��x:�\\gέ�\b=c�\u0010�\u0016\u0017oӉ\\n�\u001e&�̗�\u001d��8-\u001eg�l\\ؤM\f�6ٙ�&(�;4�*�\u0010�/�+�\u0018Ж�U]z�kh\u0003�ƣg��0/^���]�ќ\u0016��[�#ǔ��k��\b��|xt�h��Su���\u00002U�梶'�;��Ji\"�\u0000o�}�*Q���GD^��i�L�gz���\u001bg\u0018���Z�\\Ԗ�S�g>K֗�j�\fc2�\u000f\u001bX�t���*7D*&{#����y�ϊ�;��e�k[>��߿b-Z��A�5$�\u001e\u001b�/\r�I\u001fiV���q\u001f����P�e�]�\u001f���PHVV��S���\u0006�ǝI�_Fo��1/P�$�\u0011s\u001b�h�v�\u0016\u001b�l��\u0001P����yt���LvA�P\u0001�\nQ v�k}�Covg8�~���X��\u0000\u001e�\t��D�j�u~��M�\\��u>U($�e���W�*�\u0012�S��A��2\u001f��Pg5���\bS?�MOVHs���\u0004��*�B�{(��\u0000oc�\u0000\n��.�݃O��A\u0016�Vw�\u0004��|�\n��\u0017*N�԰-��<�\t&+�,�\u0001r%�\u0013=�\u0007\u0000��\"\u00142\u0019\u0016\u0003ѷ\u0000[�)�O\u001e�4^cQ�Ѥ��SJ������(+�;e��\u000b�X�и���9{�L7�%�\u001fˬ��\u0011.���1Dyh���r�\t\u0001�\u001bS@븱U��\u0017u5��/*����⃷��\u0003F�f�\n�؉+H�\r �\f��i;\u0000h-1&D�\u0006�\u0007�T�J|}\u0010w��\u001a�4�\u001f����_%��\u0006Ж�6�N��1!9�E�S�ElwW�v�[\u001a��E\u0013�D���u!��V�?n�\"�: ��������\bd�N�mbV�\u0012\u0006�a\f��|���s,�\u0006?\u001fc�\u000e͸�,\r H��bs\b����\u0007�j\u0017x�p��j��$h��uS�t�:\u000b�\u0016�x�ǅ\u001d̈�L`G֧��\b\u0003g!�m\u001c�Us�5\u001d��EF\"#*�)�HX��Ƀ\"ռ\u0013$^�j&\u0012C���T�6��\u0014p��M/�f�p�i��\u0017�k�/{\u001b�\u001d\u0011rI�!U�\u0007ϝ7�)��\u000e�x�\u0015\u0007 ���&�?�7m����\u0007\u0013(�\"*V�]_���\u0012\u0007$��\\�\u0001��t�QK����' ⠪����a�7cq[D5D犄\u0010(>�9�-z�����h�E�����\u0006�=�~��WQ�Cu��{�6��\u0012�,�?Lq�B�\f����\u0011!iBIrjF�E\\�\n\u0003�\u001f83�>骲�\\5�%�~��y$}cq6\u001b\u0017\u0013b�H֛\\\u001a\t/�Ѧ\b\u0017\n�M�G��P4벢���j$�K��֟��Ǝ2Y�\u0006�J���y��!#�m.��>\u001c����Vkdf����v��W��k��\u0017����&��K���\n/�ܱ�Z\u0016\\�Ȑ\u0003\b�\b�[֘��nZu�����\nN��*'B�7��5�4�ڝ\rʋ�E_d��P\u000fa-%}j��ڑ\u001d���u4\\tU\u0015�����xoA��\u001f\u001d�E�o���E�\u001b(�m\u0000D\u0015?Ҏ\u0015��\u001ci\u001b�0;����&P���v腔�B��zg\u0019���oav2��^���J^�bJ\u000e�\u0007pI�A|?*�\t�S \u0003�\u0019�r���|Ҕ�.Q\u001f|S\u001e�TQ���u�F\u000f*��X�\u001b��(�\u001a����}�,^B�5\f�$�X�t�u�L\u0011�\u000eS\u0019���I�K��/�&e�Uq�\"���Γt6�76�SW\\��\u0012«��D�\u001d�R�ʅ��{��7\u0001��\u0018��\u0007F�\u000fU�[uUW�1Iu�\u0002\u0018O:�K\u001d��{�����\u0015��ژZ1���j���$'����\u001a�j������\u001d\u0017�{?٢�TP��\n��M�\\�y��|�ٷ>\u0015�\u001a�S��:�b��Ѵ0���\\��\"�S�<�\u0000޳�\u0017\u0017�W�\u0003�\u0017Ʋ���\u0018��\u0012�vk)\u0016\u0019\u0017aw\n\u0016q��%�#�U�\f�հ�%�\u001e\u0019��.`�\u0012�|�*>��*[��|D�4���$�\u0007vn>��ۗEHJc��y���C��O\u0004��\\�����<���\f��q�?����0�x\u0016�\u0011<�@�Aޝ\u0018�NH��zY�\u0000�S�D󮆴x�e�q˩f���c��C���9��@i�T�sN�3_p?��\u00019�н�K�4�^�_V+�G]m�\\p�~T�wʄ�1��xBv�)7\u0003\u0015D�?\u001c�\\��J�\"\u0001_r��sOEmK�|��V��7�Q��u�\t\u0016)�w1�1���Y\u0000�\u0002�]_���'�\u0014�O�\u0019C�-j'֬���:)ޘ�|�O�Qs��ŢJ��孛�-\u0013n�4�\u001f��\u0005�2#Q,)s�%��ђ�����χJ�>�6ƥ^f�!�Ͷ�\u0000�}��t\u0004aMt���z\u0010�Vy\u001ab�×\u0007�j�ɜ�Yov��d�,\u0010�ʣ�\u0005\u0011���H_l-i��\u0007P�N�\"\u0015�9nZ�j�\u001aު��\\yG����\u001e�\u0010��e\rJ��#��k(��+����}�ܮwٮ�`�2␊�u�%\u0017]J\t���\u0019\u001e��q��g��d}+\u0006\u001e��z����\u0010؄X!>|�V�\b;NG-7��C7P͖�T�̪�����{C�\u000e 8��}�.�S��C�r�\u001e;(�a�CE��]���bD��z(���c�.}�s�n�1�N(��d=s.T�L��\t�_L\t\u0007T�78�cȪA\u000e�Y�y`�D\u0001J\u001faE�g�2�a'4NTv�\u0013�M6�\n\u0017/\n\r�%�v�\u0013��\u0011w\u001a��\u0014�g\u0001�1\u00024�a�!$Q��BHe�-�=A1�̮(���IiY�\u0018\u0016wyViy-N�ܖ�q+y/Ҙ�\u001b���w\bw\u0007r�>\\%ǳF\bV�\u0018�\u0011\u001d��q�S\"�9��m\u001d��ǒ���5%�P���Kf���\u0010-��i'B\u0007~�\u0014��-�=6\\2U��D ρy�ti�\rm�\u0012-�\\���1/\u0010�W��V���-�ɭ�\"۞��c+�^h��:��\u0011�$nY�|Q:\u001f��Rև�\u0003�\u0019�\\�<zQ��_6��v�G��`j`��FӨ�`}7T��\u0004.�F5ۅ��n�\n˯O �\u0012�݄���N����е\f\u0019��Nۉ\b^\u0000OS����4�&���\u0004k�q\"��\u0012-��\"pFd�h�U�\\c=i��\u0000t\u001f��d\u001d\u001d�\u0016yb��#-s\u0006�knS<�����P>Ϯ�a���e��q�&\u0005z���LB8i�1[GUI�D��\u001f��)�\f����\u0014?��\nh��ϝ\b\u0001��.gjґ^\u0010\u0012h\u001e\u000eE����N캉���\u001b^E�\u0002��\u0013}�֫�L��\t\u0013\n��\u000f�%\n!�3\u001f�y:.l2N��@6������q7)\n�<��ϯ��qG9Ǎtί��v�#����9^�{��i�\"ݏr�D\t�\u001bNiK�4�\u0010y'�[\u001c�33�jCU����{wb�C\t�Ƭ\u0017ˆ+�����c�>�n>kMDC���\"k�5��\u0003�I:�\u00161�\u0015k��4q��>tԜT���^j��E膍�\u0014�R&���g�J\u0005o\u00029A��*AV\u0005��*p��E\u00134��g�1P��h!�\u0002�񫻱��\u000fU�ڙ��\u0016�h����Y�\u0006��\u0017�\u000e'�9y�\u000f�;��cz�em\u001dTG�XTT�s�j�X���\u001b7\u0015�q�$%�?O��Ի*4�\u0012JF�ig9J�u�K��8FH�����1*��qW�)�VR�\u001cEyqYH��9�}/i\u0011>u�ӕ�\u001f_*�k��$�^z| Y\u0010�w�����AE�ؤFI�MȜU��b�%�D�.�\u0007e���]�]k]Rƙ�8�Q܊)�R\u000f������ɣ�:�\\T��ʷ�6<�9�N(�\u001a\u001e�Vl伫VI6*yV�O�y� =���\u001c�[4�EO*�=s��%iE\u0013�\u0017Z�5p\u0014�V�F�x�\u0015��Z�h\u000b0\u00079�\u00111��\u001c�yV�D0P��\u0000\u001dĽ\u0012�;�2�\u0005N�\u000f4�I�bN\u0017]^#\u001f�i���j�]\u000el\b��*��\u001f�9~5d\"ȘJ�\u0013\u0019�w\u0018q�D&\b���\u0019�*\u0018�P���Z�L/Z^\u000b\u001e�5�\u0000x�EӥS�\u001cN��F�Ւ���\u0011zD�\u0016An��*+b���1�mq�ܩ�\u0018\u0003\n�\u00020���(�i�\u001d��@��\n�}i�,�n�<c<�$ٲ\bk�#ϿjS\u001d�\n�w}��\r���\u0016P �\u001c\u0007b\u0019�Tk�Qi\u0006ne,\u001c!eS��,��\u0000�-�\"*�oO\u0005�h,*DSFX\u0010�Kpu\u0015�ES�Q{��?\u001a��لͱE�0��U�sU�?\u001cc\u0012�\"\u0017$�y(%ݣ�!\u000b���B\\U�\u001cx\f��f�j�Ƈ$�!�jf\u001a���\u001a�z�R�\u000bc\u0016�:�\u0000\u0018��O��/�֠ĠӪ\b+��\u000e��H,6��S\u001ap�M���U:�\u001b�\u000bu�t�p�˝@й\t�yTz�wK;�aN���\u001d)�\u001b��uY-\u0012��Y%�Z$�n�\u000f�M!蒥��8&��^s���uՔ�6�\u001d&��\u0011�!��\\�&��<K\u001b\u001a�N�Jvk��\u0003���.ІD\t\u001f�.v�?u]��f��\u0000�\u0010�R��`�{^4�-,�݉�I�Wh�j�,ڴ��K1z2J��,�\u001e?:�v/�e_\t�r�ތ\u0000*�\\D]���*\u0000ݖ,�b�\u0015��\b@I����̢[a6\u000e\u0016U\u0015\u0012��[\u0004�w�\u001a�\u0014�\u0016�\u0013e���\u0017�\u0000ڤ�a7���ӆ@%�\u0017\u00016�\u0017�%\u0012`\u0002��V�?\"K\n�ۮe\u0007\u001c�{�\u001aY��t��\u001fE�q�ju�l\n�`�+�6���\u000fQ��^�*è_p\u001ap���?�f�tM�{-\t�\u0004#��\n'N�ط4bH�$꘢�!�������\u000f\u001afh��8I�~�S\"�C�P\u0006ѭ\u0012lSy��\b�點�y$��[\u001cr�\u001a���\"#�6C��*I-�)��\u0014�\\�M���M\u001f�N\u0019&� �7�\f�k��~�쨫���AS�)֞����\u001eJ�6��7�\u001aqvm��\u0010�Q-�;W�r�74��c�Qpv��IK��_ƃR\u0011+-�<=C&;ǇA�C\u000fu\u001a�\u0000ݝkoыp�\u0015S�$��H�+P;|\u0015%'\u001a-૔%�֖�l]ܑ\u001c�(\u001c����\f��֖��<��\u001e��W�!]䪯\u0011\u001bt�\u0013�J�k��\t�d\u0007�aW5Ik[`¼8`HB�y\u0015\u0013¤\u001f�BY\u0018����7�\u0017w�Y�V�dQ�T�h���as-���\"�T��h�\u0000,w֭\u000b���gI\u0013�\u0003�_����]Ynl�\u0015}��/�LQ�\u000f�K��yW�X����\u000f*�H�4����X�-��\u0000U^�Y$#�M�v�����\u001eE�-##P6M�\u0002.~5(�D�ʨR�\"���G��U\u0017�R�!��~�*H۩��BӢ�m&s���7撚�7\u000fw?:$<��\u0004�1��hX��R�+���$\u0002����\u001b�\u001f\u000e�\u0013��Xp-�u�c\b x_%�\u0013���e��\u0007�8vmʏ���)\u00161�iO�.�1�]��s�{s�VW?v��$M�\u000e3\u001d�F�\n\"'$�ⲗA�>\u001eJ�ϟ�T]�vL6�ݽY\u0005\u0011�Y�Uy���ʭ\b��P��\u0016��\u001c`�-�*$�Ȅ�>��\u000e�g��{zwS�ⴤ� D\u0004\\c5�SO�4��|�\u0019�Pq�N^�֭\u000e�{\u0016���;w��T�>JN\u0000ueګ�\u000b��k\u0010\u00170�|(+���\u0017)���������s�3�\u0018%\u0003@s����\u0013\u0019�6�\u000b:\u0010\u0011\u001e�\u000e�?grr�/}4��Q]�t��Y 뀂(\r��8g�Jpa�\u0012�Bӎ�#�J�y��\u0018'T�\u0006;L�\"\u000eU\u0012(lPZ4¦qZ\u0014\u0011\u001ebJ4���|kq]٪,Ci����k~'�~k�P�0���BZ�C0�^o�����׈\t�:�U�\u001f}yU��Ά�qa��Ȓ\u001eh�L4>\u000e'�Utx�H��L�\u0011�, �\u0019���\u000bzZ�o��*\u0006O��sC��JT>\b0��m�\rDm�Ym\u0015S����I���mUv�:]Xۯ��\u0004��/�����\"K܀�K\u0018��#dl^�,�A���d��m�g�\u0016`�\u001e�Ӹ����J:(��\u001aP8h�4w&6.1@\u0013O؅��d��#��2\u0007\u00103��QH.=e&\u0005��J�_uI�\u0004n*����x���\b�;�\u0001OX�\"y�T'{ҳuc��u\u0005b����/t��i})���}�m+��V���R\u000bs�d[����hW\u0018�\u0000�f�\u001b���\u000f�<n�r�\u0018��Th0�����@\u0000�cx�\u0015�\u0016��\u0001�X�<j`ÄM�����~u\f]q2E�T\u000fw\rQE���}[]6m%,���7�������-P\u000e��\u0016Z���������\u001co���}�6)����\u0015{���\u0011�Ez�z�)\\W\u001ct��:U��\"J�ad�\u001a����h�?\u001d�\u001a�V٬\u0012��su\u0014_\u001e�\u0012`U<�:�L�\b�.\u00056�$\u001e���Q-�\u001a�v�����\u0000�Jl\u0018�1�hQ\u0014=�f�>�l�Xt�\u0000�s��\u0017\u0013���*�\u0007\u001f�8R�f�&����o\u0010\f���Ú55�kSe�5\u001ej��𨔨\u0016�o\u0015���R\u0013ꨈH�Q\u0013\u0015+����\"���\u001c�|h��\u001a2�.5���+I��̤e��j�ϘS\u0016��\u0015�%A{�\u000esq�w~TN�l�M�t�$��9�ƈSC�4�\u0014L\u0005M\u0005=t��(�m�\n\u0018/��NYU�\u0011\u0010�\u000b\t��!\u001d�%2e�\u0014_ai�\bape��q\u0011QE:�j=|�5\"L\u0019�\u001a11�;ܹ\u0018�ڗ�q����=a_\u001f*\u001d>?�p�z��!\u001e��j�,<Ü9Q�B\u0002�~#��Σ��i���I�v�Ho\u000f5��c�����\u0010�l\fH�?yi��\u0006�#\r��\u0013M��Π-�\fЗw��,G���m\u0015�U�{�\u0005����e��y�_Wʍ�\u000b�}\u0005�d͒\\8q��k���\u0000,�4�\u0018�ȹ=���):\u000b�����-�\u0005�\r�\u0011\nq+�ȓª-f{��=T늵l�V�\u0010���\u0000�e3�W�I7�`N'\u0011\u001c^���\u0004��/ő�`��\u001aU\u001a��\u001bU蔨0��Y�ٓ�\r֤14��\u000b�H� �|��^_~�$���+���w+��i�Pt��\u0014�\u001b,�\u0015��V�\u001e!!��ى~=\u0013)\u0003b�HqQ\u001c@U�]h��$�:IA]i\u001b5ّ��F�I�.7.�%�Zt\u0015�z8^��p���N����S�<\u000e�}�_҆F�~�;H��ʋ[_W�\u0014C�*�P�PJVtogR���ؐ�8�x�9Tݬ�u�֙�1,\u0010�\u000fT\u001aDJ�DTF\u0012��9z\u000e[��.Uq�\"��\u0006����\u0012&��k�Hh:\u0012g�A�Q\u0013\u0013�b�2\u0018u9Qp\u001cK�VE�B��U^����\u0014\u0007�\u0019�%�=zV��υ5���|�OX��@1;9���Ȕ��J�n\u0012���R�\u0001ę$\t:\u0017_��Pl�:���w\u001e?|�c�X���B>YD�\u0017\u000bж($���\\n��*c����Cg�o�(L�8T_�q���#L�\u000fEx\u0017\u0011����\u000eyWh54\t��|\u0012�W�/r\u001b>��1�D��y起ǜ���\u001f���q�\u0011;�O��A�\u0011E�,��$�㨗�j]m�3\u001aSح�r6���r<~ޯ�\"4�\u000f6Ȋ�/\fpJ>T*Wl��O�\u000el�k�\u000e n��bx]���Y\u0004�)�JX�U�y*�\u0000n�\u001b��a�u�c\\\u0015w�\n�pl��8�_�\bȋ�E���'ծ\u001b��5N���\u0016�_��s5��UMn\f ������\u0003-��ѝ��r\u001c�����]�8^~&HX�V⊝���X�`lw����\u000eH7�\f��\n�!ڦ�������\u001c�W\u0007���դ�[��֯�6;�{K�\u001aw_��\u0000�!Ocꨓ��.�8������.\r���\u0000�n֤��Bbk㳢o>_�Wđi��\u001aE�<1ɘ��M��l:�\u001f�:~{\u00038�\u0015��o�\u0010U���b{��g\u0017�}��T\u001b\u001d�l��d�9dUp!���)n\u001c.=g�\u000e��/��ۡ\t��\u0013DJ�����S�����J޷�\u000f\\(��݋E���r�k�\u0004 ذ�=��Ŀ��U'�xn>��.\u000e�m�\u0015L��\\龝\fQ�\t�\u0017B��e��\t�]�����xqІ�8�O5�̗<�xRݣΣy�<���T�)��O��l��mm��x_\u0002���5f�#]\tyr=��\u001c-΢r\u001e��}��\u0014Lע\nн:\"Է7�;��t#�6n8��>T/���Ԅ�\u0010U�xSw��Σ���\u0004���76~T��~DCۅ%��\u000eY�1aWg*\u0014�S\r\u0002z�K�%\u0006'kx��\f���I�����W�L{9\u0006ul9�\u001f��Ȗ�^{����QK�g�����<�|i~ͧI��^�$Hx\u0007\u0001\u0013��>�\u0012V\u000bU�)`��q�q�\b�\u000f�J#�(���Z�\\{L\u000b}��(�q��\u0013i�O�\u001c�Pd��J�\u0007ţT\\�N��\"i+�i�1.\u0002�3�:�e���D\u0016�\u0000e�Ο�jVړ\u0017\r�\u0005�{i�/�2�\"�zv��H��7Gh/�?�7!�\u001bb\u0010-�`<�\u0017\u0019�V�On�'×\u001fy�\u0000��\u001d���\u0004���ó��۔\u0012\u0019\u0007��Y�^�?}\u001d�\u0010eO��b\u0013���\n�����5�F�f�i�\u0006�iW\t�5\\ص�����Se�UA$��\u0005\u0019\\��\u0005��\u0016\u000b��J�m�]Ŏ��V��\u0011ʶ\u0014qTCT䴝�o\u0003���\u0014�Ue�Q]��\t-Et�!*�g8���\u0000\n�c5�D�M̴̚e�DP\\r\u001fߕ\u0013�P\u0012tHd�f1�\u0014�lSd\\#\u0001�\"$�)@��lNx_5ڋ�(��!Z;�Gc��#�\"��돤W��[��A^[�\f�h�e��:c5\u0019��\u001dfb�(\u0005H��D�\u0006���H��Ùwy~4�ͣ�o��\u0011�\u001d\u0004s���\u0017�%1^����)�t+��\u0000�Fu�M��Z\u0003=�<t`�\u001d\n�r\u0011\u0019�\u000f��\u00156�i��\u0001\u001d[x3�y.i�@��h�^\u0006��W�\u0015ٮ4K�>��y�\n�\u0010�Z6\r�C�I(��*� �om\u0004\r�����v\u0003\\>�s�\u0007k:���[\u001c�FzK.Nj3��z�]���K�\rp\u0011\u0006��\u0002��'H��ƹ3�Q���u��\\pmBr\u0011:��+]��\u0017e�\r�3Ϛb�������vqo��yv\u0004���\u0000\u0001���aW:\u0015��$����,=�2�qۍ$�\u0014�<��U�,\"\"��]'�f�[�R�M�.Q\u0011zW�\u0011ۀk;\u0013L�\u00159\b;\u0010�{��Ré�\t�\"�z.�|7c���qUɂ��q0���\u0000�t��w]Ƹ8\u0016baƤ9�mH6�~\u001f:���� Bq�k?z���\u0005K�\"��ɷU\n��nBiD�\u0019蹩�i�Y�]s�~+�\u0014�K:uY\u0000P߷�K5�U\u0015:ڝ\u0014UO\u000fu\u001b�,�=A\u0011�\u0002DCEM�2�\u0000�\u0018E�\u0000&z�3E�P�$j\b�\"\u001e�xP��,����i�Nb(�R*�q�A�K`\u0018\u001f�Jw\u001e�\r�,��\u001f�fhlY3��c���.KQ\u0018���\u001869+�ʵNӬ���qW��\u001494M\u0003�\u0013���5V�ڭ��E!2E��\u0012�\u0000��_`ɵpS��J\u0006��E�\u0007���GEER���\u0000�\u0015�G\u001e�k���`}1l&��\u001e]�Z\u001d$ʴH�ސ}on?\u0019�${�x�Ք\f>�:ja\u0011�\f�ym\\�??\u000f�e\u000f�\u001eŹ\n�Q��M���~�2Oqc��UC��xP����NKVq��c�U��ϭ��-\u0011��z�b���g~\u0017[��;�.���\u001b��U{�:�>�o�z��F\u0005�\f��\\�����A)���[<~\u001a+�>\u001f�zS\u001dL`���r\u0015\u001c]���t\u000b8Z�#�kG�%�\tT�?�i�g4��k\b����O\u000f:�\u000e\"\"��/\u0015Jj�\u0011��e�|�B\u0003,}�?ʔ�\u0017�8\u0015�jr\u001c$\u001c���U�\u00124m�\u001as%5�Ҡ*��b�\u000e#��]��f�7\u0005��/^�Uh\u0001]���+�{��\u0005ڢI���5p��E\u0004_}=\u0006�Ӽ�\u0015�E�<���\u0010s־��߱?�f�[]�\u0003�s\u0001\u0018�)�\u00061����J�O�G�nOn:��r\bci�q\u0003�_<���A�\\��E�NķZ���@P�FL�L�6\u0000wC\u001f$�vl�.��\f?c\u000b�Q���ѱ�\u001a)���KQ}q\t���$���\u0002'��i]=2kZ�&��/*\u000f\u0010�o��+��7U������&��\u0000�se+gJ\n����웬uu\u00046�\u0004�S�Z1���\u0006��\u001d\tL�7\b�-wce��N�[͐\u0005\u0012���\u0006�-���a��귀\u001f5�C\u0001��d.���^�wP\\\u0010��\u0010Sd��b�ȷ\u001d�(��=��q�^c.φ˭wQ{�u\u000b\u001c�wL%n��4i�L~?�y�u\u0013�n�\u0002\u0002�E,mO\u001a#*@�\"B�\u001e�c\u001f���j/�\u0015��6�\u0007��\u0019�K/�=��GS��n\u0018��\u0010��e9�h=�:h�\u0011nǧ���E�)�*M�[=3��n�!���܈���\u0017�\u000b���y��H��%�jP?�B���m�k\f� ��aH�)�U�o���5�&\b�'��U����l�\u0016}ȁ\b\u0015v&���\rE����\u0010�ux,�C�/�(��\u0017\u0015?A]Uf�w7\u0015�\t�sFץ/��\u0012!�=-�\u0019�r\u0015��N�4�!#G\u0019m2Y�����zE����\u0003�\n4%��|�x\u000b9�\u000baEEۻn1K@�V��\u0005�\u0010#-����K�P{,\u0017��͑\r�MEύOnWH�uZa]��\t1ҥ����\u0011�k�\u0017�v�\u0011\" ��\u000e�_\u0001�O�D�\n\u0016���H؄��\u001c�o��~��R'�~�\tVC\u001cM�\u0019�I𩦎���8�qx{�܃����\u000f��R��2�\u000e�H�\"\bm��?\u001et%�\u00105� �\u0015��!9\u0016�����v�k\rgkd�)��<�P�\u0005��G�\u0018���\"�j�\\*��\u0000E.\u0013��5��*�B\u0011�\u0019NY�^\u00031�����\u0000q=U\u0014��\u001b���e���2��A\\P�!!�t�ߍ���Z�+\u0005�I�}\u0004�AP�.2��uF2\b�t\u0014\u0013��K�:\u0013��]N�<&\u0016��HoBU 'v�So�9\tq\u001e�D\u0002�k���*V��\u0002�\\iq�a�b��GEr�����.ˑ�{b��R\u00046�<)�\t\u0007�&�'[m9!~\u0015\u0012�\u0016њ�GU�~x\\T���\u0019\"��\\\u001f.�U\u0019���Q��5\bD߈��q�\u0014&˒�:�\u001d�5�F{/ԑ\b�kD\u0002*����\u0000J�I�\u0004a�˺���q'�@�i�\u0005�����`�\u0013<�w�\u0000�i�\u001f�O��瀮s�5j7�Ĥ�D�¸\b���j���\u0007�ґ\u0014��������ĵKj؃\u0012\u0018mh\u000bwZ�e\\9��ߝ��\u0015d�:�\u001eO\u0011\u0019��3!�����I�d��\u0015v��9\u0013�*���oZ�ߧ�DY{�i�\u0014ENx�J�{a�\u0013.��p\u0012$.�!�Y1;�IYP�Ӡ��\u001f*׏�=���M\u0016Q�%PZP\u0015��)>xϳ��|0�\"\"#\\�׶�ܛk��cV�_\u001f*\u001c��\u0005Hc��>d���s��\u0004K�\u0016-��+�@P'��,\"��/\u001a0\u001d��U\u0017�_�T�ɓ �[\u0002?=�\u0014��]���z\u0014��\u0000M\u000e�+,r�\"��&��4���截�2���P\u0016���Shco�`�\u0017m.�\u001fR{\u0016���\u0000��8�\u0004���\u0000�U�\u0000���{�vg��t�\u0019�IGdM5D^k�M�@j5U͞Z�\u0000�t�~���ʿ\u0005�\u0014��\nԝ\b�\u001e�\u0001���5��6t\u0015U|����t��z2I�4���m���\u0000\u000foƍ�2�l�_�7�\u001cq~u�r�ٔ�-�:�\u0006:\"\u0015e\rD���i̸K҉�wz\u0017�*'��I�\u0018e����\u0011\u0004\u000b�T*Gl\u00173�QZj\u0002.pI��$1I�=Լ��\"��z��;ntw\u000b�\u001d\u001d��\u0005�>�\u0000*�eǙy}�d*�ㄧ����+ɷ7�[��|I\u001e\u000e����'>��\u0000��䭸�����\u0006�b\u001cg�}L���0�D@S�i�.+Ey�䦨�MBO\u0001��(��z�B*�j\u000b�\u0016Ӧy�󤕱\u0012TJnrUS���:�_T\u0015U�DAɵ�\u001c��\u0018V���v�Wíy霻�΄V��\u000e��Re\f��)�$JE�A�Uޣ�Z\\�p�i8�+�SR�+�\u0006\\>M���]�je�n�����m�~й�4��!�b�x�4\u000e\u001e;��\"����\u0000@ߣ�v�GU�8�\u0006����\u001e\u000ep�r�\u001f�.T��4Aㅳ�{%���\u0007g\u0016+ <�g*#��^|_�g�T�N��$���DM��eDs�қD�\u001d׮\u0012\tw7\u0019�\b2��?iIv\u0013����\u0006�q��|�;���,Q�'h�A�:�*\u0006��y]�M5Ž�}��u�7�U\u0003�ؠ:n�*�\u0013����0�|�i�h��S�\u0002�;DEw\"�z�Ѡw��H�h��k�ؙ�\u0016�hy�C�҂�p���=\u0019\u0018D�\u00129`�c!�Q\u0019�Y��[n&Q\u0004��\u0000�\u0005����/���\u0011��*'��4{M���6Nnظ7:%\u000f�Vŕs�\u001cf��F6�QOm?kJBe�g\u000bM.\u000b�:��ۅԒ��Kw\u0004�3�V���o��y�X\u0013V��\u000e\u0017��O\u0002�r�A��nl]�.q���Yw\u001dq\u000fM>0���0\u0004�\u0000�\u001a�{#Z�������\u001a�vϒ�t*��F�7\u001c�'�\u0006\u001aL�:o\u0016&��2^8�\u0018��'Y-���^�Ӵ�H�\u0013O�V�[I\u0001�3З�K)����֫ԇ��,\f�v�G�K�L�hDu\u000eL7P\u0004��v�?�s���o\u00176Ì�fk�p=b�U�d�Bjd�p�D�.�%Ou\\U�,j\u001e�\u0012�1j�\u0004@<���3Q(���]�̞�\"�\r{���K�\u000e^l�2\u001c�\u0000�c���u�Ѳ�����\u001c�Q\u000e ��\u000bWDT�\u0016�'[H/H\u0006\u0014dz�\u0010�J�G�]F�ɪRL��\"Eޘ�*C#���uB4���_d���%�S��g�5�-L�Ji�\u0004h�����\tOYY�e2.�[U�Er*w[��\u0003����LZ�#�\u0004�Qq�\u0013�G�J�䷢��KtTL�[S\u001c���TgL�Z�N\u0005Ű��䡹6�>��/����Փl���m���\u001e�\u0011��W�>�e��@� �ʤ���&��,hړ��@\f\u0001\r��w��{4�Xv�\u0006�:4Am\u001cm\u0005x�}�嚋�˻*����ߪ_���8� \u001bD��9��b�5t�\u0013�'\u000fx��Ѫ�X�l��\\�Z�\\��q�ǐ��;/¦����\u0016��5@6c��/R��\u0004���fA֎30Qa��\u001a^}ߍY�yI1\u0001�˰Ѭ �f��v��|v��c���'y��ȼ�s!�t��9\u0013\r\u0001��!��x�g�F����}\u0019�\";�*�vm2���J �W^��F�Oj\"!&3�\u0007�bý�\u000b�G��$�$&�r0�Eor\u001d�-��詠�\u0003\u0005�\u001a/�~tąI\u000e��Dn\u0003��F�ixg�Q��\t�\n&���z�Yo$unI�5�Қ��o\u0019*���q\u0001E* \u0012 ����\u000e\u0007�r�:�e�����W��;\u0002P�=���V�V��\"�\u001c��k�~�2�;?�@�q��\u0014Dۜw�?Jf\u000f�'\"�Y�ί=��'�Q��_�\u000fP�z�*qD�p��TyW*�^��\u000e���nq���Ϥ\u001aKZ}\u0016�v��?O�n{�)�R\r3ק�s��l;\u0017��`I��t⻔��L�>+h��ws�Z\u0003�恛�-�\u001c\u001bP���q3��?\nqڟѻQ_-��o�̉\r��lSj�~u�/I�^�O\u001b��*�v�+ƙvk�\u0005w\u001a�/�]Q>�Z��6��[ω\u0015\u0010��{�6\nI6��\u0004NK���?\"\u0017VV��3\u001d��I�}�I�4`D������9e�L�l\u001ff��qV�-�a\u001b6[�J\u0011T��W֙r\r�����ى�r�J�e\u0002\u001bE�'����n��%X&[TS�Jc-t�ج����D�LT�\t��`�C˖j+m�/F\u0007�P�4�\u0012S�\u0017��\u001b��ݚ���\u0011H7|��V����=�Lv�j��r��_\u0004�N']�RrL*����N�g|\u0004O%Z^�^�\r�D�g�ʈFm6�Lf�i�ŷ4��D8\u0004\u001c{�$�L\u0007\u0003ֲ�7c��n\u0016��]2\u001d�\u0005�\u001f��e]���/<�\u0000�W-�Td� BB�{8T�-H�P��z���\"�q\u0001qᕨ����Ν�-:n�퇙�d�I��a�ʲ5��R\u0019`J%���(\u0002<j�\u0012�D�j�\u0000\u0015n�\b�g9檴�\u0018��\u001c�q\b�\u0015Ў2�e7b�I�\u0018��$|\u0007�T�k�5N��f��Z?H\u001d¶ˤ1\u0012m���2BX财Ͷ���\u0019D=�\u0004�G+��\u000e��\r�\u001bRb)�*�i��H��<J����\bq]����}���G\u001e�W�m\u0013�\u0000L[\\�3n�|דbN��O;\u001a-�\u000b�f\u001e�y?x���}���\u001c\u0002��'.T�R\u001c\u0012A\u0016��.�U�5�\u0000�ZY㫪湺��c�v��=|\u0010�A�\u0000�F\u0011\u0013Kn��8B[�&B\u000e\u0019\u0007�N���#\u0014\b��/��}�j8ں}��zz�Y\u0007�\u001d����\u0006�����+�5���\u0002�*�\u0018��EO�\u0003�\u001d���'��6������lpȶ����_�Q�P�j�\u000b�($��\u0017<���~l�;F�p\u001a\\�@�qV-��}�q�\u001eYE��\u000e��Y\u0016���\u000e�F������\u0017�Z�=!\f$;�TP@����?\u001aW�eK����\u0000:N5�\u0007n\ts�\n�j�\u0013kQȸ����o��P�q���E�Q��_��̀\u0006\u001edUr��>]j>Ͳe�|7e�\\\u001fp\u000b�_>T]ꛒ�a�G.\u001381U��*��B�zc�t��ev��sP\u0006.�F��K�.y槝�4���6\u001c�n�ϟ��ΐ��}\u000eBJy�T�l\u0013*�\u0003\u0015\u0012(�&GO>����'?�F4��r\u0017\u001dM�i�L��\bӳ���l7\u0007\u000b�A��7��,�\u0015V�Lr뾀�Yejb�h�}f%���s�|���_\u000eq���ļԒ��.��F����\t��<ʇ;�U��!�5�`�.A��7aU\u00014lPӶ箎cy�짺�g�=+�\u001f����D<��S�z�\u0000\u000e>_�T�L��[�CLG�Em\\�\\\u0007\f*�\u0010Dy���1_?l?\\�����J�:\\�l�@�\u0010nM��Ў¥-z}���+0>Wxj����i\u0017)���\\���҆�}�M�\u0018^&���%�l@?����ם�D�>�drk�q�&�\u0010�l�'��}_֢ݦ}\u0019t\u0007�*;\u0017\u0016n��/\\A_�b\u001a/\u001d�}����\n+���5�0v�s�\u0016��'��!�x�;L�|�\u0019��[<w�-$��#(G*گ}Sܕ�=��\u001b7�7��#Y�\u0019\u0012�\u0012;\u0011\u001f/]�\u0002�z�\\��[�d�cj���&\u001c�\u0017'��z���䂿t�燺�N\n�����K�\"8\"���\u0007\u001b/Y\u000b�r��]�؏Ei�ޚ�\t��\u0015{���}�(�\u001d%��򘾤F�yD\\C\u0004ڄ\\���\u0017hw��\\�$Pu���\u0004�>ߝg���I.���v���\u0012�� \u0010��n�O}B�+�n�5#�7�ۋ\rQD�=rO�OƧ\u001ab��4�I�\u001dW8�I�3[�jF�\b0N��P\u001fV�z�}jz�܉-�f.\u0018���\\�ߴ���\u0005ϫ�*�+\\�4ė��(�OX�J�Odu%��AT\\䈾4�Ll!��d-?\"C�)��\u0007A'1�g�\u0014C���y�fS!'��Onq�\u001e\u0014�\u000e�;\u0014P\u0001$6K��_V���^X�f�`���=��U�e�\u0015wg}��\u001d�i�<[�\tٯ�ɵ,!t�vGh6\u0006�f����\u001b�K�Be�(�AR�\u0000����C_I�ݠ��1�Jv\f�u\u0005z.�����\u0015����j�\u001a5�\u0005�3W\u001e�u�l��jъr�\u001d��S���\\\u001b������\nJ�QƋ\u0007��իy�v�a\u0005�W^�%���P\u0015\f�|닾�_Lе�{�.|�E��\u000e��+�\u0004y�U��\u0017�n7j��֦��%�$M\u0018�{<����4��K���<�~�\u0010��2�w\b�\u0006c8\u001c'\u0019�\u0007<�j#~ֶٳ\u0012=�sb\u0005�#Z z���7�]|S\u000b���\u000bJ\u0014�62�c��T�+�~��H��\u0013&�\fzH�㨞\u0005ӗʻA\u001fI*��\u0010$\u001c�%�\u0015s\u0017�rɿ�����h0�8i�\rէ\u0004���:�\u000f��i�Xû�\u0013o�4��Sʈ�-�n���|+�j�\u0012T���'Z��\u0007%�N�(�s(�\u001fOw�T�\u0000ѿX�^�\u000eZ\u001ay\u0006[$�h��mZ���aor8��5r4��y�\u0013�C��������g�m�!�s�\u001dF����l���Ⱥ��ڈ9�\u0000u\u0013�T6�H�-Qbzhȷ�iRc\b�����U��\u000e[^&^\u0015C\u0015�J�N��5\u0000z|g7L\u0011�\u0019/Y>���N��ޭ�<�\"K\u001eD\n�^Tq��@�\u0012�*�g�C��l�3T�\u0012$�\u0005T}d����I�RQ��t?$(��a�2�lm3��8Dm��Z�_�J�.�L�3�t��\u0015�ةϕY�\u000bY}t�Gx���:�t�� �\"ˈD��9��Ѷ��S�\u001b!�>�i�a+�qs�§:z.�j)��9����4�\u00126��\u0005�\u0018�ʈ���6\u001bv\t{�Sp�Ц6�n#���[�\u0013oJ\n\"�W�)YR�,xVP|���{b��n\f��]Q4�Ϋ'\u0003j/�\\\u001d��\u0005�����\u0000:�8�♭�m���;�CG\u000fb��Jq3�\u0012%*F\u000b�<�\"pU��?\nyζz�ӝb�QNB�[��\u0016\u0011=���ovy��v\u0015\f�i0��H\u0000�ώ)������A\u0003��S�\tVt7Џ�\u0018ݪ��\u0019��e\u0006ϲi���W\t\r;�\u0017����N�'�9-S\u0010�\u0016y��\\O�\u0000L�̾�Ѻ�Z�\u0002W�u�d�۷)�����D���a\u0001]Uy�T���y\u0013F�Q�A�y\\H&�QAp+��y\u000fK@~z�j�*{6\u0012w\u0013޴v\r��6�j\u001b\u0002���z����څ\u0011\u0000�k[ǹ�.s��Db\u0001ֲ}\"|(��p\\>\u0019\u0010\u0016<j)�uh[�\u0015�w�K�\u001c�?�\u0007r�\u0000u���ձ�o���*nz۾�-5�I濵n�z7\u001aB\u0010���FǟZ�4$�$}���I�X�Q\"\u0007�q��v�{���\u001d �Y��\u0002l��F>fK����\"�j�\u000b�<\b)�Ƒҏ&��^��$\u0004�;�\r:��@݇\u0018��_&�.�\u0019�h�.��~\u001e���1.�xeQ�F��\u001e�,�I�:��\u0018= �zg�������\n�\u001d�C-��U1҂�bVg����M��XC,t�����Ew\u0007�!\u0017}=T��I��5\u0013N:J�\u0019�jSw��{���\u00122�����F�M�q�[E�&��?�\u0015�\u0003\u001a\fQ��l��*?\u00128��\u0004ʖ����\u001f�\f.2[l�u���9�\u0003�\u0000\u001d'����8���\u0013���U�B>���t\fQ\u0001�#!�:�M�z4uF�~z��@5u���܋�v}�Ե:c�l�_��k�5\u000e�K\"�� �Q��c@������\\��νk�\u001dd��m�r�\u0018\t#���\u0002_i\u0017�Ҿ�^{\u001d��5���!x�U\u001f\u000f�+��q�5�-\u000b)]n\u001b���UGY\u0005%\u0000�/��x�E{3���`N�>�7����f�\u001d�a\u001b��y>5\u0017�\u001d��}\u0000(6k���/�\n\bCPy\f\u0013D���\u0017\u000bH�\u0002���z��[VH5��L���ڞ��e�Q�\u000ez��k\u000b�\u0003�5\u0011�Z����bX�Ba�t\u0015S;I*W\u001fL�8�ƈ�\u001c�-��]�W�����\\Ư��\u0003�B\u0005��R\u000eF�\u0006uk.:�mÂgCv��\u001a��\u0018RHE��=�e��D�?�]�����\u0014�C�が���5\u0013N��(ć\u001c\u0019\u000e��8�XZwO��!��,�q�\u001c�+��qιy2_���E\"�����c�%d�T|�Snwm��UC�H��\"*mCN�V��\t\r����:�Ɵ]/#\u0005�p\u000b\u0004�^K�W�Q�_\u0004\\�,}_sI�p�T��TZig�\u0001\u001e\u0018�&\u001d.������l�J��J�gp�y�AFx\r���C\t�U�\u001ct+�S��M�Pd�#QE�\u001d*�Զ�5\u001d�\\5D6�\u0012m\rk��.����RHw�v��Q\u0014�� ��\b����T�i�[{p�c�>�ڒM��vf�c��󎾺�>c�㟍Q7�1s��v=�\u0014�O6� }�\u0012J�\u0011���\u0000�r7����^U\u001bN���hS\u001ckQ�a��c|�\u001c\u001dm��8�fy`���*�\u001c�����w�9�������&÷7 �8h;�U1�/����ô6��#L騏�J�.��CNu)��\u0011�\n�\u001d��sl:P��#/C��H\f��vԗ�?���\u001f�(.\rY�%�^\u0015\u001f�^��ͼ5O~sQ�of*�\\Rc��@���F.\u0000�cy\"\"��pu\u001d�m���f̐6M�Ssj�\u00159�T�.����s\u001bU\u0015SΊ\\nOH��!\t������+V\f�3&h~\u0007��i��i=Wu���\u0000��\nI�\u0007�c���Z\r2O�Cpж�,-+��;\u0011.�x�/�\u0017�M޲��U�Nv�!\\p�[/eS�z%mY椪L�v}����C\u001eDwյEDD^y��\u000e�$�a�\u0010�\u0014�8T�+�,��\u0000�8��`3�λ\u000fHvvs4�'$�\u0006Yޠ��|�.���\u0019�Or[��J���NX^����M�c�N�vV��]\u0000pS�E�S]?�>�Tp�\u0015q�U?ZH��\u00101���-�\u0010��U�h}�\\t��]�홴�����͵�܆p@���u�<��\u00016*&��\u001a\u0014�\u0007����4�K�S�nO���\n�'\u0015U0����vlZ\u0012{�\u0019mN��Q\u0005\u0013�5�\u0000j����j\u0003�&:�\u0017�\"rE�X��\u001b*ۍ��ep�L ��<��i\u0014\u000b9�>걣�l\u0003n3�\u001a\u0011{����i0���)�ز��R��!o\u0002�����>?\u001a���܌q�k��W�����z\u001b�ɧ{�E�WS�?�WV�Y.a$6�\u000e�y��d���j<�X.\"R;���%\u001b\u0019���n,Ⲇ\u0014�\u0017�>IY@\u0011���j\u0004�r�\u0001\u0013�dT��֫ƟNy�\u001fk��ֳ\u0013��j\u0018\n��k��+@���V\u0014mx絾j��\u0005\u0000�3�`�\u0017\u0010v�)�\u0015\u000b>�Fh�e!1\u0015O\u0011L��'�\u0012g֦9L/:q\u0012Q\u000b���/�h \u0003�\u001eU&��)5^��ٔ\u000b�\u0000q�,�EpE���\u001b\u001e�����ݗk{M=S9�\u0019��F�Hɔ]�\u001evm/�e��:\u000b��>δ,\u001d\r���Z\u00140�j�0.�v\u0003\u001b���~u �xr�q&�ꅶ���l��d��ó�H\u0010��5������t�\u0011�䊀��o��������\u001c�p\u0007eG��jN�\t��\\\b~�ZE�3:Z�^�\"n^y�#\u00124��\u001d\tH �Ƞ\r��/��z6�����\u001b\u0011_����\u0010ӗz����l\u0016�1;R��l�\u0000w\"�\u000b��\u001e_�2�z����k|0Y\u000e\u0016\r�\u001c���0cP΁ڼ�L����x��n��=Կh]�2:�TƉ@\b\u0005G`�\u0017���Uc��\u001e��\u001e�h+dƗh��!�&Q>\u0014'I\\��=ָ�\r�c�])͚��m*D�\u0010MI:n銏�}���\rR�\u0018e\n��l�{��leF��_Ƚ\u0011#N�\"\u0012**&R��P��m�\u001c�a��=j!p�����\u0016p�_ƥ�[QG�eN/.\u0018d���\t�\u0007t�*\fᔉ��r��S\t\u001a��v>�<M�S�ƫmi�\u001c)�<���^ʪӈ��ؘ�d\u001b�\u00156�Nt\f��I�$�nj��(�皴�;\u001a\u00023\\t��T�;���\u001d�cq�<���/](%\u001aA'E���4E-�ςs�\u0006��3t\u0007\u001cۂ\u001ex��/\u0000�t\u0014xO�j���2\u001c�r�Z��\u0010�\u000bKE(\u000e��{�R�k�NDCl\u0013&��T�#\u001b\u0007o��k2�Բߝ��V}�f�?g7K�j�x�s�Yb8�F�Ei0}z��bZ\u0002#)%4�v�_X@p��WtK[p���HXܿ\f�\u000b����}���Z�$�\n�/読zF�i��D�Ch��%`W\u001f�L��\\\u001fP�²��\u0000sm\u0018n�\u001d��\u0000��S\u000bʹTx�J\u0007�\tq�E�\u001a�\u001fA+���G��\u00044�*\u0012���}\u0019�Ҹ#�\u0012�\u0010\u0015��(�9��mY�oJ\u0004v��s/\f�5�'h\u001d��X�S\u0006���˗�A���\u00171\u001c�\u0001\u0014��_uY\u001a�N��1\u0014��|�Pɚv}�)�b;�8\"���犿`��\u0005���\u001c�6\u0018�\u000e�^Oh�ؘD�\u000b�U+?��\u001c�Q�W\u0001Iy&�)��O�E�\u0017�2��S!U�Zt1����|�e�x��仫l��E.��K\u0017nj�\u0010�ApS�/�s�w��\u0010L�n����\t�\b�9\u00063���V��Ip�\u0007\fWK���]I\u001fd�V�:\"��=9�!]�5e\u0011D��9�R�#8�\n+�9�\u0007gz�F��\u000e�\u0011��!�z�\f��3�0ո\u0016\u001e��r��+�k\"*/#Nd\u001f\u001a�jkyC���^����t͚�\u0007Sڅ�\f_����{�\u0005���6��$\u001d��}UL����X�<��R�G=^m%*\u0001�\u0012�A����P���i\u000b�ۚ�Ֆ3�Y�#�K����n\u001c��T�'1_u+�V����6Ts�Ծڒ\u001a�S\u0000��!�\u0000z��_ߕ\t�lu\\ڈ�_\u001a�4\u001d�l�㏊��&�\u0015��Z0{3�W\u0013�h\u001d��c�2�r�\u0017k\u0002Ip�A�\"[���t�0��l���\u001e3\u001fw\u0015��\u0000H���|��\u000fU�mzE��[ɗ=.`\b��{ \u001d{���e�j\u0011��)�(?�:�8�pG�ȿ&Y=�[��{`mP�I\fq-��\u0017����ʻ�J�ą\u0006\u000b*\u001b�Z\u001c�y�\u000b�=�\u0005�C\\�T�j�ؼD�\u0017��J��\u001d���\u0017sm�2��g��\u0010\u0007�A%e��y$&\u0017��|�w\"4�(���\u000b�j�6�m\u000e�pbX��4�\u001blr�u�J�\u00033\u0018��\u0017-�DZ1\u0019E��+��^�Dx\u0015\u00151��\u0003���6}\u0015\nU�`�TiȺ��\"$���n&\u0017�\\u��#�.�����ཕ����>~��tQ&�+P\u001e��;��4�\fQ\u001f\u0014Ud�=B���q��QY���M��\u0012Uڿ�0m�u0^\u0015l�m3\"4�엖T%��r������UM����A���!��R�FV��44�mbZ.���\u001a\u001e��i).}Z�2��<x��FD��zR�Z\u001b}\u0005Uv��֘\u0002�巷\u001dg\u0001\u0017l�4�%�,�&�Lf�\\m���\u001d)�Zs����>T��j�8c��JDڃ��)�����\u001d�_0�YQ$��Q\u0017�YW�B�`��\u0019\u0016���9e��U_�6'�X]���`�*te\u0007�Z�Q9���\u000e��b�8����)n*�D<xV!��̇|RN�N#8�\\�)�c�V�\u000fw�\u0003C��El'\u001e��B$�\u001a�D\u0014�_g>�����=�i\r8(�*b\f���P#2\u0014\"��W�\u001f��f\u0012;K�͖��u��6i\u000f����/�_a���n���\\��^�׻��W/ȕq\u001bqF�#r�;:��Hm��{��2\"�_�\u0017���M�ێ[\f�P�Ɩ��i�j�q\u0016����>k�_ƒH={�92t�b�\u0014Ȁr%\u001f<W-�7F<6�Lr���e.��\u0019\u000f.����B-q8�\u0004\u0003\u0018��G�O�#Ō�-7�\u0017�ki����Vƣ��^c\u0004�\u0014u���ry�\u000bԋ��KL뱚�*n�C@\u0005�i=i���EF�s&�.\u0011<*\u0007�|ۍ���%�|�m�#�^�f�=��G5U��wU7[lxj�\u000f4]��΃�\r�@+\u0003��N��Do �Ȣ��ւ�kZR�ˍ:nlNh�=�\u0000\u001a3��KH��;LIQ\b�1��Q][�!,�f2�l-�)��\u0000���]&��]�i�`�I�\u001d¢�\u001c/�D4���>�i\f�\u0004H�\u0013��(n���n�A~!\n���b��kٻ\u0013l�).\u0016̢���U���\u0001�\u0012\u0013�\u000f|\u0017i��՛�f\u0002�\u0018�%y�4��t�\u0005�\u0014D\u0004%RE\u0014�P�/zK��\u001bA\\�\u0012态\u001dY����\u0012#��6^��3���!vpfnt�YU�+��5��6��d�=��|�\u0000�O��ց��b7���&a�[\u001aiҖ\u001b�Ȋc;��\u000f�&\u00117�Z�h2�ta�h��mz�T��y�Bp�\u0012�I\u0006�&Í��4�89�GaH�\b>4<�q��C\u0013���_�'��-r0Q_*F�r��ϸ$�Bm��4�Ê�8��l\u0015*iq�,7�G\u001b�I�4����\u0014���#���TQ\u0018\u001dox����$�TӎD�\r��5\r��^</�\u001bbh�:�-\u0012Ӑ\f�������s�b�[�-3�=\u0015�'Sa}�T�p\"aWn:P�r\u001d\u0017�;`J\u001eӣ��~�E�\u0018y�\u0007�\u0010/��\u0014D9Y��i�B0BE�ɀo�&)��8�\u001b]���g�\u0007��cEd�ü��At�vU��vg�e�\"\\ߵ0�\u0001��hv�������s%6�#��\tS�s�z���@��S\u001d��=��ҒN\u0018�\u001e\u0014��V�IS8�tq�\u001e�ņ��Pz+1��\u0000\fOo�V�d�&�\u0019gv3��K��\u001dtŵǚ��\u0015ٕ�J\u001c4��#�Q8V�a�۹��\u0006!+d��\u0017�jy��<�M��W\u001c\u0006y�\\yUr��iSr�|(�\u0012\u0014�'��쫴$ҷF!�p�\u0006A�s�[/���T���\u0011�HB�����\u000e.\u0010����{=��\u000b���pL�7�8b��3X���l�!�ƾX�_fʅ$��#�^��5\u000f��ԇx�(���\u0016��sn)��'D\u0006͡�8�\u000f4���D+���\\�8\t�N�jAؼ>�ji[|%���]�\\n�A4�d��M\u0019*g�έ+��$\u000b+ͬ�r;C�ڝ��柉;଒����\r[�֚y�[-GWb�����w��W\u0015\u0011���/*�_�~�oZ+\u001a�@�0Г1��#ϕr\u001d�I���b0!*�.��\n���\u0004y��)\u0010f[7��\u0000Fk�\u0011(�\"Y���NZz������ʉl�F�y.\\IIм�Й�ӭ���\u0017V$ym�\n�c�R#Mu�\u0015r82T\u001a�{7�kj-:�G�\u0010�i9a�ܿ\"�s3�4�\u000b��X��K���fJ\u001d\u001f��m�&$\t����Ȫ�������<�!\t�P�����%��:� \u001e��6C�\u000b���þ�7=\"!\u0002��ρ�Ei�N_�J�?\u001b��S;����@��E�\u0014ڹL�\u0003KkkN��7r���d��{BU1��I-�oʥs�\u0011�WҮ�ǲF�=�n��ѻ�e܊���ܮCԶT���/�����`�D�R���(�(�\u0014W���~�}��IG�ml�Q\u0014�\t�ާC%p��\u000e4\u0016�\u001c�\u0013\f\u0010�t�\u0014�\u0010cn����-����2�c���&�'w�kt\u001d��%F��COUS�M�@���,�u\u0012T\u0004ϝ7y�\u0005ET­4\u0003�\"y�V�w�S�+(l�K�/'z�\u0013d�)\t\u001a�ς�\u000f:Qk\u00112�Ҋ�A�[;\u0013��J�\u001c�\u0000(ڦW�8h��C�'���fv��5�N�BA� \u0011�ëM\u000f�_ʓ.+\u000e+gGѯ�|�d:;�\u001b���OK����uB�];�R}��\u0002�g\u0014u�N�������.\u001a\u0015�l�t��ӧY\u0010\u0018��\u0002|E1�\u0015�n��T�u�<˃��\f�>DM��\u000eYm&vp�C�;\u0019t��6�Qَrp�q�g\u0002{��\u00058������\u001d{O�sg�\u0001d�u\u0000�dK�X\u0016�e��\u0006\u001a��\u0006�C//?}e�jcMm++�����\u000e\"{����:�?�=tԳ-�n%�T?�\u000b˳5\u000b�.ne��4#B�m��H\u0013\u0014�\u0006T\ry\u0017�\u0014�ʢW�4���O{&���\tӯ��ow�!cґ\u0000@I[N\u001f\f��bj\u0000~3�78��c�ϒ��r-Qf[ZI-���x,\u000f��� \u0016\u001b�ܮҁ@�\u0012�/�@%vy2\f�\u0012\u0010U�\u00132ک�Uf9o�l�b\u0011�t#g\u001b������}�\u001b�������P]�6�W\b�\u0005���!\u0014ܵ\u0016�Z������\u0004i�n��V��\u0002]4�[2\u0001NI�ǭD�\u0013P݉�C��޾�\u000bk�<�.;�ur�\u0000�˧Z\u0017�A�]��+d@b��>\u001dj�S��q}�\u0019\u0012\u0002s?Ҡ\u0017�K\u0005��m�hDk� /pj�\u000f^�����\u0006�]�w�-G\"_NU�򊻉��Buѽ1联0<��T���\u001a�)؜4��\u0011�\u0003���N]�Ά�\u0007tJ�=�s�G�0��n\u0010��o>X��'�C9n�\r������k�k��\u0016�P/O?\u0019�m�t�Qyf�6�g\"\u001b/�\"�)ȺR%\u001a\t2�[��8�4�\\]@\"����y��W�����ӹN�ꑫn6��S\u001c\"�u\u0019i\u000e\u0019a�Â��r�$�h�\u0014<�;o�\u0018cv�\n�E�O�:H�0�D!K4\u00021`\\q|\ry���h\u0012&��x)�����,d�>>\u00152�:ZT7\u0012D�\u00162�V\u0004�/Z\rٴg�\u0013�\u001ek(���W\u0002)�T��\u001e�$\u001bHn�Y�\u0011v�w~tءRa;��-p�Yl�ڝ��\u0012�x�~�!�bC�wn.H�~\u001bCn�����}g\u000f��\u0002��`2j\u0002M�<v��\u0017\u0012:憻zZ�����7�PS��S�P��C\u0019&[�7�����ZݻB�\u0010\u001dy�����y\u0019|�,��;�V�y�FI\u000e�\u0004反\u001c\u0015�\\\u0015\u0010���b�7vJ'��\u0014v��Σ:���\u0019�\u0014�T�����=Mp�[5;�p6�\u0012�\u0000\u0005\u001a�v�ր���٩q=A�ƺ8��|f��0\u0017֢ķ\u0010���>U&����V���'sԤԄ�x�M���Q�qO\b+��m�\bɖ)Qr��؊��֡�\u000b�\u0003\u001d]5DP�t\u0006��Db��.�|�֡Z�Y�v�\u0007�+��<*�?'xK[ԣ*�\u0007�|���sU�\u0019\u000f4�v;����ϝrޓ�����]\t٣?�\u0006}u독fʮ&���\r3���{��ٌC�p���UC� ����bd�7*\n��T�\u0002��o��Ў7��\u000bG�O�j��\u001c�\u0010���ENi�V�����\u0017��b�#��\"q\u0017�\u000f<S{�+QJq�EtL�\u0013\u001b�w*�ǼD��F�5�u<\u0005k���=����̹�mqc\u0019�����^U�\f?#.YT\u0019�=�v�s�&|[즕\u0001�@��npS�U\r�\u0000^\u001d�+�6\u0001\u0015���'���e���eƇ��zD\u0011n\u0005�g\r\\N\u0003�\u0000���\u0004���\u000by����\u0018.\u0014I0���#\u0013�ݻ\u001e8�8��(�\u0014�וy\"�|��U��+�ִ(�\u0005\u001cs<�\u001c���\\֤\u0005�ʋ�-���V\u001fV�U9b�DZʅ.\u0017�a����N���d�DXq�.D��SLjH��\\K�\u0007w� Q̢��W�;|��,\bk�7��R\u001d��>�)��\u0001\tM���\\�'\u001f���\u001c�����\u0019���'T���jsF۩�H6⢶���Jϳ�R�τ�\u0015\u0005�\u0015sW\u001d�~�.�ǲG�?��x�\u000e�<�QxD{�\u001f��R7\u0018��n�&\u0005y�ys����N��V�\u0010��\u000e��(*\u0012g�poj��I���P\u001e\u0015r��}\u0010�\u0000����s�3�%_�{�TV�R\"\u0002U^I^M�#e��T\u001f:H\u001b�k�U�\u0016kZ�Iׅ��y���� \u0012��5�tQEg��~u��+��R��I��\bew_�0�Cs����(\u001b�mF\u0003yp)ԋ?����4O8\")�Q+�_�+�����Oǐ�Iy��Ws�^9��O���~D���\u0002�GQ1�k:�k\r����\u00052#�\u001aoN�\t\f����L�@���6\u000b�ZC����s\u001dW��n��7������^��9�9&wa\u001aa+��Ӻ�f9�\u0000umv��\u0010ӎ�{�db.4���'L���Ѷ��fN�)�iO(��Jd\u001a�\f�ޅ\r�\u001d�>\u0003pu�Ɛ٢1#��|\u001bD�h�fg\u0014�y�(\u0007gM�����N��`����\u0000\u0015\u0011�W7^�Jm@�s��ih�|�f�&M\u000b���W��(\u0014��\u0010��丆L�M�z���*�G�G�iqrJ\u0016�_gƥ�m\u001fm�eu\t�\u0006B�.9g\u001f�S+u���G�6ͦ���X��\u0015L�k��`\u0018a�ު���_�Au�8z�b\u0013�A\u0011�;�V����\u0016�Ĉ�0ۛ�f��>+\u001d��\u0000���\u001a���\u0004�t\u001b|H\\%^�\u00174��,;}��\u0005�\u0012��w�w��Oc�C{z$nfJH!�TB�m{��4C�����iX�\nw�\u001b�0�m[,x��]5&ޱ�4.G�\fp��Օ�DZ�q\u0010\u0015�C��3R-Al��=�\u0019<|�\tr���,�(��/0\"�����v�yT2t6��x�Y�_߾����J�p\u000b�.\u0017�\r�dz[�!w\u001a\u0016=��U'����t4��\u0017p�q�_E�\u0010I�\u0015����\u0015R�?�VT\u0004���`�>t m\u000e2�w+H+��)I~�-�>�\u001b\u0016�\u0000��ps�u9m��M�\r�Ƅ��\u001bw\t��T$}:��\u0018�]ZV��Ъw��T�Oj�����@#Q\u00017\b\u0002���S��X}�v楋\b!-C�\u0002N����Ԛ�g[���,72��\\�!A4�fR\n���f���FZl����{\u001e\u001fֈ]f��\u001btEٰ��w!\u001frTԫ&�\u001a�p�\b�T�ik(�\u0001�s��j�\u0000��Xc\u0013N\u001e���DR�\u0013�rY��\ra\u001eەU^�����t���Ww\b�뺮(\u0007�\u000b�h�2YFF�p��\u0016����[n|�*\u0019�ww�Ӭ�sDD\u0019��˒�r�g�\u001a��oi\u0007�\t�\u0019B\u0004pv����\n�e�U�\u001e\u0013Y��-�\u000bj��\u0018�m\u0011�G��j\u000f3]�zK��,t\u000e��$�?\n�\u001f���\u001d����h�\u001a�����jX\u0000�/w*����\u0018�c���k�՗e7�\u0004���O\u001e�\u0000�V��Z���}�.��WZ�PN�\u0012x��\u001bC�\n//�9W\u0015�H�ě�/�[�\n;�>o�\u001e�w9N��qIw/_}\u001f�ܟ�\u001d\u0005\u000f9��\u0011b��9AU\u0004^kR(���D�t�ы&K����4�F��ᚌ����;��\u0012rJ=<��ڧ���E�\u0003��\u0010��U9Q!��h���R2����奮2\u001eP$m\u0004Ey(uJ��U���j\u0007<�_�.ތ��$�g)�\u001e�ǖv�\u001ar�:㨗v��\u0019�(��`K�^�bZ��c�&ʩ�\u001e�������̜�$]2���E�ҳ\u0010\"��\u0011�L�\u0011;���d<ܺ%�&�Q���sl\u0011'�/�\u0016��v�`�����9\u001d�\u000b�]\u001eK�_k���zm�m�\u0019��<�\\D\u0015�/θ��Ϥ��O�'�/[a���7���68����Q.U�Ǎ��Y�D�׬�'\"�hRB^���\u001e\"�����N\u0004�F�\u0003�bY�7��uj�\r\u0013��j�R�u��v�^�Y��wx(�@u����ng\u0007QBr�u\u0004Ⱥc�\\O�/:�G\u0014��Cv3ΰ�jۭ�\bW\u001b*����\\Zr{f\u0012\u001aF涘\u001f#�Ӎ\"�f��\u000f�Z�ߝ<��\u0006Hٖ�%�N\u0019��n�9�$[AQ8}��%�l�\u0004��(ʫ�\n�,b�\u0017*,@k\b��\u0006<�4'\u001c�Eh\u0014�R2}��{}\u0003-�cy�A��8\u0006|�x�\u00057�\\�N�?l��B��h�\u001cQs�Ǎ#$w�\u000e��ꖤz-�\u001c��Ͱ��S,T\f���#J�E�_ �\u0005��~\u0015��Q����K�=p�>�%\"�j#&a:JN8��ⵙx�췒H�\u0013~�\u0000�\u000e��څ�\u001b�z\u0019\u0012���~����i~ܺu�E]��\u001a�\u000f�Ϻ���\u0003νY �4���_$�����H~/\b�e|�o�����\u0006�OæѨ�N6����\u001e\u0019�<G���\u0000.t�WЧa�u���\u001c\u0012���\u0010\u0005fw*Q\u001eRO\u0015*�-QTB�+++IFR�Z�n��m-.�9��@�>� �t�h\\�KJ�X\u001fF���k�w\u001d�g�o��?!H3�\u0014��֍=g��\u000e}�Y�8ۢ�Ap�\t���P�F��m]��ò�$��M�ޕ�\u0006n\"�+�ԫ�����\u0005���\u0017���(���^����\u001f���\\:�#H=�a�3��4h��t�<\r\u0002�wA\u0007\u001d\u001a%�-\u0003k��nK�㫝�=\u0014�J�e��4U��t�k��\bK�΄�o�\u001a��qH�E�*��s\u001b:�\u0016֚śu�tybH`�co<�ݕ���2��|Ks���*�S�C����Lz�y$\u0012q�=��7�>t2�-p�=���\u0011`6�[k��\u0015�c��㴹��4r�\u001cm_R�٦1�.��!�;�?q��nT\u001f\n�v���j\u0000�7\n�(\u0013n<)�5LmB��]!*<c�`�\u0012\u0019mT�:\u0018�\u000e�E�]�=�m��\u001a(\nJ]��i'��]9 #Z�a�����)��>h.�V:�1\u0015;���\u000b��K\u0006�\u0015g�f�v�i�Nh�\u001c�i��\n�A`\u0018`̈���kx�e��m��\u000fPS��\u0013VL+W\r����5�֋[#\u0004؂Nru=j S(]5\u0016E��\t!�\u001d�\u0015||�\u0000�XN�菶R\u0011�\u0002��Zs�!ǂ�N\u0007p��-\u0002�W��Za1\u001f�=UsA��-5�6[�2Ҷ\b�m�t�Vƕ!b\u0019\u0016�!n,g�1��=��pS\u0019\u0004Èa�\u0011%Z0��^mL���\u00051�^�\u0013�5¦��\u0010�B��8�\u0010�i��6Ȝq\u001a4��?Ձl�:%\u001c��\u0017w.��X����1���?���j�EP\u0000�2\"���<a%ڈ��Ǿ��c��6H�jz\\�Dq��<�~�Ч-ɥ�%\u0017����h\u0019d[E�����X\u0013u\u001e�Y����\u000fy�T���\"�\u0005In�C�\u0005���%�r�b\u001a��I��|$�Q�Z�Ӣ�&�6��Bc�-�F�\u000f��S��Uy5�{��\t�E����W\u0004~fKD%Ad��m�\t\u000b>uD.M?ڳ�4\t\u0002��T�4��ާ��ù@�5�\u0004p�p(�{�\\����AfKR7�\u001f��\u0010p\u0001�gϗ�\u0016�jI1�!%�7\u0004��\u0011W+���Q`}Z̛�ϒ�bJ,����Z�Sv�:z'��!zI&\b����W���\u000fDY}28\u001c�̀�M�e\u0019\u0013�{o���T\\��6R+ψ\u0011.w\u001aՆ��K��������F�\u000fR.}��Q����|g[\u0010m\u001dq\u0010�$L�\u0017=�\u0005�;C�\u001ftx\u000f 3\u001f�*���ΩMK��Mu�[E���Zd#aQ;�z�*���;z).3T���\u0000f]��\u0018ˆ���9n�@�\u0015�t�\\%qM<Q9TZ=�L�e̷�]Qkn$�5'A�/Sa\u001e��\\��Q4��j;��R�\u0015_\u0010c��\u001f��;��ߏ�8l\b3�\u0004s䘭�ƃ�/��mܢ�\u0002��q�\u0014�o_e�\u0018���{Y�F\u000b��ˋ���}T�ٰ= ��Q\u0016�w��\u000bav�Gݓ(�U�\\'�O4���\u001d�9L�V�[�8��ޞy�*g��R!\"0�l\u0001�ϭb�Ź5�S�m�\t��&W\u001c����\u0010ߝsi��\u0013���\u0004S�@-��G\u0014D\\�Z\u001d�[؈�\u0013\\w0�洏}\u0001��ii�mzM��c�\u0013�TAEq��U����\u001e���\u0005ʩz�t/��RˍÎү\u0018�y��U���'���w�]*��H#��@�oӏ��fG\u0014\\\u000b��\u0005�ڵŝ��Z:��oVyM�ryI�i}g|�\u0015:�L�%�\u0018�mx\u0019�5��ɗ}���~\u0015D�^ѧGBV���a\b<]��>�Z�`�+9^FO��댽\nA6�;\u001aK%�\u0012E\u0002\u0015J�X{k�Ë�m��u-��ǜ��S�KR��V^�c������\u0019��#�\u0012�*��Z~U�a2�*�z��r4�Jֺs�,��vMy\u0004�iˉE���\f��\n�y\n�ª�G�gA�믶�\u0012AqG�9��|+���mȎjہБyՓdס}���{_��\u0001�%�j�(��1K��1��0�X\"��@[@!�\u0013.�y���+J�W�j\u0010\u0002�m\u0002��0j\u001a>j����X\fi\u0018���ӪD}�E^�u%cB@j<gDP�{ʞT[�\u000e1EL6g\u001b4-�I�<�k��|\u0015�h@���,U�\u001e�\f6������\u001a���9�[e\u0017-�ً#9\u0012_j�d\u001a�\u000ehm:��\u0011�f��\u0011��%Z1��:��&�(�'E\u001d��]o�7ѳH�h��u\u0002ǝq,\u0017\u0004� ?/>�O2HN�p��Pjw\u001b\u0018P_���\u0015����\u0001�:�:J�\\����o\u0011M���Y���h��f3��Z\u001cgʡ���[,�\u001d����k,��?E�\u001d\u0011\r#�\t�ViQ��)�\u000er<��΃}!>�6k|f�Zv���Q���}qO\u0014��;v�Q�̓{S����C�\u0000V�ט\u0004�\\đ\u00178��������3�U�c�@�mc�m�e]}�vp'�\u000eV�V�\u0014�ޭ��\u000b��Q|�+C�k+Z�\u00135�2\u000bDd�=��:��7fm�C��o$� ����S��+��(��giZ�\u001d�\u0019\u000bd��\u001b��x�}:њ%�=��P���G�>1\u0011P��\u0016���V\u000f\"t�\u001a���Jݷ���̲2^r1?\u001d�u�hk��Y\u001c��4,椛�\u0019�����s.P�:�^�Pږ�)\u0004�d��ݰ=_�Zi�\u0011�\u0015��56�����\tt�㟕q�峧�\u0013]<���\u0007�����\"\u001e�u9l\u0004ZN�\u001d�\b\f��\u0015��=�����\"|k�atZ�j\u0000�����\u001a\u0007�u,�\u0013�\r����uZ&G����VIw��:/\t�\u0016��\u0018�Fo�\b�8\u0019�(�%���;2z�\u001d!8���ݜ�V�v=})\u0016�jAd\t��\u0017�O�X�k�ʫo�\r4��̽U���Vv��\u0007z��L;\u0012�\u0002�\fo$�:\\�+��.��=~\u0001(ޏ\u0015�A@�j�\u001bUi��Snoi��/\u0000�l�B�P\u001e�t�[�U�\u001d�h�DU\u0016��}����\u001e�[8^�ѿ!Q\t9�5G�Gj2(�\u0011Wår�g\u0017\u0011�>Ϥ5�N�^]ծ�Ҹ��<�آ'�\u000b�O}\u0018�\nk\u001b|۝��n(� ���࿥GbN}���^�r��AC�ڊrύ\u0006�����:�cj�\u0018��PF�Vڊ�nz+�\u001ei�xS\"\\N��S�vFoQ�\u0017�PU1�U�7LF�\u0015ƔS�晪��!-\u000b&\f��Q�V�Q3��J�R\u001a���\"0d�c���Ú\u0013E��9�\u0019^U.�i\u000b��=؎��\u001b��Z\u0001l�.خ\u000e6�q76���\u001f�S�[���O��)�3��i}\u001elZ[q�$I.\"\n.zu�n^��&1)/N��\u0005}�[�I\u0017\\,����=s�R�2.�\u0017\u001d\u0017o\u0017\\�9�\u0014S�0^���A���.8�+j\f�Yi��4W]#�؎�j��`\u0017\u0018�5�\u0019��\u0002\u000fq\u001c��Cc\u0013�\t�\u0007�Jq\u0018N���J�i�\u001fV�[��iHw�!���?�����%�VJj�\u001fqR#\\�E?�?��\u001a�LrTۣ�%8�㥕\u0004�#Qp!��t�S\\y��:��%�\u0003J�6�(Z���\u0010�$\bQ�s�w�c�\u000e\u0017�L7w����P�P�\"��εԺ�\u0015��\"˜;t0V#��c�\u001a\"�t�i\u000e^no\u0005ؑ\u001c�Hhi�O�:�j�+gպr\\v\u001ae��ڨ<�w�x����b6���S��\u001av�[Pa���TǱN�D��n�����E\u0003l�\t\u00159�E\\�vM�y����+�%�S\n[n�2Q�R�j��ʹ��\u000b�fr�\u0012\n;\u001d::=\u0017�Z\u0013ԑ]9�>�)\u0005�[]��T*Kl��8��0 �x��kV� C�\t4���8�Z9o�ͲjD���+֯sDZG<�;;��8�m��{>U����J��ʄ���\n���ҺR�n��bd\u001a\u0014O:\u0001&�\u0018\u00184lTH�\u0018�y(;D\u001aՠ!�\u001dQ\u0019Dh�|%i\u001f��^Bi[��cb�?\u001fҬ8��4pa\u0003�>�\u0017�x,9�\u0000��R§�\u0007� '%DFס\"C\u0016�A\u0015\u00011���&X\u00129w\u001aݏΧ\u0005\u0011�z��\u001d)&��݈�`_��Z���\u0003\u001e)�.�U~u8�\u0013l4�C�c��R��}�Nۈ�ˮ\"�K��A�W\u0006dJ2��c��yPض3�/�^P����\r\u0017��J\u0001���Ձ�%mA�j�S���j�ۙÂh��s��^���n�ۜ\u0017_\u000e\bx�5�a[ʄ��Yʝ�k�Z�Y?!��b��d����\u0005jSS\u0001&�\\)�zȉȽ�\u0019�W]\"%�kx��4?*��Ɣ\u0011�'77�K\u0016��'��\tͻ�l�D���S�o�uD$WX\u0017�S\u000e\u0002�_*����&�\u0006Gw�\u000bҴb�v)$�~���!�U8jR\rߴo��q�\u0015�j�\u0013Q�Dx�b�\u001f\u001d\u0013ϻ֤���1\u0015�T\u0012T�嚆�]-$\u001e7ⶦ\u001e�\u000f�TD&еu��Z��\n��W�J��\u0006;Y\u0002�Jx�*�f\u0003�U<�V����D&�\u0018/?�.RQ-F�6�r�SQ$\u0012�{\u0004���Wղ߲��\u0015<9R��v\u0012�J��\u0005��EG;�����ve�q�(��\u0003�?x���cR9��Ê=qD�W�IQ��\u0003��Z�y\u001fF�3���N\u0017�Q[��fDc�\u0015��xw�O ¯��'���\u0012|V�F�\u000e�\f'��Z ����ª�)g��x�a\u0017�U�\u0010c�q���)DB7i����p�\u0000��Tf�\u0000�-�tMC�M��\u001e�\u000b�?4�1�\u0007���uU\u0004�\u0011(=\u0006�ZZ.�\u000br8[����.�=��\u0006)�ʭ�3ةڦ\t>�B=\u0014�۱h\u000b{�V;��\u0002�o/�����P[��\u0014��\"�\u0000\u0015eu|�ŭR�BV���\u0018�����\u0014��i:3����\u000b�\u001bk)�S��{�W�9�L}\r���q\u0004?H3F�!\\.G��\u0000��Ұ�\u000b�i��~(��y�݌�\u000f����δ��A��\u0005�̌�Dw��DL�\u0001��\\�\u0000\n��[i%��o8�n�˳�uOp.���W\u0013<�#��5\u0012;g�;e�h�g�๞Sʥ\u001d�j+{z�T[e�+3A�R\u000e���D%\\�d\u000b\u001b (.F����d��nO~(�i�Z'���Iq��.q��wg�x�\u00193l8;��hz\u0017\\�1\u000b�\u0019�؟\u0005�\u0000j�5\u0017e�j[�j\u000e#K\f�N/����j��?Oɱj����j�\u0012;���:��+�\u000b��[v��6e+*�}\u0017w>u���Ff�[�\u0006�\u0016�V�:�TύX�\u001bZ�Ԩ�O�3ٱES\u0006>����nu�\\��b\u0011���\t:\u0012Q-1�OH����\u0011�2\u0015\u0004X�xAsֳ�\u0000��\u0000���5\u000f��P�\u0004�4�u2_:�����(�[����G����v��V�A\t�/��\u0013��K�i��M�\u001b��8B;�t���h\b�'��\u0019�\u0010��I\u0017v<�Vwg\u001d�9�c\r�\u0016�\u0005難�\u0014���\u0000\u001eդ�\u0013(J��Y^E�;WrG�\"!�=\n��mY�VM@�6D�\\���M!\u0016�Е9�;��Բ�+{��$\u001c\u0012\u0012���ӫے�6�ET�:�!\u0012�a�r�\u0012,�e\u001f\u0011Xl]NH��{�qn�8��$\"<�P\u000b�>j�R]�+��RB�9\u0004\u001a\u001e\u001b \u0019���|�\t�-�\u001a}����\u001d�ä�{>5:h��t�Ɓ֔\r\u0010��\n�D�B���U�\u0017.�i�}\u001cC�֢:�E�\u0016��%x��.\u0017Z�&�kx(��\n\u0002T#S�ˆ�iT\u0011\u0005�\u001e&\u0017��J��\u000f���m��X&�r��Qi:P\\�\nq�\u001dL�����E�x�\u001dQ\u001a|USk����C`�i�?(�\u001cy�A\u0012\u001fdkI�LU��ms\u0007mȑO�\u0015����>y_�U�I3.rE�4\u001f2T�\"T��\f\u001f�-��\u000b ?�J\r\u000bO\u001aMHͮ\t�;ʩ�|j��\u0017r��:I\u0019�_m$H\u0004��k�Uh�%\u0003�-&q�jY6�\u001c�N��\u0002�}�M���=\u0013�77�\u0014�P\u001e�x挱ѡ\\a�o*��'�lq\u0012�r\u0017�TT^��f�B�\u0013o��Y��2p\u0013��xR��j�d�2�x\u001cg�\\�K,z�@[� @HS\bi��5]X���[\u001e\u0005\u0015L`����\\yF<06�^���i�`�z\u001c�x�F�h\u00007�S�*��?f� +@\n���m\u0016;��W����r��$���Q\"�N�QZ��/\u0013F'�ISnh�&�����<�팜<����\u0012{%�\u0015�q�\u001aRO�?�rY��.�> y��X[e�W'!\n{$Ud�W?�n\u0000���&�j��_}7����hC\u0011�\u0015W�\u001a������+�����G+�����ְ�@s���*�w!�TL��)hޗnl�[$.����D��MZ��6��\\�Zg�\u0005���\u0016#�;wc&��+�*���\u0001�̢�\\�Yue�}�\u001c/6r��f�}�?ʫW�\u0016K��`=a\\��ݹ�d6ĳ�Ƙ_�8��=��\u000e1Q\u0002��\u0014���滇��C�M�\u0011��-�f\\RX�vB\"�S^��������������\\E�%̮��l�=��9�Kč��yr��\u001d'=Հ�uS\u001d|i=�H��(�<+�/G\u0010Y��\r&��r�{�\u0000�i\u0015E(sϊc<�H\u000b�p��i�U�\u0003�\\�wةw�\u001bS���di�2�F���#^HB��P\u001e�l�\u0017j�z4�\u0007�)��lG~�?u}`�=�i}(�\r��\r�\u0014�\u0014Y�~5�3��F4p\u0016��'�\u001dR�8ݽb��\u0014\\��\u001f\u001c�H�k�L�i\u0015\t7Y+pn8(\u001b\u0004\n�Q�\r08\u0000AO$JĆ%��ΞV�jC�IB�#K\u0019�\u0014NX\u001a(ť���b\b�\b�iօ1�4�\"\u000e0���E\u0003�\u0001�/u\u0012�\u0018��g�\n9��:҈\u000f\b*��/ʔ\u000bx�w�\u0013�D\u0002�V�S`�F^�ߒ~\u0015�V�3�\u0018�\u0014�\u0018��v�N�7%\u001e7kh��h����g\u0010p��](�w������\u0002�[�\u000e�u��؍Y�w��E=aꟿ�e0�\u0002I\n��&}��V\u000e��d<�Wo�{G��\u001a��\u0018㐶�8DI�\u0012,��\u001a�E2����(7k�Z%��èN\u0012͐�>�w~�_�z���,ŉ[���ij%�&8jr=\u0011���vw�?,T����=;�&K\u0016��@e�U�\b/$\u0000��Ua�H��6��>�]i�=��/i\n�X�L}-*A7�3��\u0003���LW��>�h-x\u0003�1]\r#h}���C�\u0000\u0013\u0018�����\u001d�^e��ӗf\u001c7�\u0003g\u0010W���?|�a6RN��\u0016CB��L��\u0000�M��)�42j��'��I\u0010\\ܛ�������5. ���@�}�7u��?28\t�/XW��A4e�Cpi~�QPYϭ��\u0000֞v_�Zѓ>�c��k�z����쩗dF��\u001dm!:h\u00049P?��K}�Ȗ�԰�6�N\u0014PzR����8�ʪ-mw�u��'A��\u000e�\u001c?�[�u?�B�\u001f��Y��*�Ŷ��/MxZW�P�zn�ڳ�X��&�g�7\u0006e�㍄rɢ\u000e7g���j�[��t��j@*��\u000es�>�G�����(�E2��\u0007� �^�i�U�\u0005��\u0012o\u0015N�I\\\u000e����\u0014M��`�n�≝��U�����9$O4���i��\u0000�t̙1�=�\u001d�}�\u0010nh�\u0011�\\��=����F�um\u00116��EА雟���\u0019�my/�ʤV��'i���o9�E%^�|�ΩV�N��\u001al�^u%�n�\t��5��\u0017%\u0013_ֈ-QrY~��\u0003n�;��,�.i��\u001e��ߡ��4T%��zW\tτi\u001c�*��=T늕�]�=�G���\\���\u0004\u0002�\u0017�\u001a�\u001fF\u0018���̸�_z�}fl\u0012��)*x�U�S���h,�\u0000��1ߵ}�y�m����P��\u001c��ڌ�\u001fI\u000bBw\u0007�S�rʯ�\u001b\u0015�/��E��m�U,��ZK��A�{֣��B��k4\u0019s\u0016I��\u0018�4�*\u000f��HԒ�b8 ��6\u0004��Ǻ��\u0019�\nF��\u001b6�8��Pl9q\u001c�搙�.n\u0014��#��'#��,s$G��Th\u001dV�H{�:~U{�Y��-,Q��]r�EUƨ�\u001d��,�\n!��W\u0015Q�K�\u0001s�������\u001e\u0014ܜ����W\u0018<v]��rLt�}�Z�>»\u001f���|�\u0019h�q�y\u001d�Lx�h�v�c��\f�\u0004��)ᚔ�/qn\u0011�e�\u0013 \u001c�\u00175Wˈo�%\u000eb^5�x��Me[qI�¯�=���}�]��\t�\u0012,\u001auJwmԌIw���/V�7;�g���,���4\t�@���\u0003�J�-��.\u000b��cC��O\u0017P�x\b\\=���Z�D�\u000e��ζ@(�&U\u0017�j&���\u001b�\"@���L��]\u0017;:�U��٩\n&QEp����_\u0012�鷺���\n��_K��n�s\u001b{3= ��m��E�7b\u0000\u0013�c�.e��i��\u0005H�ʐ� A1�+�Ze>T�\u0004G\u001d'\u0001z.j�����!�E3��Q��z�J�i��`�\u001b14\u000f+o\"�\u0014tp��Qe� +�M���?%,Q6�\u00036!���&��UU�C�)<&�����|����������57�p��ܪԭ�+��e�h;ϑ��f��z��ma��]�\n�\u001e���n\u0012�2\b�[�\u0001'*m>Y\\�i\u00017��f�����Uv�\u0017���H)�ܯ6�����\u0015�7y#6{�\u0002*\t.j��H5mP�DN\u0013���Ŵ�\u001e�i\u0013�T�\u0000���k��(F7\u0013���R���Q�\u001cUQ^u ����� �eDS���\f�~��\\\b�o�)�ty)\u0017�\n۹��X:��T��\u0011֑Oi&|\t1Vh�x�\u0001�/�_\u0003L\bPˆ��\u0012U\\4u�\u001d��O�\u0016�(6#��?Pݠ�TU�8\u000e&<ƾ��s�-\u001a�H�ov�\bl�`8��&�{@_�\n��P]d�TV�ߣ��\u0012ocs\t�̽:�#��\u0000Y ?�>U�2s\u0019\u0017G��}��z�Y��p��n��8�5��;��r�n��\u0007D-?M>˥�\u000e?t�\u0010�qȅ��|�\u0007�!�T_.��J�ҵT\"�9����������\u0017VA\u001d�\u0005��_�Zp\u0012,��0�\"�e����\u001f�\u001a[�A'c\u0010d�;��[���j�yQv�\u000e\u0017q!W��6*J@��,RjH�\u000b\bD\u0019�X_�l�r���Q\u0002�\f\u00117:��T���\u0016���T1\u0003�C1��ϟ*Q�7�s���On�\b觿5�\u001a��9T����Ư�b�GTu)�3�Z\u001f#X�b��R�E�����ح��4�H��w���$|,xf��)]�\n�>\u000bH��ֲ�D�G�K5��W&#\u0002��,\"⻗BY\u0017L3i�\u0019��\u000e�n�\u001a�\u000e�`�^���&P]B��;�y�2V� �h�\u0017���D�4b�\n'���\t3QH^}�\b�\u0004y���kK�m���A�\u0002N��J�3�w�A��HV{|��h�<�\u0015?��at�\u0010V�\u0004IUHk�%gJ\"�R�&�'�U\u0011H��a/�Ι�ih��-o8���PQT��<��g��i�;x�\u001e�\u0018\f�^�\u001c�Z^��Ĥ\u001a#��[�S�JCViD7W�K�[ä\u000e\u0001).��\u000f\n��\u001a՜8#e�J�>��G��t�6�Z�:\u0004����v|�w?���~�2��s\u001c�Ex\u0007���ؾ�\u0000�?Qh'���8�W\bĩ���h֔�����ה\u0019w���\u000bN�\u001cץ�n\u0014���\u001c.\u0012�1�}\u0007�\u0007L�\u0012���\u001e\"\u0011�#�r\u001d���K~��X��\rjՎ�����{����O�?�F���m��)�G��d��\r�z�m�����g��M��VF���ӄ�\u00198{o5\u0014��\u0000��Y�I�K��ijx��E�\u001e$���Ӗ^�m���j\u000e�<�6��\u0000ƕ�vos�1>�=w�e�aiԝ8���}�E�z�\u000b��Ռ\\)��g\u0011tB\u0014�K�\r*����\u001e���-�e��)p�L\n\u0000�\u0011s�ւ�/_a1�p|7.j\u001b{�\u000e�xu���\u000bq����O�W����n�&� XP\u0003l� \u0012U��\u0018��NJI�j�B�+ٳz5�\u0019H�B��I�Q*&�\u0016�,�q&��W\u0015e\u0012H����g�\r\b�\u0005�iV��JD�Eޮ2dE�\t}U�T���\\Dd�\u001eQ�yT�3NE=�rT��P�[:�ū��\u000b��6�9SJ}n�}p����mmz�\u0017�\\�;Tj\b\u0011�z3�M*q<����\u001f�]�M�k�\b�|�!ˎ�\u001e��4\u001e�qTuZ�l\"�E��C���pu�\u001a�\u0001v�Ω��le�\u001cV��7K9C�O�ϵ�\r8պ1\u001f\b�i�Ni��C�\u0002�y�Fxդ��\u0011Բ�|�h�����:1���\u001b1�fh=$�$*T&�\u001d�2��o�wJ����V�\u000b;��ָF���oN�\u0014���\u0000��\u0005p��\fc�_�!�\u001a>�\r��\n\u000f|i�[RD��1�+�曥�૆���eR���\u0017�\u0012�x�\u0017��TZ黶��9�m;��NY�L�3\u001d���D����\u0003�RŴ:�H\u0004�E�)D\"�ݙ\\g5<~�\u0019�Qȗ�\u0018�]�Y����e��.��e�\u0001F\u0001\u0016շ��r�,���5\u0014�hz�-��;U�3\u0004pCg��֖���\u001dԈĘ\u000e��ާ�4�\u001b�2N�/\u0007\u001b|Qx�\u0010\u0001�#��`�ڱ�D���Ժ\u0006��\n\u0001�!Q求U�QKͺtK�(Ґ��n\u0015��Akq�m:=�\u0000�O�>��<��7�\u0010ZOU\u0011h��1bW\u0011��&9�k���\u0010�m��\rz(�v�\\�Q��e��S�J*���_�nx�\u0005�\u0014�浲�s\u001du�;��\u0018��\u0000�\u0019����hI̓�S��\u001f\u0017�\u0001��i;��`9�\u001b�jܡ'�%څ���hV\u001fC\u0005z*\u0013�x���R�q�e�㱂wwp��4�\u0000���y{N��i\r�:B�iӕ62@I\u0002n6�\u0017h�\u001ak\"�^�&�����\u0018�j�2\u000e���x��=A��N����7�\u0016\u0005K\u0018�*�9��k�;;Щ\u0002\u000bC�\u0013>8�C<�\u001b�*8b�ʋ���ޞ�\r����tE\u0013wO?�\\6\u001f���\u001d�-�\u001b\u0006�V��W>I�O�c��&�\t\u0011:�\u0003mmJ��L�\u0000a�\u0010�G3�_��o\u0015�\u0000-��h�S�J��w�&M��^\b���Ԕs�W�l\"x�k��-�96�h`I�E�Cʚ}fy�O���Wi����x����a<\u0001�\u0011~<ꞾĒ�o���(��y2?鯯]�}\u0019-:�4� �\b�%3Gq���q\\�����\u0007f�ȓ\u0015�#іX\"Z�����\t��G�ו��S�M���ֵ\u0017̽e�t\u0006���-�;\u0015�k��0��Ωˍ�#�����WJ\u001f��P�\u001b\u0016s�\u000f��`��_?*�4\u000fm\u001a�DI\u0019V��0(\bҺ��\u000f�ڮ\u0015�ET��Z��\u0016EqE�`n��ݞ�.���n%�Ł4�\u000b�Xd�\u0000�\u0000��Y��{:�؛\u0017\u0006���Zp\\U�-|�Y{� J'�5�\u001b��[�q��ҏD\u0002TJT�E�\u0019�L��\\�\n�Ŗ��+����aDÒ/є\u0007�\u0004?¸�A��r�ܣ��;W���G���ޮ��\u001d��mi\u0018��k�Ӡ(N�y�����\u0013��+\"\r?�숂�5�\u001d���h�|ht�s\u0012J\nD�r��\u001b\u0019��3cTŎ\u0006���E��\u0002*�Zg'^\u0014A$PlQ<D1�\u0007\u0006��Dڻ�]q\u0011�)r2_T�oj'�*\u0016�\\����)�)ޟ�G���G�C|\\\u000f\u001c/J����}W�q�V�T@?�]/$\u001bSB�\u0004��Q\u0007o\u0013\rS��~<�*�8G��kh�{�;�a�쏙s����\r4���8�ѝ���wk�{\u001c�\u0016�H�=�lU�W%���W;�';�����Һyf�IQ���:��?o�n��F\u0004P�^�M\u0018��\u0007��E\u0019�u�H�\"=\u0017>�U:\u0003TH�vz��_�\u0011I��$Æ\u001f��Ga��J\\���N(6�dA|\u0005zW6\\\u001b\u00068�?>%�=�A\u0013j\u0005�\u0011\n��k.�\u0019��\u0019-�-��\u0012Z��HѬR\u001cd��Cv��\u0015/��l\rs��\r�Pe��ܮQ\u0015z- �\u001e\u0010\u000b]��\u0006���Un\u0011�ݻ�<\n�y�>\u0006����\b�(��@��o�G�.��2ES\u0001E䔎��\u001d�{v�7�\u001d�L�=C�J]�@+ԁ�#�o�H��D^�tv�mZ����\u0006��\u0016�\f�%\u0002L�kn��R�q���l>눫�\u0017�C��5��ԋ\u001d\u0010��\u0004�\u0018wT:�\u000e�o�<\"\u001e���:3SL�r��E�sTȯD�\n�&ѯ���y���M�B���~\u0014��B��0�g7�N�N���H����n��A�l�n�<w�~5S��\r�g�!���n������Z\u001b�!?�\u0002&IzmZ�imp3Z8���\b�+�W?�Rv0��\u0001�l�\b��\u0010W�\u001f��q��/�\r\\h}TT��ή��V\t��K,�y )ꧭ�J�u|�.�܎�W�2Ҩ \u0018�4��EX�Kp�\\\u001fE��\bE\u0010W�=�_�\u000e�$@hN��8�\u0016�A��\u0019�\u000b\u0005�i(��\b�u2�^f�a\tw�FQ\u0013�@A�ʡ\u0013+6l\u001fW��G\u0002�i�0_vV�_˥[r���I\u0017\r�^�\u0019,/:\u0006}��\u0016�Z���T\u001c\u001e�<��\r0\u0004xm:{Ti��,�v�W�R�.��ml��\u001d��<W�����\u0000�Q\u001f\b��\u0018���:Ǯ\u0007�\tz~�B�蛒��$�%ЇƬ�\\B�\u0014�\u0017%�\u0014��v��Ө\u000b��\u0014(\u0002��D;2�\u001d�4U^��R1�wH�(����r������\u0017���$��\u0003ꤏ\u0012�����\u0010\u0016ƴ��(�6��Us�P�s��UW^S_*1'EN�ژ1�\u0013�\u00174\u0002�\u0006dW�\u0014a�%4�m�E%dGRX/��*�f�\n'!��*-y��#\u001b �$�<f�;%�cv�\u0000M�\u001d\u0018m�l%翮(�K|\u000b�D��v�<�q�!��'^�Fl�Y)��/�����3u�A-�!4TD.x���vO\u0002�\u001f���~���˴.�.\u0016w@�6��ڤn\u0007-�e\u001c�]��\t�8�;\u0007�i>~\u0015��^��u�@�\u00053�Lf�(V\u001b�`k!9\u000e:�\u0015)[����3bChbI��\u001cdE\u0012��\\����!���O�N6���\u0015�u��\u0016l1q�\u0001�\u0004�\u0019�)kk��l�.Z�\u0013�׏�D�DQ+����k�:\u000e�+\u001cp�%� yb��Aȷ(M�A\t\u0013�|)�m?oԱ�\fUD�L~�\u001c\r\u001e���<q��\u0003�\t����s�5�;vӯ���[$V�\u001c ⥚|���pS\u001c��9�D4�7%2a�Lg�Ί��_UFW���\u00177�\u001d)\r�D\nm���(ɶ3��u�U\u0016�j�t}Mm�2\u0013����\u0007Z�!ď{� \u000b�Y�)�\\�\u0000x�wK>�\u001b4w\r['���x���2%�u�\u001e�\n[����J�]Q1���p\u001b&S\t�b�^ͭ�i��m=}��j�ѽ��)�KY�N�\u001a�H���\b�yV�&�U��镯]\u001dÎ��lŃ���\u0001Ε��\u001eU2���\u001eO�D��r��H�6���W��\u0000L9v���HL��D�]��e���h�*��El#ʒV�s�SjGΞӾ��6_����\u0018T�Q�d���u�}�h���(p��\u0015TDT��\u001a�A1}GX8��$EJ�n����%e\u0017\u0004�x�\u0002�aq�ƺ�<�ެ�d��g�G�8X�\u0013J���]\u0017ڟd�\u001b#�G&B3 ��ۏ�J��Y�G=���\u0002�\"gfk��{\u001c�Ɓ\u001f�/*�\u0015J�>FH�S�V�yV��B=\u001b�Zsj�L��nLG�a�^D\u0004���\u0017�k\u00150�J��M\u001dU�W�Z\u001d�,{n��I�[q��\u001a����(�h�ݶ/\u0000¸.4\u0003��\u0005�}��<ciWj��uK�\u0012i���d�H�\u000f\u0012��<9�|���\t�\u001dC�&�\rK~�Q��\u001d��wc�Lg�h\u001e_\u0014����\u0014֓�\f�q���\u0002��.Co>X��0�Xg\u0014�Q�b:�@󞵔�,�\u0015n�f�uGk�hf���ZR,\u0013m�Y�\f\bG���\u0010��xP�}����X�:M28�ʵ.V��V�\u0018�u\u0007mi���\u0007Y�gڂE��\u0000\u001d�\u0012&\u001f\u001e\u0011��j˾@--vb�\u0015��;∘E�4��\u001d>��E19�e\t�0���������!�\u0013Lʆ��UU�?d�²˦�p��{����Q�lN��o®\u000b\t�\u0010��t��^T�\u0013yB�����d\u001a�;�\u0002\u0013\u0017~�\u0011�©�O�V\u0016��+\u0017\u0001���y�\u000bc엽k+����׶�֖\u0006�Z�\"�[�amr���Uv�VC����\u0004K;�\u001d\u000bƦ\u001d�\\��N|\b\b`\u0019*\b�,-Nul\u0016��bȂ��* ���\u0014�������j���<��\u0004�mmM9-Cu/g�\u0016'�s��\u001dE���\"��T��z\u0004��٫|\"B�U���{\u0017�Z�=�آ����\u001f��ma�\u0015Ū�\"�b�\u0007�oS��f�M7�DIR��4��>K�\u0011EkMe�.h��du�\u0018�*i�\u000f��CAܒB�@�!:�)m���l�;7�xB�9�ڸ��\\��g��l����\u000e0A�+}9*�m�?X;����qR��\u0007TA�ny�4$M�%�\n��ӗ��MfQ�3\u0012>��\u0003U�%O�^,څ�\tm0���\u000f?\u001a��{$��8Q�\u0019$)�w���\u0019�)ՏE=\u00129K�b�\u0000r*I����ރH��gv5��F���OQK�j��\u0016$�6���z��t�=�4\u000e�]�R\u0001�E��[Sh�\u0017�K\u0018�p�L*Hm��^]jo`���͏�'Y[�\u000e�h+�\u0014�\u0000�������\u0019M��l\u0007+��Z�i��\u0014Se�o�C��i��ҍφ�q\u001dm�\u0010�\u001f\u000f\u001a��,\u001a��~��\u001c%a�]���sR��:�(�h�\u000b���D\u001d���=\"97��CqQ=eO��Η���\u000e�\u001b\u001f���\u0000^�\\��*G�M�\u0018��BmńD%�\u0002I�:���7(�8E\u001c�8�\u0013�Eb�u+r\rx,+D��i��S(2�qG�\nٯ��J�Jͻ\r�D�a�ƨ����򥯷%��Q��HtS���ո���\"\u001e���\\Pˎ��]L�Tmۺ�h�l�\u0015�V��(>�<c�<�\u0000*�c�fCHF�j���k\u0007D�b>.5\u001f\u0002=\u0001i��C�\u001cB\u0017Q��g4J$�\u001b7ID����B\u0003��&(C�\tI�\u0006�\u0006s�jJ�w\u000bT_�h�9�(��,���A�K�!\u0016)z��\u0007�i91�Hu\\i1�$�ץ5�\u001f�\u000fGyQ\u001btv�*z�Sۤ1�\f}\u001aG\u0001O8s?�Co6�\u0011�!H�M?i�߭X�H����\u0017\t\n��-��x���UG�\u0017d�?Nm�3ޔ�\"����Q>\u001c��-�`��\u0005\b��TAޥ���[���WV�\u0018Oˈ�\n,����\u0000=P�+9����MNgc�T^KRۮ���-���\u0003\n��&*�~�o��\u0019�m\u0013��WjTWT[#�\r\u000b\u0002�\"\u0007�!u��,�G������\n�$H��5?��H���8]\u0007\u001djkkz#�m�Dq�Kơ���k�pm!�/IeQQZ\\cw�QmE��\u0010=\u0014�9&�\u0006x���S�R�����qQI\u0011\u0010�R�v\rC\u0015�J��� �)+�*\u0007.�\u001a^�z�\bTX��<a\u000e�vZC��1�OB\f\",�Q�QLs�>�Ӯ����Zm\u0000�1�Ƌ���U���j���\u0006(�lʷ���1�\u0016�\u0000�%�dYm�!���3� /��\u001e�\u0013.\b�����m�u�\u0016�\r;=��#�>]U+��s�\u0014\t9/%�wO\\�\bK{\tα�v�)*-��\"M6J]A+h2U�\u000b�;j��4�E'\\,�D\u0015�ń8Q�Ͼ�\bp%��\u0011��6�H�ᾔ�9����g.Qvo��8��[���Z:�$\\b�i U���3���L�[\u0019}�\u0013m\r?�\u0014\u0007��6�\u001ek[�\u001b�.�\u0002��B��ج\rQm��X��!\u0013<��ָ\u001b�\u001eȯ�?\u0011�\u001c�i�BW\fp�~��W֗a�\"�0�iU�iZ%����y�tU\u0017#�֧��%\u0007`K\u0014\u001a�|:�]�δ\u0019�\n&\u000fb&:�9��\u001d�\u0012��L�����z2��i�54q���1O^!�m!�\u00002b�?��eV�>L:?`�i���RD�\u0014��l� ��M�I%-�T��������w�\u000e��h�V�+\u0012`��\u0002<�A�|+������G�\u001f�̌3Ü]��~\u0015[s��]��v��n|{-��펖\u0000�y��i\\��/�hǒ�uz����)�L\u0003m�\u001b$q�\u001d�`�BJ��Ѧ�4���h�dȒ\u0004\u001dr`\"\u001e�����<�YmW\u001d\u0006->�\u0018�����\u0005�4�m�\u000f��Kn2�a�7\u0001�m�F�y���\r���`����\u0000?Γ���AzSN\u001d��v��]休1ӭ\u0013�\u001c�\u001b�\u0005�\u001dץ��\u0001�ΤZA����#\u0017\u0010K�ޛ�\u0000����M+q���u�6���\tg>\u0015M�hs�Wd�\u001b���-�\u0007���L��6��/G�����\u0013�\u0019\u0012b�+J|�v�~t[Xj&��j\u00126N�\u0016\u0001\u0010\u0001y�٭E첟�]FV6��ɚL�5G�g{���m�ۙN���\"��Q\u0012��]�\u0011֜�7�yԑ�\f-B>��\u0001\u001cD�<�5��o�H\u0002\u0010\u0017�L����f�\u001b\u0014\u001b�蘑a��Mo%��UM��\u0016����&As�\u001f\u001a���iXm�D���\u0011|h��\u0015\u0006����\u001b~\"I�(j�IQ\u0011�}�̷�0�O��[u\u0013(��k\u0000��i\u0003q'#D�Cn6+F���,!|�;U\u0012���]r���`U��ZU�:[�t\u0011��\u001ch��\rAW>�$�\u0015��\u0017��0*��ϑU�2���#@�\bM�$.&Qi8�#C%(��l���f�ʆ$;��_n\u00189p\u0011`��i��T\u000b�7\u0005\f�\u000b�6�ŦR\\vq�p�\u0017�68�\u0002��P>��\u0011�kD��s�\u0016�C\u001e@�_Z�@Ā�ʥV�\rl\u0003�q�Яa�HB$\u0017�\u0015W\tC�\u000bJ�#t�zQ����>\u0014�\u001bϾ�d\u00047����L��E\"i��c\u0019��&d\b�>4��\u0006�h�\tnC0�4\r���h�\r.\u0007�*0GBͰ7\tqʂ�\u001bcW6��\u0002�O\u001aԭ���\u000fΟ��s�[�I�|鱛,`\u0002QAE\tw/�J�.5�x8�>����y��Bq��\u0004���0�-4X\u0012���R6��b�j,\u0019���\u001a\u001b&�\u0012#��\u0019?�K^\u0014��ӭ\u0006G\u0015�>�F��:��3P��a>1�l\f�<��\u0019� uA�_\u0003�@ْ�]\u0016�\r�Q\u0017ib�ġ����\u0005�1�K�\u0003AE��V�x��VG���\u0003b�\u0004�?\u001eT��ߢ\u000e����P\u000b��\r�6�i�\u0014��]�qt���Z��Ĉ۪�;�@�A\u000e�rm7;ă9\u0012vg���`��ڀG\u0011�]��R(:z�\u0019P�#<DO[e\u0003\u001fe%\u0003F�R\u0017\u0005I�N�!�u���f{$i�\n�6-���\u001b���5yɌ\t�\u0005\u0010Q<\u0012��\u0001�NiBՑȤ�ݟ�m/\u0011w��i�­'\u0017�֌\u0010����3Wl�Dd�{y�SV�\u0000wA\u0010S�V]�)����\t�AA%L!m�P��\u001b�m?I_�\u0012ע8=���\u001br:+���\u0005LЫ���mr�9�銲E���nt��-��\u00053S\r7<�\u0011�>�Җ�\u0002ܑ�cf��A�m�@�\u0012��f�8�S,�9*�\n�>5`ZnB�m5�\rS��L�B���FXՠCȕ=���:طb\\�����#�\u0004�s>�*���Y\n����\u0019���;�E2\u0013�?:lY�XPf������a��\u0011{���l��u\f ��\u0010�}7%R����/�I��\u0005��\r=�*}e�\fD\u0006X\u0002�\u001e\b�v�X���\u0005\u0010EH�\u0019�D[��Q�w�����Y+SG�\u0004���|�D��,�I�\u0012S\u001c�I샱�<�P(\u001d�%���\u0011\u0005_m���'Rùq\u0001D\u0017�]�/\u0014�A���$\rek}�E�)\u0004���9��^�;0�g��e�a4Ar�-l/�|>U�CZ:�\u0002��\\�Z����Ғ\"M�r���\u0012*�\u0012n\u0002U�\u0000�?ʺ>\u0016m%����������\u001c\u00170d�\u0004�)\u0010w+Ҥ\u0017��/��\u0011i����\u001dA�k�ǧ\u0015���J��E\u001cyֻ�:�nI�s��M\u0016����b�i�Nb�)Y\r���L��2lHW�b��E�/N����t��-s��9�U8.2XQ\u001f�_\f%eRh�\u0013�e+�轥�>�γA\bn�\u0001�?4\u001a�˶�n��V\u0001\u0006L��\"c;�3򩥾0�\u0018I��U�zkE�q�\u0013ļF�p)�Ƽ隢\u0013�WgN5�-���\u0006�D]<�5`�C�uV�Uyc��$L'�Rض\u001f�/�x\u0000��;��\u000e��\u0012�%�8vS�\u0011/4\u0004�\u0001��w\u0001�m��\n��ܽ\u001c]wj�\u0012�/Jiv�\u0003�#����L��\u001d���n��Ę�\u001f�Y\u0005pY2\r\u001c\u000f���\u0006��\u001aVFt�٨��\u0016�&���r��iBR��\b�sUNT�l1�UM�\u001f-�4�lC\u0016���)�b�������u�Y�<��^����\u001a�\f4�d�\u00174Z�bl8��-�m��ݥ�AE\u0006\u001dy%4B�\u0000x|��S��d\u0014�\u0013�2�z\u0016�6/ⴊܞ��x��JS��9\t\u0000b����6�e.K�7�\u0018���(��0\u000b���a##�Β�\u0012\u000b\u001dsETG�LT?UOXQ�3�慐E��8��e�as�����\u0000\u001a8�1�\u001c�������^x�*��Ј\u0018\u0004U�\nt�v[t\u0013�\u0018�g�N�<��,Ы�m,� ��f��b���u�\u001e�U�T,�\u0003P�\u0017�\u0005\u001dA\u0019�Q7Grx\"�\u000fjFHU\u0005�g�AdX�\u000f�<ETD�_ΐjP\u0016j1\u001eC�MW\u0004Л� ��\"��m\u0014�*\u000b-bh�6�aW·I �ր1xm�M������P\u0005��ܘ�N}j|�\"�'�?�ꆭ�\u0016S?<TEo��ww�\u0011<3Q{��/7\u0013$-���-��h��\u0014,c���\u0007G\u001cPB2\u0013@�]Wƽ'~�f��L�2\u0012.;�M(@\\�\u001c%\u0005�/�<yթ�\u001c\u0010zD�aq�Ui�M}�UN~�\n�2[���ʤָ%\u0014\u0010�rK����v\u0017$,�\u0017O(��a��.� Ғ�twb���g)����غ\u0001�m�\u000fr'Jx��\u0006��>\u001c�G�;d�Ƶv\u0003F�ڔM�k�\u001fm�W��(�\u0017\u001e\u0018c\b���\u0014\u001a�C\u0004�W�s�P�7�M�\u0007M[/.��!5Y�i�2�8�#\u000eayP��o\u001d��y��^��d���\"�l.�fQ9\"�&���\u001cШq\u0000\"c������\u0019\u000bI��D\u001d\u0015N��=:y�C��5�y�M��xx�}\u0012��}5�c�\u0004\\\u0012�$�k��e̙��c\u001d\u0017�RJ�A��kڣ^�P�ݤ}^N\u000f\u0013����G���g\u0013��\u0002�r\u0006pm\u000eX�X��`�l�,��\u00033�L���Ug�]r��I�s�$BL�O�+�\u001e\f�Mt���l� \u001e�!�,c΋CNLPGV^5�v#�\u0003m�s�%b����{��3ʹ/�\u0000R\u001fY`f�\f|U\u000b�X�g���\u0006�9<<@\u000eH��\u0019�x�����5m�\u0005���Cu��]�ąoqx�\u0016���\u0000�j概\n<��R�3 ���\u0011\u0012_yP��8��G�SH�J*>�\u001b��5_:�D�\t\u001e\"�\u001a|*���[��)/\f|\u0011W�\u000e�k���O�����Uu��%��^��i#j�Y�\\����E;O\u001c��oly(�;�����4��p���a1�}��;����\u001b�x[��N�>���mdF\u000f\";A�3�\u000b������V����*!�%�n�8����~4\u0005�wf��?�g���in(\u001ar�)\u001e^Z�Ԕ�W\u001bZl��\u001di�{��d4\u000e\u0016Av��h[�ʝG��v��T\fh� ��.1YK>\u0000E���YP���\u0005�UD��Փ��GuDG\u001c��\u0000�F@\u00145NIҥV��48$QE\\��x��SC\rJH�親��r�H��\u0015��I�U\u001a�\u0019��\u0004|��b����Y\u0005\u001d����_:[�i\r-��kT�$\u0017k*���D�E��\u001dzP�-��q9���N���pG��\\�n�\u000f��\u0014gn�\u0012�\u0015\ffB�����t)o(�\u0011�<)�\u0002{\u000b\t���\u000e\"�d���|zah\u0005����e\u0017$U���QK`�Us��C��s�y�x恱�\u0015�@ID�]\u0013�\u0014l�6�rO²�\u0018c����OI�'E��!�\u0006QP�)�x�j����ȃ�)�⽐[��*�AN�����$�ץA�L����EګR�Jd��w|�\u0007w��\u001b÷�9�5n!؝�\u0015��D7����VՆH�F��<f�[:p�,��\u0000��Y��ڀ*�\u0015Q:����I\u0012��K\n�\u00179U�\u0014��@��5���\u0000*�ǹ�rp�\u0013�r�\u000b�Ǽ\t�$�`���j�\f_Hk\u0010%O�r��\u0000�E���~�&$��wS4���\u0005�\u0010F�wr{T�L�\u001d�>b\u0007 an�w�R��I�,�E�FAwc��Y:\u0010�+����D%\u001c\r/\u0015U;�/����4��\u0014� \n�J��%�\b\u0010�㚎_�\u001f|�2�k��R\u001dB��Y.7uW�y�\u0012��ʞn�wT�ƗВ%:NЮ�S%�Ӗ:U��\"� �a(V��){��M�\n��Q\b��\nT�\u0001OYq�*^զ\u0000~�ÈK�6���&��\\sZ��\u001aD D�ʙ\u0011R�ɋ+\"( �4��sE�@\u0016�E\u0013��\u0003\u0000��N�\u001d�ZtQ�R\u0019\u001c �- hQ\u0005HW9�\u0006\u0019L'Je%��|���\u0015\u0017`���& J����(��9�.���_�cͷ�7\u0001�4��L,����B�{_\u001a\u0016���׸�\u001e�ڊ�s��R�rި�i�s�*@ơm�\u0013���.�������ˢ��.�T\u000f�q.\n&I�鄢�냄j*X�DFb�So�F��mD%LюƯ��k\u0018�7�j)���ӕM�A$\f��4o.�ev��N��75D&�I�\u0002�������\u000ePh\u0003��j\u0014YNɐ!�S)���^�{X8��֭�F\b�y��>\\��~�W�\u0019\u0016d\u00051�O\u0000\u0013p���|��\u0017����l�\u0003�C�k�b\u001b\"\u0019�\u0000_���O�����\u0018g�GH��\u001d��ˀ5)[a���VTƕ�Zq\u0017x8�E�q\"\\\u001e\t\n���/O��ri���2p\u0000�\u0006>\u001e|�U�'�_����gEB���'\u0011v�,�y.��+e�A\u0015T�-��KU�\u001b!=�}���{�W�Ri�p\u0017�|+\u0017�u�k#:��蓕�T \u001e�).�*ӑ�VW�#��/Ν�,��\nm\u0006G·Ű�\r���i�.(>0�E��u��a\nC�^��\u0000\u001f\n�C�X�:o�i�?�T|)!m\u0014�9�\u0004��(=�XE\u001d�r\u0007��j�4���9\u001d\u0006�i\u0003q�[�S��J�]����\u0016�uK\u0005�\\�1�TݳW\u0003���\u0010Wh�/\"�$I�$\u0010��Η�\b/;\r�J(�8��mn,I�%�˺��|zU1g��\u001a�ϥ9�k��[&:8{ k�S+MÉ�ُ? �<�F ſ�\u0016ӹ�܉�֡���U5��B�>T�\u0012Ap�SrT1��'�{\fJ��<�URc��rf���uyS��dV�}�(a:�Jx�\u0016\u001fE]���N\t2�=EEU\u00159�\u0006K��W�Ml�����\u00153YI��9-e\bg�E�GS\r�<�֯H\u0016�\n�������28�d���<k�Y���{\u001ekK�\u0003�{�J��\u001b��h^4\t$�$B+E�)�3�%B�\r��AaUI\u0017��P��i3�p\\4P\\wR�ݤ�1�=�U\u0019d�><���3k�\u001d��I+��֙ch���MEH�p�B./\u001b��v)M�\u0006��HyT\u00138�\u000e���d�\u000f,c����\u000bb��B.\t!U'a�H��M�\u000f5��\u0011��Z\u00047\u0010g�Rϕ>\u0019$M�_Θ�\u000e��\u0019Z]�\u0016�\u001e��C\u0004����ҝ,�m�D��WE\b<H�aj+��4\u0012s\u0003��m\u0018�8J\nB�����\u001a$N�)�CD7�� �\u00199�9dq׭>�1����~�r\u0012ǝB��Ј~\u0014�\u0004�c \"j��\u00118u_��\u0015lɶ�\u001c\u000e\u0017��\u0014f\u001c��\f#\\1,��G\u001a�Cnaw\u0000���4\u0005u7��p�6��\u0000U\u000bD��\u0005��\u000e�f�q,(r��ױ�M�ܠ\u0002����\u0001n���\u0001�7��L��֞��R$2��d���E�4�\r�\n�m�p��nG�Qx�Q���,�y\u0013��u\u0010r�Q\u0000��*\u0001{Բ�\u000b�\u0006\u0004���*Rw���V�z�8�\u001c���\u0016Ѻd��+��I��Z�i���=\\22�⪡&*�+\u0011�\b\u0001'/΂����,�K���꺾��g�Ώ߯QCw5U��ۛ�M\n���ơ=\u0016���\u000b�=*K\nz4�U�sŻPK�;�T�\u0017�(�O�����o.\"�yԊb�K����ԧ���NU\t��\u0006H#�I�8�Ĉ9�r�P|2�\u0006I�\u0011UZj���!�Θ==L\u0014QS� ���\u0010��(Е���&*���CYAv�9�o\"\u001b��効f\\=\u0019�E\\f���_\u0017�m\u000e|�lr�\u0005���\u0001PQ0�\u001c����y�ɪb��Dq�UTkc���|B���#�~�\u0003WBBTU\\Tɋ�h�����\u000e=o\u001a�ݹ.�!<m\\�y�z�V���/:F�l�4�망\u0011��V��㵶\"G�l�\u0000t����O\u0006��q�mJ;��~\u0005�K���G�?��Nu�=iڅ�#[�I\b�\u0000\u0001��wg\u001fC��1�{��N\u001a�&�oy'�:ӃH~R6O\u000b��r\f\u001d\u0001����\\f\u001b�\u001b����.}ji\u0007賨c�&�\u0002�]+�.���ۥYF�i\bS��ti�Lb�p�䕹��*B��j�Y�F����:\u001aȊh#�r�%�o��\bn\u0010B�c\u0015���-���̖\u0000�|ǥT����l�Ӈ\t�`�\b(a�)��_��\u0007\f�'m��R\fyҟ�i�ԑ\\CE隴��e�t̃\u0017�)��#�U��67 �1Zc(�ї&\u0017��)�\u001a��\"�n��O\u0014���t1�&ė�������2\u001c�b�s���/��A.tJd�d�\r�\u001a�'D�!\u0019I{�ֆ35���4b�0��R�%/A[����a�ULT�\u0017�#Ɉ�~\u0014�JNe�D�\u0001!�uJ�Nʧ[�\u0000Gr;DD�\u0015Ǘ��yF�G�\u0003q�v�EIS`��%�\tS��:�5��j�\tYd�\u0014W���}\u000f�\u001af�~ӏ��\u0011���=��9*W�_�\u000fdw.ʵt�G\u000eE�A)G���.}J���,�#\u001f�\tF%gp��\u001e#����a�.\u0002��_\u001atE�+Lr�E\u0017^�\u001d)[\u0002�g\u001c�U~\n�4�3�i��KIi\u001f\r��t��$˝��L\u0000^[XU$�I�u[,g�9\u0012G��S\u0014���G��\b\u0010\u0005C�{\u0018�VS6\\���eY\u000f�lE��XE��Q���UI��MS�7r�D�J\u0018?��\u0012�F����ُ �>�\n�J\u001bh#����\u001e8�Q�J�����vh��kM�\\��&@<�^��\u000e��٤�\u0015{\u0001�JuG;q�x�,�Qq�\u000e~�\u0007S]l�QN�x�Z��f%�٧7+�\u0012\u0012����h:�2Y\u0016�ť��U�ݼ�\u0005D{n�\u0000zQ����TL�f\u0014E\u001e���_\u000eTQ�M��.s�J�a�t6�l��*��irq�kh�#\u0015�|\u0014�l�\u0000/*�I�W;L����\u0013�\u000e\u001b�*���m\u0015\u0000}��V��C��v|3OfH\u0018�aK�^IP�\u0015�[�U\u0013\u0002��Q2�\u000e&\u00053F�\u0011:�*A�<�\u0015\u000e)$&B<��P�wYjڣ`�ך�\u0010�K��N\u0016qҢW;�2��ʸ�D,�\u0016�\u0004\u0015��J����9�W^NL5��RwHO�w4I�\\&9���\b���M9-Ll��x\u0015��(���\u0000�SE��w��\u0011|\u0017�@��9T�\u000e�eW��\u0012\nt�Q-GnW��Y@�\u0007�E���a�^2�<���V\u001e6��p�Zq\u0001Kq\u001a� O}Eu\u0003�\f6rB��F��(�ǉ�¨�|j\u0003p�E\t��\u0013�S,��Jq���*�q�ҜBRs8�KR�\u001a�\u0018\u0015i�WG�ӕTv�V��B��`?�L��8�E2�T�G쌗0�8JE���V6��8\n��}]ˊ\u001f.1���ʦsΤ֋@�h\u0000��\u0017D%�QeY�ǳ�w\u0001T©/���~UYj�\u001b6�ߤZ��\u0000��e���t\fHJ�q�n��\u0003�4�Ȅ�h$��6ӒT-ʊ�Fv���$i��H�M><���ܶ�\u0003��\u001f\u0011\f|\u0015\u0016��_�Po�ܖт��x9aSΥ�/Zɇ\r\u0019��٦;뚊ПgC�y\u0001�IM\n���\r\u0011P����֍\u000bbH�W�ʽ-v��\u0000�Z�YD��\u0014���\u001ekU����*�Ӗ?Zcyױ�i�ܫ�r�U:�X8�'�Q�c�^�h�\u001b,�]5�Qc8\u0019\u0002ǈ.*�s_5�xj���*�=��h�8�����lq�]��\r��\u0017D�(���\u0017��m�L\u0000Nsg�\u0014te�[hRY\u0017��\t(_d�E�M�\u0015��/E�\u0014�\b�tq@�v�`���!ۣ�e\u001ab;l�&\u0013�8�H\u00113�D�3��\u000f*C��T��0\u0019�@,r�6~��H(��,֎\u000eG�\u0001�\u0004Q��~T��/,��F\u0016:��:h�|�?:�*&ȇ�m!\u0007P�q�\u0011����5Ν��\u001dZi�N\u0007q|0���-u���9�L��\t\"�`�+��4�d�]�#&5?g͝W���,�\u001bu�$\u001fi\u0013\u0015\u000b�k6�S\u0018Ǻ��k>�c_\u00180P\f�e\u0015C5˽��%.��㪺К�\b��]8y7Ñ�\u0005/�����Oc\u000e\u0013\b�*-:��C@t6/�)��ڹ\u0014�\n\\9�-\u0004�9���έ.�5I�qZq�DL(f�X���Z?e����E�@�\u001c8w6��_^�X\",���O%��lݘ��#FM�:�\u0012���c$\u0005�\u0018���=HL�Hӛ@��/�^\fK���yL�+x�5����\u001f'u\r�^��M��i[�\u0015�l�S\u0019�0�Qk���\u001d��2Y�1ӛ�Ò�<����ȶ|����VX)#��>?�6h�\u0015U\u00156��l�TqW�6����Ʒ.\u001c�C�*c9�4��O\nn&�\u001eR���y%��FA�&++bL\u0012����2\u001fx\u0016S�(�s� �8h��J\u0015���6�\u0017\u001dr��eé�x~\\��ΏfL!�\u001dI\u0013ʄj\u0019��w\b��W��\u0017\u001b�\u0005�Wƣ\u001a��리4$���S;j\u0010V\f�L����nn\u0018**\"|9P�\u0014D�)��\"Zz�>���}Z�\u001f@�R��S\u0018�>Xl�\u000b��Oj���\u001b��0\u0002\b>8�r�\u001e\u001eH�j\u0010n�ƛ,\u0012ӈ���\u0013]�_\u0015�N�`\\@Q�4n��tp���b�\t0�\u0018�\u0004�>�)��\u0018�[�q�J\u0014�b�\u000es�.\b\r3�<s�ʘ�c#,���'E���A���K�қ;y�ٖG΅;4�8�\b�1����k��\u0017��S�J��\u001f@R��\u000e�D�r�\u0003���R\u0006�G�҃\\Z)\r��\b�8�MɜP��/r\\��nǅI,Jć\u001aE,&y�mMdXl+�:.\u0017��*;l����E��=F\u0017���%�\u0010A\u0014\u0014NCN#�\u001c8�4X\u0014�ϥRq���]&EUw&\u0015P�&��Z�\u0011��\t�r-Q\u000e�+�r\"�L�nD뚉O�p�ڮdUUU\u0011*5h�b�\u0002y�]�D��<��v���z$\r�3\"\u0019���\u0015\u0007�Y&]��g~�N�8 \f4H#�����u\u00181�ig�S?\u001a[VZ�\u0019\"#�r`ZM�'�����V.���v�W\u0017~Q*�պ�\u0002�{�\u0019�6\u001dZ\r��,�u\u0015Z\u0005\u00161J�L�\"2���:���\u0005�B\u0015E�U�iC$7�e\n��.\u001e��*���H�J�s����'\u0010��J9r��D��Uv\u0017F�aLO(�\u0019����[�5sw.��j z+\u000e�J\u001c�h���\trA\u001cf�\u0010�n��\u000f%Ǎk��\u001d�P\u0014�(2.\"&W��z%4�@8쪊�\u001d(�\u0012������=�&<�������\fe8�^8�Ρ�HW��24O\u0015Z�˺� �K��HN.}��\n�8�\u0004�\u0006�\u0006��\tw�ʸ�߹z�a�o�p�����ࡳ�T�OP�\rF�6�\tZ\u0000D�\u00160�xvEc'էU�|H����*��Auǀ��W�c��\u0007���vy/�iB��\u0018!�\u001d\u0011�`\u000b\u0011\u001bR\f.(�4��S;h��n�:�vv��P���\u0017����)�Z|�7Z[C`5t\u0011\u0011p��C\u0014@Қ<\b9\\��H/C|SWP\u0015r>=i��B�ʢ*\".lLnL�P�<�\u0012}9%\f�\u001d�Z�\u0016� �*��7���\u0017h&&�\u0011s���9��T�:rt\"K�$���\b��,`PD��8�je��q\u0018���+�1]ߨ�\r\\Q��<�j��\u001a\t��8�;��qҶ��g7.;���=��JFU\u0012BN�\"�飶<c����ơm��U�\u0015D�@�V\"6\u001b�\\��l7�H�\"%�D�/\u001a��8�+�qW~���2���Z�4:\u000e�=�XY�zvm�����n|\u0017ξs^�\u001d��*\u0013���w\t�\u0015�-}%���h���*gʸs�\r�>��Rd\"a%��O�t��KS���;��\u0004p�I8�(ۙ�\t0��\u000f$\u000ew��J�x�VI\u001f�U��\u0000�\"�eqL!������]\u0000I2\\�*�����Q8C��E�\u001c'�� \u0015�_f�J��\u0000o\u0018��S�<��\u0011\u000f\u0011\\����f����\n�\u0002\b/�TgQ[�*�'?}O\u001aQ}Y5�\u0001Vˈ+�=(/�Y\u0010fp�H�&=��\u0005��\u0001�y���虭4}�,�\\�<\u0004�Q\u0015�$�{�(ۂ\u000f>N�wG<鋠�\u001b��$���P�3�s����yv�����������J���B\u0012f�ˈ\u001bG�㊐DM�tO�W�jqhv�\u0012\u0012Q\u0016�;��qv|<h�\u0012|'Z�,����/\u001a�ܵP�iG*��\u001a�w~�<\u000e*�%hVix�\u0000\u000f�(R]��=�j���\u0018�(n\r�lVX\u001e�����\"m�c��ĝ�� �\u0014�\u0011M\u0015�\u001d��\u00161R�]-h���YQe��Bg��I$o�y��^�q\u0016�n7\t�\u000f�\u0012�����A�y�R\u0004��\\�$Z�\u001f���f!�l�\u0014���RW�@�\u0007c\u001dＨ�`j��w$-�m��ǍR:��\r\u0019��#h=\u0007�>\u0011�h~��\u0016�;�\u000b�h\\�^.�쩪��\u0000[���{l�p�\u0003�\r�\u0001�P��d����\u0016\u001b%\u001dA�u�L$`\u000f\u0004��EZ���\u0003\u0019��\u001f�/�\\o�5ԋ}�y\u001a���.jдv��ˇ_����T��\u0014t�K�w\u0004u�<���G���c\u00110�)\nyUeo�+\u001d�\u0002���1󠗽R��\u001b$��z�:G�\u0012t\u0018��_u�����\b���\u000b�\u000bB��<�V�\u0019\r��?���H6i�=aE��PE�m֍[��'��NTR��#&�a�<x!f�㸉����Zg\"�l�{\th5-\u001d2���\b\u001fj�\"\u0002�\u0017��'_��\u000e$u\u0018�7�<j�-a:;n\u0000�]��^�\u001b�2D׌�x�J�(Z\u000e1:\"�څ�m�#\u001b��\u0017�^���o\u0011�&�1t�ι�\u0002(\u0012�:Qخ�'�%E�J%�(?D��\u0015$\u0013�����J�^!�\u00159�(�\\$\u0018�%_��;���\"���zU\n�FA2}R�Eu�p=Uzb��O޹L�Η�x6d�\t*�2�B%ӧm��\u0002�n\u0017ʺ/����2;�<dr�\\��/|hùUqҮ�\t(����3Tܕ�!�\f+�F�}\u001c\f�9\u0015�+@��U���\u00174]�DE�e6z7T깤�k\r�O*�W4�1�����\u0001V�<}<���\u0000�\u000e}�wq�])\u001e��)\u0007\u001d�B�M�xf�\u0013�W\u001d1G�\u0003.!s=�\u0018��:\r*f�u\\�>���<�(Rv&��NH\u0002\u0015L���I>.��E��}h�\u0016�\u000e�W=j��6���/,�T�^\"OZ�Z�\u0011�]��g\u0014�:\u00157h�5\u0005����nj\u0001p�,3%\u0011�W6�c;�\u0019�@.��jH�I+t'�9�\"����vHEJ���1b��'�L�����Ͷ�wsS\u001b\\��\u00011�&�R�#~�<\u0005L�V���;\u0010_�\nR*�\u000e�#�j�YY�k�\f(���Q5/�i�.9,��=�\u0004��\u0012�R�\u0012�X�^�t�y\u0003�֛\u0001S�\u0005�KM�1�L\u0004r\n�k+\u0003լ�!����a�DǒT��9�!w�+++�K��W�)�^�'ڗ_:\u001d'��\u0011>���YYP�t]���V[��β���Cy)��%�j\t)��Ƈ9\u0015.iYYP5�n��ɬ�<��w\b�L�J�ʅ���8�^җ5��\u001e4my�VQ�W���黖�J�/ϟ�/>�YYG\u0011��\u0007�簌�=�\u0018&�]?x�\u0012o�$*�nd��\u0015��؄R\u001d����6�q�[K�\u0015W�\u0000h�3�\u0010?$�\u0015󬬭\u0018�\u000bCi�O�42RD�ZH|k++DI�*\n�h��sF\u0002C�\\\u0018@,\"\u0010����l\u0006I\u0018��[�4���*8�\u001c4�VVY�(d�\u0000��[D�ֲ��?dAv�\u001a2��\u0019\u0012MG�eeT}�\u000btԌ��K�f�<�񬬭\u0011\u001f\u0011¥9`�7.y�VQ\u0014�\u001eH��\".*\u0013{��o�t���^�^ƭ�s�->o��VU� Xz-�m�ڸ�3W��qI�E�T���yN�/�t\u0006�p����~�.����i���I�β��ƯC\t��#���\u0011i��\\?x�VP�4� �U��ҧ�l�*��7�\u0000�Z��\u0011\u0000��z\u0018k�Z�ʸ�1����g���3�\"�es�Z��tL�\"��L\u001dV�^N'²���� B\"qҋ0K�Ouee<I露��U}��Ni�7.pU������?'�&s���|�++����y\u001f�-7NU���\u0005\u0007�eeeQ\u000f��"}],"Page":[{"title":"关于","comments":1,"_content":"## 这里是Mextra的博客\n\n- <span style=\"font-style:italic; text-decoration:line-through;\">一个双非的CV工程师</span>\n- 目前正在修仙嵌入式\n\n## 该博客如何建立？\n\n- 某个平平无奇的中午点开了b站UP主左-岚的视频\n\n  \n\n  [【大学生提高课】3 hexo与hugo博客搭建与github自动化推送和服务器推送_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1fNNreEEDi?vd_source=39ca0bb13f73f8a28e5fca7f666a2e38))\n\n- 通过一个中午的忙碌以及后续的美化 逐渐地诞生了这个博客\n\n- 再次特别鸣谢两位大大`左-岚` 以及 `拔剑Sketon`\n\n  ![00ADEA47](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505211250252.gif)\n\n## 有了博客以后会写什么？\n\n- 那当然是写一下自己的学习笔记、实习经验什么的(,,•﹏•,,)\n\n- 以及平时的一些碎碎念\n\n  ![00AD4F6E](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505211250771.gif)\n","source":"about/index.md","raw":"---\ntitle: 关于\n# date: 2021-09-22 21:01:47\ncomments: true\n---\n## 这里是Mextra的博客\n\n- <span style=\"font-style:italic; text-decoration:line-through;\">一个双非的CV工程师</span>\n- 目前正在修仙嵌入式\n\n## 该博客如何建立？\n\n- 某个平平无奇的中午点开了b站UP主左-岚的视频\n\n  \n\n  [【大学生提高课】3 hexo与hugo博客搭建与github自动化推送和服务器推送_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1fNNreEEDi?vd_source=39ca0bb13f73f8a28e5fca7f666a2e38))\n\n- 通过一个中午的忙碌以及后续的美化 逐渐地诞生了这个博客\n\n- 再次特别鸣谢两位大大`左-岚` 以及 `拔剑Sketon`\n\n  ![00ADEA47](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505211250252.gif)\n\n## 有了博客以后会写什么？\n\n- 那当然是写一下自己的学习笔记、实习经验什么的(,,•﹏•,,)\n\n- 以及平时的一些碎碎念\n\n  ![00AD4F6E](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505211250771.gif)\n","date":"2009-04-22T19:24:48.000Z","updated":"2025-05-21T04:58:26.000Z","path":"about/index.html","layout":"page","_id":"cmk8pg6xb00006sk91fju1ftm","content":"<h2 id=\"这里是Mextra的博客\"><a href=\"#这里是Mextra的博客\" class=\"headerlink\" title=\"这里是Mextra的博客\"></a>这里是Mextra的博客</h2><ul>\n<li><span style=\"font-style:italic; text-decoration:line-through;\">一个双非的CV工程师</span></li>\n<li>目前正在修仙嵌入式</li>\n</ul>\n<h2 id=\"该博客如何建立？\"><a href=\"#该博客如何建立？\" class=\"headerlink\" title=\"该博客如何建立？\"></a>该博客如何建立？</h2><ul>\n<li><p>某个平平无奇的中午点开了b站UP主左-岚的视频</p>\n<p><a href=\"https://www.bilibili.com/video/BV1fNNreEEDi?vd_source=39ca0bb13f73f8a28e5fca7f666a2e38\">【大学生提高课】3 hexo与hugo博客搭建与github自动化推送和服务器推送_哔哩哔哩_bilibili</a>)</p>\n</li>\n<li><p>通过一个中午的忙碌以及后续的美化 逐渐地诞生了这个博客</p>\n</li>\n<li><p>再次特别鸣谢两位大大<code>左-岚</code> 以及 <code>拔剑Sketon</code></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505211250252.gif\" alt=\"00ADEA47\"></p>\n</li>\n</ul>\n<h2 id=\"有了博客以后会写什么？\"><a href=\"#有了博客以后会写什么？\" class=\"headerlink\" title=\"有了博客以后会写什么？\"></a>有了博客以后会写什么？</h2><ul>\n<li><p>那当然是写一下自己的学习笔记、实习经验什么的(,,•﹏•,,)</p>\n</li>\n<li><p>以及平时的一些碎碎念</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505211250771.gif\" alt=\"00AD4F6E\"></p>\n</li>\n</ul>\n","excerpt":"","more":"<h2 id=\"这里是Mextra的博客\"><a href=\"#这里是Mextra的博客\" class=\"headerlink\" title=\"这里是Mextra的博客\"></a>这里是Mextra的博客</h2><ul>\n<li><span style=\"font-style:italic; text-decoration:line-through;\">一个双非的CV工程师</span></li>\n<li>目前正在修仙嵌入式</li>\n</ul>\n<h2 id=\"该博客如何建立？\"><a href=\"#该博客如何建立？\" class=\"headerlink\" title=\"该博客如何建立？\"></a>该博客如何建立？</h2><ul>\n<li><p>某个平平无奇的中午点开了b站UP主左-岚的视频</p>\n<p><a href=\"https://www.bilibili.com/video/BV1fNNreEEDi?vd_source=39ca0bb13f73f8a28e5fca7f666a2e38\">【大学生提高课】3 hexo与hugo博客搭建与github自动化推送和服务器推送_哔哩哔哩_bilibili</a>)</p>\n</li>\n<li><p>通过一个中午的忙碌以及后续的美化 逐渐地诞生了这个博客</p>\n</li>\n<li><p>再次特别鸣谢两位大大<code>左-岚</code> 以及 <code>拔剑Sketon</code></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505211250252.gif\" alt=\"00ADEA47\"></p>\n</li>\n</ul>\n<h2 id=\"有了博客以后会写什么？\"><a href=\"#有了博客以后会写什么？\" class=\"headerlink\" title=\"有了博客以后会写什么？\"></a>有了博客以后会写什么？</h2><ul>\n<li><p>那当然是写一下自己的学习笔记、实习经验什么的(,,•﹏•,,)</p>\n</li>\n<li><p>以及平时的一些碎碎念</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505211250771.gif\" alt=\"00AD4F6E\"></p>\n</li>\n</ul>\n"},{"title":"","date":"2025-05-20T13:48:29.000Z","layout":"search","_content":"","source":"search/index.md","raw":"---\ntitle:\ndate: 2025-05-20 21:48:29\nlayout: search\n---\n","updated":"2025-05-20T14:22:56.000Z","path":"search/index.html","comments":1,"_id":"cmk8pg6xe00026sk9396n4na1","content":"","excerpt":"","more":""},{"title":"友情链接","comments":1,"_content":"\n## 本站信息\n\n- 站名： Mextra\n- 站长： Mextra\n- 地址： https://mextra.netlify.app/\n<!-- - 备用地址：https://d-sketon.github.io/ -->\n\n## 申请方法\n\n- 添加本站后，在本页留言，格式如下\n\n````yml\n```yml\n- name: #您的名字\n  url: #您的网址\n  desc: #简短描述\n  image: #一张图片\n```\n````\n\n## 小伙伴们\n\n{% friendsLink friend/_data.yml %}\n","source":"friend/index.md","raw":"---\ntitle: 友情链接\ncomments: true\n---\n\n## 本站信息\n\n- 站名： Mextra\n- 站长： Mextra\n- 地址： https://mextra.netlify.app/\n<!-- - 备用地址：https://d-sketon.github.io/ -->\n\n## 申请方法\n\n- 添加本站后，在本页留言，格式如下\n\n````yml\n```yml\n- name: #您的名字\n  url: #您的网址\n  desc: #简短描述\n  image: #一张图片\n```\n````\n\n## 小伙伴们\n\n{% friendsLink friend/_data.yml %}\n","date":"2009-04-22T19:24:48.000Z","updated":"2025-05-19T14:43:24.000Z","path":"friend/index.html","layout":"page","_id":"cmk8pg6xg00056sk937cr5jqa","content":"<h2 id=\"本站信息\"><a href=\"#本站信息\" class=\"headerlink\" title=\"本站信息\"></a>本站信息</h2><ul>\n<li>站名： Mextra</li>\n<li>站长： Mextra</li>\n<li>地址： <a href=\"https://mextra.netlify.app/\">https://mextra.netlify.app/</a><!-- - 备用地址：https://d-sketon.github.io/ --></li>\n</ul>\n<h2 id=\"申请方法\"><a href=\"#申请方法\" class=\"headerlink\" title=\"申请方法\"></a>申请方法</h2><ul>\n<li>添加本站后，在本页留言，格式如下</li>\n</ul>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">```yml</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"comment\">#您的名字</span></span><br><span class=\"line\">  <span class=\"attr\">url:</span> <span class=\"comment\">#您的网址</span></span><br><span class=\"line\">  <span class=\"attr\">desc:</span> <span class=\"comment\">#简短描述</span></span><br><span class=\"line\">  <span class=\"attr\">image:</span> <span class=\"comment\">#一张图片</span></span><br><span class=\"line\"><span class=\"string\">```</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"小伙伴们\"><a href=\"#小伙伴们\" class=\"headerlink\" title=\"小伙伴们\"></a>小伙伴们</h2><div class=\"friend-wrap\" data-aos=\"zoom-in\"><div class=\"friend-item-wrap\">\n    <a href=\"https://mextra.netlify.app/\" rel=\"noopener external nofollow noreferrer\" target=\"_blank\"></a>\n    <div class=\"friend-icon-wrap\">\n      <div class=\"friend-icon\">\n          <img data-src=\"https://mextra.netlify.app/avatar/writer.jpg\" data-sizes=\"auto\" alt=\"Mextra\" class=\"lazyload\">\n      </div>\n    </div>\n    <div class=\"friend-info-wrap\">\n      <div class=\"friend-name\">\n          Mextra \n      </div>\n      <div class=\"friend-desc\">\n        一个双非的CV工程师 本站站长\n      </div>\n    </div>\n  </div><div class=\"friend-item-wrap\">\n    <a href=\"https://d-sketon.github.io/\" rel=\"noopener external nofollow noreferrer\" target=\"_blank\"></a>\n    <div class=\"friend-icon-wrap\">\n      <div class=\"friend-icon\">\n          <img data-src=\"https://mextra.netlify.app/avatar/avatar.webp\" data-sizes=\"auto\" alt=\"D-Sketon\" class=\"lazyload\">\n      </div>\n    </div>\n    <div class=\"friend-info-wrap\">\n      <div class=\"friend-name\">\n          D-Sketon \n      </div>\n      <div class=\"friend-desc\">\n        一个车万人\n      </div>\n    </div>\n  </div><div class=\"friend-item-wrap\">\n    <a href=\"https://kinggit.netlify.app/\" rel=\"noopener external nofollow noreferrer\" target=\"_blank\"></a>\n    <div class=\"friend-icon-wrap\">\n      <div class=\"friend-icon\">\n          <img data-src=\"https://kinggit.netlify.app/avatar/KingJt.jpg\" data-sizes=\"auto\" alt=\"KingJt\" class=\"lazyload\">\n      </div>\n    </div>\n    <div class=\"friend-info-wrap\">\n      <div class=\"friend-name\">\n          KingJt \n      </div>\n      <div class=\"friend-desc\">\n        记录生活，分享技术\n      </div>\n    </div>\n  </div></div>\n","excerpt":"","more":"<h2 id=\"本站信息\"><a href=\"#本站信息\" class=\"headerlink\" title=\"本站信息\"></a>本站信息</h2><ul>\n<li>站名： Mextra</li>\n<li>站长： Mextra</li>\n<li>地址： <a href=\"https://mextra.netlify.app/\">https://mextra.netlify.app/</a><!-- - 备用地址：https://d-sketon.github.io/ --></li>\n</ul>\n<h2 id=\"申请方法\"><a href=\"#申请方法\" class=\"headerlink\" title=\"申请方法\"></a>申请方法</h2><ul>\n<li>添加本站后，在本页留言，格式如下</li>\n</ul>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">```yml</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"comment\">#您的名字</span></span><br><span class=\"line\">  <span class=\"attr\">url:</span> <span class=\"comment\">#您的网址</span></span><br><span class=\"line\">  <span class=\"attr\">desc:</span> <span class=\"comment\">#简短描述</span></span><br><span class=\"line\">  <span class=\"attr\">image:</span> <span class=\"comment\">#一张图片</span></span><br><span class=\"line\"><span class=\"string\">```</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"小伙伴们\"><a href=\"#小伙伴们\" class=\"headerlink\" title=\"小伙伴们\"></a>小伙伴们</h2><div class=\"friend-wrap\" data-aos=\"zoom-in\"><div class=\"friend-item-wrap\">\n    <a href=\"https://mextra.netlify.app/\" rel=\"noopener external nofollow noreferrer\" target=\"_blank\"></a>\n    <div class=\"friend-icon-wrap\">\n      <div class=\"friend-icon\">\n          <img data-src=\"https://mextra.netlify.app/avatar/writer.jpg\" data-sizes=\"auto\" alt=\"Mextra\" class=\"lazyload\">\n      </div>\n    </div>\n    <div class=\"friend-info-wrap\">\n      <div class=\"friend-name\">\n          Mextra \n      </div>\n      <div class=\"friend-desc\">\n        一个双非的CV工程师 本站站长\n      </div>\n    </div>\n  </div><div class=\"friend-item-wrap\">\n    <a href=\"https://d-sketon.github.io/\" rel=\"noopener external nofollow noreferrer\" target=\"_blank\"></a>\n    <div class=\"friend-icon-wrap\">\n      <div class=\"friend-icon\">\n          <img data-src=\"https://mextra.netlify.app/avatar/avatar.webp\" data-sizes=\"auto\" alt=\"D-Sketon\" class=\"lazyload\">\n      </div>\n    </div>\n    <div class=\"friend-info-wrap\">\n      <div class=\"friend-name\">\n          D-Sketon \n      </div>\n      <div class=\"friend-desc\">\n        一个车万人\n      </div>\n    </div>\n  </div><div class=\"friend-item-wrap\">\n    <a href=\"https://kinggit.netlify.app/\" rel=\"noopener external nofollow noreferrer\" target=\"_blank\"></a>\n    <div class=\"friend-icon-wrap\">\n      <div class=\"friend-icon\">\n          <img data-src=\"https://kinggit.netlify.app/avatar/KingJt.jpg\" data-sizes=\"auto\" alt=\"KingJt\" class=\"lazyload\">\n      </div>\n    </div>\n    <div class=\"friend-info-wrap\">\n      <div class=\"friend-name\">\n          KingJt \n      </div>\n      <div class=\"friend-desc\">\n        记录生活，分享技术\n      </div>\n    </div>\n  </div></div>\n"}],"Post":[{"title":"C语言高级","date":"2025-09-02T03:36:37.000Z","cover":"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509171225629.png","_content":"\n## 关于const的进一步思考\n\n> 背景：在进行宿舍精灵项目的代码编写时， 我使用了映射表来表现楼栋，我使用了const来修饰 以稳定内容 \n>\n> 但是在我尝试将楼栋的内容分离出来时（例如中1C 在oled上需把中文提取出来 然后剩下用oled_print来显示在oled上） 但却出现了指针错误 \n\n分析了一下：const是将对应的字符数组存放在只读存储区中 而我因为想要分离 从而修改了指针的内容 故造成指针错误\n\n`解决措施`：通过malloc来申请内存，然后使用strcpy或者sprintf来存放在新申请的内存中\n\n```C\nchar *get_building_map_remain(void)\n{\n    char *map = get_building_map();\n    if (map == NULL)\n    {\n        return NULL;\n    }\n\n    size_t len = strlen(map);\n    if (len <= 3)\n    {\n        // 返回空字符串\n        char *result = malloc(1);\n        if (result)\n        {\n            result[0] = '\\0';\n        }\n        return result;\n    }\n\n    // 分配新内存并复制跳过前3字节的内容\n    char *result = malloc(len - 3 + 1);\n    if (result == NULL)\n    {\n        return NULL;\n    }\n\n    strcpy(result, map + 3);\n    return result;\n}\n```\n\n\n\n{% externalLinkCard \"freertos\" \"https://mextra.netlify.app/2025/09/05/freertos/\" \"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071511987.png\" %}\n\n## 二维数组高级应用\n\n> 背景：在进一步封装MP3_Test项目的时候，本身有个二维数组mp3Files用来存放MP3文件路径，在修饰为static保护变量时，遇到了不会返回的难题\n>\n> []优先级高于*\n\n`解决措施`：通过询问`AI`后，得出可以将其封装为`一个返回值为数组指针的函数`，然后定义一个数组指针来接收`原型为指针，但指向的是数组`\n\n### 函数封装\n\n```C\nstatic char mp3Files[100][64]; // 假设最多有100个MP3文件\n\nchar (*get_mp3_files(void)) [64]\n{\n    return mp3Files;\n}\n\nvoid task(void)\n{\n    char (*files)[64] = get_mp3_files();\n    for(int i = 0; i < 100 ;i++)\n        printf(\"file[%d]:%s\\r\\n\",i,files[i]);\n}\n```\n\n### 指针访问\n\n```C\nstatic char mp3Files[100][64]; // 假设最多有100个MP3文件\n\nvoid task(void)\n{\n    /*（1）指向数组的指针（按行访问） 即指针数组*/\n    char (*p)[64] = mp3Files;\n    /*（2）指向数组的指针（逐个访问）*/\n    char *p = &mp3Files[0][0];\n //或\tchar *p = mp3Files[0];\n}\n```\n\n","source":"_posts/C语言高级.md","raw":"---\ntitle: C语言高级\ndate: 2025-09-02 11:36:37\ncover: \"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509171225629.png\"\ntags:\n  - 嵌入式基础\n  - C语言高级 \n---\n\n## 关于const的进一步思考\n\n> 背景：在进行宿舍精灵项目的代码编写时， 我使用了映射表来表现楼栋，我使用了const来修饰 以稳定内容 \n>\n> 但是在我尝试将楼栋的内容分离出来时（例如中1C 在oled上需把中文提取出来 然后剩下用oled_print来显示在oled上） 但却出现了指针错误 \n\n分析了一下：const是将对应的字符数组存放在只读存储区中 而我因为想要分离 从而修改了指针的内容 故造成指针错误\n\n`解决措施`：通过malloc来申请内存，然后使用strcpy或者sprintf来存放在新申请的内存中\n\n```C\nchar *get_building_map_remain(void)\n{\n    char *map = get_building_map();\n    if (map == NULL)\n    {\n        return NULL;\n    }\n\n    size_t len = strlen(map);\n    if (len <= 3)\n    {\n        // 返回空字符串\n        char *result = malloc(1);\n        if (result)\n        {\n            result[0] = '\\0';\n        }\n        return result;\n    }\n\n    // 分配新内存并复制跳过前3字节的内容\n    char *result = malloc(len - 3 + 1);\n    if (result == NULL)\n    {\n        return NULL;\n    }\n\n    strcpy(result, map + 3);\n    return result;\n}\n```\n\n\n\n{% externalLinkCard \"freertos\" \"https://mextra.netlify.app/2025/09/05/freertos/\" \"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071511987.png\" %}\n\n## 二维数组高级应用\n\n> 背景：在进一步封装MP3_Test项目的时候，本身有个二维数组mp3Files用来存放MP3文件路径，在修饰为static保护变量时，遇到了不会返回的难题\n>\n> []优先级高于*\n\n`解决措施`：通过询问`AI`后，得出可以将其封装为`一个返回值为数组指针的函数`，然后定义一个数组指针来接收`原型为指针，但指向的是数组`\n\n### 函数封装\n\n```C\nstatic char mp3Files[100][64]; // 假设最多有100个MP3文件\n\nchar (*get_mp3_files(void)) [64]\n{\n    return mp3Files;\n}\n\nvoid task(void)\n{\n    char (*files)[64] = get_mp3_files();\n    for(int i = 0; i < 100 ;i++)\n        printf(\"file[%d]:%s\\r\\n\",i,files[i]);\n}\n```\n\n### 指针访问\n\n```C\nstatic char mp3Files[100][64]; // 假设最多有100个MP3文件\n\nvoid task(void)\n{\n    /*（1）指向数组的指针（按行访问） 即指针数组*/\n    char (*p)[64] = mp3Files;\n    /*（2）指向数组的指针（逐个访问）*/\n    char *p = &mp3Files[0][0];\n //或\tchar *p = mp3Files[0];\n}\n```\n\n","slug":"C语言高级","published":1,"updated":"2025-09-28T13:17:04.000Z","comments":1,"layout":"post","photos":[],"_id":"cmk8pg6xc00016sk96m9p14kv","content":"<h2 id=\"关于const的进一步思考\"><a href=\"#关于const的进一步思考\" class=\"headerlink\" title=\"关于const的进一步思考\"></a>关于const的进一步思考</h2><blockquote>\n<p>背景：在进行宿舍精灵项目的代码编写时， 我使用了映射表来表现楼栋，我使用了const来修饰 以稳定内容 </p>\n<p>但是在我尝试将楼栋的内容分离出来时（例如中1C 在oled上需把中文提取出来 然后剩下用oled_print来显示在oled上） 但却出现了指针错误 </p>\n</blockquote>\n<p>分析了一下：const是将对应的字符数组存放在只读存储区中 而我因为想要分离 从而修改了指针的内容 故造成指针错误</p>\n<p><code>解决措施</code>：通过malloc来申请内存，然后使用strcpy或者sprintf来存放在新申请的内存中</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> *<span class=\"title function_\">get_building_map_remain</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">char</span> *<span class=\"built_in\">map</span> = get_building_map();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">map</span> == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">size_t</span> len = <span class=\"built_in\">strlen</span>(<span class=\"built_in\">map</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (len &lt;= <span class=\"number\">3</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 返回空字符串</span></span><br><span class=\"line\">        <span class=\"type\">char</span> *result = <span class=\"built_in\">malloc</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (result)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            result[<span class=\"number\">0</span>] = <span class=\"string\">&#x27;\\0&#x27;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 分配新内存并复制跳过前3字节的内容</span></span><br><span class=\"line\">    <span class=\"type\">char</span> *result = <span class=\"built_in\">malloc</span>(len - <span class=\"number\">3</span> + <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (result == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">strcpy</span>(result, <span class=\"built_in\">map</span> + <span class=\"number\">3</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<div class=\"post-link-card-wrap\">\n    <div class=\"post-link-card\">\n      <a href=\"https://mextra.netlify.app/2025/09/05/freertos/\" title=\"freertos\" rel=\"noopener external nofollow noreferrer\" target=\"_blank\"></a>\n      <div class=\"post-link-card-cover-wrap\"><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071511987.png\" class=\"no-lightbox\" title=\"freertos\" alt=\"freertos\"/></div>\n      <div class=\"post-link-card-item-wrap\">\n        <div class=\"post-link-card-title\">freertos</div>\n        <div class=\"post-link-card-excerpt\"><span class=\"icon-link\"></span>https://mextra.netlify.app/2025/09/05/freertos/</div>\n      </div>\n    </div>\n  </div>\n\n<h2 id=\"二维数组高级应用\"><a href=\"#二维数组高级应用\" class=\"headerlink\" title=\"二维数组高级应用\"></a>二维数组高级应用</h2><blockquote>\n<p>背景：在进一步封装MP3_Test项目的时候，本身有个二维数组mp3Files用来存放MP3文件路径，在修饰为static保护变量时，遇到了不会返回的难题</p>\n<p>[]优先级高于*</p>\n</blockquote>\n<p><code>解决措施</code>：通过询问<code>AI</code>后，得出可以将其封装为<code>一个返回值为数组指针的函数</code>，然后定义一个数组指针来接收<code>原型为指针，但指向的是数组</code></p>\n<h3 id=\"函数封装\"><a href=\"#函数封装\" class=\"headerlink\" title=\"函数封装\"></a>函数封装</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">char</span> mp3Files[<span class=\"number\">100</span>][<span class=\"number\">64</span>]; <span class=\"comment\">// 假设最多有100个MP3文件</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">char</span> (*get_mp3_files(<span class=\"type\">void</span>)) [<span class=\"number\">64</span>]</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> mp3Files;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">task</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">char</span> (*files)[<span class=\"number\">64</span>] = get_mp3_files();</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">100</span> ;i++)</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;file[%d]:%s\\r\\n&quot;</span>,i,files[i]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"指针访问\"><a href=\"#指针访问\" class=\"headerlink\" title=\"指针访问\"></a>指针访问</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">char</span> mp3Files[<span class=\"number\">100</span>][<span class=\"number\">64</span>]; <span class=\"comment\">// 假设最多有100个MP3文件</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">task</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">/*（1）指向数组的指针（按行访问） 即指针数组*/</span></span><br><span class=\"line\">    <span class=\"type\">char</span> (*p)[<span class=\"number\">64</span>] = mp3Files;</span><br><span class=\"line\">    <span class=\"comment\">/*（2）指向数组的指针（逐个访问）*/</span></span><br><span class=\"line\">    <span class=\"type\">char</span> *p = &amp;mp3Files[<span class=\"number\">0</span>][<span class=\"number\">0</span>];</span><br><span class=\"line\"> <span class=\"comment\">//或\tchar *p = mp3Files[0];</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","excerpt":"","more":"<h2 id=\"关于const的进一步思考\"><a href=\"#关于const的进一步思考\" class=\"headerlink\" title=\"关于const的进一步思考\"></a>关于const的进一步思考</h2><blockquote>\n<p>背景：在进行宿舍精灵项目的代码编写时， 我使用了映射表来表现楼栋，我使用了const来修饰 以稳定内容 </p>\n<p>但是在我尝试将楼栋的内容分离出来时（例如中1C 在oled上需把中文提取出来 然后剩下用oled_print来显示在oled上） 但却出现了指针错误 </p>\n</blockquote>\n<p>分析了一下：const是将对应的字符数组存放在只读存储区中 而我因为想要分离 从而修改了指针的内容 故造成指针错误</p>\n<p><code>解决措施</code>：通过malloc来申请内存，然后使用strcpy或者sprintf来存放在新申请的内存中</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> *<span class=\"title function_\">get_building_map_remain</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">char</span> *<span class=\"built_in\">map</span> = get_building_map();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">map</span> == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">size_t</span> len = <span class=\"built_in\">strlen</span>(<span class=\"built_in\">map</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (len &lt;= <span class=\"number\">3</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 返回空字符串</span></span><br><span class=\"line\">        <span class=\"type\">char</span> *result = <span class=\"built_in\">malloc</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (result)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            result[<span class=\"number\">0</span>] = <span class=\"string\">&#x27;\\0&#x27;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 分配新内存并复制跳过前3字节的内容</span></span><br><span class=\"line\">    <span class=\"type\">char</span> *result = <span class=\"built_in\">malloc</span>(len - <span class=\"number\">3</span> + <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (result == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">strcpy</span>(result, <span class=\"built_in\">map</span> + <span class=\"number\">3</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<div class=\"post-link-card-wrap\">\n    <div class=\"post-link-card\">\n      <a href=\"https://mextra.netlify.app/2025/09/05/freertos/\" title=\"freertos\" rel=\"noopener external nofollow noreferrer\" target=\"_blank\"></a>\n      <div class=\"post-link-card-cover-wrap\"><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071511987.png\" class=\"no-lightbox\" title=\"freertos\" alt=\"freertos\"/></div>\n      <div class=\"post-link-card-item-wrap\">\n        <div class=\"post-link-card-title\">freertos</div>\n        <div class=\"post-link-card-excerpt\"><span class=\"icon-link\"></span>https://mextra.netlify.app/2025/09/05/freertos/</div>\n      </div>\n    </div>\n  </div>\n\n<h2 id=\"二维数组高级应用\"><a href=\"#二维数组高级应用\" class=\"headerlink\" title=\"二维数组高级应用\"></a>二维数组高级应用</h2><blockquote>\n<p>背景：在进一步封装MP3_Test项目的时候，本身有个二维数组mp3Files用来存放MP3文件路径，在修饰为static保护变量时，遇到了不会返回的难题</p>\n<p>[]优先级高于*</p>\n</blockquote>\n<p><code>解决措施</code>：通过询问<code>AI</code>后，得出可以将其封装为<code>一个返回值为数组指针的函数</code>，然后定义一个数组指针来接收<code>原型为指针，但指向的是数组</code></p>\n<h3 id=\"函数封装\"><a href=\"#函数封装\" class=\"headerlink\" title=\"函数封装\"></a>函数封装</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">char</span> mp3Files[<span class=\"number\">100</span>][<span class=\"number\">64</span>]; <span class=\"comment\">// 假设最多有100个MP3文件</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">char</span> (*get_mp3_files(<span class=\"type\">void</span>)) [<span class=\"number\">64</span>]</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> mp3Files;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">task</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">char</span> (*files)[<span class=\"number\">64</span>] = get_mp3_files();</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">100</span> ;i++)</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;file[%d]:%s\\r\\n&quot;</span>,i,files[i]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"指针访问\"><a href=\"#指针访问\" class=\"headerlink\" title=\"指针访问\"></a>指针访问</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">char</span> mp3Files[<span class=\"number\">100</span>][<span class=\"number\">64</span>]; <span class=\"comment\">// 假设最多有100个MP3文件</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">task</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">/*（1）指向数组的指针（按行访问） 即指针数组*/</span></span><br><span class=\"line\">    <span class=\"type\">char</span> (*p)[<span class=\"number\">64</span>] = mp3Files;</span><br><span class=\"line\">    <span class=\"comment\">/*（2）指向数组的指针（逐个访问）*/</span></span><br><span class=\"line\">    <span class=\"type\">char</span> *p = &amp;mp3Files[<span class=\"number\">0</span>][<span class=\"number\">0</span>];</span><br><span class=\"line\"> <span class=\"comment\">//或\tchar *p = mp3Files[0];</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n"},{"title":"LVGL学习之旅（基于正点原子STM32F407探索者）","date":"2025-09-07T06:58:25.000Z","cover":"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071514562.png","_content":"\n## LVGL 基础\n\n> LVGL（Light and Versatile Graphics Library）轻量级通用型图形库，是一个免费的开源图形库，提供了创建嵌入式 GUI 所需的一切，具有易于使用的组件，美观的视觉效果和低内存占用等特点。支持触摸屏操作，移植简单方便，开发者一直在不断完善更新。\n>\n> 特点：\n>\n> - 丰富且强大的模块化图形组件：按钮 (buttons)、图表 (charts)、列表 (lists)、滑动条 (sliders)、图片 (images) 等\n> - 高级的图形引擎：动画、抗锯齿、透明度、平滑滚动、图层混合等效果\n> - 不依赖特定的硬件平台，可以在任何显示屏上运行\n> - 配置可裁剪（最低资源占用：<span style=\"color:#FF0000;\">64 kB Flash，16 kB RAM</span>）\n> - 基于<span style=\"color:#FF0000;\">UTF-8</span>的多语种支持，例如中文、日文、韩文、阿拉伯文等\n> - 可以通过类CSS的方式来设计、布局图形界面（例如：Flexbox、Grid）\n> - 支持操作系统、外置内存、以及硬件加速（LVGL已内建支持STM32 DMA2D、NXP PXP和VGLite）\n> - 即便仅有单缓冲区(frame buffer)的情况下，也可保证渲染如丝般顺滑\n> - 全部由C编写完成，并支持C++调用\n> - 支持Micropython编程，参见：LVGL API in Micropython\n> - 支持模拟器仿真，可以无硬件依托进行开发\n\n## TFT-LCD配置——移植正点原子官方LCD例程\n\n### 点亮LCD——FSMC配置\n\n#### 先根据原理图配置`FSMC`\n\n![image-20250907155616208](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071556284.png)\n\n![image-20250907160758201](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071607256.png)\n\n#### 详细FSMC参数配置\n\n> 这里根据正点原子官方`lcd_init` 来设置 如下图\n\n![image-20250907164335816](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071643877.png)\n\n![img](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071724936.png)\n\n![img](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071725408.png)\n\n\n\n#### 背光引脚配置\n\n![img](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071725075.png)\n\n#### 生成代码并将LCD、sys、delay文件夹添加到工程中\n\n![image-20250907234315989](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509072343199.png)\n\n##### 首先将*HAL_SRAM_MspInit*函数整个屏蔽\n\n![image-20250907171842072](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071718133.png)\n\n##### 将lcd_init中有关fsmc部分屏蔽\n\n> 屏蔽部分如下\n\n```C\nvoid LCD_Init(void)\n{ \t  \n//\tGPIO_InitTypeDef GPIO_Initure;\n//\tFSMC_NORSRAM_TimingTypeDef FSMC_ReadWriteTim;\n//\tFSMC_NORSRAM_TimingTypeDef FSMC_WriteTim;\n//    \n//\t__HAL_RCC_GPIOB_CLK_ENABLE();\t\t\t//开启GPIOB时钟\n//\tGPIO_Initure.Pin=GPIO_PIN_15;          \t//PB15,背光控制\n//\tGPIO_Initure.Mode=GPIO_MODE_OUTPUT_PP;  //推挽输出\n//\tGPIO_Initure.Pull=GPIO_PULLUP;          //上拉\n//\tGPIO_Initure.Speed=GPIO_SPEED_HIGH;     //高速\n//\tHAL_GPIO_Init(GPIOB,&GPIO_Initure); \n//\t\n//\tTFTSRAM_Handler.Instance=FSMC_NORSRAM_DEVICE;                \n//\tTFTSRAM_Handler.Extended=FSMC_NORSRAM_EXTENDED_DEVICE;    \n//    \n//\tTFTSRAM_Handler.Init.NSBank=FSMC_NORSRAM_BANK4;     \t\t\t\t//使用NE4\n//\tTFTSRAM_Handler.Init.DataAddressMux=FSMC_DATA_ADDRESS_MUX_DISABLE; \t//地址/数据线不复用\n//\tTFTSRAM_Handler.Init.MemoryType=FSMC_MEMORY_TYPE_SRAM;   \t\t\t//SRAM\n//\tTFTSRAM_Handler.Init.MemoryDataWidth=FSMC_NORSRAM_MEM_BUS_WIDTH_16; //16位数据宽度\n//\tTFTSRAM_Handler.Init.BurstAccessMode=FSMC_BURST_ACCESS_MODE_DISABLE; //是否使能突发访问,仅对同步突发存储器有效,此处未用到\n//\tTFTSRAM_Handler.Init.WaitSignalPolarity=FSMC_WAIT_SIGNAL_POLARITY_LOW;//等待信号的极性,仅在突发模式访问下有用\n//\tTFTSRAM_Handler.Init.WaitSignalActive=FSMC_WAIT_TIMING_BEFORE_WS;   //存储器是在等待周期之前的一个时钟周期还是等待周期期间使能NWAIT\n//\tTFTSRAM_Handler.Init.WriteOperation=FSMC_WRITE_OPERATION_ENABLE;    //存储器写使能\n//\tTFTSRAM_Handler.Init.WaitSignal=FSMC_WAIT_SIGNAL_DISABLE;           //等待使能位,此处未用到\n//\tTFTSRAM_Handler.Init.ExtendedMode=FSMC_EXTENDED_MODE_ENABLE;        //读写使用不同的时序\n//\tTFTSRAM_Handler.Init.AsynchronousWait=FSMC_ASYNCHRONOUS_WAIT_DISABLE;//是否使能同步传输模式下的等待信号,此处未用到\n//\tTFTSRAM_Handler.Init.WriteBurst=FSMC_WRITE_BURST_DISABLE;           //禁止突发写\n//\tTFTSRAM_Handler.Init.ContinuousClock=FSMC_CONTINUOUS_CLOCK_SYNC_ASYNC;\n//    \n//\t//FMC读时序控制寄存器\n//\tFSMC_ReadWriteTim.AddressSetupTime=0x0F;       \t//地址建立时间（ADDSET）为16个HCLK 1/168M=6ns*16=96ns\n//\tFSMC_ReadWriteTim.AddressHoldTime=0;\n//\tFSMC_ReadWriteTim.DataSetupTime=60;\t\t\t\t//数据保存时间为60个HCLK\t=6*60=360ns\n//\tFSMC_ReadWriteTim.AccessMode=FSMC_ACCESS_MODE_A;//模式A\n//\t//FMC写时序控制寄存器\n//\tFSMC_WriteTim.BusTurnAroundDuration=0;\t\t\t//总线周转阶段持续时间为0，此变量不赋值的话会莫名其妙的自动修改为4。导致程序运行正常\n//\tFSMC_WriteTim.AddressSetupTime=9;          \t\t//地址建立时间（ADDSET）为9个HCLK =54ns \n//\tFSMC_WriteTim.AddressHoldTime=0;\n//\tFSMC_WriteTim.DataSetupTime=8;              \t//数据保存时间为6ns*9个HCLK=54n\n//\tFSMC_WriteTim.AccessMode=FSMC_ACCESS_MODE_A;    //模式A\n//\tHAL_SRAM_Init(&TFTSRAM_Handler,&FSMC_ReadWriteTim,&FSMC_WriteTim);\t\n\n//\tHAL_Delay(50); // delay 50 ms \n\t\n\t//尝试9341 ID的读取\t\t\n\tLCD_WR_REG(0XD3);\t\t\n    .........\n}\n```\n\n> 注意有个坑！！！！\n>\n> 正点原子官方的`lcd_init`函数中有个 `printf(\" LCD ID:%x\\r\\n\",lcddev.id);`，所以在此之前需先进行串口重定向  \n\n##### 替换官方的delay函数\n\n```C\nvoid delay_us(u32 nus)\n{\n\tuint32_t Delay = nus * 168 / 4;\n\tdo\n\t{\n\t\t__NOP();\n\t} while (Delay--);\n}\n\n// 延时nms\n// nms:要延时的ms数\nvoid delay_ms(u16 nms)\n{\n\tHAL_Delay(nms);\n}\n```\n\n\n\n##### 修改点亮背光函数\n\n> 在`lcd_init`函数最后 将`LCD_BL(1)`替换为`HAL_GPIO_WritePin(LCD_BL_GPIO_Port, LCD_BL_Pin, GPIO_PIN_SET);`\n\n### 触摸屏TOUCH移植\n\n#### 将BSP文件夹下的24CXX、IIC与TOUCH文件夹添加到项目中\n\n![image-20250907180027576](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071800663.png)\n\n## LVGL移植\n\n### LVGL源码下载\n\n- 国内码云仓库：https://gitee.com/mirrors/lvgl\n\n  ![image-20250907180958855](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071809967.png)\n\n![image-20250907181022271](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071810376.png)\n\n> 注意不要直接克隆 直接克隆下载的是最新的 可以选择右上角下载zip 就可以选中当前分支\n\n### 裁剪LVGL源码\n\n#### 根目录\n\n> 仅保留 demos、examples、src文件夹以及两个.h文件 如下图\n\n![image-20250907181309155](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071813234.png)\n\n#### 进入`examples`文件夹 删去除`porting`文件夹\n\n![image-20250907181406209](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071814287.png)\n\n#### 更改`lv_conf_template.h`\n\n> 1. 将`lv_conf_template.h`更名为`lv_conf.h`\n> 2. 进入该文件 将里面的#if 0 改为#if 1\n>\n> ![image-20250907182017202](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071820299.png)\n\n### 按以下结构创建文件夹\n\n```C\nProject\n----Middlewares\n--------LVGL\n------------GUI\n----------------lvgl\n------------GUI_APP\n```\n\n> 将裁剪后的LVGL库文件复制到`Middlewares/LVGL/GUI/lvgl`文件夹下\n\n### Keil配置\n\n#### 创建如下管理\n\n![image-20250907194802955](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071948050.png)\n\n#### 添加路径\n\n![image-20250907194859063](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071948156.png)\n\n> - 注意一定要开启C99模式\n>\n> ![image-20250907195152454](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071951544.png)\n>\n> - 可以屏蔽MDK警告\n>\n>   --diag_suppress=68 --diag_suppress=111 --diag_suppress=188 --diag_suppress=223 --diag_suppress=546  --diag_suppress=1295\n>\n> \n\n#### 添加文件到项目\n\n![image-20250907195111490](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071951610.png)\n\n### LVGL文件修改\n\n#### 配置LCD屏幕显示\n\n![image-20250907195420988](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071954102.png)\n\n##### 包含输出设备驱动头文件\n\n> 在`lv_port_disp_template.c`引入`lcd.h` 如`#include \"../BSP/LCD/lcd.h\"`\n\n##### 在`disp_init`函数中初始化\n\n```C\nstatic void disp_init(void)\n{\n    /*You code here*/\n    LCD_Init();\n    LCD_Display_Dir(1); // 横屏\n}\n```\n\n##### 配置图形数据缓冲方式\n\n> 进入`lv_port_disp_init`函数\n>\n> 选择缓冲方式 另外两个将其屏蔽\n>\n> ![image-20250907195842896](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071958994.png)\n\n##### 修改`disp_flush`函数\n\n```C\nstatic void disp_flush(lv_disp_drv_t *disp_drv, const lv_area_t *area, lv_color_t *color_p)\n{\n    /*The most simple case (but also the slowest) to put all pixels to the screen one-by-one*/\n    /*官方打点函数 */\n    // int32_t x;\n    // int32_t y;\n    // for (y = area->y1; y <= area->y2; y++)\n    // {\n    //     for (x = area->x1; x <= area->x2; x++)\n    //     {\n    //         /*Put a pixel to the display. For example:*/\n    //         /*put_px(x, y, *color_p)*/\n    //         color_p++;\n    //     }\n    // }\n\n    LCD_Color_Fill(area->x1, area->y1, area->x2, area->y2, (uint16_t *)color_p);\n    /*IMPORTANT!!!\n     *Inform the graphics library that you are ready with the flushing*/\n    lv_disp_flush_ready(disp_drv);\n}\n```\n\n#### 配置输入（触摸）\n\n![image-20250907200123083](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509072001216.png)\n\n##### 按需裁剪输入设备\n\n> 打开`lv_port_indev_template.c` 此处我们只需要触摸输入 所以把除了touchpad 其他都屏蔽或删去\n>\n> 注意：一定要把其他无关的屏蔽掉 否则会无法触摸\n\n##### 在`touchpad_init`函数中初始化触摸屏\n\n```C\nstatic void touchpad_init(void)\n{\n    /*Your code comes here*/\n    tp_dev.init();\n}\n```\n\n##### 修改`touchpad_is_pressed`函数\n\n```C\nstatic bool touchpad_is_pressed(void)\n{\n    /*Your code comes here*/\n    tp_dev.scan(0); // É¨ÃèÎïÀí×ø±ê\n    if (tp_dev.sta & TP_PRES_DOWN)\n    {\n        return true;\n    }\n    return false;\n}\n```\n\n##### 配置坐标获取函数\n\n```C\nstatic void touchpad_get_xy(lv_coord_t *x, lv_coord_t *y)\n{\n    /*Your code comes here*/\n\n    (*x) = tp_dev.x[0];\n    (*y) = tp_dev.y[0];\n}\n```\n\n#### 提供时基\n\n> - 使用CubeMX生成一个定时1ms的定时器\n> - 在`tim.c`中引用`#include \"lvgl.h\"`\n> - 在定时器中断回调函数中`lv_tick_inc(1);`\n\n![image-20250907201034944](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509072010067.png)\n\n![image-20250907200845233](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509072008331.png)\n\n#### `main`函数部分\n\n![image-20250907201115783](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509072011915.png)\n\n```C\n#include \"lvgl.h\"\n#include \"lv_port_disp_template.h\"\n#include \"lv_port_indev_template.h\"\n....\nint main(void)\n{\n    .....\n  HAL_TIM_Base_Start_IT(&htim3); // 启动定时器3中断 为lvgl提供时基\n  lv_init();                     // 初始化LVGL\n  lv_port_disp_init();           // 初始化显示接口\n  lv_port_indev_init();          // 初始化输入接口\n  while (1)\n  {\n    lv_timer_handler(); // 处理LVGL任务\n    delay_ms(5);\n  }\n}\n```\n\n","source":"_posts/LVGL学习之旅-DESKTOP-40.md","raw":"---\ntitle: LVGL学习之旅（基于正点原子STM32F407探索者）\ndate: 2025-09-07 14:58:25\ncover: \"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071514562.png\"\ntags:\n - LVGL v8.2\n - RTOS\n - 嵌入式基础\n---\n\n## LVGL 基础\n\n> LVGL（Light and Versatile Graphics Library）轻量级通用型图形库，是一个免费的开源图形库，提供了创建嵌入式 GUI 所需的一切，具有易于使用的组件，美观的视觉效果和低内存占用等特点。支持触摸屏操作，移植简单方便，开发者一直在不断完善更新。\n>\n> 特点：\n>\n> - 丰富且强大的模块化图形组件：按钮 (buttons)、图表 (charts)、列表 (lists)、滑动条 (sliders)、图片 (images) 等\n> - 高级的图形引擎：动画、抗锯齿、透明度、平滑滚动、图层混合等效果\n> - 不依赖特定的硬件平台，可以在任何显示屏上运行\n> - 配置可裁剪（最低资源占用：<span style=\"color:#FF0000;\">64 kB Flash，16 kB RAM</span>）\n> - 基于<span style=\"color:#FF0000;\">UTF-8</span>的多语种支持，例如中文、日文、韩文、阿拉伯文等\n> - 可以通过类CSS的方式来设计、布局图形界面（例如：Flexbox、Grid）\n> - 支持操作系统、外置内存、以及硬件加速（LVGL已内建支持STM32 DMA2D、NXP PXP和VGLite）\n> - 即便仅有单缓冲区(frame buffer)的情况下，也可保证渲染如丝般顺滑\n> - 全部由C编写完成，并支持C++调用\n> - 支持Micropython编程，参见：LVGL API in Micropython\n> - 支持模拟器仿真，可以无硬件依托进行开发\n\n## TFT-LCD配置——移植正点原子官方LCD例程\n\n### 点亮LCD——FSMC配置\n\n#### 先根据原理图配置`FSMC`\n\n![image-20250907155616208](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071556284.png)\n\n![image-20250907160758201](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071607256.png)\n\n#### 详细FSMC参数配置\n\n> 这里根据正点原子官方`lcd_init` 来设置 如下图\n\n![image-20250907164335816](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071643877.png)\n\n![img](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071724936.png)\n\n![img](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071725408.png)\n\n\n\n#### 背光引脚配置\n\n![img](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071725075.png)\n\n#### 生成代码并将LCD、sys、delay文件夹添加到工程中\n\n![image-20250907234315989](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509072343199.png)\n\n##### 首先将*HAL_SRAM_MspInit*函数整个屏蔽\n\n![image-20250907171842072](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071718133.png)\n\n##### 将lcd_init中有关fsmc部分屏蔽\n\n> 屏蔽部分如下\n\n```C\nvoid LCD_Init(void)\n{ \t  \n//\tGPIO_InitTypeDef GPIO_Initure;\n//\tFSMC_NORSRAM_TimingTypeDef FSMC_ReadWriteTim;\n//\tFSMC_NORSRAM_TimingTypeDef FSMC_WriteTim;\n//    \n//\t__HAL_RCC_GPIOB_CLK_ENABLE();\t\t\t//开启GPIOB时钟\n//\tGPIO_Initure.Pin=GPIO_PIN_15;          \t//PB15,背光控制\n//\tGPIO_Initure.Mode=GPIO_MODE_OUTPUT_PP;  //推挽输出\n//\tGPIO_Initure.Pull=GPIO_PULLUP;          //上拉\n//\tGPIO_Initure.Speed=GPIO_SPEED_HIGH;     //高速\n//\tHAL_GPIO_Init(GPIOB,&GPIO_Initure); \n//\t\n//\tTFTSRAM_Handler.Instance=FSMC_NORSRAM_DEVICE;                \n//\tTFTSRAM_Handler.Extended=FSMC_NORSRAM_EXTENDED_DEVICE;    \n//    \n//\tTFTSRAM_Handler.Init.NSBank=FSMC_NORSRAM_BANK4;     \t\t\t\t//使用NE4\n//\tTFTSRAM_Handler.Init.DataAddressMux=FSMC_DATA_ADDRESS_MUX_DISABLE; \t//地址/数据线不复用\n//\tTFTSRAM_Handler.Init.MemoryType=FSMC_MEMORY_TYPE_SRAM;   \t\t\t//SRAM\n//\tTFTSRAM_Handler.Init.MemoryDataWidth=FSMC_NORSRAM_MEM_BUS_WIDTH_16; //16位数据宽度\n//\tTFTSRAM_Handler.Init.BurstAccessMode=FSMC_BURST_ACCESS_MODE_DISABLE; //是否使能突发访问,仅对同步突发存储器有效,此处未用到\n//\tTFTSRAM_Handler.Init.WaitSignalPolarity=FSMC_WAIT_SIGNAL_POLARITY_LOW;//等待信号的极性,仅在突发模式访问下有用\n//\tTFTSRAM_Handler.Init.WaitSignalActive=FSMC_WAIT_TIMING_BEFORE_WS;   //存储器是在等待周期之前的一个时钟周期还是等待周期期间使能NWAIT\n//\tTFTSRAM_Handler.Init.WriteOperation=FSMC_WRITE_OPERATION_ENABLE;    //存储器写使能\n//\tTFTSRAM_Handler.Init.WaitSignal=FSMC_WAIT_SIGNAL_DISABLE;           //等待使能位,此处未用到\n//\tTFTSRAM_Handler.Init.ExtendedMode=FSMC_EXTENDED_MODE_ENABLE;        //读写使用不同的时序\n//\tTFTSRAM_Handler.Init.AsynchronousWait=FSMC_ASYNCHRONOUS_WAIT_DISABLE;//是否使能同步传输模式下的等待信号,此处未用到\n//\tTFTSRAM_Handler.Init.WriteBurst=FSMC_WRITE_BURST_DISABLE;           //禁止突发写\n//\tTFTSRAM_Handler.Init.ContinuousClock=FSMC_CONTINUOUS_CLOCK_SYNC_ASYNC;\n//    \n//\t//FMC读时序控制寄存器\n//\tFSMC_ReadWriteTim.AddressSetupTime=0x0F;       \t//地址建立时间（ADDSET）为16个HCLK 1/168M=6ns*16=96ns\n//\tFSMC_ReadWriteTim.AddressHoldTime=0;\n//\tFSMC_ReadWriteTim.DataSetupTime=60;\t\t\t\t//数据保存时间为60个HCLK\t=6*60=360ns\n//\tFSMC_ReadWriteTim.AccessMode=FSMC_ACCESS_MODE_A;//模式A\n//\t//FMC写时序控制寄存器\n//\tFSMC_WriteTim.BusTurnAroundDuration=0;\t\t\t//总线周转阶段持续时间为0，此变量不赋值的话会莫名其妙的自动修改为4。导致程序运行正常\n//\tFSMC_WriteTim.AddressSetupTime=9;          \t\t//地址建立时间（ADDSET）为9个HCLK =54ns \n//\tFSMC_WriteTim.AddressHoldTime=0;\n//\tFSMC_WriteTim.DataSetupTime=8;              \t//数据保存时间为6ns*9个HCLK=54n\n//\tFSMC_WriteTim.AccessMode=FSMC_ACCESS_MODE_A;    //模式A\n//\tHAL_SRAM_Init(&TFTSRAM_Handler,&FSMC_ReadWriteTim,&FSMC_WriteTim);\t\n\n//\tHAL_Delay(50); // delay 50 ms \n\t\n\t//尝试9341 ID的读取\t\t\n\tLCD_WR_REG(0XD3);\t\t\n    .........\n}\n```\n\n> 注意有个坑！！！！\n>\n> 正点原子官方的`lcd_init`函数中有个 `printf(\" LCD ID:%x\\r\\n\",lcddev.id);`，所以在此之前需先进行串口重定向  \n\n##### 替换官方的delay函数\n\n```C\nvoid delay_us(u32 nus)\n{\n\tuint32_t Delay = nus * 168 / 4;\n\tdo\n\t{\n\t\t__NOP();\n\t} while (Delay--);\n}\n\n// 延时nms\n// nms:要延时的ms数\nvoid delay_ms(u16 nms)\n{\n\tHAL_Delay(nms);\n}\n```\n\n\n\n##### 修改点亮背光函数\n\n> 在`lcd_init`函数最后 将`LCD_BL(1)`替换为`HAL_GPIO_WritePin(LCD_BL_GPIO_Port, LCD_BL_Pin, GPIO_PIN_SET);`\n\n### 触摸屏TOUCH移植\n\n#### 将BSP文件夹下的24CXX、IIC与TOUCH文件夹添加到项目中\n\n![image-20250907180027576](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071800663.png)\n\n## LVGL移植\n\n### LVGL源码下载\n\n- 国内码云仓库：https://gitee.com/mirrors/lvgl\n\n  ![image-20250907180958855](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071809967.png)\n\n![image-20250907181022271](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071810376.png)\n\n> 注意不要直接克隆 直接克隆下载的是最新的 可以选择右上角下载zip 就可以选中当前分支\n\n### 裁剪LVGL源码\n\n#### 根目录\n\n> 仅保留 demos、examples、src文件夹以及两个.h文件 如下图\n\n![image-20250907181309155](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071813234.png)\n\n#### 进入`examples`文件夹 删去除`porting`文件夹\n\n![image-20250907181406209](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071814287.png)\n\n#### 更改`lv_conf_template.h`\n\n> 1. 将`lv_conf_template.h`更名为`lv_conf.h`\n> 2. 进入该文件 将里面的#if 0 改为#if 1\n>\n> ![image-20250907182017202](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071820299.png)\n\n### 按以下结构创建文件夹\n\n```C\nProject\n----Middlewares\n--------LVGL\n------------GUI\n----------------lvgl\n------------GUI_APP\n```\n\n> 将裁剪后的LVGL库文件复制到`Middlewares/LVGL/GUI/lvgl`文件夹下\n\n### Keil配置\n\n#### 创建如下管理\n\n![image-20250907194802955](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071948050.png)\n\n#### 添加路径\n\n![image-20250907194859063](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071948156.png)\n\n> - 注意一定要开启C99模式\n>\n> ![image-20250907195152454](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071951544.png)\n>\n> - 可以屏蔽MDK警告\n>\n>   --diag_suppress=68 --diag_suppress=111 --diag_suppress=188 --diag_suppress=223 --diag_suppress=546  --diag_suppress=1295\n>\n> \n\n#### 添加文件到项目\n\n![image-20250907195111490](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071951610.png)\n\n### LVGL文件修改\n\n#### 配置LCD屏幕显示\n\n![image-20250907195420988](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071954102.png)\n\n##### 包含输出设备驱动头文件\n\n> 在`lv_port_disp_template.c`引入`lcd.h` 如`#include \"../BSP/LCD/lcd.h\"`\n\n##### 在`disp_init`函数中初始化\n\n```C\nstatic void disp_init(void)\n{\n    /*You code here*/\n    LCD_Init();\n    LCD_Display_Dir(1); // 横屏\n}\n```\n\n##### 配置图形数据缓冲方式\n\n> 进入`lv_port_disp_init`函数\n>\n> 选择缓冲方式 另外两个将其屏蔽\n>\n> ![image-20250907195842896](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071958994.png)\n\n##### 修改`disp_flush`函数\n\n```C\nstatic void disp_flush(lv_disp_drv_t *disp_drv, const lv_area_t *area, lv_color_t *color_p)\n{\n    /*The most simple case (but also the slowest) to put all pixels to the screen one-by-one*/\n    /*官方打点函数 */\n    // int32_t x;\n    // int32_t y;\n    // for (y = area->y1; y <= area->y2; y++)\n    // {\n    //     for (x = area->x1; x <= area->x2; x++)\n    //     {\n    //         /*Put a pixel to the display. For example:*/\n    //         /*put_px(x, y, *color_p)*/\n    //         color_p++;\n    //     }\n    // }\n\n    LCD_Color_Fill(area->x1, area->y1, area->x2, area->y2, (uint16_t *)color_p);\n    /*IMPORTANT!!!\n     *Inform the graphics library that you are ready with the flushing*/\n    lv_disp_flush_ready(disp_drv);\n}\n```\n\n#### 配置输入（触摸）\n\n![image-20250907200123083](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509072001216.png)\n\n##### 按需裁剪输入设备\n\n> 打开`lv_port_indev_template.c` 此处我们只需要触摸输入 所以把除了touchpad 其他都屏蔽或删去\n>\n> 注意：一定要把其他无关的屏蔽掉 否则会无法触摸\n\n##### 在`touchpad_init`函数中初始化触摸屏\n\n```C\nstatic void touchpad_init(void)\n{\n    /*Your code comes here*/\n    tp_dev.init();\n}\n```\n\n##### 修改`touchpad_is_pressed`函数\n\n```C\nstatic bool touchpad_is_pressed(void)\n{\n    /*Your code comes here*/\n    tp_dev.scan(0); // É¨ÃèÎïÀí×ø±ê\n    if (tp_dev.sta & TP_PRES_DOWN)\n    {\n        return true;\n    }\n    return false;\n}\n```\n\n##### 配置坐标获取函数\n\n```C\nstatic void touchpad_get_xy(lv_coord_t *x, lv_coord_t *y)\n{\n    /*Your code comes here*/\n\n    (*x) = tp_dev.x[0];\n    (*y) = tp_dev.y[0];\n}\n```\n\n#### 提供时基\n\n> - 使用CubeMX生成一个定时1ms的定时器\n> - 在`tim.c`中引用`#include \"lvgl.h\"`\n> - 在定时器中断回调函数中`lv_tick_inc(1);`\n\n![image-20250907201034944](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509072010067.png)\n\n![image-20250907200845233](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509072008331.png)\n\n#### `main`函数部分\n\n![image-20250907201115783](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509072011915.png)\n\n```C\n#include \"lvgl.h\"\n#include \"lv_port_disp_template.h\"\n#include \"lv_port_indev_template.h\"\n....\nint main(void)\n{\n    .....\n  HAL_TIM_Base_Start_IT(&htim3); // 启动定时器3中断 为lvgl提供时基\n  lv_init();                     // 初始化LVGL\n  lv_port_disp_init();           // 初始化显示接口\n  lv_port_indev_init();          // 初始化输入接口\n  while (1)\n  {\n    lv_timer_handler(); // 处理LVGL任务\n    delay_ms(5);\n  }\n}\n```\n\n","slug":"LVGL学习之旅-DESKTOP-40","published":1,"updated":"2026-01-10T17:30:28.000Z","comments":1,"layout":"post","photos":[],"_id":"cmk8pg6xe00036sk9apm6ckrv","content":"<h2 id=\"LVGL-基础\"><a href=\"#LVGL-基础\" class=\"headerlink\" title=\"LVGL 基础\"></a>LVGL 基础</h2><blockquote>\n<p>LVGL（Light and Versatile Graphics Library）轻量级通用型图形库，是一个免费的开源图形库，提供了创建嵌入式 GUI 所需的一切，具有易于使用的组件，美观的视觉效果和低内存占用等特点。支持触摸屏操作，移植简单方便，开发者一直在不断完善更新。</p>\n<p>特点：</p>\n<ul>\n<li>丰富且强大的模块化图形组件：按钮 (buttons)、图表 (charts)、列表 (lists)、滑动条 (sliders)、图片 (images) 等</li>\n<li>高级的图形引擎：动画、抗锯齿、透明度、平滑滚动、图层混合等效果</li>\n<li>不依赖特定的硬件平台，可以在任何显示屏上运行</li>\n<li>配置可裁剪（最低资源占用：<span style=\"color:#FF0000;\">64 kB Flash，16 kB RAM</span>）</li>\n<li>基于<span style=\"color:#FF0000;\">UTF-8</span>的多语种支持，例如中文、日文、韩文、阿拉伯文等</li>\n<li>可以通过类CSS的方式来设计、布局图形界面（例如：Flexbox、Grid）</li>\n<li>支持操作系统、外置内存、以及硬件加速（LVGL已内建支持STM32 DMA2D、NXP PXP和VGLite）</li>\n<li>即便仅有单缓冲区(frame buffer)的情况下，也可保证渲染如丝般顺滑</li>\n<li>全部由C编写完成，并支持C++调用</li>\n<li>支持Micropython编程，参见：LVGL API in Micropython</li>\n<li>支持模拟器仿真，可以无硬件依托进行开发</li>\n</ul>\n</blockquote>\n<h2 id=\"TFT-LCD配置——移植正点原子官方LCD例程\"><a href=\"#TFT-LCD配置——移植正点原子官方LCD例程\" class=\"headerlink\" title=\"TFT-LCD配置——移植正点原子官方LCD例程\"></a>TFT-LCD配置——移植正点原子官方LCD例程</h2><h3 id=\"点亮LCD——FSMC配置\"><a href=\"#点亮LCD——FSMC配置\" class=\"headerlink\" title=\"点亮LCD——FSMC配置\"></a>点亮LCD——FSMC配置</h3><h4 id=\"先根据原理图配置FSMC\"><a href=\"#先根据原理图配置FSMC\" class=\"headerlink\" title=\"先根据原理图配置FSMC\"></a>先根据原理图配置<code>FSMC</code></h4><p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071556284.png\" alt=\"image-20250907155616208\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071607256.png\" alt=\"image-20250907160758201\"></p>\n<h4 id=\"详细FSMC参数配置\"><a href=\"#详细FSMC参数配置\" class=\"headerlink\" title=\"详细FSMC参数配置\"></a>详细FSMC参数配置</h4><blockquote>\n<p>这里根据正点原子官方<code>lcd_init</code> 来设置 如下图</p>\n</blockquote>\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071643877.png\" alt=\"image-20250907164335816\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071724936.png\" alt=\"img\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071725408.png\" alt=\"img\"></p>\n<h4 id=\"背光引脚配置\"><a href=\"#背光引脚配置\" class=\"headerlink\" title=\"背光引脚配置\"></a>背光引脚配置</h4><p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071725075.png\" alt=\"img\"></p>\n<h4 id=\"生成代码并将LCD、sys、delay文件夹添加到工程中\"><a href=\"#生成代码并将LCD、sys、delay文件夹添加到工程中\" class=\"headerlink\" title=\"生成代码并将LCD、sys、delay文件夹添加到工程中\"></a>生成代码并将LCD、sys、delay文件夹添加到工程中</h4><p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509072343199.png\" alt=\"image-20250907234315989\"></p>\n<h5 id=\"首先将HAL-SRAM-MspInit函数整个屏蔽\"><a href=\"#首先将HAL-SRAM-MspInit函数整个屏蔽\" class=\"headerlink\" title=\"首先将HAL_SRAM_MspInit函数整个屏蔽\"></a>首先将<em>HAL_SRAM_MspInit</em>函数整个屏蔽</h5><p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071718133.png\" alt=\"image-20250907171842072\"></p>\n<h5 id=\"将lcd-init中有关fsmc部分屏蔽\"><a href=\"#将lcd-init中有关fsmc部分屏蔽\" class=\"headerlink\" title=\"将lcd_init中有关fsmc部分屏蔽\"></a>将lcd_init中有关fsmc部分屏蔽</h5><blockquote>\n<p>屏蔽部分如下</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">LCD_Init</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123; \t  </span><br><span class=\"line\"><span class=\"comment\">//\tGPIO_InitTypeDef GPIO_Initure;</span></span><br><span class=\"line\"><span class=\"comment\">//\tFSMC_NORSRAM_TimingTypeDef FSMC_ReadWriteTim;</span></span><br><span class=\"line\"><span class=\"comment\">//\tFSMC_NORSRAM_TimingTypeDef FSMC_WriteTim;</span></span><br><span class=\"line\"><span class=\"comment\">//    </span></span><br><span class=\"line\"><span class=\"comment\">//\t__HAL_RCC_GPIOB_CLK_ENABLE();\t\t\t//开启GPIOB时钟</span></span><br><span class=\"line\"><span class=\"comment\">//\tGPIO_Initure.Pin=GPIO_PIN_15;          \t//PB15,背光控制</span></span><br><span class=\"line\"><span class=\"comment\">//\tGPIO_Initure.Mode=GPIO_MODE_OUTPUT_PP;  //推挽输出</span></span><br><span class=\"line\"><span class=\"comment\">//\tGPIO_Initure.Pull=GPIO_PULLUP;          //上拉</span></span><br><span class=\"line\"><span class=\"comment\">//\tGPIO_Initure.Speed=GPIO_SPEED_HIGH;     //高速</span></span><br><span class=\"line\"><span class=\"comment\">//\tHAL_GPIO_Init(GPIOB,&amp;GPIO_Initure); </span></span><br><span class=\"line\"><span class=\"comment\">//\t</span></span><br><span class=\"line\"><span class=\"comment\">//\tTFTSRAM_Handler.Instance=FSMC_NORSRAM_DEVICE;                </span></span><br><span class=\"line\"><span class=\"comment\">//\tTFTSRAM_Handler.Extended=FSMC_NORSRAM_EXTENDED_DEVICE;    </span></span><br><span class=\"line\"><span class=\"comment\">//    </span></span><br><span class=\"line\"><span class=\"comment\">//\tTFTSRAM_Handler.Init.NSBank=FSMC_NORSRAM_BANK4;     \t\t\t\t//使用NE4</span></span><br><span class=\"line\"><span class=\"comment\">//\tTFTSRAM_Handler.Init.DataAddressMux=FSMC_DATA_ADDRESS_MUX_DISABLE; \t//地址/数据线不复用</span></span><br><span class=\"line\"><span class=\"comment\">//\tTFTSRAM_Handler.Init.MemoryType=FSMC_MEMORY_TYPE_SRAM;   \t\t\t//SRAM</span></span><br><span class=\"line\"><span class=\"comment\">//\tTFTSRAM_Handler.Init.MemoryDataWidth=FSMC_NORSRAM_MEM_BUS_WIDTH_16; //16位数据宽度</span></span><br><span class=\"line\"><span class=\"comment\">//\tTFTSRAM_Handler.Init.BurstAccessMode=FSMC_BURST_ACCESS_MODE_DISABLE; //是否使能突发访问,仅对同步突发存储器有效,此处未用到</span></span><br><span class=\"line\"><span class=\"comment\">//\tTFTSRAM_Handler.Init.WaitSignalPolarity=FSMC_WAIT_SIGNAL_POLARITY_LOW;//等待信号的极性,仅在突发模式访问下有用</span></span><br><span class=\"line\"><span class=\"comment\">//\tTFTSRAM_Handler.Init.WaitSignalActive=FSMC_WAIT_TIMING_BEFORE_WS;   //存储器是在等待周期之前的一个时钟周期还是等待周期期间使能NWAIT</span></span><br><span class=\"line\"><span class=\"comment\">//\tTFTSRAM_Handler.Init.WriteOperation=FSMC_WRITE_OPERATION_ENABLE;    //存储器写使能</span></span><br><span class=\"line\"><span class=\"comment\">//\tTFTSRAM_Handler.Init.WaitSignal=FSMC_WAIT_SIGNAL_DISABLE;           //等待使能位,此处未用到</span></span><br><span class=\"line\"><span class=\"comment\">//\tTFTSRAM_Handler.Init.ExtendedMode=FSMC_EXTENDED_MODE_ENABLE;        //读写使用不同的时序</span></span><br><span class=\"line\"><span class=\"comment\">//\tTFTSRAM_Handler.Init.AsynchronousWait=FSMC_ASYNCHRONOUS_WAIT_DISABLE;//是否使能同步传输模式下的等待信号,此处未用到</span></span><br><span class=\"line\"><span class=\"comment\">//\tTFTSRAM_Handler.Init.WriteBurst=FSMC_WRITE_BURST_DISABLE;           //禁止突发写</span></span><br><span class=\"line\"><span class=\"comment\">//\tTFTSRAM_Handler.Init.ContinuousClock=FSMC_CONTINUOUS_CLOCK_SYNC_ASYNC;</span></span><br><span class=\"line\"><span class=\"comment\">//    </span></span><br><span class=\"line\"><span class=\"comment\">//\t//FMC读时序控制寄存器</span></span><br><span class=\"line\"><span class=\"comment\">//\tFSMC_ReadWriteTim.AddressSetupTime=0x0F;       \t//地址建立时间（ADDSET）为16个HCLK 1/168M=6ns*16=96ns</span></span><br><span class=\"line\"><span class=\"comment\">//\tFSMC_ReadWriteTim.AddressHoldTime=0;</span></span><br><span class=\"line\"><span class=\"comment\">//\tFSMC_ReadWriteTim.DataSetupTime=60;\t\t\t\t//数据保存时间为60个HCLK\t=6*60=360ns</span></span><br><span class=\"line\"><span class=\"comment\">//\tFSMC_ReadWriteTim.AccessMode=FSMC_ACCESS_MODE_A;//模式A</span></span><br><span class=\"line\"><span class=\"comment\">//\t//FMC写时序控制寄存器</span></span><br><span class=\"line\"><span class=\"comment\">//\tFSMC_WriteTim.BusTurnAroundDuration=0;\t\t\t//总线周转阶段持续时间为0，此变量不赋值的话会莫名其妙的自动修改为4。导致程序运行正常</span></span><br><span class=\"line\"><span class=\"comment\">//\tFSMC_WriteTim.AddressSetupTime=9;          \t\t//地址建立时间（ADDSET）为9个HCLK =54ns </span></span><br><span class=\"line\"><span class=\"comment\">//\tFSMC_WriteTim.AddressHoldTime=0;</span></span><br><span class=\"line\"><span class=\"comment\">//\tFSMC_WriteTim.DataSetupTime=8;              \t//数据保存时间为6ns*9个HCLK=54n</span></span><br><span class=\"line\"><span class=\"comment\">//\tFSMC_WriteTim.AccessMode=FSMC_ACCESS_MODE_A;    //模式A</span></span><br><span class=\"line\"><span class=\"comment\">//\tHAL_SRAM_Init(&amp;TFTSRAM_Handler,&amp;FSMC_ReadWriteTim,&amp;FSMC_WriteTim);\t</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//\tHAL_Delay(50); // delay 50 ms </span></span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">//尝试9341 ID的读取\t\t</span></span><br><span class=\"line\">\tLCD_WR_REG(<span class=\"number\">0XD3</span>);\t\t</span><br><span class=\"line\">    .........</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意有个坑！！！！</p>\n<p>正点原子官方的<code>lcd_init</code>函数中有个 <code>printf(&quot; LCD ID:%x\\r\\n&quot;,lcddev.id);</code>，所以在此之前需先进行串口重定向  </p>\n</blockquote>\n<h5 id=\"替换官方的delay函数\"><a href=\"#替换官方的delay函数\" class=\"headerlink\" title=\"替换官方的delay函数\"></a>替换官方的delay函数</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">delay_us</span><span class=\"params\">(u32 nus)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"type\">uint32_t</span> Delay = nus * <span class=\"number\">168</span> / <span class=\"number\">4</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">do</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t__NOP();</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">while</span> (Delay--);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 延时nms</span></span><br><span class=\"line\"><span class=\"comment\">// nms:要延时的ms数</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">delay_ms</span><span class=\"params\">(u16 nms)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tHAL_Delay(nms);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"修改点亮背光函数\"><a href=\"#修改点亮背光函数\" class=\"headerlink\" title=\"修改点亮背光函数\"></a>修改点亮背光函数</h5><blockquote>\n<p>在<code>lcd_init</code>函数最后 将<code>LCD_BL(1)</code>替换为<code>HAL_GPIO_WritePin(LCD_BL_GPIO_Port, LCD_BL_Pin, GPIO_PIN_SET);</code></p>\n</blockquote>\n<h3 id=\"触摸屏TOUCH移植\"><a href=\"#触摸屏TOUCH移植\" class=\"headerlink\" title=\"触摸屏TOUCH移植\"></a>触摸屏TOUCH移植</h3><h4 id=\"将BSP文件夹下的24CXX、IIC与TOUCH文件夹添加到项目中\"><a href=\"#将BSP文件夹下的24CXX、IIC与TOUCH文件夹添加到项目中\" class=\"headerlink\" title=\"将BSP文件夹下的24CXX、IIC与TOUCH文件夹添加到项目中\"></a>将BSP文件夹下的24CXX、IIC与TOUCH文件夹添加到项目中</h4><p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071800663.png\" alt=\"image-20250907180027576\"></p>\n<h2 id=\"LVGL移植\"><a href=\"#LVGL移植\" class=\"headerlink\" title=\"LVGL移植\"></a>LVGL移植</h2><h3 id=\"LVGL源码下载\"><a href=\"#LVGL源码下载\" class=\"headerlink\" title=\"LVGL源码下载\"></a>LVGL源码下载</h3><ul>\n<li><p>国内码云仓库：<a href=\"https://gitee.com/mirrors/lvgl\">https://gitee.com/mirrors/lvgl</a></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071809967.png\" alt=\"image-20250907180958855\"></p>\n</li>\n</ul>\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071810376.png\" alt=\"image-20250907181022271\"></p>\n<blockquote>\n<p>注意不要直接克隆 直接克隆下载的是最新的 可以选择右上角下载zip 就可以选中当前分支</p>\n</blockquote>\n<h3 id=\"裁剪LVGL源码\"><a href=\"#裁剪LVGL源码\" class=\"headerlink\" title=\"裁剪LVGL源码\"></a>裁剪LVGL源码</h3><h4 id=\"根目录\"><a href=\"#根目录\" class=\"headerlink\" title=\"根目录\"></a>根目录</h4><blockquote>\n<p>仅保留 demos、examples、src文件夹以及两个.h文件 如下图</p>\n</blockquote>\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071813234.png\" alt=\"image-20250907181309155\"></p>\n<h4 id=\"进入examples文件夹-删去除porting文件夹\"><a href=\"#进入examples文件夹-删去除porting文件夹\" class=\"headerlink\" title=\"进入examples文件夹 删去除porting文件夹\"></a>进入<code>examples</code>文件夹 删去除<code>porting</code>文件夹</h4><p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071814287.png\" alt=\"image-20250907181406209\"></p>\n<h4 id=\"更改lv-conf-template-h\"><a href=\"#更改lv-conf-template-h\" class=\"headerlink\" title=\"更改lv_conf_template.h\"></a>更改<code>lv_conf_template.h</code></h4><blockquote>\n<ol>\n<li>将<code>lv_conf_template.h</code>更名为<code>lv_conf.h</code></li>\n<li>进入该文件 将里面的#if 0 改为#if 1</li>\n</ol>\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071820299.png\" alt=\"image-20250907182017202\"></p>\n</blockquote>\n<h3 id=\"按以下结构创建文件夹\"><a href=\"#按以下结构创建文件夹\" class=\"headerlink\" title=\"按以下结构创建文件夹\"></a>按以下结构创建文件夹</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Project</span><br><span class=\"line\">----Middlewares</span><br><span class=\"line\">--------LVGL</span><br><span class=\"line\">------------GUI</span><br><span class=\"line\">----------------lvgl</span><br><span class=\"line\">------------GUI_APP</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>将裁剪后的LVGL库文件复制到<code>Middlewares/LVGL/GUI/lvgl</code>文件夹下</p>\n</blockquote>\n<h3 id=\"Keil配置\"><a href=\"#Keil配置\" class=\"headerlink\" title=\"Keil配置\"></a>Keil配置</h3><h4 id=\"创建如下管理\"><a href=\"#创建如下管理\" class=\"headerlink\" title=\"创建如下管理\"></a>创建如下管理</h4><p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071948050.png\" alt=\"image-20250907194802955\"></p>\n<h4 id=\"添加路径\"><a href=\"#添加路径\" class=\"headerlink\" title=\"添加路径\"></a>添加路径</h4><p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071948156.png\" alt=\"image-20250907194859063\"></p>\n<blockquote>\n<ul>\n<li>注意一定要开启C99模式</li>\n</ul>\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071951544.png\" alt=\"image-20250907195152454\"></p>\n<ul>\n<li><p>可以屏蔽MDK警告</p>\n<p>–diag_suppress&#x3D;68 –diag_suppress&#x3D;111 –diag_suppress&#x3D;188 –diag_suppress&#x3D;223 –diag_suppress&#x3D;546  –diag_suppress&#x3D;1295</p>\n</li>\n</ul>\n</blockquote>\n<h4 id=\"添加文件到项目\"><a href=\"#添加文件到项目\" class=\"headerlink\" title=\"添加文件到项目\"></a>添加文件到项目</h4><p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071951610.png\" alt=\"image-20250907195111490\"></p>\n<h3 id=\"LVGL文件修改\"><a href=\"#LVGL文件修改\" class=\"headerlink\" title=\"LVGL文件修改\"></a>LVGL文件修改</h3><h4 id=\"配置LCD屏幕显示\"><a href=\"#配置LCD屏幕显示\" class=\"headerlink\" title=\"配置LCD屏幕显示\"></a>配置LCD屏幕显示</h4><p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071954102.png\" alt=\"image-20250907195420988\"></p>\n<h5 id=\"包含输出设备驱动头文件\"><a href=\"#包含输出设备驱动头文件\" class=\"headerlink\" title=\"包含输出设备驱动头文件\"></a>包含输出设备驱动头文件</h5><blockquote>\n<p>在<code>lv_port_disp_template.c</code>引入<code>lcd.h</code> 如<code>#include &quot;../BSP/LCD/lcd.h&quot;</code></p>\n</blockquote>\n<h5 id=\"在disp-init函数中初始化\"><a href=\"#在disp-init函数中初始化\" class=\"headerlink\" title=\"在disp_init函数中初始化\"></a>在<code>disp_init</code>函数中初始化</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title function_\">disp_init</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">/*You code here*/</span></span><br><span class=\"line\">    LCD_Init();</span><br><span class=\"line\">    LCD_Display_Dir(<span class=\"number\">1</span>); <span class=\"comment\">// 横屏</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"配置图形数据缓冲方式\"><a href=\"#配置图形数据缓冲方式\" class=\"headerlink\" title=\"配置图形数据缓冲方式\"></a>配置图形数据缓冲方式</h5><blockquote>\n<p>进入<code>lv_port_disp_init</code>函数</p>\n<p>选择缓冲方式 另外两个将其屏蔽</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071958994.png\" alt=\"image-20250907195842896\"></p>\n</blockquote>\n<h5 id=\"修改disp-flush函数\"><a href=\"#修改disp-flush函数\" class=\"headerlink\" title=\"修改disp_flush函数\"></a>修改<code>disp_flush</code>函数</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title function_\">disp_flush</span><span class=\"params\">(<span class=\"type\">lv_disp_drv_t</span> *disp_drv, <span class=\"type\">const</span> <span class=\"type\">lv_area_t</span> *area, <span class=\"type\">lv_color_t</span> *color_p)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">/*The most simple case (but also the slowest) to put all pixels to the screen one-by-one*/</span></span><br><span class=\"line\">    <span class=\"comment\">/*官方打点函数 */</span></span><br><span class=\"line\">    <span class=\"comment\">// int32_t x;</span></span><br><span class=\"line\">    <span class=\"comment\">// int32_t y;</span></span><br><span class=\"line\">    <span class=\"comment\">// for (y = area-&gt;y1; y &lt;= area-&gt;y2; y++)</span></span><br><span class=\"line\">    <span class=\"comment\">// &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//     for (x = area-&gt;x1; x &lt;= area-&gt;x2; x++)</span></span><br><span class=\"line\">    <span class=\"comment\">//     &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//         /*Put a pixel to the display. For example:*/</span></span><br><span class=\"line\">    <span class=\"comment\">//         /*put_px(x, y, *color_p)*/</span></span><br><span class=\"line\">    <span class=\"comment\">//         color_p++;</span></span><br><span class=\"line\">    <span class=\"comment\">//     &#125;</span></span><br><span class=\"line\">    <span class=\"comment\">// &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    LCD_Color_Fill(area-&gt;x1, area-&gt;y1, area-&gt;x2, area-&gt;y2, (<span class=\"type\">uint16_t</span> *)color_p);</span><br><span class=\"line\">    <span class=\"comment\">/*IMPORTANT!!!</span></span><br><span class=\"line\"><span class=\"comment\">     *Inform the graphics library that you are ready with the flushing*/</span></span><br><span class=\"line\">    lv_disp_flush_ready(disp_drv);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"配置输入（触摸）\"><a href=\"#配置输入（触摸）\" class=\"headerlink\" title=\"配置输入（触摸）\"></a>配置输入（触摸）</h4><p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509072001216.png\" alt=\"image-20250907200123083\"></p>\n<h5 id=\"按需裁剪输入设备\"><a href=\"#按需裁剪输入设备\" class=\"headerlink\" title=\"按需裁剪输入设备\"></a>按需裁剪输入设备</h5><blockquote>\n<p>打开<code>lv_port_indev_template.c</code> 此处我们只需要触摸输入 所以把除了touchpad 其他都屏蔽或删去</p>\n<p>注意：一定要把其他无关的屏蔽掉 否则会无法触摸</p>\n</blockquote>\n<h5 id=\"在touchpad-init函数中初始化触摸屏\"><a href=\"#在touchpad-init函数中初始化触摸屏\" class=\"headerlink\" title=\"在touchpad_init函数中初始化触摸屏\"></a>在<code>touchpad_init</code>函数中初始化触摸屏</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title function_\">touchpad_init</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">/*Your code comes here*/</span></span><br><span class=\"line\">    tp_dev.init();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"修改touchpad-is-pressed函数\"><a href=\"#修改touchpad-is-pressed函数\" class=\"headerlink\" title=\"修改touchpad_is_pressed函数\"></a>修改<code>touchpad_is_pressed</code>函数</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">bool</span> <span class=\"title function_\">touchpad_is_pressed</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">/*Your code comes here*/</span></span><br><span class=\"line\">    tp_dev.scan(<span class=\"number\">0</span>); <span class=\"comment\">// É¨ÃèÎïÀí×ø±ê</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tp_dev.sta &amp; TP_PRES_DOWN)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"配置坐标获取函数\"><a href=\"#配置坐标获取函数\" class=\"headerlink\" title=\"配置坐标获取函数\"></a>配置坐标获取函数</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title function_\">touchpad_get_xy</span><span class=\"params\">(<span class=\"type\">lv_coord_t</span> *x, <span class=\"type\">lv_coord_t</span> *y)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">/*Your code comes here*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">    (*x) = tp_dev.x[<span class=\"number\">0</span>];</span><br><span class=\"line\">    (*y) = tp_dev.y[<span class=\"number\">0</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"提供时基\"><a href=\"#提供时基\" class=\"headerlink\" title=\"提供时基\"></a>提供时基</h4><blockquote>\n<ul>\n<li>使用CubeMX生成一个定时1ms的定时器</li>\n<li>在<code>tim.c</code>中引用<code>#include &quot;lvgl.h&quot;</code></li>\n<li>在定时器中断回调函数中<code>lv_tick_inc(1);</code></li>\n</ul>\n</blockquote>\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509072010067.png\" alt=\"image-20250907201034944\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509072008331.png\" alt=\"image-20250907200845233\"></p>\n<h4 id=\"main函数部分\"><a href=\"#main函数部分\" class=\"headerlink\" title=\"main函数部分\"></a><code>main</code>函数部分</h4><p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509072011915.png\" alt=\"image-20250907201115783\"></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;lvgl.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;lv_port_disp_template.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;lv_port_indev_template.h&quot;</span></span></span><br><span class=\"line\">....</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    .....</span><br><span class=\"line\">  HAL_TIM_Base_Start_IT(&amp;htim3); <span class=\"comment\">// 启动定时器3中断 为lvgl提供时基</span></span><br><span class=\"line\">  lv_init();                     <span class=\"comment\">// 初始化LVGL</span></span><br><span class=\"line\">  lv_port_disp_init();           <span class=\"comment\">// 初始化显示接口</span></span><br><span class=\"line\">  lv_port_indev_init();          <span class=\"comment\">// 初始化输入接口</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (<span class=\"number\">1</span>)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    lv_timer_handler(); <span class=\"comment\">// 处理LVGL任务</span></span><br><span class=\"line\">    delay_ms(<span class=\"number\">5</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","excerpt":"","more":"<h2 id=\"LVGL-基础\"><a href=\"#LVGL-基础\" class=\"headerlink\" title=\"LVGL 基础\"></a>LVGL 基础</h2><blockquote>\n<p>LVGL（Light and Versatile Graphics Library）轻量级通用型图形库，是一个免费的开源图形库，提供了创建嵌入式 GUI 所需的一切，具有易于使用的组件，美观的视觉效果和低内存占用等特点。支持触摸屏操作，移植简单方便，开发者一直在不断完善更新。</p>\n<p>特点：</p>\n<ul>\n<li>丰富且强大的模块化图形组件：按钮 (buttons)、图表 (charts)、列表 (lists)、滑动条 (sliders)、图片 (images) 等</li>\n<li>高级的图形引擎：动画、抗锯齿、透明度、平滑滚动、图层混合等效果</li>\n<li>不依赖特定的硬件平台，可以在任何显示屏上运行</li>\n<li>配置可裁剪（最低资源占用：<span style=\"color:#FF0000;\">64 kB Flash，16 kB RAM</span>）</li>\n<li>基于<span style=\"color:#FF0000;\">UTF-8</span>的多语种支持，例如中文、日文、韩文、阿拉伯文等</li>\n<li>可以通过类CSS的方式来设计、布局图形界面（例如：Flexbox、Grid）</li>\n<li>支持操作系统、外置内存、以及硬件加速（LVGL已内建支持STM32 DMA2D、NXP PXP和VGLite）</li>\n<li>即便仅有单缓冲区(frame buffer)的情况下，也可保证渲染如丝般顺滑</li>\n<li>全部由C编写完成，并支持C++调用</li>\n<li>支持Micropython编程，参见：LVGL API in Micropython</li>\n<li>支持模拟器仿真，可以无硬件依托进行开发</li>\n</ul>\n</blockquote>\n<h2 id=\"TFT-LCD配置——移植正点原子官方LCD例程\"><a href=\"#TFT-LCD配置——移植正点原子官方LCD例程\" class=\"headerlink\" title=\"TFT-LCD配置——移植正点原子官方LCD例程\"></a>TFT-LCD配置——移植正点原子官方LCD例程</h2><h3 id=\"点亮LCD——FSMC配置\"><a href=\"#点亮LCD——FSMC配置\" class=\"headerlink\" title=\"点亮LCD——FSMC配置\"></a>点亮LCD——FSMC配置</h3><h4 id=\"先根据原理图配置FSMC\"><a href=\"#先根据原理图配置FSMC\" class=\"headerlink\" title=\"先根据原理图配置FSMC\"></a>先根据原理图配置<code>FSMC</code></h4><p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071556284.png\" alt=\"image-20250907155616208\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071607256.png\" alt=\"image-20250907160758201\"></p>\n<h4 id=\"详细FSMC参数配置\"><a href=\"#详细FSMC参数配置\" class=\"headerlink\" title=\"详细FSMC参数配置\"></a>详细FSMC参数配置</h4><blockquote>\n<p>这里根据正点原子官方<code>lcd_init</code> 来设置 如下图</p>\n</blockquote>\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071643877.png\" alt=\"image-20250907164335816\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071724936.png\" alt=\"img\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071725408.png\" alt=\"img\"></p>\n<h4 id=\"背光引脚配置\"><a href=\"#背光引脚配置\" class=\"headerlink\" title=\"背光引脚配置\"></a>背光引脚配置</h4><p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071725075.png\" alt=\"img\"></p>\n<h4 id=\"生成代码并将LCD、sys、delay文件夹添加到工程中\"><a href=\"#生成代码并将LCD、sys、delay文件夹添加到工程中\" class=\"headerlink\" title=\"生成代码并将LCD、sys、delay文件夹添加到工程中\"></a>生成代码并将LCD、sys、delay文件夹添加到工程中</h4><p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509072343199.png\" alt=\"image-20250907234315989\"></p>\n<h5 id=\"首先将HAL-SRAM-MspInit函数整个屏蔽\"><a href=\"#首先将HAL-SRAM-MspInit函数整个屏蔽\" class=\"headerlink\" title=\"首先将HAL_SRAM_MspInit函数整个屏蔽\"></a>首先将<em>HAL_SRAM_MspInit</em>函数整个屏蔽</h5><p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071718133.png\" alt=\"image-20250907171842072\"></p>\n<h5 id=\"将lcd-init中有关fsmc部分屏蔽\"><a href=\"#将lcd-init中有关fsmc部分屏蔽\" class=\"headerlink\" title=\"将lcd_init中有关fsmc部分屏蔽\"></a>将lcd_init中有关fsmc部分屏蔽</h5><blockquote>\n<p>屏蔽部分如下</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">LCD_Init</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123; \t  </span><br><span class=\"line\"><span class=\"comment\">//\tGPIO_InitTypeDef GPIO_Initure;</span></span><br><span class=\"line\"><span class=\"comment\">//\tFSMC_NORSRAM_TimingTypeDef FSMC_ReadWriteTim;</span></span><br><span class=\"line\"><span class=\"comment\">//\tFSMC_NORSRAM_TimingTypeDef FSMC_WriteTim;</span></span><br><span class=\"line\"><span class=\"comment\">//    </span></span><br><span class=\"line\"><span class=\"comment\">//\t__HAL_RCC_GPIOB_CLK_ENABLE();\t\t\t//开启GPIOB时钟</span></span><br><span class=\"line\"><span class=\"comment\">//\tGPIO_Initure.Pin=GPIO_PIN_15;          \t//PB15,背光控制</span></span><br><span class=\"line\"><span class=\"comment\">//\tGPIO_Initure.Mode=GPIO_MODE_OUTPUT_PP;  //推挽输出</span></span><br><span class=\"line\"><span class=\"comment\">//\tGPIO_Initure.Pull=GPIO_PULLUP;          //上拉</span></span><br><span class=\"line\"><span class=\"comment\">//\tGPIO_Initure.Speed=GPIO_SPEED_HIGH;     //高速</span></span><br><span class=\"line\"><span class=\"comment\">//\tHAL_GPIO_Init(GPIOB,&amp;GPIO_Initure); </span></span><br><span class=\"line\"><span class=\"comment\">//\t</span></span><br><span class=\"line\"><span class=\"comment\">//\tTFTSRAM_Handler.Instance=FSMC_NORSRAM_DEVICE;                </span></span><br><span class=\"line\"><span class=\"comment\">//\tTFTSRAM_Handler.Extended=FSMC_NORSRAM_EXTENDED_DEVICE;    </span></span><br><span class=\"line\"><span class=\"comment\">//    </span></span><br><span class=\"line\"><span class=\"comment\">//\tTFTSRAM_Handler.Init.NSBank=FSMC_NORSRAM_BANK4;     \t\t\t\t//使用NE4</span></span><br><span class=\"line\"><span class=\"comment\">//\tTFTSRAM_Handler.Init.DataAddressMux=FSMC_DATA_ADDRESS_MUX_DISABLE; \t//地址/数据线不复用</span></span><br><span class=\"line\"><span class=\"comment\">//\tTFTSRAM_Handler.Init.MemoryType=FSMC_MEMORY_TYPE_SRAM;   \t\t\t//SRAM</span></span><br><span class=\"line\"><span class=\"comment\">//\tTFTSRAM_Handler.Init.MemoryDataWidth=FSMC_NORSRAM_MEM_BUS_WIDTH_16; //16位数据宽度</span></span><br><span class=\"line\"><span class=\"comment\">//\tTFTSRAM_Handler.Init.BurstAccessMode=FSMC_BURST_ACCESS_MODE_DISABLE; //是否使能突发访问,仅对同步突发存储器有效,此处未用到</span></span><br><span class=\"line\"><span class=\"comment\">//\tTFTSRAM_Handler.Init.WaitSignalPolarity=FSMC_WAIT_SIGNAL_POLARITY_LOW;//等待信号的极性,仅在突发模式访问下有用</span></span><br><span class=\"line\"><span class=\"comment\">//\tTFTSRAM_Handler.Init.WaitSignalActive=FSMC_WAIT_TIMING_BEFORE_WS;   //存储器是在等待周期之前的一个时钟周期还是等待周期期间使能NWAIT</span></span><br><span class=\"line\"><span class=\"comment\">//\tTFTSRAM_Handler.Init.WriteOperation=FSMC_WRITE_OPERATION_ENABLE;    //存储器写使能</span></span><br><span class=\"line\"><span class=\"comment\">//\tTFTSRAM_Handler.Init.WaitSignal=FSMC_WAIT_SIGNAL_DISABLE;           //等待使能位,此处未用到</span></span><br><span class=\"line\"><span class=\"comment\">//\tTFTSRAM_Handler.Init.ExtendedMode=FSMC_EXTENDED_MODE_ENABLE;        //读写使用不同的时序</span></span><br><span class=\"line\"><span class=\"comment\">//\tTFTSRAM_Handler.Init.AsynchronousWait=FSMC_ASYNCHRONOUS_WAIT_DISABLE;//是否使能同步传输模式下的等待信号,此处未用到</span></span><br><span class=\"line\"><span class=\"comment\">//\tTFTSRAM_Handler.Init.WriteBurst=FSMC_WRITE_BURST_DISABLE;           //禁止突发写</span></span><br><span class=\"line\"><span class=\"comment\">//\tTFTSRAM_Handler.Init.ContinuousClock=FSMC_CONTINUOUS_CLOCK_SYNC_ASYNC;</span></span><br><span class=\"line\"><span class=\"comment\">//    </span></span><br><span class=\"line\"><span class=\"comment\">//\t//FMC读时序控制寄存器</span></span><br><span class=\"line\"><span class=\"comment\">//\tFSMC_ReadWriteTim.AddressSetupTime=0x0F;       \t//地址建立时间（ADDSET）为16个HCLK 1/168M=6ns*16=96ns</span></span><br><span class=\"line\"><span class=\"comment\">//\tFSMC_ReadWriteTim.AddressHoldTime=0;</span></span><br><span class=\"line\"><span class=\"comment\">//\tFSMC_ReadWriteTim.DataSetupTime=60;\t\t\t\t//数据保存时间为60个HCLK\t=6*60=360ns</span></span><br><span class=\"line\"><span class=\"comment\">//\tFSMC_ReadWriteTim.AccessMode=FSMC_ACCESS_MODE_A;//模式A</span></span><br><span class=\"line\"><span class=\"comment\">//\t//FMC写时序控制寄存器</span></span><br><span class=\"line\"><span class=\"comment\">//\tFSMC_WriteTim.BusTurnAroundDuration=0;\t\t\t//总线周转阶段持续时间为0，此变量不赋值的话会莫名其妙的自动修改为4。导致程序运行正常</span></span><br><span class=\"line\"><span class=\"comment\">//\tFSMC_WriteTim.AddressSetupTime=9;          \t\t//地址建立时间（ADDSET）为9个HCLK =54ns </span></span><br><span class=\"line\"><span class=\"comment\">//\tFSMC_WriteTim.AddressHoldTime=0;</span></span><br><span class=\"line\"><span class=\"comment\">//\tFSMC_WriteTim.DataSetupTime=8;              \t//数据保存时间为6ns*9个HCLK=54n</span></span><br><span class=\"line\"><span class=\"comment\">//\tFSMC_WriteTim.AccessMode=FSMC_ACCESS_MODE_A;    //模式A</span></span><br><span class=\"line\"><span class=\"comment\">//\tHAL_SRAM_Init(&amp;TFTSRAM_Handler,&amp;FSMC_ReadWriteTim,&amp;FSMC_WriteTim);\t</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//\tHAL_Delay(50); // delay 50 ms </span></span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">//尝试9341 ID的读取\t\t</span></span><br><span class=\"line\">\tLCD_WR_REG(<span class=\"number\">0XD3</span>);\t\t</span><br><span class=\"line\">    .........</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意有个坑！！！！</p>\n<p>正点原子官方的<code>lcd_init</code>函数中有个 <code>printf(&quot; LCD ID:%x\\r\\n&quot;,lcddev.id);</code>，所以在此之前需先进行串口重定向  </p>\n</blockquote>\n<h5 id=\"替换官方的delay函数\"><a href=\"#替换官方的delay函数\" class=\"headerlink\" title=\"替换官方的delay函数\"></a>替换官方的delay函数</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">delay_us</span><span class=\"params\">(u32 nus)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"type\">uint32_t</span> Delay = nus * <span class=\"number\">168</span> / <span class=\"number\">4</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">do</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t__NOP();</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">while</span> (Delay--);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 延时nms</span></span><br><span class=\"line\"><span class=\"comment\">// nms:要延时的ms数</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">delay_ms</span><span class=\"params\">(u16 nms)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tHAL_Delay(nms);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"修改点亮背光函数\"><a href=\"#修改点亮背光函数\" class=\"headerlink\" title=\"修改点亮背光函数\"></a>修改点亮背光函数</h5><blockquote>\n<p>在<code>lcd_init</code>函数最后 将<code>LCD_BL(1)</code>替换为<code>HAL_GPIO_WritePin(LCD_BL_GPIO_Port, LCD_BL_Pin, GPIO_PIN_SET);</code></p>\n</blockquote>\n<h3 id=\"触摸屏TOUCH移植\"><a href=\"#触摸屏TOUCH移植\" class=\"headerlink\" title=\"触摸屏TOUCH移植\"></a>触摸屏TOUCH移植</h3><h4 id=\"将BSP文件夹下的24CXX、IIC与TOUCH文件夹添加到项目中\"><a href=\"#将BSP文件夹下的24CXX、IIC与TOUCH文件夹添加到项目中\" class=\"headerlink\" title=\"将BSP文件夹下的24CXX、IIC与TOUCH文件夹添加到项目中\"></a>将BSP文件夹下的24CXX、IIC与TOUCH文件夹添加到项目中</h4><p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071800663.png\" alt=\"image-20250907180027576\"></p>\n<h2 id=\"LVGL移植\"><a href=\"#LVGL移植\" class=\"headerlink\" title=\"LVGL移植\"></a>LVGL移植</h2><h3 id=\"LVGL源码下载\"><a href=\"#LVGL源码下载\" class=\"headerlink\" title=\"LVGL源码下载\"></a>LVGL源码下载</h3><ul>\n<li><p>国内码云仓库：<a href=\"https://gitee.com/mirrors/lvgl\">https://gitee.com/mirrors/lvgl</a></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071809967.png\" alt=\"image-20250907180958855\"></p>\n</li>\n</ul>\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071810376.png\" alt=\"image-20250907181022271\"></p>\n<blockquote>\n<p>注意不要直接克隆 直接克隆下载的是最新的 可以选择右上角下载zip 就可以选中当前分支</p>\n</blockquote>\n<h3 id=\"裁剪LVGL源码\"><a href=\"#裁剪LVGL源码\" class=\"headerlink\" title=\"裁剪LVGL源码\"></a>裁剪LVGL源码</h3><h4 id=\"根目录\"><a href=\"#根目录\" class=\"headerlink\" title=\"根目录\"></a>根目录</h4><blockquote>\n<p>仅保留 demos、examples、src文件夹以及两个.h文件 如下图</p>\n</blockquote>\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071813234.png\" alt=\"image-20250907181309155\"></p>\n<h4 id=\"进入examples文件夹-删去除porting文件夹\"><a href=\"#进入examples文件夹-删去除porting文件夹\" class=\"headerlink\" title=\"进入examples文件夹 删去除porting文件夹\"></a>进入<code>examples</code>文件夹 删去除<code>porting</code>文件夹</h4><p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071814287.png\" alt=\"image-20250907181406209\"></p>\n<h4 id=\"更改lv-conf-template-h\"><a href=\"#更改lv-conf-template-h\" class=\"headerlink\" title=\"更改lv_conf_template.h\"></a>更改<code>lv_conf_template.h</code></h4><blockquote>\n<ol>\n<li>将<code>lv_conf_template.h</code>更名为<code>lv_conf.h</code></li>\n<li>进入该文件 将里面的#if 0 改为#if 1</li>\n</ol>\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071820299.png\" alt=\"image-20250907182017202\"></p>\n</blockquote>\n<h3 id=\"按以下结构创建文件夹\"><a href=\"#按以下结构创建文件夹\" class=\"headerlink\" title=\"按以下结构创建文件夹\"></a>按以下结构创建文件夹</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Project</span><br><span class=\"line\">----Middlewares</span><br><span class=\"line\">--------LVGL</span><br><span class=\"line\">------------GUI</span><br><span class=\"line\">----------------lvgl</span><br><span class=\"line\">------------GUI_APP</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>将裁剪后的LVGL库文件复制到<code>Middlewares/LVGL/GUI/lvgl</code>文件夹下</p>\n</blockquote>\n<h3 id=\"Keil配置\"><a href=\"#Keil配置\" class=\"headerlink\" title=\"Keil配置\"></a>Keil配置</h3><h4 id=\"创建如下管理\"><a href=\"#创建如下管理\" class=\"headerlink\" title=\"创建如下管理\"></a>创建如下管理</h4><p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071948050.png\" alt=\"image-20250907194802955\"></p>\n<h4 id=\"添加路径\"><a href=\"#添加路径\" class=\"headerlink\" title=\"添加路径\"></a>添加路径</h4><p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071948156.png\" alt=\"image-20250907194859063\"></p>\n<blockquote>\n<ul>\n<li>注意一定要开启C99模式</li>\n</ul>\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071951544.png\" alt=\"image-20250907195152454\"></p>\n<ul>\n<li><p>可以屏蔽MDK警告</p>\n<p>–diag_suppress&#x3D;68 –diag_suppress&#x3D;111 –diag_suppress&#x3D;188 –diag_suppress&#x3D;223 –diag_suppress&#x3D;546  –diag_suppress&#x3D;1295</p>\n</li>\n</ul>\n</blockquote>\n<h4 id=\"添加文件到项目\"><a href=\"#添加文件到项目\" class=\"headerlink\" title=\"添加文件到项目\"></a>添加文件到项目</h4><p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071951610.png\" alt=\"image-20250907195111490\"></p>\n<h3 id=\"LVGL文件修改\"><a href=\"#LVGL文件修改\" class=\"headerlink\" title=\"LVGL文件修改\"></a>LVGL文件修改</h3><h4 id=\"配置LCD屏幕显示\"><a href=\"#配置LCD屏幕显示\" class=\"headerlink\" title=\"配置LCD屏幕显示\"></a>配置LCD屏幕显示</h4><p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071954102.png\" alt=\"image-20250907195420988\"></p>\n<h5 id=\"包含输出设备驱动头文件\"><a href=\"#包含输出设备驱动头文件\" class=\"headerlink\" title=\"包含输出设备驱动头文件\"></a>包含输出设备驱动头文件</h5><blockquote>\n<p>在<code>lv_port_disp_template.c</code>引入<code>lcd.h</code> 如<code>#include &quot;../BSP/LCD/lcd.h&quot;</code></p>\n</blockquote>\n<h5 id=\"在disp-init函数中初始化\"><a href=\"#在disp-init函数中初始化\" class=\"headerlink\" title=\"在disp_init函数中初始化\"></a>在<code>disp_init</code>函数中初始化</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title function_\">disp_init</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">/*You code here*/</span></span><br><span class=\"line\">    LCD_Init();</span><br><span class=\"line\">    LCD_Display_Dir(<span class=\"number\">1</span>); <span class=\"comment\">// 横屏</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"配置图形数据缓冲方式\"><a href=\"#配置图形数据缓冲方式\" class=\"headerlink\" title=\"配置图形数据缓冲方式\"></a>配置图形数据缓冲方式</h5><blockquote>\n<p>进入<code>lv_port_disp_init</code>函数</p>\n<p>选择缓冲方式 另外两个将其屏蔽</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071958994.png\" alt=\"image-20250907195842896\"></p>\n</blockquote>\n<h5 id=\"修改disp-flush函数\"><a href=\"#修改disp-flush函数\" class=\"headerlink\" title=\"修改disp_flush函数\"></a>修改<code>disp_flush</code>函数</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title function_\">disp_flush</span><span class=\"params\">(<span class=\"type\">lv_disp_drv_t</span> *disp_drv, <span class=\"type\">const</span> <span class=\"type\">lv_area_t</span> *area, <span class=\"type\">lv_color_t</span> *color_p)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">/*The most simple case (but also the slowest) to put all pixels to the screen one-by-one*/</span></span><br><span class=\"line\">    <span class=\"comment\">/*官方打点函数 */</span></span><br><span class=\"line\">    <span class=\"comment\">// int32_t x;</span></span><br><span class=\"line\">    <span class=\"comment\">// int32_t y;</span></span><br><span class=\"line\">    <span class=\"comment\">// for (y = area-&gt;y1; y &lt;= area-&gt;y2; y++)</span></span><br><span class=\"line\">    <span class=\"comment\">// &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//     for (x = area-&gt;x1; x &lt;= area-&gt;x2; x++)</span></span><br><span class=\"line\">    <span class=\"comment\">//     &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//         /*Put a pixel to the display. For example:*/</span></span><br><span class=\"line\">    <span class=\"comment\">//         /*put_px(x, y, *color_p)*/</span></span><br><span class=\"line\">    <span class=\"comment\">//         color_p++;</span></span><br><span class=\"line\">    <span class=\"comment\">//     &#125;</span></span><br><span class=\"line\">    <span class=\"comment\">// &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    LCD_Color_Fill(area-&gt;x1, area-&gt;y1, area-&gt;x2, area-&gt;y2, (<span class=\"type\">uint16_t</span> *)color_p);</span><br><span class=\"line\">    <span class=\"comment\">/*IMPORTANT!!!</span></span><br><span class=\"line\"><span class=\"comment\">     *Inform the graphics library that you are ready with the flushing*/</span></span><br><span class=\"line\">    lv_disp_flush_ready(disp_drv);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"配置输入（触摸）\"><a href=\"#配置输入（触摸）\" class=\"headerlink\" title=\"配置输入（触摸）\"></a>配置输入（触摸）</h4><p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509072001216.png\" alt=\"image-20250907200123083\"></p>\n<h5 id=\"按需裁剪输入设备\"><a href=\"#按需裁剪输入设备\" class=\"headerlink\" title=\"按需裁剪输入设备\"></a>按需裁剪输入设备</h5><blockquote>\n<p>打开<code>lv_port_indev_template.c</code> 此处我们只需要触摸输入 所以把除了touchpad 其他都屏蔽或删去</p>\n<p>注意：一定要把其他无关的屏蔽掉 否则会无法触摸</p>\n</blockquote>\n<h5 id=\"在touchpad-init函数中初始化触摸屏\"><a href=\"#在touchpad-init函数中初始化触摸屏\" class=\"headerlink\" title=\"在touchpad_init函数中初始化触摸屏\"></a>在<code>touchpad_init</code>函数中初始化触摸屏</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title function_\">touchpad_init</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">/*Your code comes here*/</span></span><br><span class=\"line\">    tp_dev.init();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"修改touchpad-is-pressed函数\"><a href=\"#修改touchpad-is-pressed函数\" class=\"headerlink\" title=\"修改touchpad_is_pressed函数\"></a>修改<code>touchpad_is_pressed</code>函数</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">bool</span> <span class=\"title function_\">touchpad_is_pressed</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">/*Your code comes here*/</span></span><br><span class=\"line\">    tp_dev.scan(<span class=\"number\">0</span>); <span class=\"comment\">// É¨ÃèÎïÀí×ø±ê</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tp_dev.sta &amp; TP_PRES_DOWN)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"配置坐标获取函数\"><a href=\"#配置坐标获取函数\" class=\"headerlink\" title=\"配置坐标获取函数\"></a>配置坐标获取函数</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title function_\">touchpad_get_xy</span><span class=\"params\">(<span class=\"type\">lv_coord_t</span> *x, <span class=\"type\">lv_coord_t</span> *y)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">/*Your code comes here*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">    (*x) = tp_dev.x[<span class=\"number\">0</span>];</span><br><span class=\"line\">    (*y) = tp_dev.y[<span class=\"number\">0</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"提供时基\"><a href=\"#提供时基\" class=\"headerlink\" title=\"提供时基\"></a>提供时基</h4><blockquote>\n<ul>\n<li>使用CubeMX生成一个定时1ms的定时器</li>\n<li>在<code>tim.c</code>中引用<code>#include &quot;lvgl.h&quot;</code></li>\n<li>在定时器中断回调函数中<code>lv_tick_inc(1);</code></li>\n</ul>\n</blockquote>\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509072010067.png\" alt=\"image-20250907201034944\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509072008331.png\" alt=\"image-20250907200845233\"></p>\n<h4 id=\"main函数部分\"><a href=\"#main函数部分\" class=\"headerlink\" title=\"main函数部分\"></a><code>main</code>函数部分</h4><p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509072011915.png\" alt=\"image-20250907201115783\"></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;lvgl.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;lv_port_disp_template.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;lv_port_indev_template.h&quot;</span></span></span><br><span class=\"line\">....</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    .....</span><br><span class=\"line\">  HAL_TIM_Base_Start_IT(&amp;htim3); <span class=\"comment\">// 启动定时器3中断 为lvgl提供时基</span></span><br><span class=\"line\">  lv_init();                     <span class=\"comment\">// 初始化LVGL</span></span><br><span class=\"line\">  lv_port_disp_init();           <span class=\"comment\">// 初始化显示接口</span></span><br><span class=\"line\">  lv_port_indev_init();          <span class=\"comment\">// 初始化输入接口</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (<span class=\"number\">1</span>)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    lv_timer_handler(); <span class=\"comment\">// 处理LVGL任务</span></span><br><span class=\"line\">    delay_ms(<span class=\"number\">5</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n"},{"title":"LVGL学习之旅（基于正点原子STM32F407探索者）","date":"2025-09-07T06:58:25.000Z","cover":"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071514562.png","_content":"\n## LVGL 基础\n\n> LVGL（Light and Versatile Graphics Library）轻量级通用型图形库，是一个免费的开源图形库，提供了创建嵌入式 GUI 所需的一切，具有易于使用的组件，美观的视觉效果和低内存占用等特点。支持触摸屏操作，移植简单方便，开发者一直在不断完善更新。\n>\n> 特点：\n>\n> - 丰富且强大的模块化图形组件：按钮 (buttons)、图表 (charts)、列表 (lists)、滑动条 (sliders)、图片 (images) 等\n> - 高级的图形引擎：动画、抗锯齿、透明度、平滑滚动、图层混合等效果\n> - 不依赖特定的硬件平台，可以在任何显示屏上运行\n> - 配置可裁剪（最低资源占用：<span style=\"color:#FF0000;\">64 kB Flash，16 kB RAM</span>）\n> - 基于<span style=\"color:#FF0000;\">UTF-8</span>的多语种支持，例如中文、日文、韩文、阿拉伯文等\n> - 可以通过类CSS的方式来设计、布局图形界面（例如：Flexbox、Grid）\n> - 支持操作系统、外置内存、以及硬件加速（LVGL已内建支持STM32 DMA2D、NXP PXP和VGLite）\n> - 即便仅有单缓冲区(frame buffer)的情况下，也可保证渲染如丝般顺滑\n> - 全部由C编写完成，并支持C++调用\n> - 支持Micropython编程，参见：LVGL API in Micropython\n> - 支持模拟器仿真，可以无硬件依托进行开发\n\n## TFT-LCD配置——移植正点原子官方LCD例程\n\n### 点亮LCD——FSMC配置\n\n#### 先根据原理图配置`FSMC`\n\n![image-20250907155616208](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071556284.png)\n\n![image-20250907160758201](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071607256.png)\n\n#### 详细FSMC参数配置\n\n> 这里根据正点原子官方`lcd_init` 来设置 如下图\n\n![image-20250907164335816](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071643877.png)\n\n![img](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071724936.png)\n\n![img](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071725408.png)\n\n\n\n#### 背光引脚配置\n\n![img](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071725075.png)\n\n#### 生成代码并将LCD、sys、delay文件夹添加到工程中\n\n![image-20250907234315989](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509072343199.png)\n\n##### 首先将*HAL_SRAM_MspInit*函数整个屏蔽\n\n![image-20250907171842072](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071718133.png)\n\n##### 将lcd_init中有关fsmc部分屏蔽\n\n> 屏蔽部分如下\n\n```C\nvoid LCD_Init(void)\n{ \t  \n//\tGPIO_InitTypeDef GPIO_Initure;\n//\tFSMC_NORSRAM_TimingTypeDef FSMC_ReadWriteTim;\n//\tFSMC_NORSRAM_TimingTypeDef FSMC_WriteTim;\n//    \n//\t__HAL_RCC_GPIOB_CLK_ENABLE();\t\t\t//开启GPIOB时钟\n//\tGPIO_Initure.Pin=GPIO_PIN_15;          \t//PB15,背光控制\n//\tGPIO_Initure.Mode=GPIO_MODE_OUTPUT_PP;  //推挽输出\n//\tGPIO_Initure.Pull=GPIO_PULLUP;          //上拉\n//\tGPIO_Initure.Speed=GPIO_SPEED_HIGH;     //高速\n//\tHAL_GPIO_Init(GPIOB,&GPIO_Initure); \n//\t\n//\tTFTSRAM_Handler.Instance=FSMC_NORSRAM_DEVICE;                \n//\tTFTSRAM_Handler.Extended=FSMC_NORSRAM_EXTENDED_DEVICE;    \n//    \n//\tTFTSRAM_Handler.Init.NSBank=FSMC_NORSRAM_BANK4;     \t\t\t\t//使用NE4\n//\tTFTSRAM_Handler.Init.DataAddressMux=FSMC_DATA_ADDRESS_MUX_DISABLE; \t//地址/数据线不复用\n//\tTFTSRAM_Handler.Init.MemoryType=FSMC_MEMORY_TYPE_SRAM;   \t\t\t//SRAM\n//\tTFTSRAM_Handler.Init.MemoryDataWidth=FSMC_NORSRAM_MEM_BUS_WIDTH_16; //16位数据宽度\n//\tTFTSRAM_Handler.Init.BurstAccessMode=FSMC_BURST_ACCESS_MODE_DISABLE; //是否使能突发访问,仅对同步突发存储器有效,此处未用到\n//\tTFTSRAM_Handler.Init.WaitSignalPolarity=FSMC_WAIT_SIGNAL_POLARITY_LOW;//等待信号的极性,仅在突发模式访问下有用\n//\tTFTSRAM_Handler.Init.WaitSignalActive=FSMC_WAIT_TIMING_BEFORE_WS;   //存储器是在等待周期之前的一个时钟周期还是等待周期期间使能NWAIT\n//\tTFTSRAM_Handler.Init.WriteOperation=FSMC_WRITE_OPERATION_ENABLE;    //存储器写使能\n//\tTFTSRAM_Handler.Init.WaitSignal=FSMC_WAIT_SIGNAL_DISABLE;           //等待使能位,此处未用到\n//\tTFTSRAM_Handler.Init.ExtendedMode=FSMC_EXTENDED_MODE_ENABLE;        //读写使用不同的时序\n//\tTFTSRAM_Handler.Init.AsynchronousWait=FSMC_ASYNCHRONOUS_WAIT_DISABLE;//是否使能同步传输模式下的等待信号,此处未用到\n//\tTFTSRAM_Handler.Init.WriteBurst=FSMC_WRITE_BURST_DISABLE;           //禁止突发写\n//\tTFTSRAM_Handler.Init.ContinuousClock=FSMC_CONTINUOUS_CLOCK_SYNC_ASYNC;\n//    \n//\t//FMC读时序控制寄存器\n//\tFSMC_ReadWriteTim.AddressSetupTime=0x0F;       \t//地址建立时间（ADDSET）为16个HCLK 1/168M=6ns*16=96ns\n//\tFSMC_ReadWriteTim.AddressHoldTime=0;\n//\tFSMC_ReadWriteTim.DataSetupTime=60;\t\t\t\t//数据保存时间为60个HCLK\t=6*60=360ns\n//\tFSMC_ReadWriteTim.AccessMode=FSMC_ACCESS_MODE_A;//模式A\n//\t//FMC写时序控制寄存器\n//\tFSMC_WriteTim.BusTurnAroundDuration=0;\t\t\t//总线周转阶段持续时间为0，此变量不赋值的话会莫名其妙的自动修改为4。导致程序运行正常\n//\tFSMC_WriteTim.AddressSetupTime=9;          \t\t//地址建立时间（ADDSET）为9个HCLK =54ns \n//\tFSMC_WriteTim.AddressHoldTime=0;\n//\tFSMC_WriteTim.DataSetupTime=8;              \t//数据保存时间为6ns*9个HCLK=54n\n//\tFSMC_WriteTim.AccessMode=FSMC_ACCESS_MODE_A;    //模式A\n//\tHAL_SRAM_Init(&TFTSRAM_Handler,&FSMC_ReadWriteTim,&FSMC_WriteTim);\t\n\n//\tHAL_Delay(50); // delay 50 ms \n\t\n\t//尝试9341 ID的读取\t\t\n\tLCD_WR_REG(0XD3);\t\t\n    .........\n}\n```\n\n> 注意有个坑！！！！\n>\n> 正点原子官方的`lcd_init`函数中有个 `printf(\" LCD ID:%x\\r\\n\",lcddev.id);`，所以在此之前需先进行串口重定向  \n\n##### 替换官方的delay函数\n\n```C\nvoid delay_us(u32 nus)\n{\n\tuint32_t Delay = nus * 168 / 4;\n\tdo\n\t{\n\t\t__NOP();\n\t} while (Delay--);\n}\n\n// 延时nms\n// nms:要延时的ms数\nvoid delay_ms(u16 nms)\n{\n\tHAL_Delay(nms);\n}\n```\n\n\n\n##### 修改点亮背光函数\n\n> 在`lcd_init`函数最后 将`LCD_BL(1)`替换为`HAL_GPIO_WritePin(LCD_BL_GPIO_Port, LCD_BL_Pin, GPIO_PIN_SET);`\n\n### 触摸屏TOUCH移植\n\n#### 将BSP文件夹下的24CXX、IIC与TOUCH文件夹添加到项目中\n\n![image-20250907180027576](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071800663.png)\n\n## LVGL移植国内码云仓库：https://gitee.com/mirrors/lvgl\n\n![image-20250907180958855](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071809967.png)\n\n![image-20250907181022271](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071810376.png)\n\n> 注意不要直接克隆 直接克隆下载的是最新的 可以选择右上角下载zip 就可以选中当前分支\n\n### 裁剪LVGL源码\n\n#### 根目录\n\n> 仅保留 demos、examples、src文件夹以及两个.h文件 如下图\n\n![image-20250907181309155](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071813234.png)\n\n#### 进入`examples`文件夹 删去除`porting`文件夹\n\n![image-20250907181406209](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071814287.png)\n\n#### 更改`lv_conf_template.h`\n\n> 1. 将`lv_conf_template.h`更名为`lv_conf.h`\n> 2. 进入该文件 将里面的#if 0 改为#if 1\n>\n> ![image-20250907182017202](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071820299.png)\n\n### 按以下结构创建文件夹\n\n```C\nProject\n----Middlewares\n--------LVGL\n------------GUI\n----------------lvgl\n------------GUI_APP\n```\n\n> 将裁剪后的LVGL库文件复制到`Middlewares/LVGL/GUI/lvgl`文件夹下\n\n### Keil配置\n\n#### 创建如下管理\n\n![image-20250907194802955](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071948050.png)\n\n#### 添加路径\n\n![image-20250907194859063](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071948156.png)\n\n> - 注意一定要开启C99模式\n>\n> ![image-20250907195152454](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071951544.png)\n>\n> - 可以屏蔽MDK警告\n>\n>   --diag_suppress=68 --diag_suppress=111 --diag_suppress=188 --diag_suppress=223 --diag_suppress=546  --diag_suppress=1295\n>\n> \n\n#### 添加文件到项目\n\n![image-20250907195111490](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071951610.png)\n\n### LVGL文件修改\n\n#### 配置LCD屏幕显示\n\n![image-20250907195420988](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071954102.png)\n\n##### 包含输出设备驱动头文件\n\n> 在`lv_port_disp_template.c`引入`lcd.h` 如`#include \"../BSP/LCD/lcd.h\"`\n\n##### 在`disp_init`函数中初始化\n\n```C\nstatic void disp_init(void)\n{\n    /*You code here*/\n    LCD_Init();\n    LCD_Display_Dir(1); // 横屏\n}\n```\n\n##### 配置图形数据缓冲方式\n\n> 进入`lv_port_disp_init`函数\n>\n> 选择缓冲方式 另外两个将其屏蔽\n>\n> ![image-20250907195842896](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071958994.png)\n\n##### 修改`disp_flush`函数\n\n```C\nstatic void disp_flush(lv_disp_drv_t *disp_drv, const lv_area_t *area, lv_color_t *color_p)\n{\n    /*The most simple case (but also the slowest) to put all pixels to the screen one-by-one*/\n    /*官方打点函数 */\n    // int32_t x;\n    // int32_t y;\n    // for (y = area->y1; y <= area->y2; y++)\n    // {\n    //     for (x = area->x1; x <= area->x2; x++)\n    //     {\n    //         /*Put a pixel to the display. For example:*/\n    //         /*put_px(x, y, *color_p)*/\n    //         color_p++;\n    //     }\n    // }\n\n    LCD_Color_Fill(area->x1, area->y1, area->x2, area->y2, (uint16_t *)color_p);\n    /*IMPORTANT!!!\n     *Inform the graphics library that you are ready with the flushing*/\n    lv_disp_flush_ready(disp_drv);\n}\n```\n\n#### 配置输入（触摸）\n\n![image-20250907200123083](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509072001216.png)\n\n##### 按需裁剪输入设备\n\n> 打开`lv_port_indev_template.c` 此处我们只需要触摸输入 所以把除了touchpad 其他都屏蔽或删去\n>\n> 注意：一定要把其他无关的屏蔽掉 否则会无法触摸\n\n##### 在`touchpad_init`函数中初始化触摸屏\n\n```C\nstatic void touchpad_init(void)\n{\n    /*Your code comes here*/\n    tp_dev.init();\n}\n```\n\n##### 修改`touchpad_is_pressed`函数\n\n```C\nstatic bool touchpad_is_pressed(void)\n{\n    /*Your code comes here*/\n    tp_dev.scan(0); // É¨ÃèÎïÀí×ø±ê\n    if (tp_dev.sta & TP_PRES_DOWN)\n    {\n        return true;\n    }\n    return false;\n}\n```\n\n##### 配置坐标获取函数\n\n```C\nstatic void touchpad_get_xy(lv_coord_t *x, lv_coord_t *y)\n{\n    /*Your code comes here*/\n\n    (*x) = tp_dev.x[0];\n    (*y) = tp_dev.y[0];\n}\n```\n\n#### 提供时基\n\n> - 使用CubeMX生成一个定时1ms的定时器\n> - 在`tim.c`中引用`#include \"lvgl.h\"`\n> - 在定时器中断回调函数中`lv_tick_inc(1);`\n\n![image-20250907201034944](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509072010067.png)\n\n![image-20250907200845233](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509072008331.png)\n\n#### `main`函数部分\n\n![image-20250907201115783](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509072011915.png)\n\n```C\n#include \"lvgl.h\"\n#include \"lv_port_disp_template.h\"\n#include \"lv_port_indev_template.h\"\n....\nint main(void)\n{\n    .....\n  HAL_TIM_Base_Start_IT(&htim3); // 启动定时器3中断 为lvgl提供时基\n  lv_init();                     // 初始化LVGL\n  lv_port_disp_init();           // 初始化显示接口\n  lv_port_indev_init();          // 初始化输入接口\n  while (1)\n  {\n    lv_timer_handler(); // 处理LVGL任务\n    delay_ms(5);\n  }\n}\n```\n","source":"_posts/LVGL学习之旅.md","raw":"---\ntitle: LVGL学习之旅（基于正点原子STM32F407探索者）\ndate: 2025-09-07 14:58:25\ncover: \"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071514562.png\"\ntags:\n - LVGL v8.2\n - RTOS\n - 嵌入式基础\ncategories: MCU\n---\n\n## LVGL 基础\n\n> LVGL（Light and Versatile Graphics Library）轻量级通用型图形库，是一个免费的开源图形库，提供了创建嵌入式 GUI 所需的一切，具有易于使用的组件，美观的视觉效果和低内存占用等特点。支持触摸屏操作，移植简单方便，开发者一直在不断完善更新。\n>\n> 特点：\n>\n> - 丰富且强大的模块化图形组件：按钮 (buttons)、图表 (charts)、列表 (lists)、滑动条 (sliders)、图片 (images) 等\n> - 高级的图形引擎：动画、抗锯齿、透明度、平滑滚动、图层混合等效果\n> - 不依赖特定的硬件平台，可以在任何显示屏上运行\n> - 配置可裁剪（最低资源占用：<span style=\"color:#FF0000;\">64 kB Flash，16 kB RAM</span>）\n> - 基于<span style=\"color:#FF0000;\">UTF-8</span>的多语种支持，例如中文、日文、韩文、阿拉伯文等\n> - 可以通过类CSS的方式来设计、布局图形界面（例如：Flexbox、Grid）\n> - 支持操作系统、外置内存、以及硬件加速（LVGL已内建支持STM32 DMA2D、NXP PXP和VGLite）\n> - 即便仅有单缓冲区(frame buffer)的情况下，也可保证渲染如丝般顺滑\n> - 全部由C编写完成，并支持C++调用\n> - 支持Micropython编程，参见：LVGL API in Micropython\n> - 支持模拟器仿真，可以无硬件依托进行开发\n\n## TFT-LCD配置——移植正点原子官方LCD例程\n\n### 点亮LCD——FSMC配置\n\n#### 先根据原理图配置`FSMC`\n\n![image-20250907155616208](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071556284.png)\n\n![image-20250907160758201](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071607256.png)\n\n#### 详细FSMC参数配置\n\n> 这里根据正点原子官方`lcd_init` 来设置 如下图\n\n![image-20250907164335816](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071643877.png)\n\n![img](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071724936.png)\n\n![img](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071725408.png)\n\n\n\n#### 背光引脚配置\n\n![img](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071725075.png)\n\n#### 生成代码并将LCD、sys、delay文件夹添加到工程中\n\n![image-20250907234315989](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509072343199.png)\n\n##### 首先将*HAL_SRAM_MspInit*函数整个屏蔽\n\n![image-20250907171842072](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071718133.png)\n\n##### 将lcd_init中有关fsmc部分屏蔽\n\n> 屏蔽部分如下\n\n```C\nvoid LCD_Init(void)\n{ \t  \n//\tGPIO_InitTypeDef GPIO_Initure;\n//\tFSMC_NORSRAM_TimingTypeDef FSMC_ReadWriteTim;\n//\tFSMC_NORSRAM_TimingTypeDef FSMC_WriteTim;\n//    \n//\t__HAL_RCC_GPIOB_CLK_ENABLE();\t\t\t//开启GPIOB时钟\n//\tGPIO_Initure.Pin=GPIO_PIN_15;          \t//PB15,背光控制\n//\tGPIO_Initure.Mode=GPIO_MODE_OUTPUT_PP;  //推挽输出\n//\tGPIO_Initure.Pull=GPIO_PULLUP;          //上拉\n//\tGPIO_Initure.Speed=GPIO_SPEED_HIGH;     //高速\n//\tHAL_GPIO_Init(GPIOB,&GPIO_Initure); \n//\t\n//\tTFTSRAM_Handler.Instance=FSMC_NORSRAM_DEVICE;                \n//\tTFTSRAM_Handler.Extended=FSMC_NORSRAM_EXTENDED_DEVICE;    \n//    \n//\tTFTSRAM_Handler.Init.NSBank=FSMC_NORSRAM_BANK4;     \t\t\t\t//使用NE4\n//\tTFTSRAM_Handler.Init.DataAddressMux=FSMC_DATA_ADDRESS_MUX_DISABLE; \t//地址/数据线不复用\n//\tTFTSRAM_Handler.Init.MemoryType=FSMC_MEMORY_TYPE_SRAM;   \t\t\t//SRAM\n//\tTFTSRAM_Handler.Init.MemoryDataWidth=FSMC_NORSRAM_MEM_BUS_WIDTH_16; //16位数据宽度\n//\tTFTSRAM_Handler.Init.BurstAccessMode=FSMC_BURST_ACCESS_MODE_DISABLE; //是否使能突发访问,仅对同步突发存储器有效,此处未用到\n//\tTFTSRAM_Handler.Init.WaitSignalPolarity=FSMC_WAIT_SIGNAL_POLARITY_LOW;//等待信号的极性,仅在突发模式访问下有用\n//\tTFTSRAM_Handler.Init.WaitSignalActive=FSMC_WAIT_TIMING_BEFORE_WS;   //存储器是在等待周期之前的一个时钟周期还是等待周期期间使能NWAIT\n//\tTFTSRAM_Handler.Init.WriteOperation=FSMC_WRITE_OPERATION_ENABLE;    //存储器写使能\n//\tTFTSRAM_Handler.Init.WaitSignal=FSMC_WAIT_SIGNAL_DISABLE;           //等待使能位,此处未用到\n//\tTFTSRAM_Handler.Init.ExtendedMode=FSMC_EXTENDED_MODE_ENABLE;        //读写使用不同的时序\n//\tTFTSRAM_Handler.Init.AsynchronousWait=FSMC_ASYNCHRONOUS_WAIT_DISABLE;//是否使能同步传输模式下的等待信号,此处未用到\n//\tTFTSRAM_Handler.Init.WriteBurst=FSMC_WRITE_BURST_DISABLE;           //禁止突发写\n//\tTFTSRAM_Handler.Init.ContinuousClock=FSMC_CONTINUOUS_CLOCK_SYNC_ASYNC;\n//    \n//\t//FMC读时序控制寄存器\n//\tFSMC_ReadWriteTim.AddressSetupTime=0x0F;       \t//地址建立时间（ADDSET）为16个HCLK 1/168M=6ns*16=96ns\n//\tFSMC_ReadWriteTim.AddressHoldTime=0;\n//\tFSMC_ReadWriteTim.DataSetupTime=60;\t\t\t\t//数据保存时间为60个HCLK\t=6*60=360ns\n//\tFSMC_ReadWriteTim.AccessMode=FSMC_ACCESS_MODE_A;//模式A\n//\t//FMC写时序控制寄存器\n//\tFSMC_WriteTim.BusTurnAroundDuration=0;\t\t\t//总线周转阶段持续时间为0，此变量不赋值的话会莫名其妙的自动修改为4。导致程序运行正常\n//\tFSMC_WriteTim.AddressSetupTime=9;          \t\t//地址建立时间（ADDSET）为9个HCLK =54ns \n//\tFSMC_WriteTim.AddressHoldTime=0;\n//\tFSMC_WriteTim.DataSetupTime=8;              \t//数据保存时间为6ns*9个HCLK=54n\n//\tFSMC_WriteTim.AccessMode=FSMC_ACCESS_MODE_A;    //模式A\n//\tHAL_SRAM_Init(&TFTSRAM_Handler,&FSMC_ReadWriteTim,&FSMC_WriteTim);\t\n\n//\tHAL_Delay(50); // delay 50 ms \n\t\n\t//尝试9341 ID的读取\t\t\n\tLCD_WR_REG(0XD3);\t\t\n    .........\n}\n```\n\n> 注意有个坑！！！！\n>\n> 正点原子官方的`lcd_init`函数中有个 `printf(\" LCD ID:%x\\r\\n\",lcddev.id);`，所以在此之前需先进行串口重定向  \n\n##### 替换官方的delay函数\n\n```C\nvoid delay_us(u32 nus)\n{\n\tuint32_t Delay = nus * 168 / 4;\n\tdo\n\t{\n\t\t__NOP();\n\t} while (Delay--);\n}\n\n// 延时nms\n// nms:要延时的ms数\nvoid delay_ms(u16 nms)\n{\n\tHAL_Delay(nms);\n}\n```\n\n\n\n##### 修改点亮背光函数\n\n> 在`lcd_init`函数最后 将`LCD_BL(1)`替换为`HAL_GPIO_WritePin(LCD_BL_GPIO_Port, LCD_BL_Pin, GPIO_PIN_SET);`\n\n### 触摸屏TOUCH移植\n\n#### 将BSP文件夹下的24CXX、IIC与TOUCH文件夹添加到项目中\n\n![image-20250907180027576](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071800663.png)\n\n## LVGL移植国内码云仓库：https://gitee.com/mirrors/lvgl\n\n![image-20250907180958855](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071809967.png)\n\n![image-20250907181022271](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071810376.png)\n\n> 注意不要直接克隆 直接克隆下载的是最新的 可以选择右上角下载zip 就可以选中当前分支\n\n### 裁剪LVGL源码\n\n#### 根目录\n\n> 仅保留 demos、examples、src文件夹以及两个.h文件 如下图\n\n![image-20250907181309155](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071813234.png)\n\n#### 进入`examples`文件夹 删去除`porting`文件夹\n\n![image-20250907181406209](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071814287.png)\n\n#### 更改`lv_conf_template.h`\n\n> 1. 将`lv_conf_template.h`更名为`lv_conf.h`\n> 2. 进入该文件 将里面的#if 0 改为#if 1\n>\n> ![image-20250907182017202](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071820299.png)\n\n### 按以下结构创建文件夹\n\n```C\nProject\n----Middlewares\n--------LVGL\n------------GUI\n----------------lvgl\n------------GUI_APP\n```\n\n> 将裁剪后的LVGL库文件复制到`Middlewares/LVGL/GUI/lvgl`文件夹下\n\n### Keil配置\n\n#### 创建如下管理\n\n![image-20250907194802955](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071948050.png)\n\n#### 添加路径\n\n![image-20250907194859063](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071948156.png)\n\n> - 注意一定要开启C99模式\n>\n> ![image-20250907195152454](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071951544.png)\n>\n> - 可以屏蔽MDK警告\n>\n>   --diag_suppress=68 --diag_suppress=111 --diag_suppress=188 --diag_suppress=223 --diag_suppress=546  --diag_suppress=1295\n>\n> \n\n#### 添加文件到项目\n\n![image-20250907195111490](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071951610.png)\n\n### LVGL文件修改\n\n#### 配置LCD屏幕显示\n\n![image-20250907195420988](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071954102.png)\n\n##### 包含输出设备驱动头文件\n\n> 在`lv_port_disp_template.c`引入`lcd.h` 如`#include \"../BSP/LCD/lcd.h\"`\n\n##### 在`disp_init`函数中初始化\n\n```C\nstatic void disp_init(void)\n{\n    /*You code here*/\n    LCD_Init();\n    LCD_Display_Dir(1); // 横屏\n}\n```\n\n##### 配置图形数据缓冲方式\n\n> 进入`lv_port_disp_init`函数\n>\n> 选择缓冲方式 另外两个将其屏蔽\n>\n> ![image-20250907195842896](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071958994.png)\n\n##### 修改`disp_flush`函数\n\n```C\nstatic void disp_flush(lv_disp_drv_t *disp_drv, const lv_area_t *area, lv_color_t *color_p)\n{\n    /*The most simple case (but also the slowest) to put all pixels to the screen one-by-one*/\n    /*官方打点函数 */\n    // int32_t x;\n    // int32_t y;\n    // for (y = area->y1; y <= area->y2; y++)\n    // {\n    //     for (x = area->x1; x <= area->x2; x++)\n    //     {\n    //         /*Put a pixel to the display. For example:*/\n    //         /*put_px(x, y, *color_p)*/\n    //         color_p++;\n    //     }\n    // }\n\n    LCD_Color_Fill(area->x1, area->y1, area->x2, area->y2, (uint16_t *)color_p);\n    /*IMPORTANT!!!\n     *Inform the graphics library that you are ready with the flushing*/\n    lv_disp_flush_ready(disp_drv);\n}\n```\n\n#### 配置输入（触摸）\n\n![image-20250907200123083](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509072001216.png)\n\n##### 按需裁剪输入设备\n\n> 打开`lv_port_indev_template.c` 此处我们只需要触摸输入 所以把除了touchpad 其他都屏蔽或删去\n>\n> 注意：一定要把其他无关的屏蔽掉 否则会无法触摸\n\n##### 在`touchpad_init`函数中初始化触摸屏\n\n```C\nstatic void touchpad_init(void)\n{\n    /*Your code comes here*/\n    tp_dev.init();\n}\n```\n\n##### 修改`touchpad_is_pressed`函数\n\n```C\nstatic bool touchpad_is_pressed(void)\n{\n    /*Your code comes here*/\n    tp_dev.scan(0); // É¨ÃèÎïÀí×ø±ê\n    if (tp_dev.sta & TP_PRES_DOWN)\n    {\n        return true;\n    }\n    return false;\n}\n```\n\n##### 配置坐标获取函数\n\n```C\nstatic void touchpad_get_xy(lv_coord_t *x, lv_coord_t *y)\n{\n    /*Your code comes here*/\n\n    (*x) = tp_dev.x[0];\n    (*y) = tp_dev.y[0];\n}\n```\n\n#### 提供时基\n\n> - 使用CubeMX生成一个定时1ms的定时器\n> - 在`tim.c`中引用`#include \"lvgl.h\"`\n> - 在定时器中断回调函数中`lv_tick_inc(1);`\n\n![image-20250907201034944](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509072010067.png)\n\n![image-20250907200845233](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509072008331.png)\n\n#### `main`函数部分\n\n![image-20250907201115783](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509072011915.png)\n\n```C\n#include \"lvgl.h\"\n#include \"lv_port_disp_template.h\"\n#include \"lv_port_indev_template.h\"\n....\nint main(void)\n{\n    .....\n  HAL_TIM_Base_Start_IT(&htim3); // 启动定时器3中断 为lvgl提供时基\n  lv_init();                     // 初始化LVGL\n  lv_port_disp_init();           // 初始化显示接口\n  lv_port_indev_init();          // 初始化输入接口\n  while (1)\n  {\n    lv_timer_handler(); // 处理LVGL任务\n    delay_ms(5);\n  }\n}\n```\n","slug":"LVGL学习之旅","published":1,"updated":"2025-09-17T04:12:12.000Z","comments":1,"layout":"post","photos":[],"_id":"cmk8pg6xg00066sk92k77gblg","content":"<h2 id=\"LVGL-基础\"><a href=\"#LVGL-基础\" class=\"headerlink\" title=\"LVGL 基础\"></a>LVGL 基础</h2><blockquote>\n<p>LVGL（Light and Versatile Graphics Library）轻量级通用型图形库，是一个免费的开源图形库，提供了创建嵌入式 GUI 所需的一切，具有易于使用的组件，美观的视觉效果和低内存占用等特点。支持触摸屏操作，移植简单方便，开发者一直在不断完善更新。</p>\n<p>特点：</p>\n<ul>\n<li>丰富且强大的模块化图形组件：按钮 (buttons)、图表 (charts)、列表 (lists)、滑动条 (sliders)、图片 (images) 等</li>\n<li>高级的图形引擎：动画、抗锯齿、透明度、平滑滚动、图层混合等效果</li>\n<li>不依赖特定的硬件平台，可以在任何显示屏上运行</li>\n<li>配置可裁剪（最低资源占用：<span style=\"color:#FF0000;\">64 kB Flash，16 kB RAM</span>）</li>\n<li>基于<span style=\"color:#FF0000;\">UTF-8</span>的多语种支持，例如中文、日文、韩文、阿拉伯文等</li>\n<li>可以通过类CSS的方式来设计、布局图形界面（例如：Flexbox、Grid）</li>\n<li>支持操作系统、外置内存、以及硬件加速（LVGL已内建支持STM32 DMA2D、NXP PXP和VGLite）</li>\n<li>即便仅有单缓冲区(frame buffer)的情况下，也可保证渲染如丝般顺滑</li>\n<li>全部由C编写完成，并支持C++调用</li>\n<li>支持Micropython编程，参见：LVGL API in Micropython</li>\n<li>支持模拟器仿真，可以无硬件依托进行开发</li>\n</ul>\n</blockquote>\n<h2 id=\"TFT-LCD配置——移植正点原子官方LCD例程\"><a href=\"#TFT-LCD配置——移植正点原子官方LCD例程\" class=\"headerlink\" title=\"TFT-LCD配置——移植正点原子官方LCD例程\"></a>TFT-LCD配置——移植正点原子官方LCD例程</h2><h3 id=\"点亮LCD——FSMC配置\"><a href=\"#点亮LCD——FSMC配置\" class=\"headerlink\" title=\"点亮LCD——FSMC配置\"></a>点亮LCD——FSMC配置</h3><h4 id=\"先根据原理图配置FSMC\"><a href=\"#先根据原理图配置FSMC\" class=\"headerlink\" title=\"先根据原理图配置FSMC\"></a>先根据原理图配置<code>FSMC</code></h4><p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071556284.png\" alt=\"image-20250907155616208\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071607256.png\" alt=\"image-20250907160758201\"></p>\n<h4 id=\"详细FSMC参数配置\"><a href=\"#详细FSMC参数配置\" class=\"headerlink\" title=\"详细FSMC参数配置\"></a>详细FSMC参数配置</h4><blockquote>\n<p>这里根据正点原子官方<code>lcd_init</code> 来设置 如下图</p>\n</blockquote>\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071643877.png\" alt=\"image-20250907164335816\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071724936.png\" alt=\"img\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071725408.png\" alt=\"img\"></p>\n<h4 id=\"背光引脚配置\"><a href=\"#背光引脚配置\" class=\"headerlink\" title=\"背光引脚配置\"></a>背光引脚配置</h4><p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071725075.png\" alt=\"img\"></p>\n<h4 id=\"生成代码并将LCD、sys、delay文件夹添加到工程中\"><a href=\"#生成代码并将LCD、sys、delay文件夹添加到工程中\" class=\"headerlink\" title=\"生成代码并将LCD、sys、delay文件夹添加到工程中\"></a>生成代码并将LCD、sys、delay文件夹添加到工程中</h4><p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509072343199.png\" alt=\"image-20250907234315989\"></p>\n<h5 id=\"首先将HAL-SRAM-MspInit函数整个屏蔽\"><a href=\"#首先将HAL-SRAM-MspInit函数整个屏蔽\" class=\"headerlink\" title=\"首先将HAL_SRAM_MspInit函数整个屏蔽\"></a>首先将<em>HAL_SRAM_MspInit</em>函数整个屏蔽</h5><p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071718133.png\" alt=\"image-20250907171842072\"></p>\n<h5 id=\"将lcd-init中有关fsmc部分屏蔽\"><a href=\"#将lcd-init中有关fsmc部分屏蔽\" class=\"headerlink\" title=\"将lcd_init中有关fsmc部分屏蔽\"></a>将lcd_init中有关fsmc部分屏蔽</h5><blockquote>\n<p>屏蔽部分如下</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">LCD_Init</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123; \t  </span><br><span class=\"line\"><span class=\"comment\">//\tGPIO_InitTypeDef GPIO_Initure;</span></span><br><span class=\"line\"><span class=\"comment\">//\tFSMC_NORSRAM_TimingTypeDef FSMC_ReadWriteTim;</span></span><br><span class=\"line\"><span class=\"comment\">//\tFSMC_NORSRAM_TimingTypeDef FSMC_WriteTim;</span></span><br><span class=\"line\"><span class=\"comment\">//    </span></span><br><span class=\"line\"><span class=\"comment\">//\t__HAL_RCC_GPIOB_CLK_ENABLE();\t\t\t//开启GPIOB时钟</span></span><br><span class=\"line\"><span class=\"comment\">//\tGPIO_Initure.Pin=GPIO_PIN_15;          \t//PB15,背光控制</span></span><br><span class=\"line\"><span class=\"comment\">//\tGPIO_Initure.Mode=GPIO_MODE_OUTPUT_PP;  //推挽输出</span></span><br><span class=\"line\"><span class=\"comment\">//\tGPIO_Initure.Pull=GPIO_PULLUP;          //上拉</span></span><br><span class=\"line\"><span class=\"comment\">//\tGPIO_Initure.Speed=GPIO_SPEED_HIGH;     //高速</span></span><br><span class=\"line\"><span class=\"comment\">//\tHAL_GPIO_Init(GPIOB,&amp;GPIO_Initure); </span></span><br><span class=\"line\"><span class=\"comment\">//\t</span></span><br><span class=\"line\"><span class=\"comment\">//\tTFTSRAM_Handler.Instance=FSMC_NORSRAM_DEVICE;                </span></span><br><span class=\"line\"><span class=\"comment\">//\tTFTSRAM_Handler.Extended=FSMC_NORSRAM_EXTENDED_DEVICE;    </span></span><br><span class=\"line\"><span class=\"comment\">//    </span></span><br><span class=\"line\"><span class=\"comment\">//\tTFTSRAM_Handler.Init.NSBank=FSMC_NORSRAM_BANK4;     \t\t\t\t//使用NE4</span></span><br><span class=\"line\"><span class=\"comment\">//\tTFTSRAM_Handler.Init.DataAddressMux=FSMC_DATA_ADDRESS_MUX_DISABLE; \t//地址/数据线不复用</span></span><br><span class=\"line\"><span class=\"comment\">//\tTFTSRAM_Handler.Init.MemoryType=FSMC_MEMORY_TYPE_SRAM;   \t\t\t//SRAM</span></span><br><span class=\"line\"><span class=\"comment\">//\tTFTSRAM_Handler.Init.MemoryDataWidth=FSMC_NORSRAM_MEM_BUS_WIDTH_16; //16位数据宽度</span></span><br><span class=\"line\"><span class=\"comment\">//\tTFTSRAM_Handler.Init.BurstAccessMode=FSMC_BURST_ACCESS_MODE_DISABLE; //是否使能突发访问,仅对同步突发存储器有效,此处未用到</span></span><br><span class=\"line\"><span class=\"comment\">//\tTFTSRAM_Handler.Init.WaitSignalPolarity=FSMC_WAIT_SIGNAL_POLARITY_LOW;//等待信号的极性,仅在突发模式访问下有用</span></span><br><span class=\"line\"><span class=\"comment\">//\tTFTSRAM_Handler.Init.WaitSignalActive=FSMC_WAIT_TIMING_BEFORE_WS;   //存储器是在等待周期之前的一个时钟周期还是等待周期期间使能NWAIT</span></span><br><span class=\"line\"><span class=\"comment\">//\tTFTSRAM_Handler.Init.WriteOperation=FSMC_WRITE_OPERATION_ENABLE;    //存储器写使能</span></span><br><span class=\"line\"><span class=\"comment\">//\tTFTSRAM_Handler.Init.WaitSignal=FSMC_WAIT_SIGNAL_DISABLE;           //等待使能位,此处未用到</span></span><br><span class=\"line\"><span class=\"comment\">//\tTFTSRAM_Handler.Init.ExtendedMode=FSMC_EXTENDED_MODE_ENABLE;        //读写使用不同的时序</span></span><br><span class=\"line\"><span class=\"comment\">//\tTFTSRAM_Handler.Init.AsynchronousWait=FSMC_ASYNCHRONOUS_WAIT_DISABLE;//是否使能同步传输模式下的等待信号,此处未用到</span></span><br><span class=\"line\"><span class=\"comment\">//\tTFTSRAM_Handler.Init.WriteBurst=FSMC_WRITE_BURST_DISABLE;           //禁止突发写</span></span><br><span class=\"line\"><span class=\"comment\">//\tTFTSRAM_Handler.Init.ContinuousClock=FSMC_CONTINUOUS_CLOCK_SYNC_ASYNC;</span></span><br><span class=\"line\"><span class=\"comment\">//    </span></span><br><span class=\"line\"><span class=\"comment\">//\t//FMC读时序控制寄存器</span></span><br><span class=\"line\"><span class=\"comment\">//\tFSMC_ReadWriteTim.AddressSetupTime=0x0F;       \t//地址建立时间（ADDSET）为16个HCLK 1/168M=6ns*16=96ns</span></span><br><span class=\"line\"><span class=\"comment\">//\tFSMC_ReadWriteTim.AddressHoldTime=0;</span></span><br><span class=\"line\"><span class=\"comment\">//\tFSMC_ReadWriteTim.DataSetupTime=60;\t\t\t\t//数据保存时间为60个HCLK\t=6*60=360ns</span></span><br><span class=\"line\"><span class=\"comment\">//\tFSMC_ReadWriteTim.AccessMode=FSMC_ACCESS_MODE_A;//模式A</span></span><br><span class=\"line\"><span class=\"comment\">//\t//FMC写时序控制寄存器</span></span><br><span class=\"line\"><span class=\"comment\">//\tFSMC_WriteTim.BusTurnAroundDuration=0;\t\t\t//总线周转阶段持续时间为0，此变量不赋值的话会莫名其妙的自动修改为4。导致程序运行正常</span></span><br><span class=\"line\"><span class=\"comment\">//\tFSMC_WriteTim.AddressSetupTime=9;          \t\t//地址建立时间（ADDSET）为9个HCLK =54ns </span></span><br><span class=\"line\"><span class=\"comment\">//\tFSMC_WriteTim.AddressHoldTime=0;</span></span><br><span class=\"line\"><span class=\"comment\">//\tFSMC_WriteTim.DataSetupTime=8;              \t//数据保存时间为6ns*9个HCLK=54n</span></span><br><span class=\"line\"><span class=\"comment\">//\tFSMC_WriteTim.AccessMode=FSMC_ACCESS_MODE_A;    //模式A</span></span><br><span class=\"line\"><span class=\"comment\">//\tHAL_SRAM_Init(&amp;TFTSRAM_Handler,&amp;FSMC_ReadWriteTim,&amp;FSMC_WriteTim);\t</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//\tHAL_Delay(50); // delay 50 ms </span></span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">//尝试9341 ID的读取\t\t</span></span><br><span class=\"line\">\tLCD_WR_REG(<span class=\"number\">0XD3</span>);\t\t</span><br><span class=\"line\">    .........</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意有个坑！！！！</p>\n<p>正点原子官方的<code>lcd_init</code>函数中有个 <code>printf(&quot; LCD ID:%x\\r\\n&quot;,lcddev.id);</code>，所以在此之前需先进行串口重定向  </p>\n</blockquote>\n<h5 id=\"替换官方的delay函数\"><a href=\"#替换官方的delay函数\" class=\"headerlink\" title=\"替换官方的delay函数\"></a>替换官方的delay函数</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">delay_us</span><span class=\"params\">(u32 nus)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"type\">uint32_t</span> Delay = nus * <span class=\"number\">168</span> / <span class=\"number\">4</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">do</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t__NOP();</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">while</span> (Delay--);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 延时nms</span></span><br><span class=\"line\"><span class=\"comment\">// nms:要延时的ms数</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">delay_ms</span><span class=\"params\">(u16 nms)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tHAL_Delay(nms);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"修改点亮背光函数\"><a href=\"#修改点亮背光函数\" class=\"headerlink\" title=\"修改点亮背光函数\"></a>修改点亮背光函数</h5><blockquote>\n<p>在<code>lcd_init</code>函数最后 将<code>LCD_BL(1)</code>替换为<code>HAL_GPIO_WritePin(LCD_BL_GPIO_Port, LCD_BL_Pin, GPIO_PIN_SET);</code></p>\n</blockquote>\n<h3 id=\"触摸屏TOUCH移植\"><a href=\"#触摸屏TOUCH移植\" class=\"headerlink\" title=\"触摸屏TOUCH移植\"></a>触摸屏TOUCH移植</h3><h4 id=\"将BSP文件夹下的24CXX、IIC与TOUCH文件夹添加到项目中\"><a href=\"#将BSP文件夹下的24CXX、IIC与TOUCH文件夹添加到项目中\" class=\"headerlink\" title=\"将BSP文件夹下的24CXX、IIC与TOUCH文件夹添加到项目中\"></a>将BSP文件夹下的24CXX、IIC与TOUCH文件夹添加到项目中</h4><p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071800663.png\" alt=\"image-20250907180027576\"></p>\n<h2 id=\"LVGL移植国内码云仓库：https-gitee-com-mirrors-lvgl\"><a href=\"#LVGL移植国内码云仓库：https-gitee-com-mirrors-lvgl\" class=\"headerlink\" title=\"LVGL移植国内码云仓库：https://gitee.com/mirrors/lvgl\"></a>LVGL移植国内码云仓库：<a href=\"https://gitee.com/mirrors/lvgl\">https://gitee.com/mirrors/lvgl</a></h2><p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071809967.png\" alt=\"image-20250907180958855\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071810376.png\" alt=\"image-20250907181022271\"></p>\n<blockquote>\n<p>注意不要直接克隆 直接克隆下载的是最新的 可以选择右上角下载zip 就可以选中当前分支</p>\n</blockquote>\n<h3 id=\"裁剪LVGL源码\"><a href=\"#裁剪LVGL源码\" class=\"headerlink\" title=\"裁剪LVGL源码\"></a>裁剪LVGL源码</h3><h4 id=\"根目录\"><a href=\"#根目录\" class=\"headerlink\" title=\"根目录\"></a>根目录</h4><blockquote>\n<p>仅保留 demos、examples、src文件夹以及两个.h文件 如下图</p>\n</blockquote>\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071813234.png\" alt=\"image-20250907181309155\"></p>\n<h4 id=\"进入examples文件夹-删去除porting文件夹\"><a href=\"#进入examples文件夹-删去除porting文件夹\" class=\"headerlink\" title=\"进入examples文件夹 删去除porting文件夹\"></a>进入<code>examples</code>文件夹 删去除<code>porting</code>文件夹</h4><p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071814287.png\" alt=\"image-20250907181406209\"></p>\n<h4 id=\"更改lv-conf-template-h\"><a href=\"#更改lv-conf-template-h\" class=\"headerlink\" title=\"更改lv_conf_template.h\"></a>更改<code>lv_conf_template.h</code></h4><blockquote>\n<ol>\n<li>将<code>lv_conf_template.h</code>更名为<code>lv_conf.h</code></li>\n<li>进入该文件 将里面的#if 0 改为#if 1</li>\n</ol>\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071820299.png\" alt=\"image-20250907182017202\"></p>\n</blockquote>\n<h3 id=\"按以下结构创建文件夹\"><a href=\"#按以下结构创建文件夹\" class=\"headerlink\" title=\"按以下结构创建文件夹\"></a>按以下结构创建文件夹</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Project</span><br><span class=\"line\">----Middlewares</span><br><span class=\"line\">--------LVGL</span><br><span class=\"line\">------------GUI</span><br><span class=\"line\">----------------lvgl</span><br><span class=\"line\">------------GUI_APP</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>将裁剪后的LVGL库文件复制到<code>Middlewares/LVGL/GUI/lvgl</code>文件夹下</p>\n</blockquote>\n<h3 id=\"Keil配置\"><a href=\"#Keil配置\" class=\"headerlink\" title=\"Keil配置\"></a>Keil配置</h3><h4 id=\"创建如下管理\"><a href=\"#创建如下管理\" class=\"headerlink\" title=\"创建如下管理\"></a>创建如下管理</h4><p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071948050.png\" alt=\"image-20250907194802955\"></p>\n<h4 id=\"添加路径\"><a href=\"#添加路径\" class=\"headerlink\" title=\"添加路径\"></a>添加路径</h4><p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071948156.png\" alt=\"image-20250907194859063\"></p>\n<blockquote>\n<ul>\n<li>注意一定要开启C99模式</li>\n</ul>\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071951544.png\" alt=\"image-20250907195152454\"></p>\n<ul>\n<li><p>可以屏蔽MDK警告</p>\n<p>–diag_suppress&#x3D;68 –diag_suppress&#x3D;111 –diag_suppress&#x3D;188 –diag_suppress&#x3D;223 –diag_suppress&#x3D;546  –diag_suppress&#x3D;1295</p>\n</li>\n</ul>\n</blockquote>\n<h4 id=\"添加文件到项目\"><a href=\"#添加文件到项目\" class=\"headerlink\" title=\"添加文件到项目\"></a>添加文件到项目</h4><p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071951610.png\" alt=\"image-20250907195111490\"></p>\n<h3 id=\"LVGL文件修改\"><a href=\"#LVGL文件修改\" class=\"headerlink\" title=\"LVGL文件修改\"></a>LVGL文件修改</h3><h4 id=\"配置LCD屏幕显示\"><a href=\"#配置LCD屏幕显示\" class=\"headerlink\" title=\"配置LCD屏幕显示\"></a>配置LCD屏幕显示</h4><p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071954102.png\" alt=\"image-20250907195420988\"></p>\n<h5 id=\"包含输出设备驱动头文件\"><a href=\"#包含输出设备驱动头文件\" class=\"headerlink\" title=\"包含输出设备驱动头文件\"></a>包含输出设备驱动头文件</h5><blockquote>\n<p>在<code>lv_port_disp_template.c</code>引入<code>lcd.h</code> 如<code>#include &quot;../BSP/LCD/lcd.h&quot;</code></p>\n</blockquote>\n<h5 id=\"在disp-init函数中初始化\"><a href=\"#在disp-init函数中初始化\" class=\"headerlink\" title=\"在disp_init函数中初始化\"></a>在<code>disp_init</code>函数中初始化</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title function_\">disp_init</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">/*You code here*/</span></span><br><span class=\"line\">    LCD_Init();</span><br><span class=\"line\">    LCD_Display_Dir(<span class=\"number\">1</span>); <span class=\"comment\">// 横屏</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"配置图形数据缓冲方式\"><a href=\"#配置图形数据缓冲方式\" class=\"headerlink\" title=\"配置图形数据缓冲方式\"></a>配置图形数据缓冲方式</h5><blockquote>\n<p>进入<code>lv_port_disp_init</code>函数</p>\n<p>选择缓冲方式 另外两个将其屏蔽</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071958994.png\" alt=\"image-20250907195842896\"></p>\n</blockquote>\n<h5 id=\"修改disp-flush函数\"><a href=\"#修改disp-flush函数\" class=\"headerlink\" title=\"修改disp_flush函数\"></a>修改<code>disp_flush</code>函数</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title function_\">disp_flush</span><span class=\"params\">(<span class=\"type\">lv_disp_drv_t</span> *disp_drv, <span class=\"type\">const</span> <span class=\"type\">lv_area_t</span> *area, <span class=\"type\">lv_color_t</span> *color_p)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">/*The most simple case (but also the slowest) to put all pixels to the screen one-by-one*/</span></span><br><span class=\"line\">    <span class=\"comment\">/*官方打点函数 */</span></span><br><span class=\"line\">    <span class=\"comment\">// int32_t x;</span></span><br><span class=\"line\">    <span class=\"comment\">// int32_t y;</span></span><br><span class=\"line\">    <span class=\"comment\">// for (y = area-&gt;y1; y &lt;= area-&gt;y2; y++)</span></span><br><span class=\"line\">    <span class=\"comment\">// &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//     for (x = area-&gt;x1; x &lt;= area-&gt;x2; x++)</span></span><br><span class=\"line\">    <span class=\"comment\">//     &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//         /*Put a pixel to the display. For example:*/</span></span><br><span class=\"line\">    <span class=\"comment\">//         /*put_px(x, y, *color_p)*/</span></span><br><span class=\"line\">    <span class=\"comment\">//         color_p++;</span></span><br><span class=\"line\">    <span class=\"comment\">//     &#125;</span></span><br><span class=\"line\">    <span class=\"comment\">// &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    LCD_Color_Fill(area-&gt;x1, area-&gt;y1, area-&gt;x2, area-&gt;y2, (<span class=\"type\">uint16_t</span> *)color_p);</span><br><span class=\"line\">    <span class=\"comment\">/*IMPORTANT!!!</span></span><br><span class=\"line\"><span class=\"comment\">     *Inform the graphics library that you are ready with the flushing*/</span></span><br><span class=\"line\">    lv_disp_flush_ready(disp_drv);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"配置输入（触摸）\"><a href=\"#配置输入（触摸）\" class=\"headerlink\" title=\"配置输入（触摸）\"></a>配置输入（触摸）</h4><p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509072001216.png\" alt=\"image-20250907200123083\"></p>\n<h5 id=\"按需裁剪输入设备\"><a href=\"#按需裁剪输入设备\" class=\"headerlink\" title=\"按需裁剪输入设备\"></a>按需裁剪输入设备</h5><blockquote>\n<p>打开<code>lv_port_indev_template.c</code> 此处我们只需要触摸输入 所以把除了touchpad 其他都屏蔽或删去</p>\n<p>注意：一定要把其他无关的屏蔽掉 否则会无法触摸</p>\n</blockquote>\n<h5 id=\"在touchpad-init函数中初始化触摸屏\"><a href=\"#在touchpad-init函数中初始化触摸屏\" class=\"headerlink\" title=\"在touchpad_init函数中初始化触摸屏\"></a>在<code>touchpad_init</code>函数中初始化触摸屏</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title function_\">touchpad_init</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">/*Your code comes here*/</span></span><br><span class=\"line\">    tp_dev.init();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"修改touchpad-is-pressed函数\"><a href=\"#修改touchpad-is-pressed函数\" class=\"headerlink\" title=\"修改touchpad_is_pressed函数\"></a>修改<code>touchpad_is_pressed</code>函数</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">bool</span> <span class=\"title function_\">touchpad_is_pressed</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">/*Your code comes here*/</span></span><br><span class=\"line\">    tp_dev.scan(<span class=\"number\">0</span>); <span class=\"comment\">// É¨ÃèÎïÀí×ø±ê</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tp_dev.sta &amp; TP_PRES_DOWN)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"配置坐标获取函数\"><a href=\"#配置坐标获取函数\" class=\"headerlink\" title=\"配置坐标获取函数\"></a>配置坐标获取函数</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title function_\">touchpad_get_xy</span><span class=\"params\">(<span class=\"type\">lv_coord_t</span> *x, <span class=\"type\">lv_coord_t</span> *y)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">/*Your code comes here*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">    (*x) = tp_dev.x[<span class=\"number\">0</span>];</span><br><span class=\"line\">    (*y) = tp_dev.y[<span class=\"number\">0</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"提供时基\"><a href=\"#提供时基\" class=\"headerlink\" title=\"提供时基\"></a>提供时基</h4><blockquote>\n<ul>\n<li>使用CubeMX生成一个定时1ms的定时器</li>\n<li>在<code>tim.c</code>中引用<code>#include &quot;lvgl.h&quot;</code></li>\n<li>在定时器中断回调函数中<code>lv_tick_inc(1);</code></li>\n</ul>\n</blockquote>\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509072010067.png\" alt=\"image-20250907201034944\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509072008331.png\" alt=\"image-20250907200845233\"></p>\n<h4 id=\"main函数部分\"><a href=\"#main函数部分\" class=\"headerlink\" title=\"main函数部分\"></a><code>main</code>函数部分</h4><p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509072011915.png\" alt=\"image-20250907201115783\"></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;lvgl.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;lv_port_disp_template.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;lv_port_indev_template.h&quot;</span></span></span><br><span class=\"line\">....</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    .....</span><br><span class=\"line\">  HAL_TIM_Base_Start_IT(&amp;htim3); <span class=\"comment\">// 启动定时器3中断 为lvgl提供时基</span></span><br><span class=\"line\">  lv_init();                     <span class=\"comment\">// 初始化LVGL</span></span><br><span class=\"line\">  lv_port_disp_init();           <span class=\"comment\">// 初始化显示接口</span></span><br><span class=\"line\">  lv_port_indev_init();          <span class=\"comment\">// 初始化输入接口</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (<span class=\"number\">1</span>)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    lv_timer_handler(); <span class=\"comment\">// 处理LVGL任务</span></span><br><span class=\"line\">    delay_ms(<span class=\"number\">5</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","excerpt":"","more":"<h2 id=\"LVGL-基础\"><a href=\"#LVGL-基础\" class=\"headerlink\" title=\"LVGL 基础\"></a>LVGL 基础</h2><blockquote>\n<p>LVGL（Light and Versatile Graphics Library）轻量级通用型图形库，是一个免费的开源图形库，提供了创建嵌入式 GUI 所需的一切，具有易于使用的组件，美观的视觉效果和低内存占用等特点。支持触摸屏操作，移植简单方便，开发者一直在不断完善更新。</p>\n<p>特点：</p>\n<ul>\n<li>丰富且强大的模块化图形组件：按钮 (buttons)、图表 (charts)、列表 (lists)、滑动条 (sliders)、图片 (images) 等</li>\n<li>高级的图形引擎：动画、抗锯齿、透明度、平滑滚动、图层混合等效果</li>\n<li>不依赖特定的硬件平台，可以在任何显示屏上运行</li>\n<li>配置可裁剪（最低资源占用：<span style=\"color:#FF0000;\">64 kB Flash，16 kB RAM</span>）</li>\n<li>基于<span style=\"color:#FF0000;\">UTF-8</span>的多语种支持，例如中文、日文、韩文、阿拉伯文等</li>\n<li>可以通过类CSS的方式来设计、布局图形界面（例如：Flexbox、Grid）</li>\n<li>支持操作系统、外置内存、以及硬件加速（LVGL已内建支持STM32 DMA2D、NXP PXP和VGLite）</li>\n<li>即便仅有单缓冲区(frame buffer)的情况下，也可保证渲染如丝般顺滑</li>\n<li>全部由C编写完成，并支持C++调用</li>\n<li>支持Micropython编程，参见：LVGL API in Micropython</li>\n<li>支持模拟器仿真，可以无硬件依托进行开发</li>\n</ul>\n</blockquote>\n<h2 id=\"TFT-LCD配置——移植正点原子官方LCD例程\"><a href=\"#TFT-LCD配置——移植正点原子官方LCD例程\" class=\"headerlink\" title=\"TFT-LCD配置——移植正点原子官方LCD例程\"></a>TFT-LCD配置——移植正点原子官方LCD例程</h2><h3 id=\"点亮LCD——FSMC配置\"><a href=\"#点亮LCD——FSMC配置\" class=\"headerlink\" title=\"点亮LCD——FSMC配置\"></a>点亮LCD——FSMC配置</h3><h4 id=\"先根据原理图配置FSMC\"><a href=\"#先根据原理图配置FSMC\" class=\"headerlink\" title=\"先根据原理图配置FSMC\"></a>先根据原理图配置<code>FSMC</code></h4><p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071556284.png\" alt=\"image-20250907155616208\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071607256.png\" alt=\"image-20250907160758201\"></p>\n<h4 id=\"详细FSMC参数配置\"><a href=\"#详细FSMC参数配置\" class=\"headerlink\" title=\"详细FSMC参数配置\"></a>详细FSMC参数配置</h4><blockquote>\n<p>这里根据正点原子官方<code>lcd_init</code> 来设置 如下图</p>\n</blockquote>\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071643877.png\" alt=\"image-20250907164335816\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071724936.png\" alt=\"img\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071725408.png\" alt=\"img\"></p>\n<h4 id=\"背光引脚配置\"><a href=\"#背光引脚配置\" class=\"headerlink\" title=\"背光引脚配置\"></a>背光引脚配置</h4><p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071725075.png\" alt=\"img\"></p>\n<h4 id=\"生成代码并将LCD、sys、delay文件夹添加到工程中\"><a href=\"#生成代码并将LCD、sys、delay文件夹添加到工程中\" class=\"headerlink\" title=\"生成代码并将LCD、sys、delay文件夹添加到工程中\"></a>生成代码并将LCD、sys、delay文件夹添加到工程中</h4><p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509072343199.png\" alt=\"image-20250907234315989\"></p>\n<h5 id=\"首先将HAL-SRAM-MspInit函数整个屏蔽\"><a href=\"#首先将HAL-SRAM-MspInit函数整个屏蔽\" class=\"headerlink\" title=\"首先将HAL_SRAM_MspInit函数整个屏蔽\"></a>首先将<em>HAL_SRAM_MspInit</em>函数整个屏蔽</h5><p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071718133.png\" alt=\"image-20250907171842072\"></p>\n<h5 id=\"将lcd-init中有关fsmc部分屏蔽\"><a href=\"#将lcd-init中有关fsmc部分屏蔽\" class=\"headerlink\" title=\"将lcd_init中有关fsmc部分屏蔽\"></a>将lcd_init中有关fsmc部分屏蔽</h5><blockquote>\n<p>屏蔽部分如下</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">LCD_Init</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123; \t  </span><br><span class=\"line\"><span class=\"comment\">//\tGPIO_InitTypeDef GPIO_Initure;</span></span><br><span class=\"line\"><span class=\"comment\">//\tFSMC_NORSRAM_TimingTypeDef FSMC_ReadWriteTim;</span></span><br><span class=\"line\"><span class=\"comment\">//\tFSMC_NORSRAM_TimingTypeDef FSMC_WriteTim;</span></span><br><span class=\"line\"><span class=\"comment\">//    </span></span><br><span class=\"line\"><span class=\"comment\">//\t__HAL_RCC_GPIOB_CLK_ENABLE();\t\t\t//开启GPIOB时钟</span></span><br><span class=\"line\"><span class=\"comment\">//\tGPIO_Initure.Pin=GPIO_PIN_15;          \t//PB15,背光控制</span></span><br><span class=\"line\"><span class=\"comment\">//\tGPIO_Initure.Mode=GPIO_MODE_OUTPUT_PP;  //推挽输出</span></span><br><span class=\"line\"><span class=\"comment\">//\tGPIO_Initure.Pull=GPIO_PULLUP;          //上拉</span></span><br><span class=\"line\"><span class=\"comment\">//\tGPIO_Initure.Speed=GPIO_SPEED_HIGH;     //高速</span></span><br><span class=\"line\"><span class=\"comment\">//\tHAL_GPIO_Init(GPIOB,&amp;GPIO_Initure); </span></span><br><span class=\"line\"><span class=\"comment\">//\t</span></span><br><span class=\"line\"><span class=\"comment\">//\tTFTSRAM_Handler.Instance=FSMC_NORSRAM_DEVICE;                </span></span><br><span class=\"line\"><span class=\"comment\">//\tTFTSRAM_Handler.Extended=FSMC_NORSRAM_EXTENDED_DEVICE;    </span></span><br><span class=\"line\"><span class=\"comment\">//    </span></span><br><span class=\"line\"><span class=\"comment\">//\tTFTSRAM_Handler.Init.NSBank=FSMC_NORSRAM_BANK4;     \t\t\t\t//使用NE4</span></span><br><span class=\"line\"><span class=\"comment\">//\tTFTSRAM_Handler.Init.DataAddressMux=FSMC_DATA_ADDRESS_MUX_DISABLE; \t//地址/数据线不复用</span></span><br><span class=\"line\"><span class=\"comment\">//\tTFTSRAM_Handler.Init.MemoryType=FSMC_MEMORY_TYPE_SRAM;   \t\t\t//SRAM</span></span><br><span class=\"line\"><span class=\"comment\">//\tTFTSRAM_Handler.Init.MemoryDataWidth=FSMC_NORSRAM_MEM_BUS_WIDTH_16; //16位数据宽度</span></span><br><span class=\"line\"><span class=\"comment\">//\tTFTSRAM_Handler.Init.BurstAccessMode=FSMC_BURST_ACCESS_MODE_DISABLE; //是否使能突发访问,仅对同步突发存储器有效,此处未用到</span></span><br><span class=\"line\"><span class=\"comment\">//\tTFTSRAM_Handler.Init.WaitSignalPolarity=FSMC_WAIT_SIGNAL_POLARITY_LOW;//等待信号的极性,仅在突发模式访问下有用</span></span><br><span class=\"line\"><span class=\"comment\">//\tTFTSRAM_Handler.Init.WaitSignalActive=FSMC_WAIT_TIMING_BEFORE_WS;   //存储器是在等待周期之前的一个时钟周期还是等待周期期间使能NWAIT</span></span><br><span class=\"line\"><span class=\"comment\">//\tTFTSRAM_Handler.Init.WriteOperation=FSMC_WRITE_OPERATION_ENABLE;    //存储器写使能</span></span><br><span class=\"line\"><span class=\"comment\">//\tTFTSRAM_Handler.Init.WaitSignal=FSMC_WAIT_SIGNAL_DISABLE;           //等待使能位,此处未用到</span></span><br><span class=\"line\"><span class=\"comment\">//\tTFTSRAM_Handler.Init.ExtendedMode=FSMC_EXTENDED_MODE_ENABLE;        //读写使用不同的时序</span></span><br><span class=\"line\"><span class=\"comment\">//\tTFTSRAM_Handler.Init.AsynchronousWait=FSMC_ASYNCHRONOUS_WAIT_DISABLE;//是否使能同步传输模式下的等待信号,此处未用到</span></span><br><span class=\"line\"><span class=\"comment\">//\tTFTSRAM_Handler.Init.WriteBurst=FSMC_WRITE_BURST_DISABLE;           //禁止突发写</span></span><br><span class=\"line\"><span class=\"comment\">//\tTFTSRAM_Handler.Init.ContinuousClock=FSMC_CONTINUOUS_CLOCK_SYNC_ASYNC;</span></span><br><span class=\"line\"><span class=\"comment\">//    </span></span><br><span class=\"line\"><span class=\"comment\">//\t//FMC读时序控制寄存器</span></span><br><span class=\"line\"><span class=\"comment\">//\tFSMC_ReadWriteTim.AddressSetupTime=0x0F;       \t//地址建立时间（ADDSET）为16个HCLK 1/168M=6ns*16=96ns</span></span><br><span class=\"line\"><span class=\"comment\">//\tFSMC_ReadWriteTim.AddressHoldTime=0;</span></span><br><span class=\"line\"><span class=\"comment\">//\tFSMC_ReadWriteTim.DataSetupTime=60;\t\t\t\t//数据保存时间为60个HCLK\t=6*60=360ns</span></span><br><span class=\"line\"><span class=\"comment\">//\tFSMC_ReadWriteTim.AccessMode=FSMC_ACCESS_MODE_A;//模式A</span></span><br><span class=\"line\"><span class=\"comment\">//\t//FMC写时序控制寄存器</span></span><br><span class=\"line\"><span class=\"comment\">//\tFSMC_WriteTim.BusTurnAroundDuration=0;\t\t\t//总线周转阶段持续时间为0，此变量不赋值的话会莫名其妙的自动修改为4。导致程序运行正常</span></span><br><span class=\"line\"><span class=\"comment\">//\tFSMC_WriteTim.AddressSetupTime=9;          \t\t//地址建立时间（ADDSET）为9个HCLK =54ns </span></span><br><span class=\"line\"><span class=\"comment\">//\tFSMC_WriteTim.AddressHoldTime=0;</span></span><br><span class=\"line\"><span class=\"comment\">//\tFSMC_WriteTim.DataSetupTime=8;              \t//数据保存时间为6ns*9个HCLK=54n</span></span><br><span class=\"line\"><span class=\"comment\">//\tFSMC_WriteTim.AccessMode=FSMC_ACCESS_MODE_A;    //模式A</span></span><br><span class=\"line\"><span class=\"comment\">//\tHAL_SRAM_Init(&amp;TFTSRAM_Handler,&amp;FSMC_ReadWriteTim,&amp;FSMC_WriteTim);\t</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//\tHAL_Delay(50); // delay 50 ms </span></span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">//尝试9341 ID的读取\t\t</span></span><br><span class=\"line\">\tLCD_WR_REG(<span class=\"number\">0XD3</span>);\t\t</span><br><span class=\"line\">    .........</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意有个坑！！！！</p>\n<p>正点原子官方的<code>lcd_init</code>函数中有个 <code>printf(&quot; LCD ID:%x\\r\\n&quot;,lcddev.id);</code>，所以在此之前需先进行串口重定向  </p>\n</blockquote>\n<h5 id=\"替换官方的delay函数\"><a href=\"#替换官方的delay函数\" class=\"headerlink\" title=\"替换官方的delay函数\"></a>替换官方的delay函数</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">delay_us</span><span class=\"params\">(u32 nus)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"type\">uint32_t</span> Delay = nus * <span class=\"number\">168</span> / <span class=\"number\">4</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">do</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t__NOP();</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">while</span> (Delay--);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 延时nms</span></span><br><span class=\"line\"><span class=\"comment\">// nms:要延时的ms数</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">delay_ms</span><span class=\"params\">(u16 nms)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tHAL_Delay(nms);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"修改点亮背光函数\"><a href=\"#修改点亮背光函数\" class=\"headerlink\" title=\"修改点亮背光函数\"></a>修改点亮背光函数</h5><blockquote>\n<p>在<code>lcd_init</code>函数最后 将<code>LCD_BL(1)</code>替换为<code>HAL_GPIO_WritePin(LCD_BL_GPIO_Port, LCD_BL_Pin, GPIO_PIN_SET);</code></p>\n</blockquote>\n<h3 id=\"触摸屏TOUCH移植\"><a href=\"#触摸屏TOUCH移植\" class=\"headerlink\" title=\"触摸屏TOUCH移植\"></a>触摸屏TOUCH移植</h3><h4 id=\"将BSP文件夹下的24CXX、IIC与TOUCH文件夹添加到项目中\"><a href=\"#将BSP文件夹下的24CXX、IIC与TOUCH文件夹添加到项目中\" class=\"headerlink\" title=\"将BSP文件夹下的24CXX、IIC与TOUCH文件夹添加到项目中\"></a>将BSP文件夹下的24CXX、IIC与TOUCH文件夹添加到项目中</h4><p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071800663.png\" alt=\"image-20250907180027576\"></p>\n<h2 id=\"LVGL移植国内码云仓库：https-gitee-com-mirrors-lvgl\"><a href=\"#LVGL移植国内码云仓库：https-gitee-com-mirrors-lvgl\" class=\"headerlink\" title=\"LVGL移植国内码云仓库：https://gitee.com/mirrors/lvgl\"></a>LVGL移植国内码云仓库：<a href=\"https://gitee.com/mirrors/lvgl\">https://gitee.com/mirrors/lvgl</a></h2><p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071809967.png\" alt=\"image-20250907180958855\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071810376.png\" alt=\"image-20250907181022271\"></p>\n<blockquote>\n<p>注意不要直接克隆 直接克隆下载的是最新的 可以选择右上角下载zip 就可以选中当前分支</p>\n</blockquote>\n<h3 id=\"裁剪LVGL源码\"><a href=\"#裁剪LVGL源码\" class=\"headerlink\" title=\"裁剪LVGL源码\"></a>裁剪LVGL源码</h3><h4 id=\"根目录\"><a href=\"#根目录\" class=\"headerlink\" title=\"根目录\"></a>根目录</h4><blockquote>\n<p>仅保留 demos、examples、src文件夹以及两个.h文件 如下图</p>\n</blockquote>\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071813234.png\" alt=\"image-20250907181309155\"></p>\n<h4 id=\"进入examples文件夹-删去除porting文件夹\"><a href=\"#进入examples文件夹-删去除porting文件夹\" class=\"headerlink\" title=\"进入examples文件夹 删去除porting文件夹\"></a>进入<code>examples</code>文件夹 删去除<code>porting</code>文件夹</h4><p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071814287.png\" alt=\"image-20250907181406209\"></p>\n<h4 id=\"更改lv-conf-template-h\"><a href=\"#更改lv-conf-template-h\" class=\"headerlink\" title=\"更改lv_conf_template.h\"></a>更改<code>lv_conf_template.h</code></h4><blockquote>\n<ol>\n<li>将<code>lv_conf_template.h</code>更名为<code>lv_conf.h</code></li>\n<li>进入该文件 将里面的#if 0 改为#if 1</li>\n</ol>\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071820299.png\" alt=\"image-20250907182017202\"></p>\n</blockquote>\n<h3 id=\"按以下结构创建文件夹\"><a href=\"#按以下结构创建文件夹\" class=\"headerlink\" title=\"按以下结构创建文件夹\"></a>按以下结构创建文件夹</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Project</span><br><span class=\"line\">----Middlewares</span><br><span class=\"line\">--------LVGL</span><br><span class=\"line\">------------GUI</span><br><span class=\"line\">----------------lvgl</span><br><span class=\"line\">------------GUI_APP</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>将裁剪后的LVGL库文件复制到<code>Middlewares/LVGL/GUI/lvgl</code>文件夹下</p>\n</blockquote>\n<h3 id=\"Keil配置\"><a href=\"#Keil配置\" class=\"headerlink\" title=\"Keil配置\"></a>Keil配置</h3><h4 id=\"创建如下管理\"><a href=\"#创建如下管理\" class=\"headerlink\" title=\"创建如下管理\"></a>创建如下管理</h4><p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071948050.png\" alt=\"image-20250907194802955\"></p>\n<h4 id=\"添加路径\"><a href=\"#添加路径\" class=\"headerlink\" title=\"添加路径\"></a>添加路径</h4><p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071948156.png\" alt=\"image-20250907194859063\"></p>\n<blockquote>\n<ul>\n<li>注意一定要开启C99模式</li>\n</ul>\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071951544.png\" alt=\"image-20250907195152454\"></p>\n<ul>\n<li><p>可以屏蔽MDK警告</p>\n<p>–diag_suppress&#x3D;68 –diag_suppress&#x3D;111 –diag_suppress&#x3D;188 –diag_suppress&#x3D;223 –diag_suppress&#x3D;546  –diag_suppress&#x3D;1295</p>\n</li>\n</ul>\n</blockquote>\n<h4 id=\"添加文件到项目\"><a href=\"#添加文件到项目\" class=\"headerlink\" title=\"添加文件到项目\"></a>添加文件到项目</h4><p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071951610.png\" alt=\"image-20250907195111490\"></p>\n<h3 id=\"LVGL文件修改\"><a href=\"#LVGL文件修改\" class=\"headerlink\" title=\"LVGL文件修改\"></a>LVGL文件修改</h3><h4 id=\"配置LCD屏幕显示\"><a href=\"#配置LCD屏幕显示\" class=\"headerlink\" title=\"配置LCD屏幕显示\"></a>配置LCD屏幕显示</h4><p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071954102.png\" alt=\"image-20250907195420988\"></p>\n<h5 id=\"包含输出设备驱动头文件\"><a href=\"#包含输出设备驱动头文件\" class=\"headerlink\" title=\"包含输出设备驱动头文件\"></a>包含输出设备驱动头文件</h5><blockquote>\n<p>在<code>lv_port_disp_template.c</code>引入<code>lcd.h</code> 如<code>#include &quot;../BSP/LCD/lcd.h&quot;</code></p>\n</blockquote>\n<h5 id=\"在disp-init函数中初始化\"><a href=\"#在disp-init函数中初始化\" class=\"headerlink\" title=\"在disp_init函数中初始化\"></a>在<code>disp_init</code>函数中初始化</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title function_\">disp_init</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">/*You code here*/</span></span><br><span class=\"line\">    LCD_Init();</span><br><span class=\"line\">    LCD_Display_Dir(<span class=\"number\">1</span>); <span class=\"comment\">// 横屏</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"配置图形数据缓冲方式\"><a href=\"#配置图形数据缓冲方式\" class=\"headerlink\" title=\"配置图形数据缓冲方式\"></a>配置图形数据缓冲方式</h5><blockquote>\n<p>进入<code>lv_port_disp_init</code>函数</p>\n<p>选择缓冲方式 另外两个将其屏蔽</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071958994.png\" alt=\"image-20250907195842896\"></p>\n</blockquote>\n<h5 id=\"修改disp-flush函数\"><a href=\"#修改disp-flush函数\" class=\"headerlink\" title=\"修改disp_flush函数\"></a>修改<code>disp_flush</code>函数</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title function_\">disp_flush</span><span class=\"params\">(<span class=\"type\">lv_disp_drv_t</span> *disp_drv, <span class=\"type\">const</span> <span class=\"type\">lv_area_t</span> *area, <span class=\"type\">lv_color_t</span> *color_p)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">/*The most simple case (but also the slowest) to put all pixels to the screen one-by-one*/</span></span><br><span class=\"line\">    <span class=\"comment\">/*官方打点函数 */</span></span><br><span class=\"line\">    <span class=\"comment\">// int32_t x;</span></span><br><span class=\"line\">    <span class=\"comment\">// int32_t y;</span></span><br><span class=\"line\">    <span class=\"comment\">// for (y = area-&gt;y1; y &lt;= area-&gt;y2; y++)</span></span><br><span class=\"line\">    <span class=\"comment\">// &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//     for (x = area-&gt;x1; x &lt;= area-&gt;x2; x++)</span></span><br><span class=\"line\">    <span class=\"comment\">//     &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//         /*Put a pixel to the display. For example:*/</span></span><br><span class=\"line\">    <span class=\"comment\">//         /*put_px(x, y, *color_p)*/</span></span><br><span class=\"line\">    <span class=\"comment\">//         color_p++;</span></span><br><span class=\"line\">    <span class=\"comment\">//     &#125;</span></span><br><span class=\"line\">    <span class=\"comment\">// &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    LCD_Color_Fill(area-&gt;x1, area-&gt;y1, area-&gt;x2, area-&gt;y2, (<span class=\"type\">uint16_t</span> *)color_p);</span><br><span class=\"line\">    <span class=\"comment\">/*IMPORTANT!!!</span></span><br><span class=\"line\"><span class=\"comment\">     *Inform the graphics library that you are ready with the flushing*/</span></span><br><span class=\"line\">    lv_disp_flush_ready(disp_drv);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"配置输入（触摸）\"><a href=\"#配置输入（触摸）\" class=\"headerlink\" title=\"配置输入（触摸）\"></a>配置输入（触摸）</h4><p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509072001216.png\" alt=\"image-20250907200123083\"></p>\n<h5 id=\"按需裁剪输入设备\"><a href=\"#按需裁剪输入设备\" class=\"headerlink\" title=\"按需裁剪输入设备\"></a>按需裁剪输入设备</h5><blockquote>\n<p>打开<code>lv_port_indev_template.c</code> 此处我们只需要触摸输入 所以把除了touchpad 其他都屏蔽或删去</p>\n<p>注意：一定要把其他无关的屏蔽掉 否则会无法触摸</p>\n</blockquote>\n<h5 id=\"在touchpad-init函数中初始化触摸屏\"><a href=\"#在touchpad-init函数中初始化触摸屏\" class=\"headerlink\" title=\"在touchpad_init函数中初始化触摸屏\"></a>在<code>touchpad_init</code>函数中初始化触摸屏</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title function_\">touchpad_init</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">/*Your code comes here*/</span></span><br><span class=\"line\">    tp_dev.init();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"修改touchpad-is-pressed函数\"><a href=\"#修改touchpad-is-pressed函数\" class=\"headerlink\" title=\"修改touchpad_is_pressed函数\"></a>修改<code>touchpad_is_pressed</code>函数</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">bool</span> <span class=\"title function_\">touchpad_is_pressed</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">/*Your code comes here*/</span></span><br><span class=\"line\">    tp_dev.scan(<span class=\"number\">0</span>); <span class=\"comment\">// É¨ÃèÎïÀí×ø±ê</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tp_dev.sta &amp; TP_PRES_DOWN)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"配置坐标获取函数\"><a href=\"#配置坐标获取函数\" class=\"headerlink\" title=\"配置坐标获取函数\"></a>配置坐标获取函数</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title function_\">touchpad_get_xy</span><span class=\"params\">(<span class=\"type\">lv_coord_t</span> *x, <span class=\"type\">lv_coord_t</span> *y)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">/*Your code comes here*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">    (*x) = tp_dev.x[<span class=\"number\">0</span>];</span><br><span class=\"line\">    (*y) = tp_dev.y[<span class=\"number\">0</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"提供时基\"><a href=\"#提供时基\" class=\"headerlink\" title=\"提供时基\"></a>提供时基</h4><blockquote>\n<ul>\n<li>使用CubeMX生成一个定时1ms的定时器</li>\n<li>在<code>tim.c</code>中引用<code>#include &quot;lvgl.h&quot;</code></li>\n<li>在定时器中断回调函数中<code>lv_tick_inc(1);</code></li>\n</ul>\n</blockquote>\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509072010067.png\" alt=\"image-20250907201034944\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509072008331.png\" alt=\"image-20250907200845233\"></p>\n<h4 id=\"main函数部分\"><a href=\"#main函数部分\" class=\"headerlink\" title=\"main函数部分\"></a><code>main</code>函数部分</h4><p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509072011915.png\" alt=\"image-20250907201115783\"></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;lvgl.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;lv_port_disp_template.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;lv_port_indev_template.h&quot;</span></span></span><br><span class=\"line\">....</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    .....</span><br><span class=\"line\">  HAL_TIM_Base_Start_IT(&amp;htim3); <span class=\"comment\">// 启动定时器3中断 为lvgl提供时基</span></span><br><span class=\"line\">  lv_init();                     <span class=\"comment\">// 初始化LVGL</span></span><br><span class=\"line\">  lv_port_disp_init();           <span class=\"comment\">// 初始化显示接口</span></span><br><span class=\"line\">  lv_port_indev_init();          <span class=\"comment\">// 初始化输入接口</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (<span class=\"number\">1</span>)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    lv_timer_handler(); <span class=\"comment\">// 处理LVGL任务</span></span><br><span class=\"line\">    delay_ms(<span class=\"number\">5</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"ble基础学习","date":"2026-01-10T17:20:35.000Z","cover":"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/ble.jpg","_content":"---\n\n## BLE基础\n\n![image-20260111012740722](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/image-20260111012740722.png)\n\n","source":"_posts/ble基础.md","raw":"---\ntitle: ble基础学习\ndate: 2026-01-11 01:20:35\ncover: \"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/ble.jpg\"\ntags:\n - 蓝牙相关\n - BLE学习\n - 嵌入式基础\n---\n---\n\n## BLE基础\n\n![image-20260111012740722](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/image-20260111012740722.png)\n\n","slug":"ble基础","published":1,"updated":"2026-01-10T17:31:50.000Z","comments":1,"layout":"post","photos":[],"_id":"cmk8pg6xk000o6sk9d0m7af3i","content":"<hr>\n<h2 id=\"BLE基础\"><a href=\"#BLE基础\" class=\"headerlink\" title=\"BLE基础\"></a>BLE基础</h2><p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/image-20260111012740722.png\" alt=\"image-20260111012740722\"></p>\n","excerpt":"","more":"<hr>\n<h2 id=\"BLE基础\"><a href=\"#BLE基础\" class=\"headerlink\" title=\"BLE基础\"></a>BLE基础</h2><p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/image-20260111012740722.png\" alt=\"image-20260111012740722\"></p>\n"},{"title":"ESP32学习","date":"2025-09-09T03:04:10.000Z","cover":"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091106486.jpg","_content":"\n## ESP32环境搭建\n\n### WSL2安装与配置\n\n推荐查阅官方文档说明：[安装 WSL | Microsoft Learn](https://learn.microsoft.com/zh-cn/windows/wsl/install)\n\n#### 手动下载安装包\n\n1. 访问 WSL 的 GitHub Releases 页面 https://github.com/microsoft/WSL/releases\n\n2. 查找并下载最新版本的 .msi 安装包（例如 wsl.2.1.5.0.x64.msi）\n\n![image-20250909111242531](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091112594.png)\n\n#### 配置控制面板\n\n![image-20250909111552848](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091115919.png)\n\n![image-20250909111621317](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091116357.png)\n\n> 有些Windows 11新系统会没有`虚拟机平台`这个选项 没有关系！！！！\n>\n> 配置完后重新启动电脑\n\n#### 管理员身份运行Windows PowerShell\n\n![img](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091108898.png)\n\n#### 安装Ubuntu\n\n```bash\nwsl --install\n```\n\n![img](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091108464.png)\n\n> 如有可选 则选择Uuntu 如 `wsl --install -d Ubuntu`\n\n#### 等待安装完成后重启电脑打开Ubuntu\n\n![image-20250909112101810](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091121963.png)\n\n#### 输入账号密码\n\n![img](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091121306.png)\n\n#### 更新软件源\n\n```bash\nsudo apt update\n```\n\n![img](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091124279.png)\n\n#### 更新完后输入下方指令，下载espidf依赖库和工具\n\n> ```bash\n> sudo apt-get install git wget flex bison gperf python3 python3-pip python3-venv cmake ninja-build ccache libffi-dev libssl-dev dfu-util libusb-1.0-0\n> ```\n\n![img](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091126525.png)\n\n#### 输入y\n\n![image-20250909112720315](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091127364.png)\n\n### VScode配置\n\n#### 选择连接到WSL\n\n![img](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091129218.png)\n\n#### 插件安装\n\n> - 安装`Chinese`插件\n> - 安装`C/C++`插件\n> - 安装`ESP-IDF`插件\n\n#### 在linux账户新建文件用于存放espidf内容，方便后续管理\n\n![image-20250909113527188](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091135250.png)\n\n#### ESP-IDF安装\n\n![img](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091131190.png)\n\n#### 在安装路径中选择自己新建的文件夹\n\n![img](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091135132.png)\n\n> 如果出现下图这个情况\n>\n> ![img](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091137839.png)\n>\n> 那就运行一下下面的指令 \n>\n> ```bash\n> sudo chown -R $USER:$USER /home/你的用户名/你的IDF文件名/\n> chmod -R 755 /home/你的用户名/你的IDF文件名/\n> ```\n\n#### 安装完成之后先搞个工程测试一下编译能不能正常\n\n![img](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091140479.png)\n\n#### 选择文件夹来存放代码\n\n![img](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091143918.png)\n\n![img](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091143292.png)\n\n#### 设置环境\n\n##### 设置IDF_tools环境（豆包四条命令搞定）\n\n> 注意下方命令中：\n>\n> `~/ESP_IDF/v5.5.1/esp-idf`：你的IDF文件夹路径 要一直引入到`esp-idf`\n>\n> `~/ESP_IDF/Tools`：你的IDF_Tools文件夹路径\n\n```bash\necho 'export IDF_PATH=~/ESP_IDF/v5.5.1/esp-idf' >> ~/.bashrc\necho 'export IDF_TOOLS_PATH=~/ESP_IDF/Tools' >> ~/.bashrc\necho 'source ~/ESP_IDF/v5.5.1/esp-idf/export.sh' >> ~/.bashrc\nsource ~/.bashrc  # 立即生效\n```\n\n> 成功的话 重启`vscode`就会自动出现`idf`的命令\n>\n> ![image-20250909221836025](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509092218229.png)\n\n##### 若上面还不行 则根据报错情况执行下面\n\n###### 场景 1：运行 `./export.sh` 时报 “Python 虚拟环境不存在”\n\n`报错信息`\n\n```bash\nERROR: ESP-IDF Python virtual environment \"$HOME/ESP_IDF/Tools/python_env/idf5.5_py3.12_env/bin/python\" not found. Please run the install script to set it up before proceeding.\n```\n\n`原因`\n\n未执行 ESP-IDF 安装脚本，Python 虚拟环境未创建。\n\n`解决方案`\n\n必须先运行安装脚本，自动创建虚拟环境和安装依赖：\n\n```bash\n# 进入 ESP-IDF 根目录（替换为你的实际路径）\ncd ~/ESP_IDF/v5.5.1/esp-idf\n# 执行安装脚本（Linux/macOS 用 install.sh，Windows 用 install.bat）\n./install.sh\n# 安装完成后再执行 export.sh 导出环境\n. ./export.sh\n```\n\n###### 场景 2：运行 `./install.sh` 时 “下载工具包卡住”\n\n`报错表现`\n\n安装过程中卡在某一工具包下载（如 `riscv32-esp-elf-gdb`），进度条不动或反复重试。\n\n`原因`\n\nESP-IDF 工具包托管在 GitHub，国内网络访问速度慢或不稳定，导致下载中断。\n\n1. **用国内镜像加速（推荐）**\n   配置 `IDF_GITHUB_ASSETS` 环境变量，将下载源切换为 Espressif 国内镜像，无需手动下载：\n\n   ```bash\n   # 临时生效，每次打开终端需重新执行（或写入 shell 配置文件）\n   export IDF_GITHUB_ASSETS=\"dl.espressif.com/github_assets\"\n   # 重新运行安装脚本\n   ./install.sh\n   ```\n\n#### 烧录文件\n\n##### 下载wsl-usb-manager.exe\n\n> <a href=\"https://mextra.netlify.app/download/ESP32/wsl-usb-manager.exe\">wsl-usb-manager.exe </a>\n\n##### 插上ESP32S3\n\n![059f326e4709ef71f539677c5da784c2](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091454477.jpg)\n\n##### 配置WSL USB\n\n###### 管理员身份打开Windows PowerShell\n\n> 输入`winget install usbipd`，然后输入`y`（`看情况选择开不开魔法`，不开也能20s左右下载安装完）\n\n这个指令是安装usbipd-win工具，用于将windows系统的usb设备共享给wsl环境。\n\n![img](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509092343890.png)\n\n安装好之后 更改权限\n\n> - 输入`sudo usermod -aG dialout 你的用户名`\n>\n> - 然后`重启电脑`\n> - 输入`groups`验证一下\n>   - 如果输出中包含 `dialout` 或 `uucp`，则表示设置成功，之后就可以正常访问串口了。\n\n##### 进入WSL USB选择端口并烧录\n\n![image-20250909145724459](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091457549.png)\n\n![image-20250909150034639](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091500732.png)\n\n以上环境参考：[（二）vscode搭建espidf环境，配置wsl2_wsl 编译idf项目-CSDN博客](https://blog.csdn.net/QL_SD/article/details/150216599?spm=1001.2014.3001.5502)\n\n感谢[QL.ql](https://blog.csdn.net/QL_SD)大博主\n\n## ESP32基础知识\n\n![image-20250909173749995](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091737219.png)\n\n![image-20250909173836126](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091738212.png)\n\n### 使用命令行创建工程\n\n```bash\nidf.py create-project 工程名\n```\n\n#### 打开vscode 切换到新建的工程\n\n```bash\ncd ~/ESP_Code/刚刚的工程名\ncode .\n\n按`ctrl+shift+p` 寻找add 添加idf路径\n```\n\n> 在写代码时候 如果出现宏没定义 则重新设置一下芯片型号 稍等一会就会出现\n>\n> ![image-20250910100948617](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509101009919.png)\n>\n> ![image-20250910102600612](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509101026730.png)\n>\n> 如果想要删除文件夹 则运行以下命令\n>\n> ```bash\n> cd ..\n> rm -rf 文件夹\n> ```\n>\n> 必备头文件\n>\n> ```C\n> #include \"freertos/FreeRTOS.h\"\n> #include \"freertos/task.h\"\n> #include \"esp_log.h\"\n> ```\n>\n\n### CMakeList.txt使用说明\n\n一般CmakeList.txt呈现下面的结构\n\n```C\nmain\n    main.c\n    CMakeList.txt\nCMakeList.txt\n```\n\n#### 创建自定义文件夹\n\n> 如\n>\n> ```C\n> components\n>     led\n>     \tled.c\n>     \tled.h\n>     \tCMakeList.txt\n> main\n>     main.c\n>     CMakeList.txt\n> ```\n>\n> 在这个目录下 则`components/led`文件夹下的`CMakeList.txt`，可以这么写\n>\n> ```cmake\n> idf_component_register(SRCS \"led.c\"\n>                     INCLUDE_DIRS \".\"\n>                     REQUIRES esp_driver_gpio\n>                     )\n> ```\n>\n> - `SRCS`：`.c`文件 多个用空格隔开\n>\n> - `INCLUDE_DIRS`：文件名 多个同样用空格隔开\n>\n> - `REQUIRES`：引入ESP官方的组件库`components` ，名字为官方`idf`下的`components`文件夹下的文件夹名 如此处的`esp_driver_gpio`\n>\n>   ![image-20250912184005520](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509121840992.png)\n>\n> 而若要引用 则`main`文件夹下的`CMakeList.txt` 可以这么写\n>\n> ```cmake\n> idf_component_register(SRCS \"main.c\" \"../components/led/led.c\"\n>                     INCLUDE_DIRS \".\" \"../components\")\n> ```\n\n### FreeRTOS-ESP32 基础API\n\n#### 任务创建\n\n```C\nBaseType_t xTaskCreatePinnedToCore(\n\tTaskFunction_t pvTaskCode,\t\t\t\t//任务函数指针，原型是voidfun(void*param)\n\tconst char *constpcName,\t\t\t\t//任务的名称，打印调试可能会有用\n\tconst uint32_t usStackDepth,\t\t\t//指定的任务堆栈空间大小（字节）\n\tvoid *constpvParameters,\t\t\t\t//任务参数\n\tUBaseType_t uxPriority,\t\t\t\t\t//优先级，数字越大，优先级越大，0到(configMAX_PRIORITIES-1) 即0-24\n\tTaskHandle_t *constpvCreatedTask,\t\t //传回来的任务句柄\n\tconst BaseType_t xCoreID)\t\t\t\t//分配在哪个内核上运行 ESP32是双核 所以可以选0或1\n```\n\n> ESP32的任务堆栈空间大小`usStackDepth`与原生FreeRTOS不一样\n>\n> - 原生FreeRTOS的任务堆栈空间大小单位是`字`，即目标平台若是32位 则为4个字节\n> - ESP32的任务堆栈空间大小单位是`字节`，最小是`2048`\n\n#### 阻塞函数（少用 可替代）\n\n```C\n//粗略延时xTicksToDelay个周期 \n//使用该函数后 任务进入阻塞 等延时结束且调度到来才会再次运行\nvoid vTaskDelay(const TickType_t xTicksToDelay)\t\n\n//用于表示精确的解除阻塞时间    \n//即使任务的执行时间超过了周期时间，它也能自动调整延迟时间，保证任务的周期性运行\nvoid vTaskDelayUntil(TickType_t *pxPreviousWakeTime,const TickType_t xTimeIncrement)\n\n```\n\n#### 打印调试\n\n```C\n#include <stdio.h>\n#include \"freertos/FreeRTOS.h\"\n#include \"freertos/task.h\"\n#include \"esp_log.h\"\nvoid taskA(void *param)\n{\n    while (1)\n    {\n        ESP_LOGI(\"TaskA\", \"Hello from Task A%d\", 1);//前面是一个TAG标签，后面是打印内容 他会自动回车换行\n        vTaskDelay(pdMS_TO_TICKS(500));\n    }\n}\n\nvoid app_main(void)\n{\n    xTaskCreatePinnedToCore(taskA, \"TaskA\", 2048, NULL, 5, NULL, 1);\n}\n\t\n```\n\n效果如图\n\n![image-20250910101607354](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509101016442.png)\n\n#### 队列\n\n> 队列特性：先进先出\n\n```C\nQueueHandle_t queue_handle = NULL; // 创建队列句柄\n\n/**\n * @brief 创建一个队列\n * @param uxQueueLength 队列长度\n * @param uxItemSize 每个元素的大小(单位是字节)\n */\nQueueHandle_t xQueueCreate(UBaseType_t uxQueueLength, UBaseType_t uxItemSize);\n\n/**\n * @brief 向队列头部发送数据\n * @param xQueue 队列句柄\n * @param pvItemToQueue 要发送的数据的指针\n * @param xTicksToWait 等待的时间(单位是tick)\n * @return 如果在等待时间内发送成功返回pdTRUE，否则返回errQUEUE_FULL\n */\nBaseType_t xQueueSend(QueueHandle_t xQueue, const void *pvItemToQueue, TickType_t xTicksToWait);\n\n/**\n * @brief 向队列尾部发送数据（新数据放在队尾）\n * @param xQueue 队列句柄\n * @param pvItemToQueue 要发送的数据的指针\n * @param xTicksToWait 等待的时间\n * @return pdTRUE 如果发送成功\n *         errQUEUE_FULL 如果队列已满，发送失败\n */\nBaseType_t xQueueSendToBack(QueueHandle_t xQueue, const void *pvItemToQueue, TickType_t xTicksToWait);\n\n/**\n * @brief 从队列中接收数据\n * @param xQueue 队列句柄\n * @param pvBuffer 用于存储接收数据的缓冲区\n * @param xTicksToWait 等待数据的最大时间，以系统节拍为单位\n * @return pdPASS 表示接收成功，errQUEUE_EMPTY 表示队列为空且等待超时，接收失败。\n */\nBaseType_t xQueueReceive(QueueHandle_t xQueue, void *pvBuffer, TickType_t xTicksToWait);\n\n/**\n * @brief 该函数在中断中使用，从队列发送数据 这个函数的行为和普通的 xQueueSend 有差异，且不允许阻塞（等待）\n * @param xQueue 队列句柄\n * @param pvItemToQueue 要发送的数据\n * @param pxHigherPriorityTaskWoken 如果发送数据后，有更高优先级的任务被唤醒，则该参数会被置为pdTRUE\n * @return 如果发送成功，返回pdTRUE，否则返回errQUEUE_FULL\n */\nBaseType_t xQueueSendFromISR(QueueHandle_t xQueue, const void *pvItemToQueue, BaseType_t *pxHigherPriorityTaskWoken);\n```\n\n##### 调用示例\n\n```C\n#include <stdio.h>\n#include <string.h>\n#include \"freertos/FreeRTOS.h\"\n#include \"freertos/task.h\"\n#include \"freertos/queue.h\"\n#include \"esp_log.h\"\n\nQueueHandle_t queue_handle = NULL; // 定义一个队列句柄\n\ntypedef struct\n{\n    int value;\n} queue_date_t;\n\nvoid taskA(void *param)\n{\n    // 从队列里面接收数据，并打印\n    queue_date_t data;\n    while (1)\n    {\n        if (xQueueReceive(queue_handle, &data, 100) == pdTRUE) // 从队列中接收数据，阻塞等待\n        {\n            ESP_LOGI(\"re_queue\", \"receive queue value:%d\", data.value); // 前面是一个TAG标签，后面是打印内容 他会自动回车换行\n        }\n    }\n}\n\nvoid taskB(void *param)\n{\n    queue_date_t data;\n    memset(&data, 0, sizeof(data));\n    // 每隔1s向队列里面发送数据\n    while (1)\n    {\n        xQueueSendToBack(queue_handle, &data, 100); // 向队列中发送数据，阻塞等待\n        vTaskDelay(pdMS_TO_TICKS(1000));            // 延时1s\n        data.value++;\n    }\n}\n\nvoid app_main(void)\n{\n    queue_handle = xQueueCreate(10, sizeof(queue_date_t)); // 创建一个队列，队列长度为10，每个元素的大小为queue_date_t结构体的大小\n    xTaskCreatePinnedToCore(taskA, \"re_queue\", 2048, NULL, 3, NULL, 1);\n    xTaskCreatePinnedToCore(taskB, \"se_queue\", 2048, NULL, 3, NULL, 1);\n}\n```\n\n> ![image-20250910110704875](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509101107988.png)\n\n#### 信号量\n\n```C\n/**\n * @brief 创建一个二值信号量\n * @return SemaphoreHandle_t 信号量句柄\n */\nSemaphoreHandle_t xSemaphoreCreateBinary(void);\n\n/**\n * @brief 创建一个计数信号量\n * @param uxMaxCount 计数信号量的最大值\n * @param uxInitialCount 计数信号量的初始值\n * \n */\nSemaphoreHandle_t xSemaphoreCreateCounting(UBaseType_t uxMaxCount, UBaseType_t uxInitialCount);\n\n/**\n * @brief 创建一个互斥锁\n * @return SemaphoreHandle_t 互斥锁句柄\n */\nSemaphoreHandle_t xSemaphoreCreateMutex(void);\n\n/**\n * @brief 取得一个信号量\n * @param xSemaphore 信号量句柄\n * @param xTicksToWait 等待信号量的时间，单位为ticks\n * @return 如果成功取得信号量则返回pdTRUE，否则返回pdFALSE\n */\nBaseType_t xSemaphoreTake(SemaphoreHandle_t xSemaphore, TickType_t xTicksToWait);\n\n/**\n * @brief 释放一个信号量\n * @param xSemaphore 信号量句柄\n * @return 如果成功释放信号量则返回pdTRUE，否则返回pdFALSE\n */\nBaseType_t xSemaphoreGive(SemaphoreHandle_t xSemaphore);\n\n/**\n * @brief 删除一个信号量\n * @param xSemaphore 要删除的信号量句柄\n */\nvoid vSemaphoreDelete(SemaphoreHandle_t xSemaphore);\n```\n\n##### 调用示例\n\n```C\n#include <string.h>\n#include \"freertos/FreeRTOS.h\"\n#include \"freertos/task.h\"\n#include \"freertos/queue.h\"\n#include \"freertos/semphr.h\"\n#include \"esp_log.h\"\n\nSemaphoreHandle_t mutex_handle;\n\nvoid taskA(void *param)\n{\n    while (1)\n    {\n        vTaskDelay(pdMS_TO_TICKS(1000));\n        xSemaphoreTake(mutex_handle, portMAX_DELAY);\n        ESP_LOGI(\"TASK_A\", \"Task A is running\");\n\n        xSemaphoreGive(mutex_handle);\n        vTaskDelay(pdMS_TO_TICKS(10)); // 给其他任务机会\n    }\n}\n\nvoid taskB(void *param)\n{\n    while (1)\n    {\n        vTaskDelay(pdMS_TO_TICKS(500));\n        xSemaphoreTake(mutex_handle, portMAX_DELAY);\n        ESP_LOGI(\"TASK_B\", \"Task B is running\");\n\n        xSemaphoreGive(mutex_handle);\n        vTaskDelay(pdMS_TO_TICKS(10)); // 给其他任务机会\n    }\n}\n\nvoid app_main(void)\n{\n    mutex_handle = xSemaphoreCreateMutex();\n    xTaskCreatePinnedToCore(taskA, \"taskA\", 2048, NULL, 6, NULL, 1);\n    xTaskCreatePinnedToCore(taskB, \"taskB\", 2048, NULL, 4, NULL, 1);\n}\n```\n\n> 注意释放信号量的时候 一般会给个延时 不加的话任务会马上回到`while(1)`初始的时候 反应出来的现象就是一直是A任务运行\n>\n> 原因：RTOS任务调度需要时间 并且最少只能是10ms 已测试\n\n#### 事件组\n\n```C\n/**\n * @brief 创建事件组\n * @return EventGroupHandle_t 事件组句柄\n */\nEventGroupHandle_t xEventGroupCreate(void);\n\n/**\n * @brief 设置事件位\n * @param xEventGroup 事件组句柄\n * @param uxBitsToSet 要设置的事件位\n * @return 设置后事件组的值\n */\nEventBits_t xEventGroupSetBits(EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet);\n\n/**\n * @brief 事件组等待位函数\n * @param xEventGroup 事件组句柄\n * @param uxBitsToWaitFor 等待的事件位\n * @param xClearOnExit 退出时是否清除事件位 pdTRUE or pdFALSE\n * @param xWaitForAllBits 是否等待所有位 pdTRUE or pdFALSE\n * @param xTicksToWait 等待的最大时间\n * @return 返回实际获得的事件位\n */\nEventBits_t xEventGroupWaitBits(const EventGroupHandle_t xEventGroup,\n                                const EventBits_t uxBitsToWaitFor,\n                                const BaseType_t xClearOnExit,\n                                const BaseType_t xWaitForAllBits,\n                                TickType_t xTicksToWait);\n\n\n/**\n * @brief 清除事件组指定事件位\n * @param xEventGroup 事件组句柄\n * @param uxBitsToClear 要清除的事件位\n * @return 清除前的事件组位值\n */\nEventBits_t xEventGroupClearBits(EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear);\n\n/* 以下使用消息直达机制*/\n\n/**\n * @brief 任务通知函数\n * @param xTaskToNotify 任务句柄\n * @param ulValue 发送的值\n * @param eAction 发送的动作 \n *                eNoAction 不改变任务的通知值(即不更新 会一直发送初始值)\n *                eSetBits 将ulValue的值按位或 到任务的通知值中 \n *                eIncrement 将任务的通知值加1\n *                eSetValueWithOverwrite 将任务的通知值设置为ulValue\n *                eSetValueWithoutOverwrite 如果任务的通知值为0，则将其设置为ulValue，否则不改变任务的通知值\n * @return 如果通知成功返回pdPASS，否则返回errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY\n */\nBaseType_t xTaskNotify(TaskHandle_t xTaskToNotify,\n                       uint32_t ulValue,\n                       eNotifyAction eAction);\n\n/**\n * @brief 将任务设置为等待接收通知\n * @param ulBitsToClearOnEntry 进入等待前要清除的位\n * @param ulBitsToClearOnExit 退出等待后要清除的位\n * @param pulNotificationValue 指向接收通知值的指针\n * @param xTicksToWait 等待通知的最大时间（以滴答为单位）\n * @return 如果在指定的等待时间内收到通知，则返回pdTRUE；否则返回\n */\nBaseType_t xTaskNotifyWait(uint32_t ulBitsToClearOnEntry,\n                           uint32_t ulBitsToClearOnExit,\n                           uint32_t *pulNotificationValue,\n                           TickType_t xTicksToWait);\n```\n\n##### 调用示例\n\n###### 事件组设置\n\n```C\n#include <string.h>\n#include \"freertos/FreeRTOS.h\"\n#include \"freertos/task.h\"\n#include \"freertos/queue.h\"\n#include \"freertos/semphr.h\"\n#include \"freertos/event_groups.h\"\n#include \"esp_log.h\"\n\n#define EVENT_BIT_0 BIT0\n#define EVENT_BIT_1 BIT1\n\nEventGroupHandle_t event_handle;\n\nvoid taskA(void *param)\n{\n    // 定时1s向任务B发送事件消息\n    while (1)\n    {\n        xEventGroupSetBits(event_handle, EVENT_BIT_0);\n        vTaskDelay(pdMS_TO_TICKS(1000));\n        xEventGroupSetBits(event_handle, EVENT_BIT_1);\n        vTaskDelay(pdMS_TO_TICKS(1000));\n    }\n}\n\nvoid taskB(void *param)\n{\n    EventBits_t ev;\n    while (1)\n    {\n        ev = xEventGroupWaitBits(event_handle, EVENT_BIT_0 | EVENT_BIT_1, pdTRUE, pdFALSE, pdMS_TO_TICKS(5000));\n        if (ev & EVENT_BIT_0)\n        {\n            ESP_LOGI(\"ev\", \"ev get event0\");\n        }\n        if (ev & EVENT_BIT_1)\n        {\n            ESP_LOGI(\"ev\", \"ev get event1\");\n        }\n    }\n}\n\nvoid app_main(void)\n{\n    event_handle = xEventGroupCreate();\n    xTaskCreatePinnedToCore(taskA, \"taskA\", 2048, NULL, 3, NULL, 1);\n    xTaskCreatePinnedToCore(taskB, \"taskB\", 2048, NULL, 3, NULL, 1);\n}\n```\n\n###### 消息直达\n\n```C\n#include <string.h>\n#include \"freertos/FreeRTOS.h\"\n#include \"freertos/task.h\"\n#include \"freertos/queue.h\"\n#include \"freertos/semphr.h\"\n#include \"freertos/event_groups.h\"\n#include \"esp_log.h\"\n\nstatic TaskHandle_t taskA_handle;\nstatic TaskHandle_t taskB_handle;\n\nvoid taskA(void *param)\n{\n    // 定时1s向任务B发送事件消息\n    uint32_t count = 0;\n    vTaskDelay(pdMS_TO_TICKS(100));\n    while (1)\n    {\n        xTaskNotify(taskB_handle, count, eSetValueWithoutOverwrite);\n        count++;\n        vTaskDelay(pdMS_TO_TICKS(1000));\n    }\n}\n\nvoid taskB(void *param)\n{\n    uint32_t count = 0;\n    while (1)\n    {\n        xTaskNotifyWait(0, 0, &count, portMAX_DELAY);\n        ESP_LOGI(\"taskB\", \"Notify count: %lu\", count);\n    }\n}\n\nvoid app_main(void)\n{\n    xTaskCreatePinnedToCore(taskA, \"taskA\", 2048, NULL, 3, &taskA_handle, 1);\n    xTaskCreatePinnedToCore(taskB, \"taskB\", 2048, NULL, 3, &taskB_handle, 1);\n}\n```\n\n#### ESP-IDF中的FreeRTOS与原生区别\n\n> 1. ESP32是多核的 所以可以完全实现程序并发执行 即不是单核那种 低优先级的任务因为高优先级任务存在而执行不了\n> 2. esp-idf自动创建五个任务\n>    - 空闲任务（每个核都会创建一个，`优先级为0`）\n>    - FreeRTOS定时器任务（`优先级为1`）\n>    - app_main任务（我们的应用入口，`优先级为1`）\n>    - IPC任务（每个核创建一个，用于多核协调，`优先级为24`）\n>    - ESP定时器任务（负责ESP32定时器回调，`优先级为22`）\n> 3. esp-idf不使用原生FreeRTOS的内存堆管理，实现了自己的堆\n> 4. 创建任务使用`xTaskCreatePinnedToCore()` 可以指定用哪个核创建任务\n>    - 负责处理`无线网络的任务（如WiFi蓝牙）`将被固定到`CPU0`，即`PRO_CPU`\n>    - 处理`应用程序`其余部分任务将被固定到`CPU1`，即`APP_CPU`\n> 5. 如果任务中用到浮点运算，则创建任务的时候必须指定具体运行在哪个核上，不能由系统自动安排\n\n## GPIO配置\n\n### 引脚基础配置\n\n#### `gpio_config()`：批量配置 GPIO（核心入口）\n\n- **函数原型**\n\n  ```c\n  esp_err_t gpio_config(const gpio_config_t *pGPIOConfig);\n  ```\n\n- **作用**：一次性配置一组 GPIO 的模式、上下拉、中断类型（覆盖该引脚当前所有配置）。\n\n- **参数**：`pGPIOConfig`：指向 `gpio_config_t` 结构体的指针（需提前初始化）。\n\n- **返回值**：`ESP_OK`（成功）、`ESP_ERR_INVALID_ARG`（参数错误，如引脚无效）。\n\n- **示例**：配置 GPIO2、GPIO3 为输出模式，禁用上下拉和中断：\n\n  ```c\n  gpio_config_t io_conf = {\n      .pin_bit_mask = (1ULL << GPIO_NUM_2) | (1ULL << GPIO_NUM_3),  // 仅配置 GPIO2\n      .mode = GPIO_MODE_OUTPUT,\n      .pull_up_en = GPIO_PULLUP_DISABLE,\n      .pull_down_en = GPIO_PULLDOWN_DISABLE,\n      .intr_type = GPIO_INTR_DISABLE\n  };\n  gpio_config(&io_conf);  // 执行配置\n  ```\n\n> `intr_type` :\n>\n> - `GPIO_INTR_DISABLE`：禁用中断\n> -  `GPIO_INTR_POSEDGE`：上升沿触发\n> - `GPIO_INTR_NEGEDGE`：下降沿触发\n> - `GPIO_INTR_ANYEDGE`：双边沿触发\n> - `GPIO_INTR_LOW_LEVEL`：低电平触发\n> - `GPIO_INTR_HIGH_LEVEL`：高电平触发\n\n#### `gpio_reset_pin()`：重置引脚为默认状态\n\n- **函数原型**\n\n  ```c\n  esp_err_t gpio_reset_pin(gpio_num_t gpio_num);\n  ```\n\n- **作用**：将指定 GPIO 重置为默认状态（输入模式、禁用上下拉、禁用中断、选择 GPIO 功能）。\n\n- **参数**：`gpio_num`：要重置的 GPIO 编号（如 `GPIO_NUM_4`）。\n\n- **示例**：重置 GPIO4，恢复初始状态：\n\n  ```c\n  gpio_reset_pin(GPIO_NUM_4);\n  ```\n\n#### `gpio_set_direction()`：单独设置引脚方向\n\n- **函数原型**\n\n  ```c\n  esp_err_t gpio_set_direction(gpio_num_t gpio_num, gpio_mode_t mode);\n  ```\n\n- **作用**：单独修改某个 GPIO 的模式（输入 / 输出 / 输入输出），覆盖当前模式。\n\n- **参数**\n\n  - `gpio_num`：目标 GPIO 编号。\n  - `mode`：目标模式（如 `GPIO_MODE_INPUT`）。\n\n- **示例**：将已配置的 GPIO2 改为输入模式\n\n  ```c\n  gpio_set_direction(GPIO_NUM_2, GPIO_MODE_INPUT);\n  ```\n\n#### 配置上下拉函数（`gpio_pullup_en`/`gpio_pulldown_en`）\n\n- **函数原型**\n\n  ```c\n  esp_err_t gpio_pullup_en(gpio_num_t gpio_num);    // 启用上拉\n  esp_err_t gpio_pullup_dis(gpio_num_t gpio_num);   // 禁用上拉\n  esp_err_t gpio_pulldown_en(gpio_num_t gpio_num);  // 启用下拉\n  esp_err_t gpio_pulldown_dis(gpio_num_t gpio_num); // 禁用下拉\n  ```\n\n- **作用**：比 `gpio_set_pull_mode` 更直观，单独控制上拉 / 下拉的启用 / 禁用。\n\n- **示例**：启用 GPIO0 下拉，禁用上拉：\n\n  ```c\n  gpio_pulldown_en(GPIO_NUM_0);\n  gpio_pullup_dis(GPIO_NUM_0);\n  ```\n\n### 引脚电平控制函数\n\n#### `gpio_set_level()`：设置输出电平\n\n- **函数原型**\n\n  ```c\n  esp_err_t gpio_set_level(gpio_num_t gpio_num, uint32_t level);\n  ```\n\n- **作用**：给输出模式的 GPIO 设置高 / 低电平（仅输出模式有效）。\n\n- **参数**：\n\n  - `level`：`0`（低电平）、`1`（高电平）。\n\n#### `gpio_get_level()`：读取输入电平\n\n- **函数原型**\n\n  ```c\n  int gpio_get_level(gpio_num_t gpio_num);\n  ```\n\n- **作用**：读取 GPIO 的当前输入电平（需引脚为输入 / 输入输出模式，否则返回 0）。\n\n- **返回值**：`0`（低电平）、`1`（高电平）。\n\n## LEDC库学习笔记\n\n> **定义**：LEDC（Light Emitting Diode Controller）是 ESP32 内置的 LED 控制器，核心功能是生成 PWM（脉冲宽度调制）信号，不仅用于 LED 亮度调节，还可驱动电机、舵机等需 PWM 信号的设备。\n>\n> **核心优势**：无需手动编写定时器中断逻辑，ESP-IDF 提供完整库接口，配置简单、信号稳定\n>\n> **注意**：LEDC 控制器有自己`专属的 4 个定时器`（`LEDC_TIMER_0` ~ `LEDC_TIMER_3`），这些定时器是 LEDC 模块内部集成的，专门用于生成 PWM 信号。\n>\n> 与`通用定时器（TIMER_0 ~ TIMER_3）`完全分离\n\n### LEDC关键概念\n\n| 概念                      | 说明                                                         |\n| ------------------------- | ------------------------------------------------------------ |\n| 通道（Channel）           | ESP32 有 16 个独立通道，每个通道可独立配置 PWM 参数（频率、占空比），并映射到 1 个 GPIO 引脚输出信号。 |\n| 定时器（Timer）           | 每个通道需绑定定时器，定时器决定 PWM 频率（由预分频和计数范围计算），多个通道可共享同一定时器（频率相同）。 |\n| 频率（Frequency）         | PWM 信号周期的倒数（单位：Hz），如 50Hz（舵机常用，对应 20ms 周期）、1000Hz（LED 常用，避免人眼闪烁）。 |\n| 占空比（Duty Cycle）      | PWM 高电平持续时间与周期的比值（0~100%），LEDC 中用数值表示（如 12 位分辨率对应 0~4095）。 |\n| 分辨率（Duty Resolution） | 占空比的可调精度，范围 `LEDC_TIMER_1_BIT`~`LEDC_TIMER_20_BIT`，如 12 位表示占空比可设为 0~4095（共 4096 级）。 |\n| 速度模式                  | 分 `LEDC_LOW_SPEED_MODE`（低速模式）和 `LEDC_HIGH_SPEED_MODE`（高速模式），高速模式支持更高 PWM 频率。 |\n\n### 常用API（需包含头文件 `driver/ledc.h`）\n\n#### 定时器初始化\n\n- **作用**：初始化 LEDC 定时器，设置频率、分辨率等核心参数。\n\n- 函数原型\n\n  ```c\n  esp_err_t ledc_timer_config(const ledc_timer_config_t *timer_conf);\n  ```\n\n- **参数结构体 `ledc_timer_config_t` 说明**：\n\n  | 参数              | 取值 / 说明                                                  |\n  | ----------------- | ------------------------------------------------------------ |\n  | `speed_mode`      | 速度模式：`LEDC_LOW_SPEED_MODE` 或 `LEDC_HIGH_SPEED_MODE`    |\n  | `duty_resolution` | 占空比分辨率：`LEDC_TIMER_1_BIT` ~ `LEDC_TIMER_20_BIT`（如 12 位选 `LEDC_TIMER_12_BIT`） |\n  | `timer_num`       | 定时器编号：`LEDC_TIMER_0` ~ `LEDC_TIMER_3`（共 4 个定时器） |\n  | `freq_hz`         | PWM 频率（如 50、1000，单位：Hz）                            |\n  | `clk_cfg`         | 时钟源：通常用 `LEDC_AUTO_CLK`（自动选择最优时钟）           |\n\n- **示例**：配置 1000Hz、12 位分辨率的定时器 0（低速模式）\n\n  ```c\n  ledc_timer_config_t timer_conf = {\n      .speed_mode = LEDC_LOW_SPEED_MODE,\n      .duty_resolution = LEDC_TIMER_12_BIT,  // 0~4095 级占空比\n      .timer_num = LEDC_TIMER_0,\n      .freq_hz = 1000,                       // 1000Hz 频率\n      .clk_cfg = LEDC_AUTO_CLK\n  };\n  ledc_timer_config(&timer_conf);  // 执行配置\n  ```\n\n####  通道配置：`ledc_channel_config()`\n\n#### 通道配置：`ledc_channel_config()`\n\n- **作用**：将 LEDC 通道绑定到定时器和 GPIO 引脚，设置初始占空比。\n\n- **函数原型**\n\n  ```c\n  esp_err_t ledc_channel_config(const ledc_channel_config_t *channel_conf);\n  ```\n\n- **参数结构体** `ledc_channel_config_t` **说明**\n\n  | 参数         | 取值 / 说明                                                  |\n  | ------------ | ------------------------------------------------------------ |\n  | `speed_mode` | 需与绑定的定时器速度模式一致（如 `LEDC_LOW_SPEED_MODE`）     |\n  | `channel`    | 通道编号：`LEDC_CHANNEL_0` ~ `LEDC_CHANNEL_15`（共 16 个通道） |\n  | `timer_sel`  | 绑定的定时器编号（如 `LEDC_TIMER_0`）                        |\n  | `intr_type`  | 中断类型：通常设 `LEDC_INTR_DISABLE`（禁用中断）             |\n  | `gpio_num`   | 输出 PWM 的 GPIO 引脚（如 `GPIO_NUM_2`、`GPIO_NUM_4`）       |\n  | `duty`       | 初始占空比（0 ~ 分辨率最大值，如 12 位初始为 0 表示 LED 灭） |\n  | `hpoint`     | 脉冲起点偏移：通常设 0（无偏移）                             |\n\n- 示例\n\n  ```c\n  ledc_channel_config_t channel_conf = {\n      .speed_mode = LEDC_LOW_SPEED_MODE,\n      .channel = LEDC_CHANNEL_0,\n      .timer_sel = LEDC_TIMER_0,  // 绑定定时器 0\n      .intr_type = LEDC_INTR_DISABLE,\n      .gpio_num = GPIO_NUM_2,     // GPIO2 输出 PWM\n      .duty = 0,                  // 初始占空比 0（LED 不亮）\n      .hpoint = 0\n  };\n  ledc_channel_config(&channel_conf);  // 执行配置\n  ```\n\n#### 3. 占空比修改：`ledc_set_duty()` + `ledc_update_duty()`\n\n- **作用**：动态调整通道的 PWM 占空比（`ledc_set_duty` 仅修改寄存器，`ledc_update_duty` 使修改生效）。\n\n- **函数原型**\n\n  ```c\n  // 1. 设置占空比（不立即生效）\n  esp_err_t ledc_set_duty(ledc_mode_t speed_mode, ledc_channel_t channel, uint32_t duty);\n  // 2. 使占空比生效\n  esp_err_t ledc_update_duty(ledc_mode_t speed_mode, ledc_channel_t channel);\n  ```\n\n- **参数说明**\n\n  - `speed_mode`：速度模式（与通道一致）\n  - `channel`：目标通道编号\n  - `duty`：目标占空比（0 ~ 分辨率最大值）\n\n- **示例**：将通道 0 占空比设为 50%（12 位分辨率对应 2048）\n\n  ```c\n  // 12 位分辨率下，50% 占空比 = 4096 / 2 = 2048\n  ledc_set_duty(LEDC_LOW_SPEED_MODE, LEDC_CHANNEL_0, 2048);\n  ledc_update_duty(LEDC_LOW_SPEED_MODE, LEDC_CHANNEL_0);  // 占空比生效\n  ```\n\n#### 4. 硬件渐变：`ledc_fade_*` 系列函数\n\n- **作用**：实现硬件自动渐变（无需软件循环），适合 LED 呼吸灯、平滑调光等场景。\n\n- **核心函数**：\n\n  | 函数                        | 作用                                                    |\n  | --------------------------- | ------------------------------------------------------- |\n  | `ledc_fade_func_install()`  | 初始化渐变功能（需开启中断，参数 0 表示不使用中断回调） |\n  | `ledc_set_fade_with_time()` | 配置渐变参数（目标占空比、渐变时间）                    |\n  | `ledc_fade_start()`         | 启动渐变（可选择阻塞 / 非阻塞模式）                     |\n  | `ledc_cb_register()`        | 注册 LEDC 回调函数                                      |\n\n- **函数原型**\n\n  ```c\n  // 1. 初始化渐变功能\n  esp_err_t ledc_fade_func_install(int intr_alloc_flags);\n  // 2. 配置渐变：在指定时间内从当前占空比渐变到目标占空比\n  esp_err_t ledc_set_fade_with_time(ledc_mode_t speed_mode, ledc_channel_t channel, uint32_t target_duty, uint32_t fade_time_ms);\n  // 3. 启动渐变\n  esp_err_t ledc_fade_start(ledc_mode_t speed_mode, ledc_channel_t channel, ledc_fade_mode_t fade_mode);\n  ```\n\n- **参数说明**：\n\n  - `intr_alloc_flags`：中断分配标志（设 0 即可）\n  - `target_duty`：渐变目标占空比\n  - `fade_time_ms`：渐变总时间（单位：ms）\n  - `fade_mode`：渐变模式：`LEDC_FADE_WAIT_DONE`（阻塞，等待渐变完成返回）/ `LEDC_FADE_NO_WAIT`（非阻塞）\n\n- **示例**：2 秒内从当前占空比渐变到最大亮度（12 位对应 4095）\n\n  ```c\n  // 1. 初始化渐变功能\n  ledc_fade_func_install(0);  // 不使用中断回调\n  \n  // 2. 配置渐变：2000ms（2秒）内渐变到 4095（最大亮度）\n  ledc_set_fade_with_time(LEDC_LOW_SPEED_MODE, \n                          LEDC_CHANNEL_0, \n                          4095,        // 目标占空比（最大）\n                          2000);       // 渐变时间（ms）\n  \n  // 3. 启动渐变（阻塞模式，等待渐变完成后再执行后续代码）\n  ledc_fade_start(LEDC_LOW_SPEED_MODE, LEDC_CHANNEL_0, LEDC_FADE_WAIT_DONE);\n  ```\n\n##### 启用中断模式\n\n- **函数原型**\n\n  ```C\n  esp_err_t ledc_cb_register(ledc_mode_t speed_mode, ledc_channel_t channel, ledc_cbs_t *cbs, void *user_arg)\n  ```\n\n- **参数结构体** `ledc_cbs_t` **说明**\n\n  - `fade_cb`：需要注册的中断回调函数\n\n- **示例**\n\n  ```C\n  #include <stdio.h>\n  #include \"freertos/FreeRTOS.h\"\n  #include \"freertos/task.h\"\n  #include \"driver/gpio.h\"\n  #include \"driver/ledc.h\"\n  \n  #define LED_GPIO GPIO_NUM_18\n  \n  #define FULL_EV_BIT BIT0\n  #define EMPTY_EV_BIT BIT1\n  \n  static EventGroupHandle_t led_fade_handle;\n  \n  /**\n   * @brief 重写LEDC完成回调函数\n   * @note IRAM_ATTR 修饰符表示该函数在IRAM中执行，中断服务程序中不能调用RAM中的函数\n   */\n  bool IRAM_ATTR ledc_finish_cb(const ledc_cb_param_t *param, void *user_arg)\n  {\n      BaseType_t taskWoken;\n      if (param->duty)\n      {\n          xEventGroupSetBitsFromISR(led_fade_handle, FULL_EV_BIT, &taskWoken);\n      }\n      else\n      {\n          xEventGroupSetBitsFromISR(led_fade_handle, EMPTY_EV_BIT, &taskWoken);\n      }\n      return taskWoken;\n  }\n  \n  void led_run_task(void *param)\n  {\n      EventBits_t ev;\n      while (1)\n      {\n          ev = xEventGroupWaitBits(led_fade_handle, FULL_EV_BIT | EMPTY_EV_BIT, pdTRUE, pdFALSE, pdMS_TO_TICKS(5000));\n          if (ev & FULL_EV_BIT)\n          {\n              ledc_set_fade_with_time(LEDC_LOW_SPEED_MODE, LEDC_CHANNEL_0, 0, 2000);\n              ledc_fade_start(LEDC_LOW_SPEED_MODE, LEDC_CHANNEL_0, LEDC_FADE_NO_WAIT);\n          }\n          if (ev & EMPTY_EV_BIT)\n          {\n              ledc_set_fade_with_time(LEDC_LOW_SPEED_MODE, LEDC_CHANNEL_0, 8191, 2000);\n              ledc_fade_start(LEDC_LOW_SPEED_MODE, LEDC_CHANNEL_0, LEDC_FADE_NO_WAIT);\n          }\n  \n          ledc_cbs_t ledc_cbs = {\n              .fade_cb = ledc_finish_cb,\n          };\n  \n          ledc_cb_register(LEDC_LOW_SPEED_MODE, LEDC_CHANNEL_0, &ledc_cbs, NULL);\n      }\n  }\n  \n  void app_main(void)\n  {\n      // gpio_config_t led_cfg = {\n      //     .pin_bit_mask = (1 << LED_GPIO),\n      //     .pull_down_en = GPIO_PULLDOWN_DISABLE,\n      //     .pull_up_en = GPIO_PULLUP_DISABLE,\n      //     .intr_type = GPIO_INTR_DISABLE,\n      //     .mode = GPIO_MODE_OUTPUT,\n      // };\n      // gpio_config(&led_cfg);\n  \n      ledc_timer_config_t ledc_timer = {\n          .speed_mode = LEDC_LOW_SPEED_MODE,\n          .timer_num = LEDC_TIMER_0,\n          .clk_cfg = LEDC_AUTO_CLK,\n          .freq_hz = 5000,\n          .duty_resolution = LEDC_TIMER_13_BIT, // 占空比分辨率 0-8191\n      };\n      ledc_timer_config(&ledc_timer);\n  \n      ledc_channel_config_t ledc_channel = {\n          .gpio_num = LED_GPIO,\n          .channel = LEDC_CHANNEL_0,\n          .duty = 0,\n          .speed_mode = LEDC_LOW_SPEED_MODE,\n          .timer_sel = LEDC_TIMER_0,\n          .intr_type = LEDC_INTR_DISABLE,\n      };\n      ledc_channel_config(&ledc_channel);\n  \n      ledc_fade_func_install(0); // 使能渐变 不需要自己手动调节占空比\n      ledc_set_fade_with_time(LEDC_LOW_SPEED_MODE, LEDC_CHANNEL_0, 8191, 2000);\n      ledc_fade_start(LEDC_LOW_SPEED_MODE, LEDC_CHANNEL_0, LEDC_FADE_NO_WAIT);\n  \n      led_fade_handle = xEventGroupCreate();\n  \n      ledc_cbs_t ledc_cbs = {\n          .fade_cb = ledc_finish_cb,\n      };\n  \n      ledc_cb_register(LEDC_LOW_SPEED_MODE, LEDC_CHANNEL_0, &ledc_cbs, NULL);\n  \n      xTaskCreatePinnedToCore(led_run_task, \"led_run_task\", 2048, NULL, 3, NULL, 1);\n  }\n  ```\n\n\n## UART配置\n\n### ESP32 UART 硬件特性\n\n- **硬件资源**：ESP32 内置 3 个 UART 接口（UART0、UART1、UART2），支持不同引脚映射\n- **通信参数**：可配置波特率（1200 ~ 5000000bps）、数据位（5 ~ 8 位）、校验位（无 / 奇 / 偶）、停止位（1/1.5/2 位）\n- **缓冲区**：每个 UART 支持硬件 FIFO 缓冲区，可通过软件配置环形缓冲区大小\n- **事件驱动**：支持通过 FreeRTOS 队列触发 UART 事件（数据接收、缓冲区满、溢出等）\n\n### 关键API\n\n| API 函数                | 功能描述                               | 核心参数说明                                                 |\n| ----------------------- | -------------------------------------- | ------------------------------------------------------------ |\n| `uart_param_config()`   | 配置 UART 通信参数（波特率、数据位等） | 端口号、`uart_config_t` 结构体                               |\n| `uart_set_pin()`        | 绑定 UART 信号到物理引脚               | 端口号、TX 引脚、RX 引脚、RTS 引脚、CTS 引脚                 |\n| `uart_driver_install()` | 安装 UART 驱动并创建事件队列           | 端口号、接收缓冲区大小、发送缓冲区大小、队列容量、队列句柄、标志 |\n| `uart_read_bytes()`     | 读取 UART 接收数据                     | 端口号、接收缓冲区、读取长度、超时时间                       |\n| `uart_write_bytes()`    | 发送 UART 数据                         | 端口号、发送缓冲区、发送长度                                 |\n| `uart_flush_input()`    | 清空 UART 接收缓冲区                   | 端口号                                                       |\n| `xQueueReceive()`       | 从事件队列接收 UART 事件               | 队列句柄、事件存储变量地址、超时时间                         |\n| `xTaskCreate()`         | 创建独立任务处理 UART 事件             | 任务函数、任务名称、栈大小、优先级等                         |\n\n### 基础配置\n\n#### 步骤 1：定义核心参数（宏定义）\n\n```c\n// 1. 定义 UART 端口号\n#define USER_UART_NUM UART_NUM_1  // 避免 UART0 冲突（默认用于串口打印）\n#define USER_UART_BAUD 115200  // 串口波特率设置\n\n// 2. 定义引脚（需根据硬件接线调整）\n#define UART_TX_PIN 17  // TX 发送引脚\n#define UART_RX_PIN 16  // RX 接收引脚\n\n// 3. 定义缓冲区和队列参数\n#define UART_BUFFER_SIZE 1024    // 数据缓冲区大小\n#define UART_QUEUE_SIZE 10       // 事件队列容量（最多缓存 10 个事件）\n#define UART_TASK_STACK_SIZE 4096// UART 处理任务栈大小\n#define UART_TASK_PRIORITY 5     // UART 任务优先级（1~24，数值越大优先级越高）\n\n// 4. 全局变量声明\nstatic QueueHandle_t uart_event_queue;  // UART 事件队列句柄\nstatic uint8_t uart_rx_buffer[UART_BUFFER_SIZE];  // 接收数据缓冲区\nstatic const char *TAG = \"UART_DEV\";    // 日志标签\n```\n\n#### 步骤 2：配置 UART 硬件参数\n\n通过 `uart_config_t` 结构体配置通信参数，再调用 `uart_param_config()` 生效：\n\n```c\n// 配置 UART 通信参数\nuart_config_t uart_config = {\n    .baud_rate = USER_UART_BAUD,          // 波特率（常用：9600、115200、1000000）\n    .data_bits = UART_DATA_8_BITS,// 数据位：8 位\n    .parity = UART_PARITY_DISABLE,// 校验位：禁用\n    .stop_bits = UART_STOP_BITS_1,// 停止位：1 位\n    .flow_ctrl = UART_HW_FLOWCTRL_DISABLE,  // 硬件流控：禁用（无需 RTS/CTS 引脚）\n    .source_clk = UART_SCLK_DEFAULT,         // 时钟源：默认\n};\n// 应用配置到指定 UART 端口\nESP_ERROR_CHECK(uart_param_config(USER_UART_NUM, &uart_config));\n```\n\n#### 步骤 3：绑定引脚并安装驱动 （如果用默认串口的话 则不需要绑定引脚）\n\n- **引脚绑定**：通过 `uart_set_pin()` 将 UART 信号映射到 ESP32 物理引脚\n- **驱动安装**：调用 `uart_driver_install()` 初始化 UART 驱动，创建事件队列（可选）\n\n```c\n// 1. 绑定 UART 引脚（TX/RX，流控引脚填 UART_PIN_NO_CHANGE 表示禁用）\nESP_ERROR_CHECK(uart_set_pin(USER_UART_NUM, \n                            UART_TX_PIN,  // TX 引脚\n                            UART_RX_PIN,  // RX 引脚\n                            UART_PIN_NO_CHANGE,  // RTS 引脚（禁用）\n                            UART_PIN_NO_CHANGE)); // CTS 引脚（禁用）\n\n// 2. 安装 UART 驱动（参数依次：端口号、接收缓冲区大小、发送缓冲区大小、事件队列容量、队列句柄、标志）\nESP_ERROR_CHECK(uart_driver_install(USER_UART_NUM, \n                                    UART_BUFFER_SIZE * 2,  // 接收缓冲区（建议比单次接收大）\n                                    UART_BUFFER_SIZE * 2,  // 发送缓冲区\n                                    UART_QUEUE_SIZE,       // 事件队列容量\n                                    &uart_event_queue,     // 事件队列句柄（传出）\n                                    0));                   // 标志：0（默认）\n```\n\n### ESP32 UART 数据处理方式\n\n| 特性       | 轮询方式（简单场景）                      | 事件驱动方式（高效场景）          |\n| ---------- | ----------------------------------------- | --------------------------------- |\n| 核心函数   | `uart_read_bytes()`、`uart_write_bytes()` | `xQueueReceive()`（监听事件队列） |\n| 适用场景   | 简单回显、低频率数据交互                  | 高频率数据、多事件处理（如溢出）  |\n| CPU 占用率 | 较高（循环查询）                          | 较低（事件触发，无轮询）          |\n| 代码复杂度 | 低                                        | 中（需处理多事件类型）            |\n| 看门狗风险 | 高（需避免长阻塞）                        | 低（事件队列超时释放 CPU）        |\n\n### 实战代码示例\n\n#### 事件驱动方式\n\n- 通过 FreeRTOS 队列接收 UART 事件，按需处理数据接收、缓冲区满、溢出等场景：\n\n  ```C\n  #include <stdio.h>\n  #include \"freertos/FreeRTOS.h\"\n  #include \"freertos/task.h\"\n  #include \"driver/uart.h\"\n  #include \"esp_log.h\"\n  #include \"driver/gpio.h\"\n  \n  // -------------- 1. 宏定义参数 --------------\n  #define USER_UART_NUM UART_NUM_1\n  #define USER_UART_BAUD 115200\n  #define UART_TX_PIN 17\n  #define UART_RX_PIN 16\n  #define UART_BUFFER_SIZE 1024\n  #define UART_QUEUE_SIZE 10\n  #define UART_TASK_STACK_SIZE 4096\n  #define UART_TASK_PRIORITY 5\n  \n  // -------------- 2. 全局变量 --------------\n  static QueueHandle_t uart_event_queue;\n  static uint8_t uart_rx_buffer[UART_BUFFER_SIZE];\n  static const char *TAG = \"UART_DEV\";\n  \n  // -------------- 3. UART 事件处理任务 --------------\n  void uart_event_task(void *arg) {\n      uart_event_t event;  // 存储 UART 事件的结构体\n  \n      while (1) {\n          // 从事件队列接收事件（超时 100ms，避免阻塞触发看门狗）\n          if (xQueueReceive(uart_event_queue, &event, pdMS_TO_TICKS(100)) == pdTRUE) {\n              switch (event.type) {\n                  // 1. 接收数据事件\n                  case UART_DATA:\n                      ESP_LOGI(TAG, \"收到数据，长度：%d 字节\", event.size);\n                      // 读取数据到缓冲区（超时 50ms，确保数据完整性）\n                      int read_len = uart_read_bytes(USER_UART_NUM, \n                                                    uart_rx_buffer, \n                                                    event.size, \n                                                    pdMS_TO_TICKS(50));\n                      if (read_len > 0) {\n                          // 示例1：回显数据（发送收到的数据）\n                          uart_write_bytes(USER_UART_NUM, uart_rx_buffer, read_len);\n                          // 示例2：打印接收的数据（十六进制）\n                          ESP_LOGI(TAG, \"接收数据（hex）：\");\n                          for (int i = 0; i < read_len; i++) {\n                              printf(\"%02X \", uart_rx_buffer[i]);\n                          }\n                          printf(\"\\n\");\n                      }\n                      break;\n  \n                  // 2. 接收缓冲区满事件\n                  case UART_BUFFER_FULL:\n                      ESP_LOGI(TAG, \"接收缓冲区满，清空缓冲区\");\n                      uart_flush_input(USER_UART_NUM);  // 清空接收缓冲区\n                      xQueueReset(uart_event_queue);    // 重置事件队列\n                      break;\n  \n                  // 3. FIFO 溢出事件（硬件缓冲区溢出）\n                  case UART_FIFO_OVF:\n                      ESP_LOGI(TAG, \"UART FIFO 溢出，清空缓冲区\");\n                      uart_flush_input(USER_UART_NUM);\n                      xQueueReset(uart_event_queue);\n                      break;\n  \n                  // 4. 帧错误事件（数据格式错误）\n                  case UART_FRAME_ERR:\n                      ESP_LOGI(TAG, \"帧错误（数据格式异常）\");\n                      break;\n  \n                  // 5. 校验错误事件（启用校验时生效）\n                  case UART_PARITY_ERR:\n                      ESP_LOGI(TAG, \"校验错误（数据校验不匹配）\");\n                      break;\n  \n                  // 其他未处理事件\n                  default:\n                      ESP_LOGI(TAG, \"未处理事件类型：%d\", event.type);\n                      break;\n              }\n          }\n      }\n  }\n  \n  // -------------- 4. 主函数初始化 --------------\n  void app_main(void) {\n      // 1. 配置 UART 硬件参数\n      uart_config_t uart_config = {\n          .baud_rate = USER_UART_BAUD,\n          .data_bits = UART_DATA_8_BITS,\n          .parity = UART_PARITY_DISABLE,\n          .stop_bits = UART_STOP_BITS_1,\n          .flow_ctrl = UART_HW_FLOWCTRL_DISABLE,\n          .source_clk = UART_SCLK_DEFAULT,\n      };\n      ESP_ERROR_CHECK(uart_param_config(USER_UART_NUM, &uart_config));\n  \n      // 2. 绑定引脚\n      ESP_ERROR_CHECK(uart_set_pin(USER_UART_NUM, \n                                  UART_TX_PIN, \n                                  UART_RX_PIN, \n                                  UART_PIN_NO_CHANGE, \n                                  UART_PIN_NO_CHANGE));\n  \n      // 3. 安装 UART 驱动并创建事件队列\n      ESP_ERROR_CHECK(uart_driver_install(USER_UART_NUM, \n                                          UART_BUFFER_SIZE * 2, \n                                          UART_BUFFER_SIZE * 2, \n                                          UART_QUEUE_SIZE, \n                                          &uart_event_queue, \n                                          0));\n  \n      // 4. 创建 UART 事件处理任务（独立任务，避免阻塞 main 任务）\n      xTaskCreate(uart_event_task,          // 任务函数\n                  \"uart_event_task\",        // 任务名称\n                  UART_TASK_STACK_SIZE,     // 栈大小\n                  NULL,                     // 任务参数\n                  UART_TASK_PRIORITY,       // 优先级\n                  NULL);                    // 任务句柄（无需则填 NULL）\n  }\n  ```\n\n#### 轮询方式（简单场景，如回显）\n\n- 适用于数据量小、交互频率低的场景，代码更简洁：\n\n  ```C\n  void app_main(void) {\n      // 1. 配置 UART 参数（同事件驱动方式）\n      uart_config_t uart_config = {\n          .baud_rate = 115200,\n          .data_bits = UART_DATA_8_BITS,\n          .parity = UART_PARITY_DISABLE,\n          .stop_bits = UART_STOP_BITS_1,\n          .flow_ctrl = UART_HW_FLOWCTRL_DISABLE,\n      };\n      ESP_ERROR_CHECK(uart_param_config(USER_UART_NUM, &uart_config));\n      ESP_ERROR_CHECK(uart_set_pin(USER_UART_NUM, 17, 16, UART_PIN_NO_CHANGE, UART_PIN_NO_CHANGE));\n      ESP_ERROR_CHECK(uart_driver_install(USER_UART_NUM, 1024, 1024, 0, NULL, 0));\n  \n      // 2. 轮询读取数据并回显\n      while (1) {\n          // 读取数据（超时 50ms，无数据则返回 0）\n          int read_len = uart_read_bytes(USER_UART_NUM, uart_rx_buffer, 1024, pdMS_TO_TICKS(50));\n          if (read_len > 0) {\n              // 回显数据\n              uart_write_bytes(USER_UART_NUM, uart_rx_buffer, read_len);\n              ESP_LOGI(TAG, \"轮询接收数据长度：%d\", read_len);\n          }\n          // 短暂延迟，释放 CPU（避免触发看门狗）\n          vTaskDelay(pdMS_TO_TICKS(10));\n      }\n  }\n  ```\n\n### 常见问题与解决方案\n\n#### 触发 Task Watchdog（任务看门狗）\n\n- **原因**：\n  1. 轮询方式中 `uart_read_bytes()` 超时过长，或无 `vTaskDelay()` 释放 CPU；\n  2. 事件驱动方式中 `xQueueReceive()` 使用 `portMAX_DELAY` 永久阻塞。\n- **解决方案**：\n  - 轮询方式：在循环中添加 `vTaskDelay(pdMS_TO_TICKS(10))`；\n  - 事件驱动方式：`xQueueReceive()` 超时设为有限值（如 `pdMS_TO_TICKS(100)`）。\n\n#### 数据接收不完整或丢失\n\n- **原因**：\n  1. 接收缓冲区过小，无法容纳单次接收的数据；\n  2. `uart_read_bytes()` 超时过短，数据未完全接收；\n  3. 波特率不匹配（发送端与接收端波特率必须一致）。\n- **解决方案**：\n  - 增大接收缓冲区（如 `UART_BUFFER_SIZE * 2`）；\n  - 延长 `uart_read_bytes()` 超时时间（如 50~100ms）；\n  - 确保发送端与 ESP32 UART 波特率、数据位、校验位完全一致。\n\n#### UART0 与串口打印冲突\n\n- **原因**：ESP32 默认将 `printf()` 映射到 UART0（引脚 TX=1，RX=3），若使用 UART0 通信会导致打印乱码。\n- **解决方案**：\n  - 优先使用 UART1 或 UART2 作为通信端口；\n  - 若必须使用 UART0，需重新映射 `printf()` 到其他 UART（需修改 ESP-IDF 配置）。\n\n## WIFI\n\n### ESP32下WIFI组件三种模式\n\n- **AP 模式**：ESP32 自身作为接入点，其他设备（如手机、电脑）可连接 ESP32 创建的 WiFi 热点，适用于 “本地设备直连 ESP32” 场景（如配置 ESP32 参数）；\n\n- **AP+STA 混合模式**：ESP32 同时作为接入点和客户端，既允许其他设备连接自身，又能接入外部路由器，适用于 “本地控制 + 远程联网” 复合场景（如智能家居设备）；\n\n- **STA 模式**：仅作为客户端，专注于接入外部网络，是 ESP32 实现联网功能的最常用模式（如传感器数据上传云端、远程控制指令接收）。\n\n### STA模式核心工作原理\n\nESP32 的 STA 模式连接 WiFi 的过程遵循 IEEE 802.11 协议，核心流程可分为 4 个阶段，各阶段依赖 ESP-IDF 提供的 WiFi 驱动接口实现：\n\n1. **初始化阶段**：\n\n   - 初始化 WiFi 组件（调用esp_wifi_init()），配置 WiFi 工作模式为 STA（通过wifi_init_config_t结构体设置mode = WIFI_MODE_STA）；\n\n   - 配置 TCP/IP 协议栈（ESP-IDF 默认自动初始化，无需手动操作，支持 DHCP 自动获取 IP 或静态 IP 配置）。\n\n2. **配置连接参数阶段**：\n\n   - 定义wifi_config_t结构体，填入目标 AP 的**SSID（WiFi 名称）** 和**Password（WiFi 密码）**，确保参数与 AP 一致（区分 SSID 大小写，密码长度需符合 AP 要求，如 WPA2-PSK 密码通常为 8-63 位）；\n\n   - 通过esp_wifi_set_config(WIFI_IF_STA, &wifi_config)将配置参数写入 ESP32 的 WiFi 接口。\n\n3. **启动与连接阶段**：\n\n   - 启动 STA 接口（esp_wifi_start()），ESP32 开始扫描周围 WiFi 信号；\n\n   - 自动匹配目标 AP 的 SSID，发起连接请求，与 AP 进行**认证（如 WPA2-PSK 认证）** 和**关联**；\n\n   - 若认证通过，ESP32 通过 DHCP 向 AP 请求 IP 地址（默认开启 DHCP 客户端），获取到 IP、子网掩码、网关后，完成 “物理连接→网络层连接” 的全流程。\n\n4. **状态监测阶段**：\n\n   - ESP32 通过**事件回调机制**（esp_event_loop_create_default()创建事件循环，esp_event_handler_instance_register()注册事件处理函数）反馈连接状态；\n\n   - 关键事件包括：WIFI_EVENT_STA_START（STA 接口启动成功）、WIFI_EVENT_STA_CONNECTED（与 AP 物理连接成功）、IP_EVENT_STA_GOT_IP（获取 IP 地址，联网完成）、WIFI_EVENT_STA_DISCONNECTED（与 AP 断开连接）。\n\n#### 实现步骤\n\n##### 重写事件处理函数（核心）\n\n```C\n/**\n * @brief WiFi事件与IP事件处理回调函数（核心逻辑）\n * @param arg：用户自定义参数，本代码未使用，传入NULL即可\n * @param event_base：事件基础类型，用于区分是WiFi相关事件（WIFI_EVENT）还是IP相关事件（IP_EVENT）\n * @param event_id：具体事件ID，标识当前触发的是该事件类型下的哪一种具体事件\n * @param event_data：事件关联的数据指针，如IP事件中可获取分配的IP地址信息\n * 功能：响应ESP32 WiFi模块的关键事件，更新连接状态、触发重连逻辑、通知外部状态变化\n */\nstatic void event_handler(void *arg, esp_event_base_t event_base,\n                          int32_t event_id, void *event_data)\n```\n\n##### 实现 STA 模式初始化函数\n\n```C\n// 引入所需头文件：自定义WiFi管理模块头文件、ESP32 WiFi驱动库、事件处理库\n// 日志打印库、FreeRTOS实时操作系统任务调度库、标准输入输出库\n#include \"wifi_manager.h\"\n#include \"esp_wifi.h\"\n#include \"esp_event.h\"\n#include \"esp_log.h\"\n#include \"nvs_flash.h\"\n#include \"freertos/FreeRTOS.h\"\n#include \"freertos/task.h\"\n#include <stdio.h>\n\n#define WIFI_SSID \"2078\"\n#define WIFI_PASSWORD \"12345678\"\n\n// 静态全局变量：WiFi状态回调函数指针，用于将WiFi连接/断开状态通知给外部调用者\n// 外部需通过wifi_manager_init函数传入自定义回调，接收WIFI_STATE_CONNECTED/WIFI_STATE_DISCONNECTED状态\nstatic p_wifi_state_cb wifi_state_cb = NULL;\n\n// 宏定义：STA模式下最大重连次数，限制重连次数避免无限循环占用CPU资源\n#define MAX_CONNECT_RETRY 10\n// 宏定义：日志标签，串口打印时用于区分该模块的日志，方便调试定位\n#define TAG \"wifi_manager\"\n\n// 静态全局变量：记录STA模式当前的重连尝试次数，初始值为0，每次重连失败自增1\nstatic int sta_connect_cnt = 0; // 重连次数\n\n// 静态全局变量：标记STA模式是否已成功连接到目标AP，true表示已连接，false表示未连接/已断开\nstatic bool is_sta_connected = false;\n\n/**\n * @brief WiFi事件与IP事件处理回调函数（核心逻辑）\n * @param arg：用户自定义参数，本代码未使用，传入NULL即可\n * @param event_base：事件基础类型，用于区分是WiFi相关事件（WIFI_EVENT）还是IP相关事件（IP_EVENT）\n * @param event_id：具体事件ID，标识当前触发的是该事件类型下的哪一种具体事件\n * @param event_data：事件关联的数据指针，如IP事件中可获取分配的IP地址信息\n * 功能：响应ESP32 WiFi模块的关键事件，更新连接状态、触发重连逻辑、通知外部状态变化\n */\nstatic void event_handler(void *arg, esp_event_base_t event_base,\n                          int32_t event_id, void *event_data)\n{\n    // 判断事件类型为WiFi相关事件（WIFI_EVENT）\n    if (event_base == WIFI_EVENT)\n    {\n        // 根据具体事件ID处理不同场景\n        switch (event_id)\n        {\n        // 事件：STA接口启动成功（调用esp_wifi_start()后触发此事件）\n        case WIFI_EVENT_STA_START:\n            // 启动成功后，主动调用esp_wifi_connect()发起WiFi连接请求\n            esp_wifi_connect();\n            break;\n\n        // 事件：STA与已连接的AP断开连接（如信号弱、密码错误、路由器重启等）\n        case WIFI_EVENT_STA_DISCONNECTED:\n            // 若之前处于已连接状态，先更新连接状态并通知外部\n            if (is_sta_connected)\n            {\n                is_sta_connected = false; // 将连接状态标记为未连接\n                if (wifi_state_cb)        // 若外部注册了回调函数，触发\"断开连接\"状态通知\n                    wifi_state_cb(WIFI_STATE_DISCONNECTED);\n            }\n\n            // 检查当前重连次数是否小于最大重连次数，若未达到则继续重试\n            if (sta_connect_cnt < MAX_CONNECT_RETRY)\n            {\n                sta_connect_cnt++;  // 重连次数自增1\n                esp_wifi_connect(); // 发起新一轮连接请求\n            }\n            // 若已达到最大重连次数，不再重试（避免无限重连）\n            wifi_state_cb(WIFI_STATE_DISCONNECTED);\n            break;\n\n        // 其他未定义的WiFi事件，暂不处理，直接break\n        default:\n            break;\n        }\n    }\n    // 判断事件类型为IP相关事件（IP_EVENT）\n    else if (event_base == IP_EVENT)\n    {\n        // 事件：STA成功从DHCP服务器获取到IP地址（标志网络层连接完成）\n        if (event_id == IP_EVENT_STA_GOT_IP)\n        {\n            // 打印日志提示已获取IP地址，便于调试确认\n            ESP_LOGI(TAG, \"Got IP address\");\n            sta_connect_cnt = 0;     // 重置重连次数\n            is_sta_connected = true; // 将连接状态标记为已连接\n            if (wifi_state_cb)       // 若外部注册了回调函数，触发\"连接成功\"状态通知\n                wifi_state_cb(WIFI_STATE_CONNECTED);\n        }\n    }\n}\n\n/**\n * @brief WiFi管理器初始化函数（STA模式初始化入口）\n * @param f：外部传入的WiFi状态回调函数，用于接收连接/断开状态通知\n * 功能：初始化ESP32网络接口、事件循环、WiFi驱动，配置STA模式并启动WiFi模块\n * 注意：使用WiFi功能前必须先调用此函数完成初始化，建议在app_main()中优先执行\n */\nvoid wifi_manager_init(p_wifi_state_cb f)\n{\n    // 1. 初始化NVS（ESP32存储WiFi配置的依赖组件，必须先初始化）\n    esp_err_t ret = nvs_flash_init();\n    if (ret == ESP_ERR_NVS_NO_FREE_PAGES || ret == ESP_ERR_NVS_NEW_VERSION_FOUND)\n    {\n        ESP_ERROR_CHECK(nvs_flash_erase()); // 若NVS有问题，先擦除再初始化\n        ret = nvs_flash_init();\n    }\n\n    // 2. 初始化ESP32网络接口（TCP/IP协议栈初始化，必须在WiFi初始化前执行）\n    ESP_ERROR_CHECK(esp_netif_init());\n\n    // 3. 创建默认的事件循环（用于处理WiFi和IP事件）\n    ESP_ERROR_CHECK(esp_event_loop_create_default());\n    esp_netif_create_default_wifi_sta(); // 使用默认的STA模式网络接口\n\n    // 4. 初始化WiFi驱动：使用WIFI_INIT_CONFIG_DEFAULT()获取默认配置（包含时钟、中断等参数）\n    wifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT();\n    ESP_ERROR_CHECK(esp_wifi_init(&cfg)); // 执行WiFi驱动初始化，若失败则触发错误检查\n\n    // 5. 注册事件处理函数：监听WiFi事件和IP事件\n    // 5.1注册WiFi事件监听器：监听所有WiFi事件（ESP_EVENT_ANY_ID），触发时调用event_handler处理\n    ESP_ERROR_CHECK(esp_event_handler_instance_register(WIFI_EVENT,\n                                                        ESP_EVENT_ANY_ID,\n                                                        &event_handler,\n                                                        NULL,\n                                                        NULL));\n    // 5.2注册IP事件监听器：仅监听\"STA获取IP\"事件（IP_EVENT_STA_GOT_IP）\n    ESP_ERROR_CHECK(esp_event_handler_instance_register(IP_EVENT,\n                                                        IP_EVENT_STA_GOT_IP,\n                                                        &event_handler,\n                                                        NULL,\n                                                        NULL));\n\n    // 6. 保存外部传入的状态回调函数，后续状态变化时通过此函数通知外部\n    wifi_state_cb = f;\n\n    wifi_config_t wifi_config = {\n        .sta = {\n            // 配置STA的认证模式为WPA2-PSK（主流家用/工业路由器默认加密方式）\n            .threshold.authmode = WIFI_AUTH_WPA2_PSK,\n            .ssid = WIFI_SSID,\n            .password = WIFI_PASSWORD,\n        },\n    };\n\n    // 7. 配置WiFi工作模式为纯STA模式（仅作为客户端连接外部AP，不开启AP模式）\n    ESP_ERROR_CHECK(esp_wifi_set_mode(WIFI_MODE_STA));\n    ESP_ERROR_CHECK(esp_wifi_set_config(WIFI_IF_STA, &wifi_config)); // 写入配置\n    // 8. 启动WiFi模块（启动后会触发WIFI_EVENT_STA_START事件，进而发起连接）\n    ESP_ERROR_CHECK(esp_wifi_start());\n    ESP_LOGI(TAG, \"STA initialization done\");\n}\n\n```\n\n\n\n\n\n\n\n","source":"_posts/ESP32学习.md","raw":"---\ntitle: ESP32学习\ndate: 2025-09-09 11:04:10\ncover: \"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091106486.jpg\"\ntags:\n  - ESP32\n  - RTOS\ncategories: MCU\n---\n\n## ESP32环境搭建\n\n### WSL2安装与配置\n\n推荐查阅官方文档说明：[安装 WSL | Microsoft Learn](https://learn.microsoft.com/zh-cn/windows/wsl/install)\n\n#### 手动下载安装包\n\n1. 访问 WSL 的 GitHub Releases 页面 https://github.com/microsoft/WSL/releases\n\n2. 查找并下载最新版本的 .msi 安装包（例如 wsl.2.1.5.0.x64.msi）\n\n![image-20250909111242531](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091112594.png)\n\n#### 配置控制面板\n\n![image-20250909111552848](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091115919.png)\n\n![image-20250909111621317](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091116357.png)\n\n> 有些Windows 11新系统会没有`虚拟机平台`这个选项 没有关系！！！！\n>\n> 配置完后重新启动电脑\n\n#### 管理员身份运行Windows PowerShell\n\n![img](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091108898.png)\n\n#### 安装Ubuntu\n\n```bash\nwsl --install\n```\n\n![img](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091108464.png)\n\n> 如有可选 则选择Uuntu 如 `wsl --install -d Ubuntu`\n\n#### 等待安装完成后重启电脑打开Ubuntu\n\n![image-20250909112101810](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091121963.png)\n\n#### 输入账号密码\n\n![img](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091121306.png)\n\n#### 更新软件源\n\n```bash\nsudo apt update\n```\n\n![img](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091124279.png)\n\n#### 更新完后输入下方指令，下载espidf依赖库和工具\n\n> ```bash\n> sudo apt-get install git wget flex bison gperf python3 python3-pip python3-venv cmake ninja-build ccache libffi-dev libssl-dev dfu-util libusb-1.0-0\n> ```\n\n![img](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091126525.png)\n\n#### 输入y\n\n![image-20250909112720315](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091127364.png)\n\n### VScode配置\n\n#### 选择连接到WSL\n\n![img](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091129218.png)\n\n#### 插件安装\n\n> - 安装`Chinese`插件\n> - 安装`C/C++`插件\n> - 安装`ESP-IDF`插件\n\n#### 在linux账户新建文件用于存放espidf内容，方便后续管理\n\n![image-20250909113527188](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091135250.png)\n\n#### ESP-IDF安装\n\n![img](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091131190.png)\n\n#### 在安装路径中选择自己新建的文件夹\n\n![img](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091135132.png)\n\n> 如果出现下图这个情况\n>\n> ![img](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091137839.png)\n>\n> 那就运行一下下面的指令 \n>\n> ```bash\n> sudo chown -R $USER:$USER /home/你的用户名/你的IDF文件名/\n> chmod -R 755 /home/你的用户名/你的IDF文件名/\n> ```\n\n#### 安装完成之后先搞个工程测试一下编译能不能正常\n\n![img](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091140479.png)\n\n#### 选择文件夹来存放代码\n\n![img](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091143918.png)\n\n![img](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091143292.png)\n\n#### 设置环境\n\n##### 设置IDF_tools环境（豆包四条命令搞定）\n\n> 注意下方命令中：\n>\n> `~/ESP_IDF/v5.5.1/esp-idf`：你的IDF文件夹路径 要一直引入到`esp-idf`\n>\n> `~/ESP_IDF/Tools`：你的IDF_Tools文件夹路径\n\n```bash\necho 'export IDF_PATH=~/ESP_IDF/v5.5.1/esp-idf' >> ~/.bashrc\necho 'export IDF_TOOLS_PATH=~/ESP_IDF/Tools' >> ~/.bashrc\necho 'source ~/ESP_IDF/v5.5.1/esp-idf/export.sh' >> ~/.bashrc\nsource ~/.bashrc  # 立即生效\n```\n\n> 成功的话 重启`vscode`就会自动出现`idf`的命令\n>\n> ![image-20250909221836025](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509092218229.png)\n\n##### 若上面还不行 则根据报错情况执行下面\n\n###### 场景 1：运行 `./export.sh` 时报 “Python 虚拟环境不存在”\n\n`报错信息`\n\n```bash\nERROR: ESP-IDF Python virtual environment \"$HOME/ESP_IDF/Tools/python_env/idf5.5_py3.12_env/bin/python\" not found. Please run the install script to set it up before proceeding.\n```\n\n`原因`\n\n未执行 ESP-IDF 安装脚本，Python 虚拟环境未创建。\n\n`解决方案`\n\n必须先运行安装脚本，自动创建虚拟环境和安装依赖：\n\n```bash\n# 进入 ESP-IDF 根目录（替换为你的实际路径）\ncd ~/ESP_IDF/v5.5.1/esp-idf\n# 执行安装脚本（Linux/macOS 用 install.sh，Windows 用 install.bat）\n./install.sh\n# 安装完成后再执行 export.sh 导出环境\n. ./export.sh\n```\n\n###### 场景 2：运行 `./install.sh` 时 “下载工具包卡住”\n\n`报错表现`\n\n安装过程中卡在某一工具包下载（如 `riscv32-esp-elf-gdb`），进度条不动或反复重试。\n\n`原因`\n\nESP-IDF 工具包托管在 GitHub，国内网络访问速度慢或不稳定，导致下载中断。\n\n1. **用国内镜像加速（推荐）**\n   配置 `IDF_GITHUB_ASSETS` 环境变量，将下载源切换为 Espressif 国内镜像，无需手动下载：\n\n   ```bash\n   # 临时生效，每次打开终端需重新执行（或写入 shell 配置文件）\n   export IDF_GITHUB_ASSETS=\"dl.espressif.com/github_assets\"\n   # 重新运行安装脚本\n   ./install.sh\n   ```\n\n#### 烧录文件\n\n##### 下载wsl-usb-manager.exe\n\n> <a href=\"https://mextra.netlify.app/download/ESP32/wsl-usb-manager.exe\">wsl-usb-manager.exe </a>\n\n##### 插上ESP32S3\n\n![059f326e4709ef71f539677c5da784c2](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091454477.jpg)\n\n##### 配置WSL USB\n\n###### 管理员身份打开Windows PowerShell\n\n> 输入`winget install usbipd`，然后输入`y`（`看情况选择开不开魔法`，不开也能20s左右下载安装完）\n\n这个指令是安装usbipd-win工具，用于将windows系统的usb设备共享给wsl环境。\n\n![img](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509092343890.png)\n\n安装好之后 更改权限\n\n> - 输入`sudo usermod -aG dialout 你的用户名`\n>\n> - 然后`重启电脑`\n> - 输入`groups`验证一下\n>   - 如果输出中包含 `dialout` 或 `uucp`，则表示设置成功，之后就可以正常访问串口了。\n\n##### 进入WSL USB选择端口并烧录\n\n![image-20250909145724459](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091457549.png)\n\n![image-20250909150034639](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091500732.png)\n\n以上环境参考：[（二）vscode搭建espidf环境，配置wsl2_wsl 编译idf项目-CSDN博客](https://blog.csdn.net/QL_SD/article/details/150216599?spm=1001.2014.3001.5502)\n\n感谢[QL.ql](https://blog.csdn.net/QL_SD)大博主\n\n## ESP32基础知识\n\n![image-20250909173749995](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091737219.png)\n\n![image-20250909173836126](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091738212.png)\n\n### 使用命令行创建工程\n\n```bash\nidf.py create-project 工程名\n```\n\n#### 打开vscode 切换到新建的工程\n\n```bash\ncd ~/ESP_Code/刚刚的工程名\ncode .\n\n按`ctrl+shift+p` 寻找add 添加idf路径\n```\n\n> 在写代码时候 如果出现宏没定义 则重新设置一下芯片型号 稍等一会就会出现\n>\n> ![image-20250910100948617](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509101009919.png)\n>\n> ![image-20250910102600612](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509101026730.png)\n>\n> 如果想要删除文件夹 则运行以下命令\n>\n> ```bash\n> cd ..\n> rm -rf 文件夹\n> ```\n>\n> 必备头文件\n>\n> ```C\n> #include \"freertos/FreeRTOS.h\"\n> #include \"freertos/task.h\"\n> #include \"esp_log.h\"\n> ```\n>\n\n### CMakeList.txt使用说明\n\n一般CmakeList.txt呈现下面的结构\n\n```C\nmain\n    main.c\n    CMakeList.txt\nCMakeList.txt\n```\n\n#### 创建自定义文件夹\n\n> 如\n>\n> ```C\n> components\n>     led\n>     \tled.c\n>     \tled.h\n>     \tCMakeList.txt\n> main\n>     main.c\n>     CMakeList.txt\n> ```\n>\n> 在这个目录下 则`components/led`文件夹下的`CMakeList.txt`，可以这么写\n>\n> ```cmake\n> idf_component_register(SRCS \"led.c\"\n>                     INCLUDE_DIRS \".\"\n>                     REQUIRES esp_driver_gpio\n>                     )\n> ```\n>\n> - `SRCS`：`.c`文件 多个用空格隔开\n>\n> - `INCLUDE_DIRS`：文件名 多个同样用空格隔开\n>\n> - `REQUIRES`：引入ESP官方的组件库`components` ，名字为官方`idf`下的`components`文件夹下的文件夹名 如此处的`esp_driver_gpio`\n>\n>   ![image-20250912184005520](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509121840992.png)\n>\n> 而若要引用 则`main`文件夹下的`CMakeList.txt` 可以这么写\n>\n> ```cmake\n> idf_component_register(SRCS \"main.c\" \"../components/led/led.c\"\n>                     INCLUDE_DIRS \".\" \"../components\")\n> ```\n\n### FreeRTOS-ESP32 基础API\n\n#### 任务创建\n\n```C\nBaseType_t xTaskCreatePinnedToCore(\n\tTaskFunction_t pvTaskCode,\t\t\t\t//任务函数指针，原型是voidfun(void*param)\n\tconst char *constpcName,\t\t\t\t//任务的名称，打印调试可能会有用\n\tconst uint32_t usStackDepth,\t\t\t//指定的任务堆栈空间大小（字节）\n\tvoid *constpvParameters,\t\t\t\t//任务参数\n\tUBaseType_t uxPriority,\t\t\t\t\t//优先级，数字越大，优先级越大，0到(configMAX_PRIORITIES-1) 即0-24\n\tTaskHandle_t *constpvCreatedTask,\t\t //传回来的任务句柄\n\tconst BaseType_t xCoreID)\t\t\t\t//分配在哪个内核上运行 ESP32是双核 所以可以选0或1\n```\n\n> ESP32的任务堆栈空间大小`usStackDepth`与原生FreeRTOS不一样\n>\n> - 原生FreeRTOS的任务堆栈空间大小单位是`字`，即目标平台若是32位 则为4个字节\n> - ESP32的任务堆栈空间大小单位是`字节`，最小是`2048`\n\n#### 阻塞函数（少用 可替代）\n\n```C\n//粗略延时xTicksToDelay个周期 \n//使用该函数后 任务进入阻塞 等延时结束且调度到来才会再次运行\nvoid vTaskDelay(const TickType_t xTicksToDelay)\t\n\n//用于表示精确的解除阻塞时间    \n//即使任务的执行时间超过了周期时间，它也能自动调整延迟时间，保证任务的周期性运行\nvoid vTaskDelayUntil(TickType_t *pxPreviousWakeTime,const TickType_t xTimeIncrement)\n\n```\n\n#### 打印调试\n\n```C\n#include <stdio.h>\n#include \"freertos/FreeRTOS.h\"\n#include \"freertos/task.h\"\n#include \"esp_log.h\"\nvoid taskA(void *param)\n{\n    while (1)\n    {\n        ESP_LOGI(\"TaskA\", \"Hello from Task A%d\", 1);//前面是一个TAG标签，后面是打印内容 他会自动回车换行\n        vTaskDelay(pdMS_TO_TICKS(500));\n    }\n}\n\nvoid app_main(void)\n{\n    xTaskCreatePinnedToCore(taskA, \"TaskA\", 2048, NULL, 5, NULL, 1);\n}\n\t\n```\n\n效果如图\n\n![image-20250910101607354](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509101016442.png)\n\n#### 队列\n\n> 队列特性：先进先出\n\n```C\nQueueHandle_t queue_handle = NULL; // 创建队列句柄\n\n/**\n * @brief 创建一个队列\n * @param uxQueueLength 队列长度\n * @param uxItemSize 每个元素的大小(单位是字节)\n */\nQueueHandle_t xQueueCreate(UBaseType_t uxQueueLength, UBaseType_t uxItemSize);\n\n/**\n * @brief 向队列头部发送数据\n * @param xQueue 队列句柄\n * @param pvItemToQueue 要发送的数据的指针\n * @param xTicksToWait 等待的时间(单位是tick)\n * @return 如果在等待时间内发送成功返回pdTRUE，否则返回errQUEUE_FULL\n */\nBaseType_t xQueueSend(QueueHandle_t xQueue, const void *pvItemToQueue, TickType_t xTicksToWait);\n\n/**\n * @brief 向队列尾部发送数据（新数据放在队尾）\n * @param xQueue 队列句柄\n * @param pvItemToQueue 要发送的数据的指针\n * @param xTicksToWait 等待的时间\n * @return pdTRUE 如果发送成功\n *         errQUEUE_FULL 如果队列已满，发送失败\n */\nBaseType_t xQueueSendToBack(QueueHandle_t xQueue, const void *pvItemToQueue, TickType_t xTicksToWait);\n\n/**\n * @brief 从队列中接收数据\n * @param xQueue 队列句柄\n * @param pvBuffer 用于存储接收数据的缓冲区\n * @param xTicksToWait 等待数据的最大时间，以系统节拍为单位\n * @return pdPASS 表示接收成功，errQUEUE_EMPTY 表示队列为空且等待超时，接收失败。\n */\nBaseType_t xQueueReceive(QueueHandle_t xQueue, void *pvBuffer, TickType_t xTicksToWait);\n\n/**\n * @brief 该函数在中断中使用，从队列发送数据 这个函数的行为和普通的 xQueueSend 有差异，且不允许阻塞（等待）\n * @param xQueue 队列句柄\n * @param pvItemToQueue 要发送的数据\n * @param pxHigherPriorityTaskWoken 如果发送数据后，有更高优先级的任务被唤醒，则该参数会被置为pdTRUE\n * @return 如果发送成功，返回pdTRUE，否则返回errQUEUE_FULL\n */\nBaseType_t xQueueSendFromISR(QueueHandle_t xQueue, const void *pvItemToQueue, BaseType_t *pxHigherPriorityTaskWoken);\n```\n\n##### 调用示例\n\n```C\n#include <stdio.h>\n#include <string.h>\n#include \"freertos/FreeRTOS.h\"\n#include \"freertos/task.h\"\n#include \"freertos/queue.h\"\n#include \"esp_log.h\"\n\nQueueHandle_t queue_handle = NULL; // 定义一个队列句柄\n\ntypedef struct\n{\n    int value;\n} queue_date_t;\n\nvoid taskA(void *param)\n{\n    // 从队列里面接收数据，并打印\n    queue_date_t data;\n    while (1)\n    {\n        if (xQueueReceive(queue_handle, &data, 100) == pdTRUE) // 从队列中接收数据，阻塞等待\n        {\n            ESP_LOGI(\"re_queue\", \"receive queue value:%d\", data.value); // 前面是一个TAG标签，后面是打印内容 他会自动回车换行\n        }\n    }\n}\n\nvoid taskB(void *param)\n{\n    queue_date_t data;\n    memset(&data, 0, sizeof(data));\n    // 每隔1s向队列里面发送数据\n    while (1)\n    {\n        xQueueSendToBack(queue_handle, &data, 100); // 向队列中发送数据，阻塞等待\n        vTaskDelay(pdMS_TO_TICKS(1000));            // 延时1s\n        data.value++;\n    }\n}\n\nvoid app_main(void)\n{\n    queue_handle = xQueueCreate(10, sizeof(queue_date_t)); // 创建一个队列，队列长度为10，每个元素的大小为queue_date_t结构体的大小\n    xTaskCreatePinnedToCore(taskA, \"re_queue\", 2048, NULL, 3, NULL, 1);\n    xTaskCreatePinnedToCore(taskB, \"se_queue\", 2048, NULL, 3, NULL, 1);\n}\n```\n\n> ![image-20250910110704875](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509101107988.png)\n\n#### 信号量\n\n```C\n/**\n * @brief 创建一个二值信号量\n * @return SemaphoreHandle_t 信号量句柄\n */\nSemaphoreHandle_t xSemaphoreCreateBinary(void);\n\n/**\n * @brief 创建一个计数信号量\n * @param uxMaxCount 计数信号量的最大值\n * @param uxInitialCount 计数信号量的初始值\n * \n */\nSemaphoreHandle_t xSemaphoreCreateCounting(UBaseType_t uxMaxCount, UBaseType_t uxInitialCount);\n\n/**\n * @brief 创建一个互斥锁\n * @return SemaphoreHandle_t 互斥锁句柄\n */\nSemaphoreHandle_t xSemaphoreCreateMutex(void);\n\n/**\n * @brief 取得一个信号量\n * @param xSemaphore 信号量句柄\n * @param xTicksToWait 等待信号量的时间，单位为ticks\n * @return 如果成功取得信号量则返回pdTRUE，否则返回pdFALSE\n */\nBaseType_t xSemaphoreTake(SemaphoreHandle_t xSemaphore, TickType_t xTicksToWait);\n\n/**\n * @brief 释放一个信号量\n * @param xSemaphore 信号量句柄\n * @return 如果成功释放信号量则返回pdTRUE，否则返回pdFALSE\n */\nBaseType_t xSemaphoreGive(SemaphoreHandle_t xSemaphore);\n\n/**\n * @brief 删除一个信号量\n * @param xSemaphore 要删除的信号量句柄\n */\nvoid vSemaphoreDelete(SemaphoreHandle_t xSemaphore);\n```\n\n##### 调用示例\n\n```C\n#include <string.h>\n#include \"freertos/FreeRTOS.h\"\n#include \"freertos/task.h\"\n#include \"freertos/queue.h\"\n#include \"freertos/semphr.h\"\n#include \"esp_log.h\"\n\nSemaphoreHandle_t mutex_handle;\n\nvoid taskA(void *param)\n{\n    while (1)\n    {\n        vTaskDelay(pdMS_TO_TICKS(1000));\n        xSemaphoreTake(mutex_handle, portMAX_DELAY);\n        ESP_LOGI(\"TASK_A\", \"Task A is running\");\n\n        xSemaphoreGive(mutex_handle);\n        vTaskDelay(pdMS_TO_TICKS(10)); // 给其他任务机会\n    }\n}\n\nvoid taskB(void *param)\n{\n    while (1)\n    {\n        vTaskDelay(pdMS_TO_TICKS(500));\n        xSemaphoreTake(mutex_handle, portMAX_DELAY);\n        ESP_LOGI(\"TASK_B\", \"Task B is running\");\n\n        xSemaphoreGive(mutex_handle);\n        vTaskDelay(pdMS_TO_TICKS(10)); // 给其他任务机会\n    }\n}\n\nvoid app_main(void)\n{\n    mutex_handle = xSemaphoreCreateMutex();\n    xTaskCreatePinnedToCore(taskA, \"taskA\", 2048, NULL, 6, NULL, 1);\n    xTaskCreatePinnedToCore(taskB, \"taskB\", 2048, NULL, 4, NULL, 1);\n}\n```\n\n> 注意释放信号量的时候 一般会给个延时 不加的话任务会马上回到`while(1)`初始的时候 反应出来的现象就是一直是A任务运行\n>\n> 原因：RTOS任务调度需要时间 并且最少只能是10ms 已测试\n\n#### 事件组\n\n```C\n/**\n * @brief 创建事件组\n * @return EventGroupHandle_t 事件组句柄\n */\nEventGroupHandle_t xEventGroupCreate(void);\n\n/**\n * @brief 设置事件位\n * @param xEventGroup 事件组句柄\n * @param uxBitsToSet 要设置的事件位\n * @return 设置后事件组的值\n */\nEventBits_t xEventGroupSetBits(EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet);\n\n/**\n * @brief 事件组等待位函数\n * @param xEventGroup 事件组句柄\n * @param uxBitsToWaitFor 等待的事件位\n * @param xClearOnExit 退出时是否清除事件位 pdTRUE or pdFALSE\n * @param xWaitForAllBits 是否等待所有位 pdTRUE or pdFALSE\n * @param xTicksToWait 等待的最大时间\n * @return 返回实际获得的事件位\n */\nEventBits_t xEventGroupWaitBits(const EventGroupHandle_t xEventGroup,\n                                const EventBits_t uxBitsToWaitFor,\n                                const BaseType_t xClearOnExit,\n                                const BaseType_t xWaitForAllBits,\n                                TickType_t xTicksToWait);\n\n\n/**\n * @brief 清除事件组指定事件位\n * @param xEventGroup 事件组句柄\n * @param uxBitsToClear 要清除的事件位\n * @return 清除前的事件组位值\n */\nEventBits_t xEventGroupClearBits(EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear);\n\n/* 以下使用消息直达机制*/\n\n/**\n * @brief 任务通知函数\n * @param xTaskToNotify 任务句柄\n * @param ulValue 发送的值\n * @param eAction 发送的动作 \n *                eNoAction 不改变任务的通知值(即不更新 会一直发送初始值)\n *                eSetBits 将ulValue的值按位或 到任务的通知值中 \n *                eIncrement 将任务的通知值加1\n *                eSetValueWithOverwrite 将任务的通知值设置为ulValue\n *                eSetValueWithoutOverwrite 如果任务的通知值为0，则将其设置为ulValue，否则不改变任务的通知值\n * @return 如果通知成功返回pdPASS，否则返回errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY\n */\nBaseType_t xTaskNotify(TaskHandle_t xTaskToNotify,\n                       uint32_t ulValue,\n                       eNotifyAction eAction);\n\n/**\n * @brief 将任务设置为等待接收通知\n * @param ulBitsToClearOnEntry 进入等待前要清除的位\n * @param ulBitsToClearOnExit 退出等待后要清除的位\n * @param pulNotificationValue 指向接收通知值的指针\n * @param xTicksToWait 等待通知的最大时间（以滴答为单位）\n * @return 如果在指定的等待时间内收到通知，则返回pdTRUE；否则返回\n */\nBaseType_t xTaskNotifyWait(uint32_t ulBitsToClearOnEntry,\n                           uint32_t ulBitsToClearOnExit,\n                           uint32_t *pulNotificationValue,\n                           TickType_t xTicksToWait);\n```\n\n##### 调用示例\n\n###### 事件组设置\n\n```C\n#include <string.h>\n#include \"freertos/FreeRTOS.h\"\n#include \"freertos/task.h\"\n#include \"freertos/queue.h\"\n#include \"freertos/semphr.h\"\n#include \"freertos/event_groups.h\"\n#include \"esp_log.h\"\n\n#define EVENT_BIT_0 BIT0\n#define EVENT_BIT_1 BIT1\n\nEventGroupHandle_t event_handle;\n\nvoid taskA(void *param)\n{\n    // 定时1s向任务B发送事件消息\n    while (1)\n    {\n        xEventGroupSetBits(event_handle, EVENT_BIT_0);\n        vTaskDelay(pdMS_TO_TICKS(1000));\n        xEventGroupSetBits(event_handle, EVENT_BIT_1);\n        vTaskDelay(pdMS_TO_TICKS(1000));\n    }\n}\n\nvoid taskB(void *param)\n{\n    EventBits_t ev;\n    while (1)\n    {\n        ev = xEventGroupWaitBits(event_handle, EVENT_BIT_0 | EVENT_BIT_1, pdTRUE, pdFALSE, pdMS_TO_TICKS(5000));\n        if (ev & EVENT_BIT_0)\n        {\n            ESP_LOGI(\"ev\", \"ev get event0\");\n        }\n        if (ev & EVENT_BIT_1)\n        {\n            ESP_LOGI(\"ev\", \"ev get event1\");\n        }\n    }\n}\n\nvoid app_main(void)\n{\n    event_handle = xEventGroupCreate();\n    xTaskCreatePinnedToCore(taskA, \"taskA\", 2048, NULL, 3, NULL, 1);\n    xTaskCreatePinnedToCore(taskB, \"taskB\", 2048, NULL, 3, NULL, 1);\n}\n```\n\n###### 消息直达\n\n```C\n#include <string.h>\n#include \"freertos/FreeRTOS.h\"\n#include \"freertos/task.h\"\n#include \"freertos/queue.h\"\n#include \"freertos/semphr.h\"\n#include \"freertos/event_groups.h\"\n#include \"esp_log.h\"\n\nstatic TaskHandle_t taskA_handle;\nstatic TaskHandle_t taskB_handle;\n\nvoid taskA(void *param)\n{\n    // 定时1s向任务B发送事件消息\n    uint32_t count = 0;\n    vTaskDelay(pdMS_TO_TICKS(100));\n    while (1)\n    {\n        xTaskNotify(taskB_handle, count, eSetValueWithoutOverwrite);\n        count++;\n        vTaskDelay(pdMS_TO_TICKS(1000));\n    }\n}\n\nvoid taskB(void *param)\n{\n    uint32_t count = 0;\n    while (1)\n    {\n        xTaskNotifyWait(0, 0, &count, portMAX_DELAY);\n        ESP_LOGI(\"taskB\", \"Notify count: %lu\", count);\n    }\n}\n\nvoid app_main(void)\n{\n    xTaskCreatePinnedToCore(taskA, \"taskA\", 2048, NULL, 3, &taskA_handle, 1);\n    xTaskCreatePinnedToCore(taskB, \"taskB\", 2048, NULL, 3, &taskB_handle, 1);\n}\n```\n\n#### ESP-IDF中的FreeRTOS与原生区别\n\n> 1. ESP32是多核的 所以可以完全实现程序并发执行 即不是单核那种 低优先级的任务因为高优先级任务存在而执行不了\n> 2. esp-idf自动创建五个任务\n>    - 空闲任务（每个核都会创建一个，`优先级为0`）\n>    - FreeRTOS定时器任务（`优先级为1`）\n>    - app_main任务（我们的应用入口，`优先级为1`）\n>    - IPC任务（每个核创建一个，用于多核协调，`优先级为24`）\n>    - ESP定时器任务（负责ESP32定时器回调，`优先级为22`）\n> 3. esp-idf不使用原生FreeRTOS的内存堆管理，实现了自己的堆\n> 4. 创建任务使用`xTaskCreatePinnedToCore()` 可以指定用哪个核创建任务\n>    - 负责处理`无线网络的任务（如WiFi蓝牙）`将被固定到`CPU0`，即`PRO_CPU`\n>    - 处理`应用程序`其余部分任务将被固定到`CPU1`，即`APP_CPU`\n> 5. 如果任务中用到浮点运算，则创建任务的时候必须指定具体运行在哪个核上，不能由系统自动安排\n\n## GPIO配置\n\n### 引脚基础配置\n\n#### `gpio_config()`：批量配置 GPIO（核心入口）\n\n- **函数原型**\n\n  ```c\n  esp_err_t gpio_config(const gpio_config_t *pGPIOConfig);\n  ```\n\n- **作用**：一次性配置一组 GPIO 的模式、上下拉、中断类型（覆盖该引脚当前所有配置）。\n\n- **参数**：`pGPIOConfig`：指向 `gpio_config_t` 结构体的指针（需提前初始化）。\n\n- **返回值**：`ESP_OK`（成功）、`ESP_ERR_INVALID_ARG`（参数错误，如引脚无效）。\n\n- **示例**：配置 GPIO2、GPIO3 为输出模式，禁用上下拉和中断：\n\n  ```c\n  gpio_config_t io_conf = {\n      .pin_bit_mask = (1ULL << GPIO_NUM_2) | (1ULL << GPIO_NUM_3),  // 仅配置 GPIO2\n      .mode = GPIO_MODE_OUTPUT,\n      .pull_up_en = GPIO_PULLUP_DISABLE,\n      .pull_down_en = GPIO_PULLDOWN_DISABLE,\n      .intr_type = GPIO_INTR_DISABLE\n  };\n  gpio_config(&io_conf);  // 执行配置\n  ```\n\n> `intr_type` :\n>\n> - `GPIO_INTR_DISABLE`：禁用中断\n> -  `GPIO_INTR_POSEDGE`：上升沿触发\n> - `GPIO_INTR_NEGEDGE`：下降沿触发\n> - `GPIO_INTR_ANYEDGE`：双边沿触发\n> - `GPIO_INTR_LOW_LEVEL`：低电平触发\n> - `GPIO_INTR_HIGH_LEVEL`：高电平触发\n\n#### `gpio_reset_pin()`：重置引脚为默认状态\n\n- **函数原型**\n\n  ```c\n  esp_err_t gpio_reset_pin(gpio_num_t gpio_num);\n  ```\n\n- **作用**：将指定 GPIO 重置为默认状态（输入模式、禁用上下拉、禁用中断、选择 GPIO 功能）。\n\n- **参数**：`gpio_num`：要重置的 GPIO 编号（如 `GPIO_NUM_4`）。\n\n- **示例**：重置 GPIO4，恢复初始状态：\n\n  ```c\n  gpio_reset_pin(GPIO_NUM_4);\n  ```\n\n#### `gpio_set_direction()`：单独设置引脚方向\n\n- **函数原型**\n\n  ```c\n  esp_err_t gpio_set_direction(gpio_num_t gpio_num, gpio_mode_t mode);\n  ```\n\n- **作用**：单独修改某个 GPIO 的模式（输入 / 输出 / 输入输出），覆盖当前模式。\n\n- **参数**\n\n  - `gpio_num`：目标 GPIO 编号。\n  - `mode`：目标模式（如 `GPIO_MODE_INPUT`）。\n\n- **示例**：将已配置的 GPIO2 改为输入模式\n\n  ```c\n  gpio_set_direction(GPIO_NUM_2, GPIO_MODE_INPUT);\n  ```\n\n#### 配置上下拉函数（`gpio_pullup_en`/`gpio_pulldown_en`）\n\n- **函数原型**\n\n  ```c\n  esp_err_t gpio_pullup_en(gpio_num_t gpio_num);    // 启用上拉\n  esp_err_t gpio_pullup_dis(gpio_num_t gpio_num);   // 禁用上拉\n  esp_err_t gpio_pulldown_en(gpio_num_t gpio_num);  // 启用下拉\n  esp_err_t gpio_pulldown_dis(gpio_num_t gpio_num); // 禁用下拉\n  ```\n\n- **作用**：比 `gpio_set_pull_mode` 更直观，单独控制上拉 / 下拉的启用 / 禁用。\n\n- **示例**：启用 GPIO0 下拉，禁用上拉：\n\n  ```c\n  gpio_pulldown_en(GPIO_NUM_0);\n  gpio_pullup_dis(GPIO_NUM_0);\n  ```\n\n### 引脚电平控制函数\n\n#### `gpio_set_level()`：设置输出电平\n\n- **函数原型**\n\n  ```c\n  esp_err_t gpio_set_level(gpio_num_t gpio_num, uint32_t level);\n  ```\n\n- **作用**：给输出模式的 GPIO 设置高 / 低电平（仅输出模式有效）。\n\n- **参数**：\n\n  - `level`：`0`（低电平）、`1`（高电平）。\n\n#### `gpio_get_level()`：读取输入电平\n\n- **函数原型**\n\n  ```c\n  int gpio_get_level(gpio_num_t gpio_num);\n  ```\n\n- **作用**：读取 GPIO 的当前输入电平（需引脚为输入 / 输入输出模式，否则返回 0）。\n\n- **返回值**：`0`（低电平）、`1`（高电平）。\n\n## LEDC库学习笔记\n\n> **定义**：LEDC（Light Emitting Diode Controller）是 ESP32 内置的 LED 控制器，核心功能是生成 PWM（脉冲宽度调制）信号，不仅用于 LED 亮度调节，还可驱动电机、舵机等需 PWM 信号的设备。\n>\n> **核心优势**：无需手动编写定时器中断逻辑，ESP-IDF 提供完整库接口，配置简单、信号稳定\n>\n> **注意**：LEDC 控制器有自己`专属的 4 个定时器`（`LEDC_TIMER_0` ~ `LEDC_TIMER_3`），这些定时器是 LEDC 模块内部集成的，专门用于生成 PWM 信号。\n>\n> 与`通用定时器（TIMER_0 ~ TIMER_3）`完全分离\n\n### LEDC关键概念\n\n| 概念                      | 说明                                                         |\n| ------------------------- | ------------------------------------------------------------ |\n| 通道（Channel）           | ESP32 有 16 个独立通道，每个通道可独立配置 PWM 参数（频率、占空比），并映射到 1 个 GPIO 引脚输出信号。 |\n| 定时器（Timer）           | 每个通道需绑定定时器，定时器决定 PWM 频率（由预分频和计数范围计算），多个通道可共享同一定时器（频率相同）。 |\n| 频率（Frequency）         | PWM 信号周期的倒数（单位：Hz），如 50Hz（舵机常用，对应 20ms 周期）、1000Hz（LED 常用，避免人眼闪烁）。 |\n| 占空比（Duty Cycle）      | PWM 高电平持续时间与周期的比值（0~100%），LEDC 中用数值表示（如 12 位分辨率对应 0~4095）。 |\n| 分辨率（Duty Resolution） | 占空比的可调精度，范围 `LEDC_TIMER_1_BIT`~`LEDC_TIMER_20_BIT`，如 12 位表示占空比可设为 0~4095（共 4096 级）。 |\n| 速度模式                  | 分 `LEDC_LOW_SPEED_MODE`（低速模式）和 `LEDC_HIGH_SPEED_MODE`（高速模式），高速模式支持更高 PWM 频率。 |\n\n### 常用API（需包含头文件 `driver/ledc.h`）\n\n#### 定时器初始化\n\n- **作用**：初始化 LEDC 定时器，设置频率、分辨率等核心参数。\n\n- 函数原型\n\n  ```c\n  esp_err_t ledc_timer_config(const ledc_timer_config_t *timer_conf);\n  ```\n\n- **参数结构体 `ledc_timer_config_t` 说明**：\n\n  | 参数              | 取值 / 说明                                                  |\n  | ----------------- | ------------------------------------------------------------ |\n  | `speed_mode`      | 速度模式：`LEDC_LOW_SPEED_MODE` 或 `LEDC_HIGH_SPEED_MODE`    |\n  | `duty_resolution` | 占空比分辨率：`LEDC_TIMER_1_BIT` ~ `LEDC_TIMER_20_BIT`（如 12 位选 `LEDC_TIMER_12_BIT`） |\n  | `timer_num`       | 定时器编号：`LEDC_TIMER_0` ~ `LEDC_TIMER_3`（共 4 个定时器） |\n  | `freq_hz`         | PWM 频率（如 50、1000，单位：Hz）                            |\n  | `clk_cfg`         | 时钟源：通常用 `LEDC_AUTO_CLK`（自动选择最优时钟）           |\n\n- **示例**：配置 1000Hz、12 位分辨率的定时器 0（低速模式）\n\n  ```c\n  ledc_timer_config_t timer_conf = {\n      .speed_mode = LEDC_LOW_SPEED_MODE,\n      .duty_resolution = LEDC_TIMER_12_BIT,  // 0~4095 级占空比\n      .timer_num = LEDC_TIMER_0,\n      .freq_hz = 1000,                       // 1000Hz 频率\n      .clk_cfg = LEDC_AUTO_CLK\n  };\n  ledc_timer_config(&timer_conf);  // 执行配置\n  ```\n\n####  通道配置：`ledc_channel_config()`\n\n#### 通道配置：`ledc_channel_config()`\n\n- **作用**：将 LEDC 通道绑定到定时器和 GPIO 引脚，设置初始占空比。\n\n- **函数原型**\n\n  ```c\n  esp_err_t ledc_channel_config(const ledc_channel_config_t *channel_conf);\n  ```\n\n- **参数结构体** `ledc_channel_config_t` **说明**\n\n  | 参数         | 取值 / 说明                                                  |\n  | ------------ | ------------------------------------------------------------ |\n  | `speed_mode` | 需与绑定的定时器速度模式一致（如 `LEDC_LOW_SPEED_MODE`）     |\n  | `channel`    | 通道编号：`LEDC_CHANNEL_0` ~ `LEDC_CHANNEL_15`（共 16 个通道） |\n  | `timer_sel`  | 绑定的定时器编号（如 `LEDC_TIMER_0`）                        |\n  | `intr_type`  | 中断类型：通常设 `LEDC_INTR_DISABLE`（禁用中断）             |\n  | `gpio_num`   | 输出 PWM 的 GPIO 引脚（如 `GPIO_NUM_2`、`GPIO_NUM_4`）       |\n  | `duty`       | 初始占空比（0 ~ 分辨率最大值，如 12 位初始为 0 表示 LED 灭） |\n  | `hpoint`     | 脉冲起点偏移：通常设 0（无偏移）                             |\n\n- 示例\n\n  ```c\n  ledc_channel_config_t channel_conf = {\n      .speed_mode = LEDC_LOW_SPEED_MODE,\n      .channel = LEDC_CHANNEL_0,\n      .timer_sel = LEDC_TIMER_0,  // 绑定定时器 0\n      .intr_type = LEDC_INTR_DISABLE,\n      .gpio_num = GPIO_NUM_2,     // GPIO2 输出 PWM\n      .duty = 0,                  // 初始占空比 0（LED 不亮）\n      .hpoint = 0\n  };\n  ledc_channel_config(&channel_conf);  // 执行配置\n  ```\n\n#### 3. 占空比修改：`ledc_set_duty()` + `ledc_update_duty()`\n\n- **作用**：动态调整通道的 PWM 占空比（`ledc_set_duty` 仅修改寄存器，`ledc_update_duty` 使修改生效）。\n\n- **函数原型**\n\n  ```c\n  // 1. 设置占空比（不立即生效）\n  esp_err_t ledc_set_duty(ledc_mode_t speed_mode, ledc_channel_t channel, uint32_t duty);\n  // 2. 使占空比生效\n  esp_err_t ledc_update_duty(ledc_mode_t speed_mode, ledc_channel_t channel);\n  ```\n\n- **参数说明**\n\n  - `speed_mode`：速度模式（与通道一致）\n  - `channel`：目标通道编号\n  - `duty`：目标占空比（0 ~ 分辨率最大值）\n\n- **示例**：将通道 0 占空比设为 50%（12 位分辨率对应 2048）\n\n  ```c\n  // 12 位分辨率下，50% 占空比 = 4096 / 2 = 2048\n  ledc_set_duty(LEDC_LOW_SPEED_MODE, LEDC_CHANNEL_0, 2048);\n  ledc_update_duty(LEDC_LOW_SPEED_MODE, LEDC_CHANNEL_0);  // 占空比生效\n  ```\n\n#### 4. 硬件渐变：`ledc_fade_*` 系列函数\n\n- **作用**：实现硬件自动渐变（无需软件循环），适合 LED 呼吸灯、平滑调光等场景。\n\n- **核心函数**：\n\n  | 函数                        | 作用                                                    |\n  | --------------------------- | ------------------------------------------------------- |\n  | `ledc_fade_func_install()`  | 初始化渐变功能（需开启中断，参数 0 表示不使用中断回调） |\n  | `ledc_set_fade_with_time()` | 配置渐变参数（目标占空比、渐变时间）                    |\n  | `ledc_fade_start()`         | 启动渐变（可选择阻塞 / 非阻塞模式）                     |\n  | `ledc_cb_register()`        | 注册 LEDC 回调函数                                      |\n\n- **函数原型**\n\n  ```c\n  // 1. 初始化渐变功能\n  esp_err_t ledc_fade_func_install(int intr_alloc_flags);\n  // 2. 配置渐变：在指定时间内从当前占空比渐变到目标占空比\n  esp_err_t ledc_set_fade_with_time(ledc_mode_t speed_mode, ledc_channel_t channel, uint32_t target_duty, uint32_t fade_time_ms);\n  // 3. 启动渐变\n  esp_err_t ledc_fade_start(ledc_mode_t speed_mode, ledc_channel_t channel, ledc_fade_mode_t fade_mode);\n  ```\n\n- **参数说明**：\n\n  - `intr_alloc_flags`：中断分配标志（设 0 即可）\n  - `target_duty`：渐变目标占空比\n  - `fade_time_ms`：渐变总时间（单位：ms）\n  - `fade_mode`：渐变模式：`LEDC_FADE_WAIT_DONE`（阻塞，等待渐变完成返回）/ `LEDC_FADE_NO_WAIT`（非阻塞）\n\n- **示例**：2 秒内从当前占空比渐变到最大亮度（12 位对应 4095）\n\n  ```c\n  // 1. 初始化渐变功能\n  ledc_fade_func_install(0);  // 不使用中断回调\n  \n  // 2. 配置渐变：2000ms（2秒）内渐变到 4095（最大亮度）\n  ledc_set_fade_with_time(LEDC_LOW_SPEED_MODE, \n                          LEDC_CHANNEL_0, \n                          4095,        // 目标占空比（最大）\n                          2000);       // 渐变时间（ms）\n  \n  // 3. 启动渐变（阻塞模式，等待渐变完成后再执行后续代码）\n  ledc_fade_start(LEDC_LOW_SPEED_MODE, LEDC_CHANNEL_0, LEDC_FADE_WAIT_DONE);\n  ```\n\n##### 启用中断模式\n\n- **函数原型**\n\n  ```C\n  esp_err_t ledc_cb_register(ledc_mode_t speed_mode, ledc_channel_t channel, ledc_cbs_t *cbs, void *user_arg)\n  ```\n\n- **参数结构体** `ledc_cbs_t` **说明**\n\n  - `fade_cb`：需要注册的中断回调函数\n\n- **示例**\n\n  ```C\n  #include <stdio.h>\n  #include \"freertos/FreeRTOS.h\"\n  #include \"freertos/task.h\"\n  #include \"driver/gpio.h\"\n  #include \"driver/ledc.h\"\n  \n  #define LED_GPIO GPIO_NUM_18\n  \n  #define FULL_EV_BIT BIT0\n  #define EMPTY_EV_BIT BIT1\n  \n  static EventGroupHandle_t led_fade_handle;\n  \n  /**\n   * @brief 重写LEDC完成回调函数\n   * @note IRAM_ATTR 修饰符表示该函数在IRAM中执行，中断服务程序中不能调用RAM中的函数\n   */\n  bool IRAM_ATTR ledc_finish_cb(const ledc_cb_param_t *param, void *user_arg)\n  {\n      BaseType_t taskWoken;\n      if (param->duty)\n      {\n          xEventGroupSetBitsFromISR(led_fade_handle, FULL_EV_BIT, &taskWoken);\n      }\n      else\n      {\n          xEventGroupSetBitsFromISR(led_fade_handle, EMPTY_EV_BIT, &taskWoken);\n      }\n      return taskWoken;\n  }\n  \n  void led_run_task(void *param)\n  {\n      EventBits_t ev;\n      while (1)\n      {\n          ev = xEventGroupWaitBits(led_fade_handle, FULL_EV_BIT | EMPTY_EV_BIT, pdTRUE, pdFALSE, pdMS_TO_TICKS(5000));\n          if (ev & FULL_EV_BIT)\n          {\n              ledc_set_fade_with_time(LEDC_LOW_SPEED_MODE, LEDC_CHANNEL_0, 0, 2000);\n              ledc_fade_start(LEDC_LOW_SPEED_MODE, LEDC_CHANNEL_0, LEDC_FADE_NO_WAIT);\n          }\n          if (ev & EMPTY_EV_BIT)\n          {\n              ledc_set_fade_with_time(LEDC_LOW_SPEED_MODE, LEDC_CHANNEL_0, 8191, 2000);\n              ledc_fade_start(LEDC_LOW_SPEED_MODE, LEDC_CHANNEL_0, LEDC_FADE_NO_WAIT);\n          }\n  \n          ledc_cbs_t ledc_cbs = {\n              .fade_cb = ledc_finish_cb,\n          };\n  \n          ledc_cb_register(LEDC_LOW_SPEED_MODE, LEDC_CHANNEL_0, &ledc_cbs, NULL);\n      }\n  }\n  \n  void app_main(void)\n  {\n      // gpio_config_t led_cfg = {\n      //     .pin_bit_mask = (1 << LED_GPIO),\n      //     .pull_down_en = GPIO_PULLDOWN_DISABLE,\n      //     .pull_up_en = GPIO_PULLUP_DISABLE,\n      //     .intr_type = GPIO_INTR_DISABLE,\n      //     .mode = GPIO_MODE_OUTPUT,\n      // };\n      // gpio_config(&led_cfg);\n  \n      ledc_timer_config_t ledc_timer = {\n          .speed_mode = LEDC_LOW_SPEED_MODE,\n          .timer_num = LEDC_TIMER_0,\n          .clk_cfg = LEDC_AUTO_CLK,\n          .freq_hz = 5000,\n          .duty_resolution = LEDC_TIMER_13_BIT, // 占空比分辨率 0-8191\n      };\n      ledc_timer_config(&ledc_timer);\n  \n      ledc_channel_config_t ledc_channel = {\n          .gpio_num = LED_GPIO,\n          .channel = LEDC_CHANNEL_0,\n          .duty = 0,\n          .speed_mode = LEDC_LOW_SPEED_MODE,\n          .timer_sel = LEDC_TIMER_0,\n          .intr_type = LEDC_INTR_DISABLE,\n      };\n      ledc_channel_config(&ledc_channel);\n  \n      ledc_fade_func_install(0); // 使能渐变 不需要自己手动调节占空比\n      ledc_set_fade_with_time(LEDC_LOW_SPEED_MODE, LEDC_CHANNEL_0, 8191, 2000);\n      ledc_fade_start(LEDC_LOW_SPEED_MODE, LEDC_CHANNEL_0, LEDC_FADE_NO_WAIT);\n  \n      led_fade_handle = xEventGroupCreate();\n  \n      ledc_cbs_t ledc_cbs = {\n          .fade_cb = ledc_finish_cb,\n      };\n  \n      ledc_cb_register(LEDC_LOW_SPEED_MODE, LEDC_CHANNEL_0, &ledc_cbs, NULL);\n  \n      xTaskCreatePinnedToCore(led_run_task, \"led_run_task\", 2048, NULL, 3, NULL, 1);\n  }\n  ```\n\n\n## UART配置\n\n### ESP32 UART 硬件特性\n\n- **硬件资源**：ESP32 内置 3 个 UART 接口（UART0、UART1、UART2），支持不同引脚映射\n- **通信参数**：可配置波特率（1200 ~ 5000000bps）、数据位（5 ~ 8 位）、校验位（无 / 奇 / 偶）、停止位（1/1.5/2 位）\n- **缓冲区**：每个 UART 支持硬件 FIFO 缓冲区，可通过软件配置环形缓冲区大小\n- **事件驱动**：支持通过 FreeRTOS 队列触发 UART 事件（数据接收、缓冲区满、溢出等）\n\n### 关键API\n\n| API 函数                | 功能描述                               | 核心参数说明                                                 |\n| ----------------------- | -------------------------------------- | ------------------------------------------------------------ |\n| `uart_param_config()`   | 配置 UART 通信参数（波特率、数据位等） | 端口号、`uart_config_t` 结构体                               |\n| `uart_set_pin()`        | 绑定 UART 信号到物理引脚               | 端口号、TX 引脚、RX 引脚、RTS 引脚、CTS 引脚                 |\n| `uart_driver_install()` | 安装 UART 驱动并创建事件队列           | 端口号、接收缓冲区大小、发送缓冲区大小、队列容量、队列句柄、标志 |\n| `uart_read_bytes()`     | 读取 UART 接收数据                     | 端口号、接收缓冲区、读取长度、超时时间                       |\n| `uart_write_bytes()`    | 发送 UART 数据                         | 端口号、发送缓冲区、发送长度                                 |\n| `uart_flush_input()`    | 清空 UART 接收缓冲区                   | 端口号                                                       |\n| `xQueueReceive()`       | 从事件队列接收 UART 事件               | 队列句柄、事件存储变量地址、超时时间                         |\n| `xTaskCreate()`         | 创建独立任务处理 UART 事件             | 任务函数、任务名称、栈大小、优先级等                         |\n\n### 基础配置\n\n#### 步骤 1：定义核心参数（宏定义）\n\n```c\n// 1. 定义 UART 端口号\n#define USER_UART_NUM UART_NUM_1  // 避免 UART0 冲突（默认用于串口打印）\n#define USER_UART_BAUD 115200  // 串口波特率设置\n\n// 2. 定义引脚（需根据硬件接线调整）\n#define UART_TX_PIN 17  // TX 发送引脚\n#define UART_RX_PIN 16  // RX 接收引脚\n\n// 3. 定义缓冲区和队列参数\n#define UART_BUFFER_SIZE 1024    // 数据缓冲区大小\n#define UART_QUEUE_SIZE 10       // 事件队列容量（最多缓存 10 个事件）\n#define UART_TASK_STACK_SIZE 4096// UART 处理任务栈大小\n#define UART_TASK_PRIORITY 5     // UART 任务优先级（1~24，数值越大优先级越高）\n\n// 4. 全局变量声明\nstatic QueueHandle_t uart_event_queue;  // UART 事件队列句柄\nstatic uint8_t uart_rx_buffer[UART_BUFFER_SIZE];  // 接收数据缓冲区\nstatic const char *TAG = \"UART_DEV\";    // 日志标签\n```\n\n#### 步骤 2：配置 UART 硬件参数\n\n通过 `uart_config_t` 结构体配置通信参数，再调用 `uart_param_config()` 生效：\n\n```c\n// 配置 UART 通信参数\nuart_config_t uart_config = {\n    .baud_rate = USER_UART_BAUD,          // 波特率（常用：9600、115200、1000000）\n    .data_bits = UART_DATA_8_BITS,// 数据位：8 位\n    .parity = UART_PARITY_DISABLE,// 校验位：禁用\n    .stop_bits = UART_STOP_BITS_1,// 停止位：1 位\n    .flow_ctrl = UART_HW_FLOWCTRL_DISABLE,  // 硬件流控：禁用（无需 RTS/CTS 引脚）\n    .source_clk = UART_SCLK_DEFAULT,         // 时钟源：默认\n};\n// 应用配置到指定 UART 端口\nESP_ERROR_CHECK(uart_param_config(USER_UART_NUM, &uart_config));\n```\n\n#### 步骤 3：绑定引脚并安装驱动 （如果用默认串口的话 则不需要绑定引脚）\n\n- **引脚绑定**：通过 `uart_set_pin()` 将 UART 信号映射到 ESP32 物理引脚\n- **驱动安装**：调用 `uart_driver_install()` 初始化 UART 驱动，创建事件队列（可选）\n\n```c\n// 1. 绑定 UART 引脚（TX/RX，流控引脚填 UART_PIN_NO_CHANGE 表示禁用）\nESP_ERROR_CHECK(uart_set_pin(USER_UART_NUM, \n                            UART_TX_PIN,  // TX 引脚\n                            UART_RX_PIN,  // RX 引脚\n                            UART_PIN_NO_CHANGE,  // RTS 引脚（禁用）\n                            UART_PIN_NO_CHANGE)); // CTS 引脚（禁用）\n\n// 2. 安装 UART 驱动（参数依次：端口号、接收缓冲区大小、发送缓冲区大小、事件队列容量、队列句柄、标志）\nESP_ERROR_CHECK(uart_driver_install(USER_UART_NUM, \n                                    UART_BUFFER_SIZE * 2,  // 接收缓冲区（建议比单次接收大）\n                                    UART_BUFFER_SIZE * 2,  // 发送缓冲区\n                                    UART_QUEUE_SIZE,       // 事件队列容量\n                                    &uart_event_queue,     // 事件队列句柄（传出）\n                                    0));                   // 标志：0（默认）\n```\n\n### ESP32 UART 数据处理方式\n\n| 特性       | 轮询方式（简单场景）                      | 事件驱动方式（高效场景）          |\n| ---------- | ----------------------------------------- | --------------------------------- |\n| 核心函数   | `uart_read_bytes()`、`uart_write_bytes()` | `xQueueReceive()`（监听事件队列） |\n| 适用场景   | 简单回显、低频率数据交互                  | 高频率数据、多事件处理（如溢出）  |\n| CPU 占用率 | 较高（循环查询）                          | 较低（事件触发，无轮询）          |\n| 代码复杂度 | 低                                        | 中（需处理多事件类型）            |\n| 看门狗风险 | 高（需避免长阻塞）                        | 低（事件队列超时释放 CPU）        |\n\n### 实战代码示例\n\n#### 事件驱动方式\n\n- 通过 FreeRTOS 队列接收 UART 事件，按需处理数据接收、缓冲区满、溢出等场景：\n\n  ```C\n  #include <stdio.h>\n  #include \"freertos/FreeRTOS.h\"\n  #include \"freertos/task.h\"\n  #include \"driver/uart.h\"\n  #include \"esp_log.h\"\n  #include \"driver/gpio.h\"\n  \n  // -------------- 1. 宏定义参数 --------------\n  #define USER_UART_NUM UART_NUM_1\n  #define USER_UART_BAUD 115200\n  #define UART_TX_PIN 17\n  #define UART_RX_PIN 16\n  #define UART_BUFFER_SIZE 1024\n  #define UART_QUEUE_SIZE 10\n  #define UART_TASK_STACK_SIZE 4096\n  #define UART_TASK_PRIORITY 5\n  \n  // -------------- 2. 全局变量 --------------\n  static QueueHandle_t uart_event_queue;\n  static uint8_t uart_rx_buffer[UART_BUFFER_SIZE];\n  static const char *TAG = \"UART_DEV\";\n  \n  // -------------- 3. UART 事件处理任务 --------------\n  void uart_event_task(void *arg) {\n      uart_event_t event;  // 存储 UART 事件的结构体\n  \n      while (1) {\n          // 从事件队列接收事件（超时 100ms，避免阻塞触发看门狗）\n          if (xQueueReceive(uart_event_queue, &event, pdMS_TO_TICKS(100)) == pdTRUE) {\n              switch (event.type) {\n                  // 1. 接收数据事件\n                  case UART_DATA:\n                      ESP_LOGI(TAG, \"收到数据，长度：%d 字节\", event.size);\n                      // 读取数据到缓冲区（超时 50ms，确保数据完整性）\n                      int read_len = uart_read_bytes(USER_UART_NUM, \n                                                    uart_rx_buffer, \n                                                    event.size, \n                                                    pdMS_TO_TICKS(50));\n                      if (read_len > 0) {\n                          // 示例1：回显数据（发送收到的数据）\n                          uart_write_bytes(USER_UART_NUM, uart_rx_buffer, read_len);\n                          // 示例2：打印接收的数据（十六进制）\n                          ESP_LOGI(TAG, \"接收数据（hex）：\");\n                          for (int i = 0; i < read_len; i++) {\n                              printf(\"%02X \", uart_rx_buffer[i]);\n                          }\n                          printf(\"\\n\");\n                      }\n                      break;\n  \n                  // 2. 接收缓冲区满事件\n                  case UART_BUFFER_FULL:\n                      ESP_LOGI(TAG, \"接收缓冲区满，清空缓冲区\");\n                      uart_flush_input(USER_UART_NUM);  // 清空接收缓冲区\n                      xQueueReset(uart_event_queue);    // 重置事件队列\n                      break;\n  \n                  // 3. FIFO 溢出事件（硬件缓冲区溢出）\n                  case UART_FIFO_OVF:\n                      ESP_LOGI(TAG, \"UART FIFO 溢出，清空缓冲区\");\n                      uart_flush_input(USER_UART_NUM);\n                      xQueueReset(uart_event_queue);\n                      break;\n  \n                  // 4. 帧错误事件（数据格式错误）\n                  case UART_FRAME_ERR:\n                      ESP_LOGI(TAG, \"帧错误（数据格式异常）\");\n                      break;\n  \n                  // 5. 校验错误事件（启用校验时生效）\n                  case UART_PARITY_ERR:\n                      ESP_LOGI(TAG, \"校验错误（数据校验不匹配）\");\n                      break;\n  \n                  // 其他未处理事件\n                  default:\n                      ESP_LOGI(TAG, \"未处理事件类型：%d\", event.type);\n                      break;\n              }\n          }\n      }\n  }\n  \n  // -------------- 4. 主函数初始化 --------------\n  void app_main(void) {\n      // 1. 配置 UART 硬件参数\n      uart_config_t uart_config = {\n          .baud_rate = USER_UART_BAUD,\n          .data_bits = UART_DATA_8_BITS,\n          .parity = UART_PARITY_DISABLE,\n          .stop_bits = UART_STOP_BITS_1,\n          .flow_ctrl = UART_HW_FLOWCTRL_DISABLE,\n          .source_clk = UART_SCLK_DEFAULT,\n      };\n      ESP_ERROR_CHECK(uart_param_config(USER_UART_NUM, &uart_config));\n  \n      // 2. 绑定引脚\n      ESP_ERROR_CHECK(uart_set_pin(USER_UART_NUM, \n                                  UART_TX_PIN, \n                                  UART_RX_PIN, \n                                  UART_PIN_NO_CHANGE, \n                                  UART_PIN_NO_CHANGE));\n  \n      // 3. 安装 UART 驱动并创建事件队列\n      ESP_ERROR_CHECK(uart_driver_install(USER_UART_NUM, \n                                          UART_BUFFER_SIZE * 2, \n                                          UART_BUFFER_SIZE * 2, \n                                          UART_QUEUE_SIZE, \n                                          &uart_event_queue, \n                                          0));\n  \n      // 4. 创建 UART 事件处理任务（独立任务，避免阻塞 main 任务）\n      xTaskCreate(uart_event_task,          // 任务函数\n                  \"uart_event_task\",        // 任务名称\n                  UART_TASK_STACK_SIZE,     // 栈大小\n                  NULL,                     // 任务参数\n                  UART_TASK_PRIORITY,       // 优先级\n                  NULL);                    // 任务句柄（无需则填 NULL）\n  }\n  ```\n\n#### 轮询方式（简单场景，如回显）\n\n- 适用于数据量小、交互频率低的场景，代码更简洁：\n\n  ```C\n  void app_main(void) {\n      // 1. 配置 UART 参数（同事件驱动方式）\n      uart_config_t uart_config = {\n          .baud_rate = 115200,\n          .data_bits = UART_DATA_8_BITS,\n          .parity = UART_PARITY_DISABLE,\n          .stop_bits = UART_STOP_BITS_1,\n          .flow_ctrl = UART_HW_FLOWCTRL_DISABLE,\n      };\n      ESP_ERROR_CHECK(uart_param_config(USER_UART_NUM, &uart_config));\n      ESP_ERROR_CHECK(uart_set_pin(USER_UART_NUM, 17, 16, UART_PIN_NO_CHANGE, UART_PIN_NO_CHANGE));\n      ESP_ERROR_CHECK(uart_driver_install(USER_UART_NUM, 1024, 1024, 0, NULL, 0));\n  \n      // 2. 轮询读取数据并回显\n      while (1) {\n          // 读取数据（超时 50ms，无数据则返回 0）\n          int read_len = uart_read_bytes(USER_UART_NUM, uart_rx_buffer, 1024, pdMS_TO_TICKS(50));\n          if (read_len > 0) {\n              // 回显数据\n              uart_write_bytes(USER_UART_NUM, uart_rx_buffer, read_len);\n              ESP_LOGI(TAG, \"轮询接收数据长度：%d\", read_len);\n          }\n          // 短暂延迟，释放 CPU（避免触发看门狗）\n          vTaskDelay(pdMS_TO_TICKS(10));\n      }\n  }\n  ```\n\n### 常见问题与解决方案\n\n#### 触发 Task Watchdog（任务看门狗）\n\n- **原因**：\n  1. 轮询方式中 `uart_read_bytes()` 超时过长，或无 `vTaskDelay()` 释放 CPU；\n  2. 事件驱动方式中 `xQueueReceive()` 使用 `portMAX_DELAY` 永久阻塞。\n- **解决方案**：\n  - 轮询方式：在循环中添加 `vTaskDelay(pdMS_TO_TICKS(10))`；\n  - 事件驱动方式：`xQueueReceive()` 超时设为有限值（如 `pdMS_TO_TICKS(100)`）。\n\n#### 数据接收不完整或丢失\n\n- **原因**：\n  1. 接收缓冲区过小，无法容纳单次接收的数据；\n  2. `uart_read_bytes()` 超时过短，数据未完全接收；\n  3. 波特率不匹配（发送端与接收端波特率必须一致）。\n- **解决方案**：\n  - 增大接收缓冲区（如 `UART_BUFFER_SIZE * 2`）；\n  - 延长 `uart_read_bytes()` 超时时间（如 50~100ms）；\n  - 确保发送端与 ESP32 UART 波特率、数据位、校验位完全一致。\n\n#### UART0 与串口打印冲突\n\n- **原因**：ESP32 默认将 `printf()` 映射到 UART0（引脚 TX=1，RX=3），若使用 UART0 通信会导致打印乱码。\n- **解决方案**：\n  - 优先使用 UART1 或 UART2 作为通信端口；\n  - 若必须使用 UART0，需重新映射 `printf()` 到其他 UART（需修改 ESP-IDF 配置）。\n\n## WIFI\n\n### ESP32下WIFI组件三种模式\n\n- **AP 模式**：ESP32 自身作为接入点，其他设备（如手机、电脑）可连接 ESP32 创建的 WiFi 热点，适用于 “本地设备直连 ESP32” 场景（如配置 ESP32 参数）；\n\n- **AP+STA 混合模式**：ESP32 同时作为接入点和客户端，既允许其他设备连接自身，又能接入外部路由器，适用于 “本地控制 + 远程联网” 复合场景（如智能家居设备）；\n\n- **STA 模式**：仅作为客户端，专注于接入外部网络，是 ESP32 实现联网功能的最常用模式（如传感器数据上传云端、远程控制指令接收）。\n\n### STA模式核心工作原理\n\nESP32 的 STA 模式连接 WiFi 的过程遵循 IEEE 802.11 协议，核心流程可分为 4 个阶段，各阶段依赖 ESP-IDF 提供的 WiFi 驱动接口实现：\n\n1. **初始化阶段**：\n\n   - 初始化 WiFi 组件（调用esp_wifi_init()），配置 WiFi 工作模式为 STA（通过wifi_init_config_t结构体设置mode = WIFI_MODE_STA）；\n\n   - 配置 TCP/IP 协议栈（ESP-IDF 默认自动初始化，无需手动操作，支持 DHCP 自动获取 IP 或静态 IP 配置）。\n\n2. **配置连接参数阶段**：\n\n   - 定义wifi_config_t结构体，填入目标 AP 的**SSID（WiFi 名称）** 和**Password（WiFi 密码）**，确保参数与 AP 一致（区分 SSID 大小写，密码长度需符合 AP 要求，如 WPA2-PSK 密码通常为 8-63 位）；\n\n   - 通过esp_wifi_set_config(WIFI_IF_STA, &wifi_config)将配置参数写入 ESP32 的 WiFi 接口。\n\n3. **启动与连接阶段**：\n\n   - 启动 STA 接口（esp_wifi_start()），ESP32 开始扫描周围 WiFi 信号；\n\n   - 自动匹配目标 AP 的 SSID，发起连接请求，与 AP 进行**认证（如 WPA2-PSK 认证）** 和**关联**；\n\n   - 若认证通过，ESP32 通过 DHCP 向 AP 请求 IP 地址（默认开启 DHCP 客户端），获取到 IP、子网掩码、网关后，完成 “物理连接→网络层连接” 的全流程。\n\n4. **状态监测阶段**：\n\n   - ESP32 通过**事件回调机制**（esp_event_loop_create_default()创建事件循环，esp_event_handler_instance_register()注册事件处理函数）反馈连接状态；\n\n   - 关键事件包括：WIFI_EVENT_STA_START（STA 接口启动成功）、WIFI_EVENT_STA_CONNECTED（与 AP 物理连接成功）、IP_EVENT_STA_GOT_IP（获取 IP 地址，联网完成）、WIFI_EVENT_STA_DISCONNECTED（与 AP 断开连接）。\n\n#### 实现步骤\n\n##### 重写事件处理函数（核心）\n\n```C\n/**\n * @brief WiFi事件与IP事件处理回调函数（核心逻辑）\n * @param arg：用户自定义参数，本代码未使用，传入NULL即可\n * @param event_base：事件基础类型，用于区分是WiFi相关事件（WIFI_EVENT）还是IP相关事件（IP_EVENT）\n * @param event_id：具体事件ID，标识当前触发的是该事件类型下的哪一种具体事件\n * @param event_data：事件关联的数据指针，如IP事件中可获取分配的IP地址信息\n * 功能：响应ESP32 WiFi模块的关键事件，更新连接状态、触发重连逻辑、通知外部状态变化\n */\nstatic void event_handler(void *arg, esp_event_base_t event_base,\n                          int32_t event_id, void *event_data)\n```\n\n##### 实现 STA 模式初始化函数\n\n```C\n// 引入所需头文件：自定义WiFi管理模块头文件、ESP32 WiFi驱动库、事件处理库\n// 日志打印库、FreeRTOS实时操作系统任务调度库、标准输入输出库\n#include \"wifi_manager.h\"\n#include \"esp_wifi.h\"\n#include \"esp_event.h\"\n#include \"esp_log.h\"\n#include \"nvs_flash.h\"\n#include \"freertos/FreeRTOS.h\"\n#include \"freertos/task.h\"\n#include <stdio.h>\n\n#define WIFI_SSID \"2078\"\n#define WIFI_PASSWORD \"12345678\"\n\n// 静态全局变量：WiFi状态回调函数指针，用于将WiFi连接/断开状态通知给外部调用者\n// 外部需通过wifi_manager_init函数传入自定义回调，接收WIFI_STATE_CONNECTED/WIFI_STATE_DISCONNECTED状态\nstatic p_wifi_state_cb wifi_state_cb = NULL;\n\n// 宏定义：STA模式下最大重连次数，限制重连次数避免无限循环占用CPU资源\n#define MAX_CONNECT_RETRY 10\n// 宏定义：日志标签，串口打印时用于区分该模块的日志，方便调试定位\n#define TAG \"wifi_manager\"\n\n// 静态全局变量：记录STA模式当前的重连尝试次数，初始值为0，每次重连失败自增1\nstatic int sta_connect_cnt = 0; // 重连次数\n\n// 静态全局变量：标记STA模式是否已成功连接到目标AP，true表示已连接，false表示未连接/已断开\nstatic bool is_sta_connected = false;\n\n/**\n * @brief WiFi事件与IP事件处理回调函数（核心逻辑）\n * @param arg：用户自定义参数，本代码未使用，传入NULL即可\n * @param event_base：事件基础类型，用于区分是WiFi相关事件（WIFI_EVENT）还是IP相关事件（IP_EVENT）\n * @param event_id：具体事件ID，标识当前触发的是该事件类型下的哪一种具体事件\n * @param event_data：事件关联的数据指针，如IP事件中可获取分配的IP地址信息\n * 功能：响应ESP32 WiFi模块的关键事件，更新连接状态、触发重连逻辑、通知外部状态变化\n */\nstatic void event_handler(void *arg, esp_event_base_t event_base,\n                          int32_t event_id, void *event_data)\n{\n    // 判断事件类型为WiFi相关事件（WIFI_EVENT）\n    if (event_base == WIFI_EVENT)\n    {\n        // 根据具体事件ID处理不同场景\n        switch (event_id)\n        {\n        // 事件：STA接口启动成功（调用esp_wifi_start()后触发此事件）\n        case WIFI_EVENT_STA_START:\n            // 启动成功后，主动调用esp_wifi_connect()发起WiFi连接请求\n            esp_wifi_connect();\n            break;\n\n        // 事件：STA与已连接的AP断开连接（如信号弱、密码错误、路由器重启等）\n        case WIFI_EVENT_STA_DISCONNECTED:\n            // 若之前处于已连接状态，先更新连接状态并通知外部\n            if (is_sta_connected)\n            {\n                is_sta_connected = false; // 将连接状态标记为未连接\n                if (wifi_state_cb)        // 若外部注册了回调函数，触发\"断开连接\"状态通知\n                    wifi_state_cb(WIFI_STATE_DISCONNECTED);\n            }\n\n            // 检查当前重连次数是否小于最大重连次数，若未达到则继续重试\n            if (sta_connect_cnt < MAX_CONNECT_RETRY)\n            {\n                sta_connect_cnt++;  // 重连次数自增1\n                esp_wifi_connect(); // 发起新一轮连接请求\n            }\n            // 若已达到最大重连次数，不再重试（避免无限重连）\n            wifi_state_cb(WIFI_STATE_DISCONNECTED);\n            break;\n\n        // 其他未定义的WiFi事件，暂不处理，直接break\n        default:\n            break;\n        }\n    }\n    // 判断事件类型为IP相关事件（IP_EVENT）\n    else if (event_base == IP_EVENT)\n    {\n        // 事件：STA成功从DHCP服务器获取到IP地址（标志网络层连接完成）\n        if (event_id == IP_EVENT_STA_GOT_IP)\n        {\n            // 打印日志提示已获取IP地址，便于调试确认\n            ESP_LOGI(TAG, \"Got IP address\");\n            sta_connect_cnt = 0;     // 重置重连次数\n            is_sta_connected = true; // 将连接状态标记为已连接\n            if (wifi_state_cb)       // 若外部注册了回调函数，触发\"连接成功\"状态通知\n                wifi_state_cb(WIFI_STATE_CONNECTED);\n        }\n    }\n}\n\n/**\n * @brief WiFi管理器初始化函数（STA模式初始化入口）\n * @param f：外部传入的WiFi状态回调函数，用于接收连接/断开状态通知\n * 功能：初始化ESP32网络接口、事件循环、WiFi驱动，配置STA模式并启动WiFi模块\n * 注意：使用WiFi功能前必须先调用此函数完成初始化，建议在app_main()中优先执行\n */\nvoid wifi_manager_init(p_wifi_state_cb f)\n{\n    // 1. 初始化NVS（ESP32存储WiFi配置的依赖组件，必须先初始化）\n    esp_err_t ret = nvs_flash_init();\n    if (ret == ESP_ERR_NVS_NO_FREE_PAGES || ret == ESP_ERR_NVS_NEW_VERSION_FOUND)\n    {\n        ESP_ERROR_CHECK(nvs_flash_erase()); // 若NVS有问题，先擦除再初始化\n        ret = nvs_flash_init();\n    }\n\n    // 2. 初始化ESP32网络接口（TCP/IP协议栈初始化，必须在WiFi初始化前执行）\n    ESP_ERROR_CHECK(esp_netif_init());\n\n    // 3. 创建默认的事件循环（用于处理WiFi和IP事件）\n    ESP_ERROR_CHECK(esp_event_loop_create_default());\n    esp_netif_create_default_wifi_sta(); // 使用默认的STA模式网络接口\n\n    // 4. 初始化WiFi驱动：使用WIFI_INIT_CONFIG_DEFAULT()获取默认配置（包含时钟、中断等参数）\n    wifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT();\n    ESP_ERROR_CHECK(esp_wifi_init(&cfg)); // 执行WiFi驱动初始化，若失败则触发错误检查\n\n    // 5. 注册事件处理函数：监听WiFi事件和IP事件\n    // 5.1注册WiFi事件监听器：监听所有WiFi事件（ESP_EVENT_ANY_ID），触发时调用event_handler处理\n    ESP_ERROR_CHECK(esp_event_handler_instance_register(WIFI_EVENT,\n                                                        ESP_EVENT_ANY_ID,\n                                                        &event_handler,\n                                                        NULL,\n                                                        NULL));\n    // 5.2注册IP事件监听器：仅监听\"STA获取IP\"事件（IP_EVENT_STA_GOT_IP）\n    ESP_ERROR_CHECK(esp_event_handler_instance_register(IP_EVENT,\n                                                        IP_EVENT_STA_GOT_IP,\n                                                        &event_handler,\n                                                        NULL,\n                                                        NULL));\n\n    // 6. 保存外部传入的状态回调函数，后续状态变化时通过此函数通知外部\n    wifi_state_cb = f;\n\n    wifi_config_t wifi_config = {\n        .sta = {\n            // 配置STA的认证模式为WPA2-PSK（主流家用/工业路由器默认加密方式）\n            .threshold.authmode = WIFI_AUTH_WPA2_PSK,\n            .ssid = WIFI_SSID,\n            .password = WIFI_PASSWORD,\n        },\n    };\n\n    // 7. 配置WiFi工作模式为纯STA模式（仅作为客户端连接外部AP，不开启AP模式）\n    ESP_ERROR_CHECK(esp_wifi_set_mode(WIFI_MODE_STA));\n    ESP_ERROR_CHECK(esp_wifi_set_config(WIFI_IF_STA, &wifi_config)); // 写入配置\n    // 8. 启动WiFi模块（启动后会触发WIFI_EVENT_STA_START事件，进而发起连接）\n    ESP_ERROR_CHECK(esp_wifi_start());\n    ESP_LOGI(TAG, \"STA initialization done\");\n}\n\n```\n\n\n\n\n\n\n\n","slug":"ESP32学习","published":1,"updated":"2025-09-17T04:11:34.000Z","comments":1,"layout":"post","photos":[],"_id":"cmk8pg6xk000p6sk9dd7he1y7","content":"<h2 id=\"ESP32环境搭建\"><a href=\"#ESP32环境搭建\" class=\"headerlink\" title=\"ESP32环境搭建\"></a>ESP32环境搭建</h2><h3 id=\"WSL2安装与配置\"><a href=\"#WSL2安装与配置\" class=\"headerlink\" title=\"WSL2安装与配置\"></a>WSL2安装与配置</h3><p>推荐查阅官方文档说明：<a href=\"https://learn.microsoft.com/zh-cn/windows/wsl/install\">安装 WSL | Microsoft Learn</a></p>\n<h4 id=\"手动下载安装包\"><a href=\"#手动下载安装包\" class=\"headerlink\" title=\"手动下载安装包\"></a>手动下载安装包</h4><ol>\n<li><p>访问 WSL 的 GitHub Releases 页面 <a href=\"https://github.com/microsoft/WSL/releases\">https://github.com/microsoft/WSL/releases</a></p>\n</li>\n<li><p>查找并下载最新版本的 .msi 安装包（例如 wsl.2.1.5.0.x64.msi）</p>\n</li>\n</ol>\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091112594.png\" alt=\"image-20250909111242531\"></p>\n<h4 id=\"配置控制面板\"><a href=\"#配置控制面板\" class=\"headerlink\" title=\"配置控制面板\"></a>配置控制面板</h4><p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091115919.png\" alt=\"image-20250909111552848\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091116357.png\" alt=\"image-20250909111621317\"></p>\n<blockquote>\n<p>有些Windows 11新系统会没有<code>虚拟机平台</code>这个选项 没有关系！！！！</p>\n<p>配置完后重新启动电脑</p>\n</blockquote>\n<h4 id=\"管理员身份运行Windows-PowerShell\"><a href=\"#管理员身份运行Windows-PowerShell\" class=\"headerlink\" title=\"管理员身份运行Windows PowerShell\"></a>管理员身份运行Windows PowerShell</h4><p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091108898.png\" alt=\"img\"></p>\n<h4 id=\"安装Ubuntu\"><a href=\"#安装Ubuntu\" class=\"headerlink\" title=\"安装Ubuntu\"></a>安装Ubuntu</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsl --install</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091108464.png\" alt=\"img\"></p>\n<blockquote>\n<p>如有可选 则选择Uuntu 如 <code>wsl --install -d Ubuntu</code></p>\n</blockquote>\n<h4 id=\"等待安装完成后重启电脑打开Ubuntu\"><a href=\"#等待安装完成后重启电脑打开Ubuntu\" class=\"headerlink\" title=\"等待安装完成后重启电脑打开Ubuntu\"></a>等待安装完成后重启电脑打开Ubuntu</h4><p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091121963.png\" alt=\"image-20250909112101810\"></p>\n<h4 id=\"输入账号密码\"><a href=\"#输入账号密码\" class=\"headerlink\" title=\"输入账号密码\"></a>输入账号密码</h4><p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091121306.png\" alt=\"img\"></p>\n<h4 id=\"更新软件源\"><a href=\"#更新软件源\" class=\"headerlink\" title=\"更新软件源\"></a>更新软件源</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">sudo</span> apt update</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091124279.png\" alt=\"img\"></p>\n<h4 id=\"更新完后输入下方指令，下载espidf依赖库和工具\"><a href=\"#更新完后输入下方指令，下载espidf依赖库和工具\" class=\"headerlink\" title=\"更新完后输入下方指令，下载espidf依赖库和工具\"></a>更新完后输入下方指令，下载espidf依赖库和工具</h4><blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">sudo</span> apt-get install git wget flex bison gperf python3 python3-pip python3-venv cmake ninja-build ccache libffi-dev libssl-dev dfu-util libusb-1.0-0</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091126525.png\" alt=\"img\"></p>\n<h4 id=\"输入y\"><a href=\"#输入y\" class=\"headerlink\" title=\"输入y\"></a>输入y</h4><p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091127364.png\" alt=\"image-20250909112720315\"></p>\n<h3 id=\"VScode配置\"><a href=\"#VScode配置\" class=\"headerlink\" title=\"VScode配置\"></a>VScode配置</h3><h4 id=\"选择连接到WSL\"><a href=\"#选择连接到WSL\" class=\"headerlink\" title=\"选择连接到WSL\"></a>选择连接到WSL</h4><p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091129218.png\" alt=\"img\"></p>\n<h4 id=\"插件安装\"><a href=\"#插件安装\" class=\"headerlink\" title=\"插件安装\"></a>插件安装</h4><blockquote>\n<ul>\n<li>安装<code>Chinese</code>插件</li>\n<li>安装<code>C/C++</code>插件</li>\n<li>安装<code>ESP-IDF</code>插件</li>\n</ul>\n</blockquote>\n<h4 id=\"在linux账户新建文件用于存放espidf内容，方便后续管理\"><a href=\"#在linux账户新建文件用于存放espidf内容，方便后续管理\" class=\"headerlink\" title=\"在linux账户新建文件用于存放espidf内容，方便后续管理\"></a>在linux账户新建文件用于存放espidf内容，方便后续管理</h4><p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091135250.png\" alt=\"image-20250909113527188\"></p>\n<h4 id=\"ESP-IDF安装\"><a href=\"#ESP-IDF安装\" class=\"headerlink\" title=\"ESP-IDF安装\"></a>ESP-IDF安装</h4><p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091131190.png\" alt=\"img\"></p>\n<h4 id=\"在安装路径中选择自己新建的文件夹\"><a href=\"#在安装路径中选择自己新建的文件夹\" class=\"headerlink\" title=\"在安装路径中选择自己新建的文件夹\"></a>在安装路径中选择自己新建的文件夹</h4><p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091135132.png\" alt=\"img\"></p>\n<blockquote>\n<p>如果出现下图这个情况</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091137839.png\" alt=\"img\"></p>\n<p>那就运行一下下面的指令 </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">sudo</span> <span class=\"built_in\">chown</span> -R <span class=\"variable\">$USER</span>:<span class=\"variable\">$USER</span> /home/你的用户名/你的IDF文件名/</span><br><span class=\"line\"><span class=\"built_in\">chmod</span> -R 755 /home/你的用户名/你的IDF文件名/</span><br></pre></td></tr></table></figure>\n</blockquote>\n<h4 id=\"安装完成之后先搞个工程测试一下编译能不能正常\"><a href=\"#安装完成之后先搞个工程测试一下编译能不能正常\" class=\"headerlink\" title=\"安装完成之后先搞个工程测试一下编译能不能正常\"></a>安装完成之后先搞个工程测试一下编译能不能正常</h4><p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091140479.png\" alt=\"img\"></p>\n<h4 id=\"选择文件夹来存放代码\"><a href=\"#选择文件夹来存放代码\" class=\"headerlink\" title=\"选择文件夹来存放代码\"></a>选择文件夹来存放代码</h4><p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091143918.png\" alt=\"img\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091143292.png\" alt=\"img\"></p>\n<h4 id=\"设置环境\"><a href=\"#设置环境\" class=\"headerlink\" title=\"设置环境\"></a>设置环境</h4><h5 id=\"设置IDF-tools环境（豆包四条命令搞定）\"><a href=\"#设置IDF-tools环境（豆包四条命令搞定）\" class=\"headerlink\" title=\"设置IDF_tools环境（豆包四条命令搞定）\"></a>设置IDF_tools环境（豆包四条命令搞定）</h5><blockquote>\n<p>注意下方命令中：</p>\n<p><code>~/ESP_IDF/v5.5.1/esp-idf</code>：你的IDF文件夹路径 要一直引入到<code>esp-idf</code></p>\n<p><code>~/ESP_IDF/Tools</code>：你的IDF_Tools文件夹路径</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&#x27;export IDF_PATH=~/ESP_IDF/v5.5.1/esp-idf&#x27;</span> &gt;&gt; ~/.bashrc</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&#x27;export IDF_TOOLS_PATH=~/ESP_IDF/Tools&#x27;</span> &gt;&gt; ~/.bashrc</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&#x27;source ~/ESP_IDF/v5.5.1/esp-idf/export.sh&#x27;</span> &gt;&gt; ~/.bashrc</span><br><span class=\"line\"><span class=\"built_in\">source</span> ~/.bashrc  <span class=\"comment\"># 立即生效</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>成功的话 重启<code>vscode</code>就会自动出现<code>idf</code>的命令</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509092218229.png\" alt=\"image-20250909221836025\"></p>\n</blockquote>\n<h5 id=\"若上面还不行-则根据报错情况执行下面\"><a href=\"#若上面还不行-则根据报错情况执行下面\" class=\"headerlink\" title=\"若上面还不行 则根据报错情况执行下面\"></a>若上面还不行 则根据报错情况执行下面</h5><h6 id=\"场景-1：运行-export-sh-时报-“Python-虚拟环境不存在”\"><a href=\"#场景-1：运行-export-sh-时报-“Python-虚拟环境不存在”\" class=\"headerlink\" title=\"场景 1：运行 ./export.sh 时报 “Python 虚拟环境不存在”\"></a>场景 1：运行 <code>./export.sh</code> 时报 “Python 虚拟环境不存在”</h6><p><code>报错信息</code></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ERROR: ESP-IDF Python virtual environment <span class=\"string\">&quot;<span class=\"variable\">$HOME</span>/ESP_IDF/Tools/python_env/idf5.5_py3.12_env/bin/python&quot;</span> not found. Please run the install script to <span class=\"built_in\">set</span> it up before proceeding.</span><br></pre></td></tr></table></figure>\n\n<p><code>原因</code></p>\n<p>未执行 ESP-IDF 安装脚本，Python 虚拟环境未创建。</p>\n<p><code>解决方案</code></p>\n<p>必须先运行安装脚本，自动创建虚拟环境和安装依赖：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 进入 ESP-IDF 根目录（替换为你的实际路径）</span></span><br><span class=\"line\"><span class=\"built_in\">cd</span> ~/ESP_IDF/v5.5.1/esp-idf</span><br><span class=\"line\"><span class=\"comment\"># 执行安装脚本（Linux/macOS 用 install.sh，Windows 用 install.bat）</span></span><br><span class=\"line\">./install.sh</span><br><span class=\"line\"><span class=\"comment\"># 安装完成后再执行 export.sh 导出环境</span></span><br><span class=\"line\">. ./export.sh</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"场景-2：运行-install-sh-时-“下载工具包卡住”\"><a href=\"#场景-2：运行-install-sh-时-“下载工具包卡住”\" class=\"headerlink\" title=\"场景 2：运行 ./install.sh 时 “下载工具包卡住”\"></a>场景 2：运行 <code>./install.sh</code> 时 “下载工具包卡住”</h6><p><code>报错表现</code></p>\n<p>安装过程中卡在某一工具包下载（如 <code>riscv32-esp-elf-gdb</code>），进度条不动或反复重试。</p>\n<p><code>原因</code></p>\n<p>ESP-IDF 工具包托管在 GitHub，国内网络访问速度慢或不稳定，导致下载中断。</p>\n<ol>\n<li><p><strong>用国内镜像加速（推荐）</strong><br>配置 <code>IDF_GITHUB_ASSETS</code> 环境变量，将下载源切换为 Espressif 国内镜像，无需手动下载：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 临时生效，每次打开终端需重新执行（或写入 shell 配置文件）</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> IDF_GITHUB_ASSETS=<span class=\"string\">&quot;dl.espressif.com/github_assets&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># 重新运行安装脚本</span></span><br><span class=\"line\">./install.sh</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h4 id=\"烧录文件\"><a href=\"#烧录文件\" class=\"headerlink\" title=\"烧录文件\"></a>烧录文件</h4><h5 id=\"下载wsl-usb-manager-exe\"><a href=\"#下载wsl-usb-manager-exe\" class=\"headerlink\" title=\"下载wsl-usb-manager.exe\"></a>下载wsl-usb-manager.exe</h5><blockquote>\n<p><a href=\"https://mextra.netlify.app/download/ESP32/wsl-usb-manager.exe\">wsl-usb-manager.exe </a></p>\n</blockquote>\n<h5 id=\"插上ESP32S3\"><a href=\"#插上ESP32S3\" class=\"headerlink\" title=\"插上ESP32S3\"></a>插上ESP32S3</h5><p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091454477.jpg\" alt=\"059f326e4709ef71f539677c5da784c2\"></p>\n<h5 id=\"配置WSL-USB\"><a href=\"#配置WSL-USB\" class=\"headerlink\" title=\"配置WSL USB\"></a>配置WSL USB</h5><h6 id=\"管理员身份打开Windows-PowerShell\"><a href=\"#管理员身份打开Windows-PowerShell\" class=\"headerlink\" title=\"管理员身份打开Windows PowerShell\"></a>管理员身份打开Windows PowerShell</h6><blockquote>\n<p>输入<code>winget install usbipd</code>，然后输入<code>y</code>（<code>看情况选择开不开魔法</code>，不开也能20s左右下载安装完）</p>\n</blockquote>\n<p>这个指令是安装usbipd-win工具，用于将windows系统的usb设备共享给wsl环境。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509092343890.png\" alt=\"img\"></p>\n<p>安装好之后 更改权限</p>\n<blockquote>\n<ul>\n<li><p>输入<code>sudo usermod -aG dialout 你的用户名</code></p>\n</li>\n<li><p>然后<code>重启电脑</code></p>\n</li>\n<li><p>输入<code>groups</code>验证一下</p>\n<ul>\n<li>如果输出中包含 <code>dialout</code> 或 <code>uucp</code>，则表示设置成功，之后就可以正常访问串口了。</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<h5 id=\"进入WSL-USB选择端口并烧录\"><a href=\"#进入WSL-USB选择端口并烧录\" class=\"headerlink\" title=\"进入WSL USB选择端口并烧录\"></a>进入WSL USB选择端口并烧录</h5><p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091457549.png\" alt=\"image-20250909145724459\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091500732.png\" alt=\"image-20250909150034639\"></p>\n<p>以上环境参考：<a href=\"https://blog.csdn.net/QL_SD/article/details/150216599?spm=1001.2014.3001.5502\">（二）vscode搭建espidf环境，配置wsl2_wsl 编译idf项目-CSDN博客</a></p>\n<p>感谢<a href=\"https://blog.csdn.net/QL_SD\">QL.ql</a>大博主</p>\n<h2 id=\"ESP32基础知识\"><a href=\"#ESP32基础知识\" class=\"headerlink\" title=\"ESP32基础知识\"></a>ESP32基础知识</h2><p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091737219.png\" alt=\"image-20250909173749995\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091738212.png\" alt=\"image-20250909173836126\"></p>\n<h3 id=\"使用命令行创建工程\"><a href=\"#使用命令行创建工程\" class=\"headerlink\" title=\"使用命令行创建工程\"></a>使用命令行创建工程</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">idf.py create-project 工程名</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"打开vscode-切换到新建的工程\"><a href=\"#打开vscode-切换到新建的工程\" class=\"headerlink\" title=\"打开vscode 切换到新建的工程\"></a>打开vscode 切换到新建的工程</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> ~/ESP_Code/刚刚的工程名</span><br><span class=\"line\">code .</span><br><span class=\"line\"></span><br><span class=\"line\">按`ctrl+<span class=\"built_in\">shift</span>+p` 寻找add 添加idf路径</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>在写代码时候 如果出现宏没定义 则重新设置一下芯片型号 稍等一会就会出现</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509101009919.png\" alt=\"image-20250910100948617\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509101026730.png\" alt=\"image-20250910102600612\"></p>\n<p>如果想要删除文件夹 则运行以下命令</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> ..</span><br><span class=\"line\"><span class=\"built_in\">rm</span> -rf 文件夹</span><br></pre></td></tr></table></figure>\n\n<p>必备头文件</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;freertos/FreeRTOS.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;freertos/task.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;esp_log.h&quot;</span></span></span><br></pre></td></tr></table></figure>\n\n</blockquote>\n<h3 id=\"CMakeList-txt使用说明\"><a href=\"#CMakeList-txt使用说明\" class=\"headerlink\" title=\"CMakeList.txt使用说明\"></a>CMakeList.txt使用说明</h3><p>一般CmakeList.txt呈现下面的结构</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">main</span><br><span class=\"line\">    main.c</span><br><span class=\"line\">    CMakeList.txt</span><br><span class=\"line\">CMakeList.txt</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"创建自定义文件夹\"><a href=\"#创建自定义文件夹\" class=\"headerlink\" title=\"创建自定义文件夹\"></a>创建自定义文件夹</h4><blockquote>\n<p>如</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">components</span><br><span class=\"line\">    led</span><br><span class=\"line\">    \tled.c</span><br><span class=\"line\">    \tled.h</span><br><span class=\"line\">    \tCMakeList.txt</span><br><span class=\"line\">main</span><br><span class=\"line\">    main.c</span><br><span class=\"line\">    CMakeList.txt</span><br></pre></td></tr></table></figure>\n\n<p>在这个目录下 则<code>components/led</code>文件夹下的<code>CMakeList.txt</code>，可以这么写</p>\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">idf_component_register(SRCS <span class=\"string\">&quot;led.c&quot;</span></span><br><span class=\"line\">                    INCLUDE_DIRS <span class=\"string\">&quot;.&quot;</span></span><br><span class=\"line\">                    REQUIRES esp_driver_gpio</span><br><span class=\"line\">                    )</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p><code>SRCS</code>：<code>.c</code>文件 多个用空格隔开</p>\n</li>\n<li><p><code>INCLUDE_DIRS</code>：文件名 多个同样用空格隔开</p>\n</li>\n<li><p><code>REQUIRES</code>：引入ESP官方的组件库<code>components</code> ，名字为官方<code>idf</code>下的<code>components</code>文件夹下的文件夹名 如此处的<code>esp_driver_gpio</code></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509121840992.png\" alt=\"image-20250912184005520\"></p>\n</li>\n</ul>\n<p>而若要引用 则<code>main</code>文件夹下的<code>CMakeList.txt</code> 可以这么写</p>\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">idf_component_register(SRCS <span class=\"string\">&quot;main.c&quot;</span> <span class=\"string\">&quot;../components/led/led.c&quot;</span></span><br><span class=\"line\">                    INCLUDE_DIRS <span class=\"string\">&quot;.&quot;</span> <span class=\"string\">&quot;../components&quot;</span>)</span><br></pre></td></tr></table></figure>\n</blockquote>\n<h3 id=\"FreeRTOS-ESP32-基础API\"><a href=\"#FreeRTOS-ESP32-基础API\" class=\"headerlink\" title=\"FreeRTOS-ESP32 基础API\"></a>FreeRTOS-ESP32 基础API</h3><h4 id=\"任务创建\"><a href=\"#任务创建\" class=\"headerlink\" title=\"任务创建\"></a>任务创建</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BaseType_t <span class=\"title function_\">xTaskCreatePinnedToCore</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">\tTaskFunction_t pvTaskCode,\t\t\t\t<span class=\"comment\">//任务函数指针，原型是voidfun(void*param)</span></span></span><br><span class=\"line\"><span class=\"params\">\t<span class=\"type\">const</span> <span class=\"type\">char</span> *constpcName,\t\t\t\t<span class=\"comment\">//任务的名称，打印调试可能会有用</span></span></span><br><span class=\"line\"><span class=\"params\">\t<span class=\"type\">const</span> <span class=\"type\">uint32_t</span> usStackDepth,\t\t\t<span class=\"comment\">//指定的任务堆栈空间大小（字节）</span></span></span><br><span class=\"line\"><span class=\"params\">\t<span class=\"type\">void</span> *constpvParameters,\t\t\t\t<span class=\"comment\">//任务参数</span></span></span><br><span class=\"line\"><span class=\"params\">\tUBaseType_t uxPriority,\t\t\t\t\t<span class=\"comment\">//优先级，数字越大，优先级越大，0到(configMAX_PRIORITIES-1) 即0-24</span></span></span><br><span class=\"line\"><span class=\"params\">\tTaskHandle_t *constpvCreatedTask,\t\t <span class=\"comment\">//传回来的任务句柄</span></span></span><br><span class=\"line\"><span class=\"params\">\t<span class=\"type\">const</span> BaseType_t xCoreID)</span>\t\t\t\t<span class=\"comment\">//分配在哪个内核上运行 ESP32是双核 所以可以选0或1</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>ESP32的任务堆栈空间大小<code>usStackDepth</code>与原生FreeRTOS不一样</p>\n<ul>\n<li>原生FreeRTOS的任务堆栈空间大小单位是<code>字</code>，即目标平台若是32位 则为4个字节</li>\n<li>ESP32的任务堆栈空间大小单位是<code>字节</code>，最小是<code>2048</code></li>\n</ul>\n</blockquote>\n<h4 id=\"阻塞函数（少用-可替代）\"><a href=\"#阻塞函数（少用-可替代）\" class=\"headerlink\" title=\"阻塞函数（少用 可替代）\"></a>阻塞函数（少用 可替代）</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//粗略延时xTicksToDelay个周期 </span></span><br><span class=\"line\"><span class=\"comment\">//使用该函数后 任务进入阻塞 等延时结束且调度到来才会再次运行</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">vTaskDelay</span><span class=\"params\">(<span class=\"type\">const</span> TickType_t xTicksToDelay)</span>\t</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//用于表示精确的解除阻塞时间    </span></span><br><span class=\"line\"><span class=\"comment\">//即使任务的执行时间超过了周期时间，它也能自动调整延迟时间，保证任务的周期性运行</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">vTaskDelayUntil</span><span class=\"params\">(TickType_t *pxPreviousWakeTime,<span class=\"type\">const</span> TickType_t xTimeIncrement)</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"打印调试\"><a href=\"#打印调试\" class=\"headerlink\" title=\"打印调试\"></a>打印调试</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;freertos/FreeRTOS.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;freertos/task.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;esp_log.h&quot;</span></span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">taskA</span><span class=\"params\">(<span class=\"type\">void</span> *param)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        ESP_LOGI(<span class=\"string\">&quot;TaskA&quot;</span>, <span class=\"string\">&quot;Hello from Task A%d&quot;</span>, <span class=\"number\">1</span>);<span class=\"comment\">//前面是一个TAG标签，后面是打印内容 他会自动回车换行</span></span><br><span class=\"line\">        vTaskDelay(pdMS_TO_TICKS(<span class=\"number\">500</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">app_main</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    xTaskCreatePinnedToCore(taskA, <span class=\"string\">&quot;TaskA&quot;</span>, <span class=\"number\">2048</span>, <span class=\"literal\">NULL</span>, <span class=\"number\">5</span>, <span class=\"literal\">NULL</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">\t</span><br></pre></td></tr></table></figure>\n\n<p>效果如图</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509101016442.png\" alt=\"image-20250910101607354\"></p>\n<h4 id=\"队列\"><a href=\"#队列\" class=\"headerlink\" title=\"队列\"></a>队列</h4><blockquote>\n<p>队列特性：先进先出</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">QueueHandle_t queue_handle = <span class=\"literal\">NULL</span>; <span class=\"comment\">// 创建队列句柄</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 创建一个队列</span></span><br><span class=\"line\"><span class=\"comment\"> * @param uxQueueLength 队列长度</span></span><br><span class=\"line\"><span class=\"comment\"> * @param uxItemSize 每个元素的大小(单位是字节)</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">QueueHandle_t <span class=\"title function_\">xQueueCreate</span><span class=\"params\">(UBaseType_t uxQueueLength, UBaseType_t uxItemSize)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 向队列头部发送数据</span></span><br><span class=\"line\"><span class=\"comment\"> * @param xQueue 队列句柄</span></span><br><span class=\"line\"><span class=\"comment\"> * @param pvItemToQueue 要发送的数据的指针</span></span><br><span class=\"line\"><span class=\"comment\"> * @param xTicksToWait 等待的时间(单位是tick)</span></span><br><span class=\"line\"><span class=\"comment\"> * @return 如果在等待时间内发送成功返回pdTRUE，否则返回errQUEUE_FULL</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">BaseType_t <span class=\"title function_\">xQueueSend</span><span class=\"params\">(QueueHandle_t xQueue, <span class=\"type\">const</span> <span class=\"type\">void</span> *pvItemToQueue, TickType_t xTicksToWait)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 向队列尾部发送数据（新数据放在队尾）</span></span><br><span class=\"line\"><span class=\"comment\"> * @param xQueue 队列句柄</span></span><br><span class=\"line\"><span class=\"comment\"> * @param pvItemToQueue 要发送的数据的指针</span></span><br><span class=\"line\"><span class=\"comment\"> * @param xTicksToWait 等待的时间</span></span><br><span class=\"line\"><span class=\"comment\"> * @return pdTRUE 如果发送成功</span></span><br><span class=\"line\"><span class=\"comment\"> *         errQUEUE_FULL 如果队列已满，发送失败</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">BaseType_t <span class=\"title function_\">xQueueSendToBack</span><span class=\"params\">(QueueHandle_t xQueue, <span class=\"type\">const</span> <span class=\"type\">void</span> *pvItemToQueue, TickType_t xTicksToWait)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 从队列中接收数据</span></span><br><span class=\"line\"><span class=\"comment\"> * @param xQueue 队列句柄</span></span><br><span class=\"line\"><span class=\"comment\"> * @param pvBuffer 用于存储接收数据的缓冲区</span></span><br><span class=\"line\"><span class=\"comment\"> * @param xTicksToWait 等待数据的最大时间，以系统节拍为单位</span></span><br><span class=\"line\"><span class=\"comment\"> * @return pdPASS 表示接收成功，errQUEUE_EMPTY 表示队列为空且等待超时，接收失败。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">BaseType_t <span class=\"title function_\">xQueueReceive</span><span class=\"params\">(QueueHandle_t xQueue, <span class=\"type\">void</span> *pvBuffer, TickType_t xTicksToWait)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 该函数在中断中使用，从队列发送数据 这个函数的行为和普通的 xQueueSend 有差异，且不允许阻塞（等待）</span></span><br><span class=\"line\"><span class=\"comment\"> * @param xQueue 队列句柄</span></span><br><span class=\"line\"><span class=\"comment\"> * @param pvItemToQueue 要发送的数据</span></span><br><span class=\"line\"><span class=\"comment\"> * @param pxHigherPriorityTaskWoken 如果发送数据后，有更高优先级的任务被唤醒，则该参数会被置为pdTRUE</span></span><br><span class=\"line\"><span class=\"comment\"> * @return 如果发送成功，返回pdTRUE，否则返回errQUEUE_FULL</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">BaseType_t <span class=\"title function_\">xQueueSendFromISR</span><span class=\"params\">(QueueHandle_t xQueue, <span class=\"type\">const</span> <span class=\"type\">void</span> *pvItemToQueue, BaseType_t *pxHigherPriorityTaskWoken)</span>;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"调用示例\"><a href=\"#调用示例\" class=\"headerlink\" title=\"调用示例\"></a>调用示例</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;freertos/FreeRTOS.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;freertos/task.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;freertos/queue.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;esp_log.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">QueueHandle_t queue_handle = <span class=\"literal\">NULL</span>; <span class=\"comment\">// 定义一个队列句柄</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"type\">int</span> value;</span><br><span class=\"line\">&#125; <span class=\"type\">queue_date_t</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">taskA</span><span class=\"params\">(<span class=\"type\">void</span> *param)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 从队列里面接收数据，并打印</span></span><br><span class=\"line\">    <span class=\"type\">queue_date_t</span> data;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (xQueueReceive(queue_handle, &amp;data, <span class=\"number\">100</span>) == pdTRUE) <span class=\"comment\">// 从队列中接收数据，阻塞等待</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            ESP_LOGI(<span class=\"string\">&quot;re_queue&quot;</span>, <span class=\"string\">&quot;receive queue value:%d&quot;</span>, data.value); <span class=\"comment\">// 前面是一个TAG标签，后面是打印内容 他会自动回车换行</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">taskB</span><span class=\"params\">(<span class=\"type\">void</span> *param)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">queue_date_t</span> data;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(&amp;data, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(data));</span><br><span class=\"line\">    <span class=\"comment\">// 每隔1s向队列里面发送数据</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        xQueueSendToBack(queue_handle, &amp;data, <span class=\"number\">100</span>); <span class=\"comment\">// 向队列中发送数据，阻塞等待</span></span><br><span class=\"line\">        vTaskDelay(pdMS_TO_TICKS(<span class=\"number\">1000</span>));            <span class=\"comment\">// 延时1s</span></span><br><span class=\"line\">        data.value++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">app_main</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    queue_handle = xQueueCreate(<span class=\"number\">10</span>, <span class=\"keyword\">sizeof</span>(<span class=\"type\">queue_date_t</span>)); <span class=\"comment\">// 创建一个队列，队列长度为10，每个元素的大小为queue_date_t结构体的大小</span></span><br><span class=\"line\">    xTaskCreatePinnedToCore(taskA, <span class=\"string\">&quot;re_queue&quot;</span>, <span class=\"number\">2048</span>, <span class=\"literal\">NULL</span>, <span class=\"number\">3</span>, <span class=\"literal\">NULL</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">    xTaskCreatePinnedToCore(taskB, <span class=\"string\">&quot;se_queue&quot;</span>, <span class=\"number\">2048</span>, <span class=\"literal\">NULL</span>, <span class=\"number\">3</span>, <span class=\"literal\">NULL</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509101107988.png\" alt=\"image-20250910110704875\"></p>\n</blockquote>\n<h4 id=\"信号量\"><a href=\"#信号量\" class=\"headerlink\" title=\"信号量\"></a>信号量</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 创建一个二值信号量</span></span><br><span class=\"line\"><span class=\"comment\"> * @return SemaphoreHandle_t 信号量句柄</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">SemaphoreHandle_t <span class=\"title function_\">xSemaphoreCreateBinary</span><span class=\"params\">(<span class=\"type\">void</span>)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 创建一个计数信号量</span></span><br><span class=\"line\"><span class=\"comment\"> * @param uxMaxCount 计数信号量的最大值</span></span><br><span class=\"line\"><span class=\"comment\"> * @param uxInitialCount 计数信号量的初始值</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">SemaphoreHandle_t <span class=\"title function_\">xSemaphoreCreateCounting</span><span class=\"params\">(UBaseType_t uxMaxCount, UBaseType_t uxInitialCount)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 创建一个互斥锁</span></span><br><span class=\"line\"><span class=\"comment\"> * @return SemaphoreHandle_t 互斥锁句柄</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">SemaphoreHandle_t <span class=\"title function_\">xSemaphoreCreateMutex</span><span class=\"params\">(<span class=\"type\">void</span>)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 取得一个信号量</span></span><br><span class=\"line\"><span class=\"comment\"> * @param xSemaphore 信号量句柄</span></span><br><span class=\"line\"><span class=\"comment\"> * @param xTicksToWait 等待信号量的时间，单位为ticks</span></span><br><span class=\"line\"><span class=\"comment\"> * @return 如果成功取得信号量则返回pdTRUE，否则返回pdFALSE</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">BaseType_t <span class=\"title function_\">xSemaphoreTake</span><span class=\"params\">(SemaphoreHandle_t xSemaphore, TickType_t xTicksToWait)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 释放一个信号量</span></span><br><span class=\"line\"><span class=\"comment\"> * @param xSemaphore 信号量句柄</span></span><br><span class=\"line\"><span class=\"comment\"> * @return 如果成功释放信号量则返回pdTRUE，否则返回pdFALSE</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">BaseType_t <span class=\"title function_\">xSemaphoreGive</span><span class=\"params\">(SemaphoreHandle_t xSemaphore)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 删除一个信号量</span></span><br><span class=\"line\"><span class=\"comment\"> * @param xSemaphore 要删除的信号量句柄</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">vSemaphoreDelete</span><span class=\"params\">(SemaphoreHandle_t xSemaphore)</span>;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"调用示例-1\"><a href=\"#调用示例-1\" class=\"headerlink\" title=\"调用示例\"></a>调用示例</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;freertos/FreeRTOS.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;freertos/task.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;freertos/queue.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;freertos/semphr.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;esp_log.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">SemaphoreHandle_t mutex_handle;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">taskA</span><span class=\"params\">(<span class=\"type\">void</span> *param)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        vTaskDelay(pdMS_TO_TICKS(<span class=\"number\">1000</span>));</span><br><span class=\"line\">        xSemaphoreTake(mutex_handle, portMAX_DELAY);</span><br><span class=\"line\">        ESP_LOGI(<span class=\"string\">&quot;TASK_A&quot;</span>, <span class=\"string\">&quot;Task A is running&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        xSemaphoreGive(mutex_handle);</span><br><span class=\"line\">        vTaskDelay(pdMS_TO_TICKS(<span class=\"number\">10</span>)); <span class=\"comment\">// 给其他任务机会</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">taskB</span><span class=\"params\">(<span class=\"type\">void</span> *param)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        vTaskDelay(pdMS_TO_TICKS(<span class=\"number\">500</span>));</span><br><span class=\"line\">        xSemaphoreTake(mutex_handle, portMAX_DELAY);</span><br><span class=\"line\">        ESP_LOGI(<span class=\"string\">&quot;TASK_B&quot;</span>, <span class=\"string\">&quot;Task B is running&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        xSemaphoreGive(mutex_handle);</span><br><span class=\"line\">        vTaskDelay(pdMS_TO_TICKS(<span class=\"number\">10</span>)); <span class=\"comment\">// 给其他任务机会</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">app_main</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    mutex_handle = xSemaphoreCreateMutex();</span><br><span class=\"line\">    xTaskCreatePinnedToCore(taskA, <span class=\"string\">&quot;taskA&quot;</span>, <span class=\"number\">2048</span>, <span class=\"literal\">NULL</span>, <span class=\"number\">6</span>, <span class=\"literal\">NULL</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">    xTaskCreatePinnedToCore(taskB, <span class=\"string\">&quot;taskB&quot;</span>, <span class=\"number\">2048</span>, <span class=\"literal\">NULL</span>, <span class=\"number\">4</span>, <span class=\"literal\">NULL</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意释放信号量的时候 一般会给个延时 不加的话任务会马上回到<code>while(1)</code>初始的时候 反应出来的现象就是一直是A任务运行</p>\n<p>原因：RTOS任务调度需要时间 并且最少只能是10ms 已测试</p>\n</blockquote>\n<h4 id=\"事件组\"><a href=\"#事件组\" class=\"headerlink\" title=\"事件组\"></a>事件组</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 创建事件组</span></span><br><span class=\"line\"><span class=\"comment\"> * @return EventGroupHandle_t 事件组句柄</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">EventGroupHandle_t <span class=\"title function_\">xEventGroupCreate</span><span class=\"params\">(<span class=\"type\">void</span>)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 设置事件位</span></span><br><span class=\"line\"><span class=\"comment\"> * @param xEventGroup 事件组句柄</span></span><br><span class=\"line\"><span class=\"comment\"> * @param uxBitsToSet 要设置的事件位</span></span><br><span class=\"line\"><span class=\"comment\"> * @return 设置后事件组的值</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">EventBits_t <span class=\"title function_\">xEventGroupSetBits</span><span class=\"params\">(EventGroupHandle_t xEventGroup, <span class=\"type\">const</span> EventBits_t uxBitsToSet)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 事件组等待位函数</span></span><br><span class=\"line\"><span class=\"comment\"> * @param xEventGroup 事件组句柄</span></span><br><span class=\"line\"><span class=\"comment\"> * @param uxBitsToWaitFor 等待的事件位</span></span><br><span class=\"line\"><span class=\"comment\"> * @param xClearOnExit 退出时是否清除事件位 pdTRUE or pdFALSE</span></span><br><span class=\"line\"><span class=\"comment\"> * @param xWaitForAllBits 是否等待所有位 pdTRUE or pdFALSE</span></span><br><span class=\"line\"><span class=\"comment\"> * @param xTicksToWait 等待的最大时间</span></span><br><span class=\"line\"><span class=\"comment\"> * @return 返回实际获得的事件位</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">EventBits_t <span class=\"title function_\">xEventGroupWaitBits</span><span class=\"params\">(<span class=\"type\">const</span> EventGroupHandle_t xEventGroup,</span></span><br><span class=\"line\"><span class=\"params\">                                <span class=\"type\">const</span> EventBits_t uxBitsToWaitFor,</span></span><br><span class=\"line\"><span class=\"params\">                                <span class=\"type\">const</span> BaseType_t xClearOnExit,</span></span><br><span class=\"line\"><span class=\"params\">                                <span class=\"type\">const</span> BaseType_t xWaitForAllBits,</span></span><br><span class=\"line\"><span class=\"params\">                                TickType_t xTicksToWait)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 清除事件组指定事件位</span></span><br><span class=\"line\"><span class=\"comment\"> * @param xEventGroup 事件组句柄</span></span><br><span class=\"line\"><span class=\"comment\"> * @param uxBitsToClear 要清除的事件位</span></span><br><span class=\"line\"><span class=\"comment\"> * @return 清除前的事件组位值</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">EventBits_t <span class=\"title function_\">xEventGroupClearBits</span><span class=\"params\">(EventGroupHandle_t xEventGroup, <span class=\"type\">const</span> EventBits_t uxBitsToClear)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 以下使用消息直达机制*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 任务通知函数</span></span><br><span class=\"line\"><span class=\"comment\"> * @param xTaskToNotify 任务句柄</span></span><br><span class=\"line\"><span class=\"comment\"> * @param ulValue 发送的值</span></span><br><span class=\"line\"><span class=\"comment\"> * @param eAction 发送的动作 </span></span><br><span class=\"line\"><span class=\"comment\"> *                eNoAction 不改变任务的通知值(即不更新 会一直发送初始值)</span></span><br><span class=\"line\"><span class=\"comment\"> *                eSetBits 将ulValue的值按位或 到任务的通知值中 </span></span><br><span class=\"line\"><span class=\"comment\"> *                eIncrement 将任务的通知值加1</span></span><br><span class=\"line\"><span class=\"comment\"> *                eSetValueWithOverwrite 将任务的通知值设置为ulValue</span></span><br><span class=\"line\"><span class=\"comment\"> *                eSetValueWithoutOverwrite 如果任务的通知值为0，则将其设置为ulValue，否则不改变任务的通知值</span></span><br><span class=\"line\"><span class=\"comment\"> * @return 如果通知成功返回pdPASS，否则返回errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">BaseType_t <span class=\"title function_\">xTaskNotify</span><span class=\"params\">(TaskHandle_t xTaskToNotify,</span></span><br><span class=\"line\"><span class=\"params\">                       <span class=\"type\">uint32_t</span> ulValue,</span></span><br><span class=\"line\"><span class=\"params\">                       eNotifyAction eAction)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 将任务设置为等待接收通知</span></span><br><span class=\"line\"><span class=\"comment\"> * @param ulBitsToClearOnEntry 进入等待前要清除的位</span></span><br><span class=\"line\"><span class=\"comment\"> * @param ulBitsToClearOnExit 退出等待后要清除的位</span></span><br><span class=\"line\"><span class=\"comment\"> * @param pulNotificationValue 指向接收通知值的指针</span></span><br><span class=\"line\"><span class=\"comment\"> * @param xTicksToWait 等待通知的最大时间（以滴答为单位）</span></span><br><span class=\"line\"><span class=\"comment\"> * @return 如果在指定的等待时间内收到通知，则返回pdTRUE；否则返回</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">BaseType_t <span class=\"title function_\">xTaskNotifyWait</span><span class=\"params\">(<span class=\"type\">uint32_t</span> ulBitsToClearOnEntry,</span></span><br><span class=\"line\"><span class=\"params\">                           <span class=\"type\">uint32_t</span> ulBitsToClearOnExit,</span></span><br><span class=\"line\"><span class=\"params\">                           <span class=\"type\">uint32_t</span> *pulNotificationValue,</span></span><br><span class=\"line\"><span class=\"params\">                           TickType_t xTicksToWait)</span>;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"调用示例-2\"><a href=\"#调用示例-2\" class=\"headerlink\" title=\"调用示例\"></a>调用示例</h5><h6 id=\"事件组设置\"><a href=\"#事件组设置\" class=\"headerlink\" title=\"事件组设置\"></a>事件组设置</h6><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;freertos/FreeRTOS.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;freertos/task.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;freertos/queue.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;freertos/semphr.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;freertos/event_groups.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;esp_log.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> EVENT_BIT_0 BIT0</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> EVENT_BIT_1 BIT1</span></span><br><span class=\"line\"></span><br><span class=\"line\">EventGroupHandle_t event_handle;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">taskA</span><span class=\"params\">(<span class=\"type\">void</span> *param)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 定时1s向任务B发送事件消息</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        xEventGroupSetBits(event_handle, EVENT_BIT_0);</span><br><span class=\"line\">        vTaskDelay(pdMS_TO_TICKS(<span class=\"number\">1000</span>));</span><br><span class=\"line\">        xEventGroupSetBits(event_handle, EVENT_BIT_1);</span><br><span class=\"line\">        vTaskDelay(pdMS_TO_TICKS(<span class=\"number\">1000</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">taskB</span><span class=\"params\">(<span class=\"type\">void</span> *param)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    EventBits_t ev;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        ev = xEventGroupWaitBits(event_handle, EVENT_BIT_0 | EVENT_BIT_1, pdTRUE, pdFALSE, pdMS_TO_TICKS(<span class=\"number\">5000</span>));</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ev &amp; EVENT_BIT_0)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            ESP_LOGI(<span class=\"string\">&quot;ev&quot;</span>, <span class=\"string\">&quot;ev get event0&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ev &amp; EVENT_BIT_1)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            ESP_LOGI(<span class=\"string\">&quot;ev&quot;</span>, <span class=\"string\">&quot;ev get event1&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">app_main</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    event_handle = xEventGroupCreate();</span><br><span class=\"line\">    xTaskCreatePinnedToCore(taskA, <span class=\"string\">&quot;taskA&quot;</span>, <span class=\"number\">2048</span>, <span class=\"literal\">NULL</span>, <span class=\"number\">3</span>, <span class=\"literal\">NULL</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">    xTaskCreatePinnedToCore(taskB, <span class=\"string\">&quot;taskB&quot;</span>, <span class=\"number\">2048</span>, <span class=\"literal\">NULL</span>, <span class=\"number\">3</span>, <span class=\"literal\">NULL</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"消息直达\"><a href=\"#消息直达\" class=\"headerlink\" title=\"消息直达\"></a>消息直达</h6><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;freertos/FreeRTOS.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;freertos/task.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;freertos/queue.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;freertos/semphr.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;freertos/event_groups.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;esp_log.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> TaskHandle_t taskA_handle;</span><br><span class=\"line\"><span class=\"type\">static</span> TaskHandle_t taskB_handle;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">taskA</span><span class=\"params\">(<span class=\"type\">void</span> *param)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 定时1s向任务B发送事件消息</span></span><br><span class=\"line\">    <span class=\"type\">uint32_t</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">    vTaskDelay(pdMS_TO_TICKS(<span class=\"number\">100</span>));</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        xTaskNotify(taskB_handle, count, eSetValueWithoutOverwrite);</span><br><span class=\"line\">        count++;</span><br><span class=\"line\">        vTaskDelay(pdMS_TO_TICKS(<span class=\"number\">1000</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">taskB</span><span class=\"params\">(<span class=\"type\">void</span> *param)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">uint32_t</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        xTaskNotifyWait(<span class=\"number\">0</span>, <span class=\"number\">0</span>, &amp;count, portMAX_DELAY);</span><br><span class=\"line\">        ESP_LOGI(<span class=\"string\">&quot;taskB&quot;</span>, <span class=\"string\">&quot;Notify count: %lu&quot;</span>, count);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">app_main</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    xTaskCreatePinnedToCore(taskA, <span class=\"string\">&quot;taskA&quot;</span>, <span class=\"number\">2048</span>, <span class=\"literal\">NULL</span>, <span class=\"number\">3</span>, &amp;taskA_handle, <span class=\"number\">1</span>);</span><br><span class=\"line\">    xTaskCreatePinnedToCore(taskB, <span class=\"string\">&quot;taskB&quot;</span>, <span class=\"number\">2048</span>, <span class=\"literal\">NULL</span>, <span class=\"number\">3</span>, &amp;taskB_handle, <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"ESP-IDF中的FreeRTOS与原生区别\"><a href=\"#ESP-IDF中的FreeRTOS与原生区别\" class=\"headerlink\" title=\"ESP-IDF中的FreeRTOS与原生区别\"></a>ESP-IDF中的FreeRTOS与原生区别</h4><blockquote>\n<ol>\n<li>ESP32是多核的 所以可以完全实现程序并发执行 即不是单核那种 低优先级的任务因为高优先级任务存在而执行不了</li>\n<li>esp-idf自动创建五个任务<ul>\n<li>空闲任务（每个核都会创建一个，<code>优先级为0</code>）</li>\n<li>FreeRTOS定时器任务（<code>优先级为1</code>）</li>\n<li>app_main任务（我们的应用入口，<code>优先级为1</code>）</li>\n<li>IPC任务（每个核创建一个，用于多核协调，<code>优先级为24</code>）</li>\n<li>ESP定时器任务（负责ESP32定时器回调，<code>优先级为22</code>）</li>\n</ul>\n</li>\n<li>esp-idf不使用原生FreeRTOS的内存堆管理，实现了自己的堆</li>\n<li>创建任务使用<code>xTaskCreatePinnedToCore()</code> 可以指定用哪个核创建任务<ul>\n<li>负责处理<code>无线网络的任务（如WiFi蓝牙）</code>将被固定到<code>CPU0</code>，即<code>PRO_CPU</code></li>\n<li>处理<code>应用程序</code>其余部分任务将被固定到<code>CPU1</code>，即<code>APP_CPU</code></li>\n</ul>\n</li>\n<li>如果任务中用到浮点运算，则创建任务的时候必须指定具体运行在哪个核上，不能由系统自动安排</li>\n</ol>\n</blockquote>\n<h2 id=\"GPIO配置\"><a href=\"#GPIO配置\" class=\"headerlink\" title=\"GPIO配置\"></a>GPIO配置</h2><h3 id=\"引脚基础配置\"><a href=\"#引脚基础配置\" class=\"headerlink\" title=\"引脚基础配置\"></a>引脚基础配置</h3><h4 id=\"gpio-config-：批量配置-GPIO（核心入口）\"><a href=\"#gpio-config-：批量配置-GPIO（核心入口）\" class=\"headerlink\" title=\"gpio_config()：批量配置 GPIO（核心入口）\"></a><code>gpio_config()</code>：批量配置 GPIO（核心入口）</h4><ul>\n<li><p><strong>函数原型</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">esp_err_t</span> <span class=\"title function_\">gpio_config</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">gpio_config_t</span> *pGPIOConfig)</span>;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>作用</strong>：一次性配置一组 GPIO 的模式、上下拉、中断类型（覆盖该引脚当前所有配置）。</p>\n</li>\n<li><p><strong>参数</strong>：<code>pGPIOConfig</code>：指向 <code>gpio_config_t</code> 结构体的指针（需提前初始化）。</p>\n</li>\n<li><p><strong>返回值</strong>：<code>ESP_OK</code>（成功）、<code>ESP_ERR_INVALID_ARG</code>（参数错误，如引脚无效）。</p>\n</li>\n<li><p><strong>示例</strong>：配置 GPIO2、GPIO3 为输出模式，禁用上下拉和中断：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">gpio_config_t</span> io_conf = &#123;</span><br><span class=\"line\">    .pin_bit_mask = (<span class=\"number\">1ULL</span> &lt;&lt; GPIO_NUM_2) | (<span class=\"number\">1ULL</span> &lt;&lt; GPIO_NUM_3),  <span class=\"comment\">// 仅配置 GPIO2</span></span><br><span class=\"line\">    .mode = GPIO_MODE_OUTPUT,</span><br><span class=\"line\">    .pull_up_en = GPIO_PULLUP_DISABLE,</span><br><span class=\"line\">    .pull_down_en = GPIO_PULLDOWN_DISABLE,</span><br><span class=\"line\">    .intr_type = GPIO_INTR_DISABLE</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">gpio_config(&amp;io_conf);  <span class=\"comment\">// 执行配置</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n<blockquote>\n<p><code>intr_type</code> :</p>\n<ul>\n<li><code>GPIO_INTR_DISABLE</code>：禁用中断</li>\n<li><code>GPIO_INTR_POSEDGE</code>：上升沿触发</li>\n<li><code>GPIO_INTR_NEGEDGE</code>：下降沿触发</li>\n<li><code>GPIO_INTR_ANYEDGE</code>：双边沿触发</li>\n<li><code>GPIO_INTR_LOW_LEVEL</code>：低电平触发</li>\n<li><code>GPIO_INTR_HIGH_LEVEL</code>：高电平触发</li>\n</ul>\n</blockquote>\n<h4 id=\"gpio-reset-pin-：重置引脚为默认状态\"><a href=\"#gpio-reset-pin-：重置引脚为默认状态\" class=\"headerlink\" title=\"gpio_reset_pin()：重置引脚为默认状态\"></a><code>gpio_reset_pin()</code>：重置引脚为默认状态</h4><ul>\n<li><p><strong>函数原型</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">esp_err_t</span> <span class=\"title function_\">gpio_reset_pin</span><span class=\"params\">(<span class=\"type\">gpio_num_t</span> gpio_num)</span>;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>作用</strong>：将指定 GPIO 重置为默认状态（输入模式、禁用上下拉、禁用中断、选择 GPIO 功能）。</p>\n</li>\n<li><p><strong>参数</strong>：<code>gpio_num</code>：要重置的 GPIO 编号（如 <code>GPIO_NUM_4</code>）。</p>\n</li>\n<li><p><strong>示例</strong>：重置 GPIO4，恢复初始状态：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gpio_reset_pin(GPIO_NUM_4);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h4 id=\"gpio-set-direction-：单独设置引脚方向\"><a href=\"#gpio-set-direction-：单独设置引脚方向\" class=\"headerlink\" title=\"gpio_set_direction()：单独设置引脚方向\"></a><code>gpio_set_direction()</code>：单独设置引脚方向</h4><ul>\n<li><p><strong>函数原型</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">esp_err_t</span> <span class=\"title function_\">gpio_set_direction</span><span class=\"params\">(<span class=\"type\">gpio_num_t</span> gpio_num, <span class=\"type\">gpio_mode_t</span> mode)</span>;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>作用</strong>：单独修改某个 GPIO 的模式（输入 &#x2F; 输出 &#x2F; 输入输出），覆盖当前模式。</p>\n</li>\n<li><p><strong>参数</strong></p>\n<ul>\n<li><code>gpio_num</code>：目标 GPIO 编号。</li>\n<li><code>mode</code>：目标模式（如 <code>GPIO_MODE_INPUT</code>）。</li>\n</ul>\n</li>\n<li><p><strong>示例</strong>：将已配置的 GPIO2 改为输入模式</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gpio_set_direction(GPIO_NUM_2, GPIO_MODE_INPUT);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h4 id=\"配置上下拉函数（gpio-pullup-en-gpio-pulldown-en）\"><a href=\"#配置上下拉函数（gpio-pullup-en-gpio-pulldown-en）\" class=\"headerlink\" title=\"配置上下拉函数（gpio_pullup_en&#x2F;gpio_pulldown_en）\"></a>配置上下拉函数（<code>gpio_pullup_en</code>&#x2F;<code>gpio_pulldown_en</code>）</h4><ul>\n<li><p><strong>函数原型</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">esp_err_t</span> <span class=\"title function_\">gpio_pullup_en</span><span class=\"params\">(<span class=\"type\">gpio_num_t</span> gpio_num)</span>;    <span class=\"comment\">// 启用上拉</span></span><br><span class=\"line\"><span class=\"type\">esp_err_t</span> <span class=\"title function_\">gpio_pullup_dis</span><span class=\"params\">(<span class=\"type\">gpio_num_t</span> gpio_num)</span>;   <span class=\"comment\">// 禁用上拉</span></span><br><span class=\"line\"><span class=\"type\">esp_err_t</span> <span class=\"title function_\">gpio_pulldown_en</span><span class=\"params\">(<span class=\"type\">gpio_num_t</span> gpio_num)</span>;  <span class=\"comment\">// 启用下拉</span></span><br><span class=\"line\"><span class=\"type\">esp_err_t</span> <span class=\"title function_\">gpio_pulldown_dis</span><span class=\"params\">(<span class=\"type\">gpio_num_t</span> gpio_num)</span>; <span class=\"comment\">// 禁用下拉</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>作用</strong>：比 <code>gpio_set_pull_mode</code> 更直观，单独控制上拉 &#x2F; 下拉的启用 &#x2F; 禁用。</p>\n</li>\n<li><p><strong>示例</strong>：启用 GPIO0 下拉，禁用上拉：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gpio_pulldown_en(GPIO_NUM_0);</span><br><span class=\"line\">gpio_pullup_dis(GPIO_NUM_0);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"引脚电平控制函数\"><a href=\"#引脚电平控制函数\" class=\"headerlink\" title=\"引脚电平控制函数\"></a>引脚电平控制函数</h3><h4 id=\"gpio-set-level-：设置输出电平\"><a href=\"#gpio-set-level-：设置输出电平\" class=\"headerlink\" title=\"gpio_set_level()：设置输出电平\"></a><code>gpio_set_level()</code>：设置输出电平</h4><ul>\n<li><p><strong>函数原型</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">esp_err_t</span> <span class=\"title function_\">gpio_set_level</span><span class=\"params\">(<span class=\"type\">gpio_num_t</span> gpio_num, <span class=\"type\">uint32_t</span> level)</span>;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>作用</strong>：给输出模式的 GPIO 设置高 &#x2F; 低电平（仅输出模式有效）。</p>\n</li>\n<li><p><strong>参数</strong>：</p>\n<ul>\n<li><code>level</code>：<code>0</code>（低电平）、<code>1</code>（高电平）。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"gpio-get-level-：读取输入电平\"><a href=\"#gpio-get-level-：读取输入电平\" class=\"headerlink\" title=\"gpio_get_level()：读取输入电平\"></a><code>gpio_get_level()</code>：读取输入电平</h4><ul>\n<li><p><strong>函数原型</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">gpio_get_level</span><span class=\"params\">(<span class=\"type\">gpio_num_t</span> gpio_num)</span>;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>作用</strong>：读取 GPIO 的当前输入电平（需引脚为输入 &#x2F; 输入输出模式，否则返回 0）。</p>\n</li>\n<li><p><strong>返回值</strong>：<code>0</code>（低电平）、<code>1</code>（高电平）。</p>\n</li>\n</ul>\n<h2 id=\"LEDC库学习笔记\"><a href=\"#LEDC库学习笔记\" class=\"headerlink\" title=\"LEDC库学习笔记\"></a>LEDC库学习笔记</h2><blockquote>\n<p><strong>定义</strong>：LEDC（Light Emitting Diode Controller）是 ESP32 内置的 LED 控制器，核心功能是生成 PWM（脉冲宽度调制）信号，不仅用于 LED 亮度调节，还可驱动电机、舵机等需 PWM 信号的设备。</p>\n<p><strong>核心优势</strong>：无需手动编写定时器中断逻辑，ESP-IDF 提供完整库接口，配置简单、信号稳定</p>\n<p><strong>注意</strong>：LEDC 控制器有自己<code>专属的 4 个定时器</code>（<code>LEDC_TIMER_0</code> ~ <code>LEDC_TIMER_3</code>），这些定时器是 LEDC 模块内部集成的，专门用于生成 PWM 信号。</p>\n<p>与<code>通用定时器（TIMER_0 ~ TIMER_3）</code>完全分离</p>\n</blockquote>\n<h3 id=\"LEDC关键概念\"><a href=\"#LEDC关键概念\" class=\"headerlink\" title=\"LEDC关键概念\"></a>LEDC关键概念</h3><table>\n<thead>\n<tr>\n<th>概念</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>通道（Channel）</td>\n<td>ESP32 有 16 个独立通道，每个通道可独立配置 PWM 参数（频率、占空比），并映射到 1 个 GPIO 引脚输出信号。</td>\n</tr>\n<tr>\n<td>定时器（Timer）</td>\n<td>每个通道需绑定定时器，定时器决定 PWM 频率（由预分频和计数范围计算），多个通道可共享同一定时器（频率相同）。</td>\n</tr>\n<tr>\n<td>频率（Frequency）</td>\n<td>PWM 信号周期的倒数（单位：Hz），如 50Hz（舵机常用，对应 20ms 周期）、1000Hz（LED 常用，避免人眼闪烁）。</td>\n</tr>\n<tr>\n<td>占空比（Duty Cycle）</td>\n<td>PWM 高电平持续时间与周期的比值（0<del>100%），LEDC 中用数值表示（如 12 位分辨率对应 0</del>4095）。</td>\n</tr>\n<tr>\n<td>分辨率（Duty Resolution）</td>\n<td>占空比的可调精度，范围 <code>LEDC_TIMER_1_BIT</code><del><code>LEDC_TIMER_20_BIT</code>，如 12 位表示占空比可设为 0</del>4095（共 4096 级）。</td>\n</tr>\n<tr>\n<td>速度模式</td>\n<td>分 <code>LEDC_LOW_SPEED_MODE</code>（低速模式）和 <code>LEDC_HIGH_SPEED_MODE</code>（高速模式），高速模式支持更高 PWM 频率。</td>\n</tr>\n</tbody></table>\n<h3 id=\"常用API（需包含头文件-driver-ledc-h）\"><a href=\"#常用API（需包含头文件-driver-ledc-h）\" class=\"headerlink\" title=\"常用API（需包含头文件 driver/ledc.h）\"></a>常用API（需包含头文件 <code>driver/ledc.h</code>）</h3><h4 id=\"定时器初始化\"><a href=\"#定时器初始化\" class=\"headerlink\" title=\"定时器初始化\"></a>定时器初始化</h4><ul>\n<li><p><strong>作用</strong>：初始化 LEDC 定时器，设置频率、分辨率等核心参数。</p>\n</li>\n<li><p>函数原型</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">esp_err_t</span> <span class=\"title function_\">ledc_timer_config</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">ledc_timer_config_t</span> *timer_conf)</span>;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>参数结构体 <code>ledc_timer_config_t</code> 说明</strong>：</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>取值 &#x2F; 说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>speed_mode</code></td>\n<td>速度模式：<code>LEDC_LOW_SPEED_MODE</code> 或 <code>LEDC_HIGH_SPEED_MODE</code></td>\n</tr>\n<tr>\n<td><code>duty_resolution</code></td>\n<td>占空比分辨率：<code>LEDC_TIMER_1_BIT</code> ~ <code>LEDC_TIMER_20_BIT</code>（如 12 位选 <code>LEDC_TIMER_12_BIT</code>）</td>\n</tr>\n<tr>\n<td><code>timer_num</code></td>\n<td>定时器编号：<code>LEDC_TIMER_0</code> ~ <code>LEDC_TIMER_3</code>（共 4 个定时器）</td>\n</tr>\n<tr>\n<td><code>freq_hz</code></td>\n<td>PWM 频率（如 50、1000，单位：Hz）</td>\n</tr>\n<tr>\n<td><code>clk_cfg</code></td>\n<td>时钟源：通常用 <code>LEDC_AUTO_CLK</code>（自动选择最优时钟）</td>\n</tr>\n</tbody></table>\n</li>\n<li><p><strong>示例</strong>：配置 1000Hz、12 位分辨率的定时器 0（低速模式）</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">ledc_timer_config_t</span> timer_conf = &#123;</span><br><span class=\"line\">    .speed_mode = LEDC_LOW_SPEED_MODE,</span><br><span class=\"line\">    .duty_resolution = LEDC_TIMER_12_BIT,  <span class=\"comment\">// 0~4095 级占空比</span></span><br><span class=\"line\">    .timer_num = LEDC_TIMER_0,</span><br><span class=\"line\">    .freq_hz = <span class=\"number\">1000</span>,                       <span class=\"comment\">// 1000Hz 频率</span></span><br><span class=\"line\">    .clk_cfg = LEDC_AUTO_CLK</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">ledc_timer_config(&amp;timer_conf);  <span class=\"comment\">// 执行配置</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n<h4 id=\"通道配置：ledc-channel-config\"><a href=\"#通道配置：ledc-channel-config\" class=\"headerlink\" title=\"通道配置：ledc_channel_config()\"></a>通道配置：<code>ledc_channel_config()</code></h4><h4 id=\"通道配置：ledc-channel-config-1\"><a href=\"#通道配置：ledc-channel-config-1\" class=\"headerlink\" title=\"通道配置：ledc_channel_config()\"></a>通道配置：<code>ledc_channel_config()</code></h4><ul>\n<li><p><strong>作用</strong>：将 LEDC 通道绑定到定时器和 GPIO 引脚，设置初始占空比。</p>\n</li>\n<li><p><strong>函数原型</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">esp_err_t</span> <span class=\"title function_\">ledc_channel_config</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">ledc_channel_config_t</span> *channel_conf)</span>;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>参数结构体</strong> <code>ledc_channel_config_t</code> <strong>说明</strong></p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>取值 &#x2F; 说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>speed_mode</code></td>\n<td>需与绑定的定时器速度模式一致（如 <code>LEDC_LOW_SPEED_MODE</code>）</td>\n</tr>\n<tr>\n<td><code>channel</code></td>\n<td>通道编号：<code>LEDC_CHANNEL_0</code> ~ <code>LEDC_CHANNEL_15</code>（共 16 个通道）</td>\n</tr>\n<tr>\n<td><code>timer_sel</code></td>\n<td>绑定的定时器编号（如 <code>LEDC_TIMER_0</code>）</td>\n</tr>\n<tr>\n<td><code>intr_type</code></td>\n<td>中断类型：通常设 <code>LEDC_INTR_DISABLE</code>（禁用中断）</td>\n</tr>\n<tr>\n<td><code>gpio_num</code></td>\n<td>输出 PWM 的 GPIO 引脚（如 <code>GPIO_NUM_2</code>、<code>GPIO_NUM_4</code>）</td>\n</tr>\n<tr>\n<td><code>duty</code></td>\n<td>初始占空比（0 ~ 分辨率最大值，如 12 位初始为 0 表示 LED 灭）</td>\n</tr>\n<tr>\n<td><code>hpoint</code></td>\n<td>脉冲起点偏移：通常设 0（无偏移）</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>示例</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">ledc_channel_config_t</span> channel_conf = &#123;</span><br><span class=\"line\">    .speed_mode = LEDC_LOW_SPEED_MODE,</span><br><span class=\"line\">    .channel = LEDC_CHANNEL_0,</span><br><span class=\"line\">    .timer_sel = LEDC_TIMER_0,  <span class=\"comment\">// 绑定定时器 0</span></span><br><span class=\"line\">    .intr_type = LEDC_INTR_DISABLE,</span><br><span class=\"line\">    .gpio_num = GPIO_NUM_2,     <span class=\"comment\">// GPIO2 输出 PWM</span></span><br><span class=\"line\">    .duty = <span class=\"number\">0</span>,                  <span class=\"comment\">// 初始占空比 0（LED 不亮）</span></span><br><span class=\"line\">    .hpoint = <span class=\"number\">0</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">ledc_channel_config(&amp;channel_conf);  <span class=\"comment\">// 执行配置</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n<h4 id=\"3-占空比修改：ledc-set-duty-ledc-update-duty\"><a href=\"#3-占空比修改：ledc-set-duty-ledc-update-duty\" class=\"headerlink\" title=\"3. 占空比修改：ledc_set_duty() + ledc_update_duty()\"></a>3. 占空比修改：<code>ledc_set_duty()</code> + <code>ledc_update_duty()</code></h4><ul>\n<li><p><strong>作用</strong>：动态调整通道的 PWM 占空比（<code>ledc_set_duty</code> 仅修改寄存器，<code>ledc_update_duty</code> 使修改生效）。</p>\n</li>\n<li><p><strong>函数原型</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1. 设置占空比（不立即生效）</span></span><br><span class=\"line\"><span class=\"type\">esp_err_t</span> <span class=\"title function_\">ledc_set_duty</span><span class=\"params\">(<span class=\"type\">ledc_mode_t</span> speed_mode, <span class=\"type\">ledc_channel_t</span> channel, <span class=\"type\">uint32_t</span> duty)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 2. 使占空比生效</span></span><br><span class=\"line\"><span class=\"type\">esp_err_t</span> <span class=\"title function_\">ledc_update_duty</span><span class=\"params\">(<span class=\"type\">ledc_mode_t</span> speed_mode, <span class=\"type\">ledc_channel_t</span> channel)</span>;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>参数说明</strong></p>\n<ul>\n<li><code>speed_mode</code>：速度模式（与通道一致）</li>\n<li><code>channel</code>：目标通道编号</li>\n<li><code>duty</code>：目标占空比（0 ~ 分辨率最大值）</li>\n</ul>\n</li>\n<li><p><strong>示例</strong>：将通道 0 占空比设为 50%（12 位分辨率对应 2048）</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 12 位分辨率下，50% 占空比 = 4096 / 2 = 2048</span></span><br><span class=\"line\">ledc_set_duty(LEDC_LOW_SPEED_MODE, LEDC_CHANNEL_0, <span class=\"number\">2048</span>);</span><br><span class=\"line\">ledc_update_duty(LEDC_LOW_SPEED_MODE, LEDC_CHANNEL_0);  <span class=\"comment\">// 占空比生效</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n<h4 id=\"4-硬件渐变：ledc-fade-系列函数\"><a href=\"#4-硬件渐变：ledc-fade-系列函数\" class=\"headerlink\" title=\"4. 硬件渐变：ledc_fade_* 系列函数\"></a>4. 硬件渐变：<code>ledc_fade_*</code> 系列函数</h4><ul>\n<li><p><strong>作用</strong>：实现硬件自动渐变（无需软件循环），适合 LED 呼吸灯、平滑调光等场景。</p>\n</li>\n<li><p><strong>核心函数</strong>：</p>\n<table>\n<thead>\n<tr>\n<th>函数</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>ledc_fade_func_install()</code></td>\n<td>初始化渐变功能（需开启中断，参数 0 表示不使用中断回调）</td>\n</tr>\n<tr>\n<td><code>ledc_set_fade_with_time()</code></td>\n<td>配置渐变参数（目标占空比、渐变时间）</td>\n</tr>\n<tr>\n<td><code>ledc_fade_start()</code></td>\n<td>启动渐变（可选择阻塞 &#x2F; 非阻塞模式）</td>\n</tr>\n<tr>\n<td><code>ledc_cb_register()</code></td>\n<td>注册 LEDC 回调函数</td>\n</tr>\n</tbody></table>\n</li>\n<li><p><strong>函数原型</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1. 初始化渐变功能</span></span><br><span class=\"line\"><span class=\"type\">esp_err_t</span> <span class=\"title function_\">ledc_fade_func_install</span><span class=\"params\">(<span class=\"type\">int</span> intr_alloc_flags)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 2. 配置渐变：在指定时间内从当前占空比渐变到目标占空比</span></span><br><span class=\"line\"><span class=\"type\">esp_err_t</span> <span class=\"title function_\">ledc_set_fade_with_time</span><span class=\"params\">(<span class=\"type\">ledc_mode_t</span> speed_mode, <span class=\"type\">ledc_channel_t</span> channel, <span class=\"type\">uint32_t</span> target_duty, <span class=\"type\">uint32_t</span> fade_time_ms)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 3. 启动渐变</span></span><br><span class=\"line\"><span class=\"type\">esp_err_t</span> <span class=\"title function_\">ledc_fade_start</span><span class=\"params\">(<span class=\"type\">ledc_mode_t</span> speed_mode, <span class=\"type\">ledc_channel_t</span> channel, <span class=\"type\">ledc_fade_mode_t</span> fade_mode)</span>;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>参数说明</strong>：</p>\n<ul>\n<li><code>intr_alloc_flags</code>：中断分配标志（设 0 即可）</li>\n<li><code>target_duty</code>：渐变目标占空比</li>\n<li><code>fade_time_ms</code>：渐变总时间（单位：ms）</li>\n<li><code>fade_mode</code>：渐变模式：<code>LEDC_FADE_WAIT_DONE</code>（阻塞，等待渐变完成返回）&#x2F; <code>LEDC_FADE_NO_WAIT</code>（非阻塞）</li>\n</ul>\n</li>\n<li><p><strong>示例</strong>：2 秒内从当前占空比渐变到最大亮度（12 位对应 4095）</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1. 初始化渐变功能</span></span><br><span class=\"line\">ledc_fade_func_install(<span class=\"number\">0</span>);  <span class=\"comment\">// 不使用中断回调</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2. 配置渐变：2000ms（2秒）内渐变到 4095（最大亮度）</span></span><br><span class=\"line\">ledc_set_fade_with_time(LEDC_LOW_SPEED_MODE, </span><br><span class=\"line\">                        LEDC_CHANNEL_0, </span><br><span class=\"line\">                        <span class=\"number\">4095</span>,        <span class=\"comment\">// 目标占空比（最大）</span></span><br><span class=\"line\">                        <span class=\"number\">2000</span>);       <span class=\"comment\">// 渐变时间（ms）</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 3. 启动渐变（阻塞模式，等待渐变完成后再执行后续代码）</span></span><br><span class=\"line\">ledc_fade_start(LEDC_LOW_SPEED_MODE, LEDC_CHANNEL_0, LEDC_FADE_WAIT_DONE);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h5 id=\"启用中断模式\"><a href=\"#启用中断模式\" class=\"headerlink\" title=\"启用中断模式\"></a>启用中断模式</h5><ul>\n<li><p><strong>函数原型</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">esp_err_t</span> <span class=\"title function_\">ledc_cb_register</span><span class=\"params\">(<span class=\"type\">ledc_mode_t</span> speed_mode, <span class=\"type\">ledc_channel_t</span> channel, <span class=\"type\">ledc_cbs_t</span> *cbs, <span class=\"type\">void</span> *user_arg)</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>参数结构体</strong> <code>ledc_cbs_t</code> <strong>说明</strong></p>\n<ul>\n<li><code>fade_cb</code>：需要注册的中断回调函数</li>\n</ul>\n</li>\n<li><p><strong>示例</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;freertos/FreeRTOS.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;freertos/task.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;driver/gpio.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;driver/ledc.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LED_GPIO GPIO_NUM_18</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> FULL_EV_BIT BIT0</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> EMPTY_EV_BIT BIT1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> EventGroupHandle_t led_fade_handle;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 重写LEDC完成回调函数</span></span><br><span class=\"line\"><span class=\"comment\"> * @note IRAM_ATTR 修饰符表示该函数在IRAM中执行，中断服务程序中不能调用RAM中的函数</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">bool</span> IRAM_ATTR <span class=\"title function_\">ledc_finish_cb</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">ledc_cb_param_t</span> *param, <span class=\"type\">void</span> *user_arg)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    BaseType_t taskWoken;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (param-&gt;duty)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        xEventGroupSetBitsFromISR(led_fade_handle, FULL_EV_BIT, &amp;taskWoken);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        xEventGroupSetBitsFromISR(led_fade_handle, EMPTY_EV_BIT, &amp;taskWoken);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> taskWoken;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">led_run_task</span><span class=\"params\">(<span class=\"type\">void</span> *param)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    EventBits_t ev;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        ev = xEventGroupWaitBits(led_fade_handle, FULL_EV_BIT | EMPTY_EV_BIT, pdTRUE, pdFALSE, pdMS_TO_TICKS(<span class=\"number\">5000</span>));</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ev &amp; FULL_EV_BIT)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            ledc_set_fade_with_time(LEDC_LOW_SPEED_MODE, LEDC_CHANNEL_0, <span class=\"number\">0</span>, <span class=\"number\">2000</span>);</span><br><span class=\"line\">            ledc_fade_start(LEDC_LOW_SPEED_MODE, LEDC_CHANNEL_0, LEDC_FADE_NO_WAIT);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ev &amp; EMPTY_EV_BIT)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            ledc_set_fade_with_time(LEDC_LOW_SPEED_MODE, LEDC_CHANNEL_0, <span class=\"number\">8191</span>, <span class=\"number\">2000</span>);</span><br><span class=\"line\">            ledc_fade_start(LEDC_LOW_SPEED_MODE, LEDC_CHANNEL_0, LEDC_FADE_NO_WAIT);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">ledc_cbs_t</span> ledc_cbs = &#123;</span><br><span class=\"line\">            .fade_cb = ledc_finish_cb,</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        ledc_cb_register(LEDC_LOW_SPEED_MODE, LEDC_CHANNEL_0, &amp;ledc_cbs, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">app_main</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// gpio_config_t led_cfg = &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//     .pin_bit_mask = (1 &lt;&lt; LED_GPIO),</span></span><br><span class=\"line\">    <span class=\"comment\">//     .pull_down_en = GPIO_PULLDOWN_DISABLE,</span></span><br><span class=\"line\">    <span class=\"comment\">//     .pull_up_en = GPIO_PULLUP_DISABLE,</span></span><br><span class=\"line\">    <span class=\"comment\">//     .intr_type = GPIO_INTR_DISABLE,</span></span><br><span class=\"line\">    <span class=\"comment\">//     .mode = GPIO_MODE_OUTPUT,</span></span><br><span class=\"line\">    <span class=\"comment\">// &#125;;</span></span><br><span class=\"line\">    <span class=\"comment\">// gpio_config(&amp;led_cfg);</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">ledc_timer_config_t</span> ledc_timer = &#123;</span><br><span class=\"line\">        .speed_mode = LEDC_LOW_SPEED_MODE,</span><br><span class=\"line\">        .timer_num = LEDC_TIMER_0,</span><br><span class=\"line\">        .clk_cfg = LEDC_AUTO_CLK,</span><br><span class=\"line\">        .freq_hz = <span class=\"number\">5000</span>,</span><br><span class=\"line\">        .duty_resolution = LEDC_TIMER_13_BIT, <span class=\"comment\">// 占空比分辨率 0-8191</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    ledc_timer_config(&amp;ledc_timer);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">ledc_channel_config_t</span> ledc_channel = &#123;</span><br><span class=\"line\">        .gpio_num = LED_GPIO,</span><br><span class=\"line\">        .channel = LEDC_CHANNEL_0,</span><br><span class=\"line\">        .duty = <span class=\"number\">0</span>,</span><br><span class=\"line\">        .speed_mode = LEDC_LOW_SPEED_MODE,</span><br><span class=\"line\">        .timer_sel = LEDC_TIMER_0,</span><br><span class=\"line\">        .intr_type = LEDC_INTR_DISABLE,</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    ledc_channel_config(&amp;ledc_channel);</span><br><span class=\"line\"></span><br><span class=\"line\">    ledc_fade_func_install(<span class=\"number\">0</span>); <span class=\"comment\">// 使能渐变 不需要自己手动调节占空比</span></span><br><span class=\"line\">    ledc_set_fade_with_time(LEDC_LOW_SPEED_MODE, LEDC_CHANNEL_0, <span class=\"number\">8191</span>, <span class=\"number\">2000</span>);</span><br><span class=\"line\">    ledc_fade_start(LEDC_LOW_SPEED_MODE, LEDC_CHANNEL_0, LEDC_FADE_NO_WAIT);</span><br><span class=\"line\"></span><br><span class=\"line\">    led_fade_handle = xEventGroupCreate();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">ledc_cbs_t</span> ledc_cbs = &#123;</span><br><span class=\"line\">        .fade_cb = ledc_finish_cb,</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    ledc_cb_register(LEDC_LOW_SPEED_MODE, LEDC_CHANNEL_0, &amp;ledc_cbs, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    xTaskCreatePinnedToCore(led_run_task, <span class=\"string\">&quot;led_run_task&quot;</span>, <span class=\"number\">2048</span>, <span class=\"literal\">NULL</span>, <span class=\"number\">3</span>, <span class=\"literal\">NULL</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"UART配置\"><a href=\"#UART配置\" class=\"headerlink\" title=\"UART配置\"></a>UART配置</h2><h3 id=\"ESP32-UART-硬件特性\"><a href=\"#ESP32-UART-硬件特性\" class=\"headerlink\" title=\"ESP32 UART 硬件特性\"></a>ESP32 UART 硬件特性</h3><ul>\n<li><strong>硬件资源</strong>：ESP32 内置 3 个 UART 接口（UART0、UART1、UART2），支持不同引脚映射</li>\n<li><strong>通信参数</strong>：可配置波特率（1200 ~ 5000000bps）、数据位（5 ~ 8 位）、校验位（无 &#x2F; 奇 &#x2F; 偶）、停止位（1&#x2F;1.5&#x2F;2 位）</li>\n<li><strong>缓冲区</strong>：每个 UART 支持硬件 FIFO 缓冲区，可通过软件配置环形缓冲区大小</li>\n<li><strong>事件驱动</strong>：支持通过 FreeRTOS 队列触发 UART 事件（数据接收、缓冲区满、溢出等）</li>\n</ul>\n<h3 id=\"关键API\"><a href=\"#关键API\" class=\"headerlink\" title=\"关键API\"></a>关键API</h3><table>\n<thead>\n<tr>\n<th>API 函数</th>\n<th>功能描述</th>\n<th>核心参数说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>uart_param_config()</code></td>\n<td>配置 UART 通信参数（波特率、数据位等）</td>\n<td>端口号、<code>uart_config_t</code> 结构体</td>\n</tr>\n<tr>\n<td><code>uart_set_pin()</code></td>\n<td>绑定 UART 信号到物理引脚</td>\n<td>端口号、TX 引脚、RX 引脚、RTS 引脚、CTS 引脚</td>\n</tr>\n<tr>\n<td><code>uart_driver_install()</code></td>\n<td>安装 UART 驱动并创建事件队列</td>\n<td>端口号、接收缓冲区大小、发送缓冲区大小、队列容量、队列句柄、标志</td>\n</tr>\n<tr>\n<td><code>uart_read_bytes()</code></td>\n<td>读取 UART 接收数据</td>\n<td>端口号、接收缓冲区、读取长度、超时时间</td>\n</tr>\n<tr>\n<td><code>uart_write_bytes()</code></td>\n<td>发送 UART 数据</td>\n<td>端口号、发送缓冲区、发送长度</td>\n</tr>\n<tr>\n<td><code>uart_flush_input()</code></td>\n<td>清空 UART 接收缓冲区</td>\n<td>端口号</td>\n</tr>\n<tr>\n<td><code>xQueueReceive()</code></td>\n<td>从事件队列接收 UART 事件</td>\n<td>队列句柄、事件存储变量地址、超时时间</td>\n</tr>\n<tr>\n<td><code>xTaskCreate()</code></td>\n<td>创建独立任务处理 UART 事件</td>\n<td>任务函数、任务名称、栈大小、优先级等</td>\n</tr>\n</tbody></table>\n<h3 id=\"基础配置\"><a href=\"#基础配置\" class=\"headerlink\" title=\"基础配置\"></a>基础配置</h3><h4 id=\"步骤-1：定义核心参数（宏定义）\"><a href=\"#步骤-1：定义核心参数（宏定义）\" class=\"headerlink\" title=\"步骤 1：定义核心参数（宏定义）\"></a>步骤 1：定义核心参数（宏定义）</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1. 定义 UART 端口号</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> USER_UART_NUM UART_NUM_1  <span class=\"comment\">// 避免 UART0 冲突（默认用于串口打印）</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> USER_UART_BAUD 115200  <span class=\"comment\">// 串口波特率设置</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2. 定义引脚（需根据硬件接线调整）</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> UART_TX_PIN 17  <span class=\"comment\">// TX 发送引脚</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> UART_RX_PIN 16  <span class=\"comment\">// RX 接收引脚</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 3. 定义缓冲区和队列参数</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> UART_BUFFER_SIZE 1024    <span class=\"comment\">// 数据缓冲区大小</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> UART_QUEUE_SIZE 10       <span class=\"comment\">// 事件队列容量（最多缓存 10 个事件）</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> UART_TASK_STACK_SIZE 4096<span class=\"comment\">// UART 处理任务栈大小</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> UART_TASK_PRIORITY 5     <span class=\"comment\">// UART 任务优先级（1~24，数值越大优先级越高）</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 4. 全局变量声明</span></span><br><span class=\"line\"><span class=\"type\">static</span> QueueHandle_t uart_event_queue;  <span class=\"comment\">// UART 事件队列句柄</span></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">uint8_t</span> uart_rx_buffer[UART_BUFFER_SIZE];  <span class=\"comment\">// 接收数据缓冲区</span></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">const</span> <span class=\"type\">char</span> *TAG = <span class=\"string\">&quot;UART_DEV&quot;</span>;    <span class=\"comment\">// 日志标签</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"步骤-2：配置-UART-硬件参数\"><a href=\"#步骤-2：配置-UART-硬件参数\" class=\"headerlink\" title=\"步骤 2：配置 UART 硬件参数\"></a>步骤 2：配置 UART 硬件参数</h4><p>通过 <code>uart_config_t</code> 结构体配置通信参数，再调用 <code>uart_param_config()</code> 生效：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 配置 UART 通信参数</span></span><br><span class=\"line\"><span class=\"type\">uart_config_t</span> uart_config = &#123;</span><br><span class=\"line\">    .baud_rate = USER_UART_BAUD,          <span class=\"comment\">// 波特率（常用：9600、115200、1000000）</span></span><br><span class=\"line\">    .data_bits = UART_DATA_8_BITS,<span class=\"comment\">// 数据位：8 位</span></span><br><span class=\"line\">    .parity = UART_PARITY_DISABLE,<span class=\"comment\">// 校验位：禁用</span></span><br><span class=\"line\">    .stop_bits = UART_STOP_BITS_1,<span class=\"comment\">// 停止位：1 位</span></span><br><span class=\"line\">    .flow_ctrl = UART_HW_FLOWCTRL_DISABLE,  <span class=\"comment\">// 硬件流控：禁用（无需 RTS/CTS 引脚）</span></span><br><span class=\"line\">    .source_clk = UART_SCLK_DEFAULT,         <span class=\"comment\">// 时钟源：默认</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 应用配置到指定 UART 端口</span></span><br><span class=\"line\">ESP_ERROR_CHECK(uart_param_config(USER_UART_NUM, &amp;uart_config));</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"步骤-3：绑定引脚并安装驱动-（如果用默认串口的话-则不需要绑定引脚）\"><a href=\"#步骤-3：绑定引脚并安装驱动-（如果用默认串口的话-则不需要绑定引脚）\" class=\"headerlink\" title=\"步骤 3：绑定引脚并安装驱动 （如果用默认串口的话 则不需要绑定引脚）\"></a>步骤 3：绑定引脚并安装驱动 （如果用默认串口的话 则不需要绑定引脚）</h4><ul>\n<li><strong>引脚绑定</strong>：通过 <code>uart_set_pin()</code> 将 UART 信号映射到 ESP32 物理引脚</li>\n<li><strong>驱动安装</strong>：调用 <code>uart_driver_install()</code> 初始化 UART 驱动，创建事件队列（可选）</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1. 绑定 UART 引脚（TX/RX，流控引脚填 UART_PIN_NO_CHANGE 表示禁用）</span></span><br><span class=\"line\">ESP_ERROR_CHECK(uart_set_pin(USER_UART_NUM, </span><br><span class=\"line\">                            UART_TX_PIN,  <span class=\"comment\">// TX 引脚</span></span><br><span class=\"line\">                            UART_RX_PIN,  <span class=\"comment\">// RX 引脚</span></span><br><span class=\"line\">                            UART_PIN_NO_CHANGE,  <span class=\"comment\">// RTS 引脚（禁用）</span></span><br><span class=\"line\">                            UART_PIN_NO_CHANGE)); <span class=\"comment\">// CTS 引脚（禁用）</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2. 安装 UART 驱动（参数依次：端口号、接收缓冲区大小、发送缓冲区大小、事件队列容量、队列句柄、标志）</span></span><br><span class=\"line\">ESP_ERROR_CHECK(uart_driver_install(USER_UART_NUM, </span><br><span class=\"line\">                                    UART_BUFFER_SIZE * <span class=\"number\">2</span>,  <span class=\"comment\">// 接收缓冲区（建议比单次接收大）</span></span><br><span class=\"line\">                                    UART_BUFFER_SIZE * <span class=\"number\">2</span>,  <span class=\"comment\">// 发送缓冲区</span></span><br><span class=\"line\">                                    UART_QUEUE_SIZE,       <span class=\"comment\">// 事件队列容量</span></span><br><span class=\"line\">                                    &amp;uart_event_queue,     <span class=\"comment\">// 事件队列句柄（传出）</span></span><br><span class=\"line\">                                    <span class=\"number\">0</span>));                   <span class=\"comment\">// 标志：0（默认）</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"ESP32-UART-数据处理方式\"><a href=\"#ESP32-UART-数据处理方式\" class=\"headerlink\" title=\"ESP32 UART 数据处理方式\"></a>ESP32 UART 数据处理方式</h3><table>\n<thead>\n<tr>\n<th>特性</th>\n<th>轮询方式（简单场景）</th>\n<th>事件驱动方式（高效场景）</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>核心函数</td>\n<td><code>uart_read_bytes()</code>、<code>uart_write_bytes()</code></td>\n<td><code>xQueueReceive()</code>（监听事件队列）</td>\n</tr>\n<tr>\n<td>适用场景</td>\n<td>简单回显、低频率数据交互</td>\n<td>高频率数据、多事件处理（如溢出）</td>\n</tr>\n<tr>\n<td>CPU 占用率</td>\n<td>较高（循环查询）</td>\n<td>较低（事件触发，无轮询）</td>\n</tr>\n<tr>\n<td>代码复杂度</td>\n<td>低</td>\n<td>中（需处理多事件类型）</td>\n</tr>\n<tr>\n<td>看门狗风险</td>\n<td>高（需避免长阻塞）</td>\n<td>低（事件队列超时释放 CPU）</td>\n</tr>\n</tbody></table>\n<h3 id=\"实战代码示例\"><a href=\"#实战代码示例\" class=\"headerlink\" title=\"实战代码示例\"></a>实战代码示例</h3><h4 id=\"事件驱动方式\"><a href=\"#事件驱动方式\" class=\"headerlink\" title=\"事件驱动方式\"></a>事件驱动方式</h4><ul>\n<li><p>通过 FreeRTOS 队列接收 UART 事件，按需处理数据接收、缓冲区满、溢出等场景：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;freertos/FreeRTOS.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;freertos/task.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;driver/uart.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;esp_log.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;driver/gpio.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// -------------- 1. 宏定义参数 --------------</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> USER_UART_NUM UART_NUM_1</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> USER_UART_BAUD 115200</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> UART_TX_PIN 17</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> UART_RX_PIN 16</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> UART_BUFFER_SIZE 1024</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> UART_QUEUE_SIZE 10</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> UART_TASK_STACK_SIZE 4096</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> UART_TASK_PRIORITY 5</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// -------------- 2. 全局变量 --------------</span></span><br><span class=\"line\"><span class=\"type\">static</span> QueueHandle_t uart_event_queue;</span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">uint8_t</span> uart_rx_buffer[UART_BUFFER_SIZE];</span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">const</span> <span class=\"type\">char</span> *TAG = <span class=\"string\">&quot;UART_DEV&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// -------------- 3. UART 事件处理任务 --------------</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">uart_event_task</span><span class=\"params\">(<span class=\"type\">void</span> *arg)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">uart_event_t</span> event;  <span class=\"comment\">// 存储 UART 事件的结构体</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 从事件队列接收事件（超时 100ms，避免阻塞触发看门狗）</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (xQueueReceive(uart_event_queue, &amp;event, pdMS_TO_TICKS(<span class=\"number\">100</span>)) == pdTRUE) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">switch</span> (event.type) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 1. 接收数据事件</span></span><br><span class=\"line\">                <span class=\"keyword\">case</span> UART_DATA:</span><br><span class=\"line\">                    ESP_LOGI(TAG, <span class=\"string\">&quot;收到数据，长度：%d 字节&quot;</span>, event.size);</span><br><span class=\"line\">                    <span class=\"comment\">// 读取数据到缓冲区（超时 50ms，确保数据完整性）</span></span><br><span class=\"line\">                    <span class=\"type\">int</span> read_len = uart_read_bytes(USER_UART_NUM, </span><br><span class=\"line\">                                                  uart_rx_buffer, </span><br><span class=\"line\">                                                  event.size, </span><br><span class=\"line\">                                                  pdMS_TO_TICKS(<span class=\"number\">50</span>));</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (read_len &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// 示例1：回显数据（发送收到的数据）</span></span><br><span class=\"line\">                        uart_write_bytes(USER_UART_NUM, uart_rx_buffer, read_len);</span><br><span class=\"line\">                        <span class=\"comment\">// 示例2：打印接收的数据（十六进制）</span></span><br><span class=\"line\">                        ESP_LOGI(TAG, <span class=\"string\">&quot;接收数据（hex）：&quot;</span>);</span><br><span class=\"line\">                        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; read_len; i++) &#123;</span><br><span class=\"line\">                            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%02X &quot;</span>, uart_rx_buffer[i]);</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// 2. 接收缓冲区满事件</span></span><br><span class=\"line\">                <span class=\"keyword\">case</span> UART_BUFFER_FULL:</span><br><span class=\"line\">                    ESP_LOGI(TAG, <span class=\"string\">&quot;接收缓冲区满，清空缓冲区&quot;</span>);</span><br><span class=\"line\">                    uart_flush_input(USER_UART_NUM);  <span class=\"comment\">// 清空接收缓冲区</span></span><br><span class=\"line\">                    xQueueReset(uart_event_queue);    <span class=\"comment\">// 重置事件队列</span></span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// 3. FIFO 溢出事件（硬件缓冲区溢出）</span></span><br><span class=\"line\">                <span class=\"keyword\">case</span> UART_FIFO_OVF:</span><br><span class=\"line\">                    ESP_LOGI(TAG, <span class=\"string\">&quot;UART FIFO 溢出，清空缓冲区&quot;</span>);</span><br><span class=\"line\">                    uart_flush_input(USER_UART_NUM);</span><br><span class=\"line\">                    xQueueReset(uart_event_queue);</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// 4. 帧错误事件（数据格式错误）</span></span><br><span class=\"line\">                <span class=\"keyword\">case</span> UART_FRAME_ERR:</span><br><span class=\"line\">                    ESP_LOGI(TAG, <span class=\"string\">&quot;帧错误（数据格式异常）&quot;</span>);</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// 5. 校验错误事件（启用校验时生效）</span></span><br><span class=\"line\">                <span class=\"keyword\">case</span> UART_PARITY_ERR:</span><br><span class=\"line\">                    ESP_LOGI(TAG, <span class=\"string\">&quot;校验错误（数据校验不匹配）&quot;</span>);</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// 其他未处理事件</span></span><br><span class=\"line\">                <span class=\"keyword\">default</span>:</span><br><span class=\"line\">                    ESP_LOGI(TAG, <span class=\"string\">&quot;未处理事件类型：%d&quot;</span>, event.type);</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// -------------- 4. 主函数初始化 --------------</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">app_main</span><span class=\"params\">(<span class=\"type\">void</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1. 配置 UART 硬件参数</span></span><br><span class=\"line\">    <span class=\"type\">uart_config_t</span> uart_config = &#123;</span><br><span class=\"line\">        .baud_rate = USER_UART_BAUD,</span><br><span class=\"line\">        .data_bits = UART_DATA_8_BITS,</span><br><span class=\"line\">        .parity = UART_PARITY_DISABLE,</span><br><span class=\"line\">        .stop_bits = UART_STOP_BITS_1,</span><br><span class=\"line\">        .flow_ctrl = UART_HW_FLOWCTRL_DISABLE,</span><br><span class=\"line\">        .source_clk = UART_SCLK_DEFAULT,</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    ESP_ERROR_CHECK(uart_param_config(USER_UART_NUM, &amp;uart_config));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 2. 绑定引脚</span></span><br><span class=\"line\">    ESP_ERROR_CHECK(uart_set_pin(USER_UART_NUM, </span><br><span class=\"line\">                                UART_TX_PIN, </span><br><span class=\"line\">                                UART_RX_PIN, </span><br><span class=\"line\">                                UART_PIN_NO_CHANGE, </span><br><span class=\"line\">                                UART_PIN_NO_CHANGE));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 3. 安装 UART 驱动并创建事件队列</span></span><br><span class=\"line\">    ESP_ERROR_CHECK(uart_driver_install(USER_UART_NUM, </span><br><span class=\"line\">                                        UART_BUFFER_SIZE * <span class=\"number\">2</span>, </span><br><span class=\"line\">                                        UART_BUFFER_SIZE * <span class=\"number\">2</span>, </span><br><span class=\"line\">                                        UART_QUEUE_SIZE, </span><br><span class=\"line\">                                        &amp;uart_event_queue, </span><br><span class=\"line\">                                        <span class=\"number\">0</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 4. 创建 UART 事件处理任务（独立任务，避免阻塞 main 任务）</span></span><br><span class=\"line\">    xTaskCreate(uart_event_task,          <span class=\"comment\">// 任务函数</span></span><br><span class=\"line\">                <span class=\"string\">&quot;uart_event_task&quot;</span>,        <span class=\"comment\">// 任务名称</span></span><br><span class=\"line\">                UART_TASK_STACK_SIZE,     <span class=\"comment\">// 栈大小</span></span><br><span class=\"line\">                <span class=\"literal\">NULL</span>,                     <span class=\"comment\">// 任务参数</span></span><br><span class=\"line\">                UART_TASK_PRIORITY,       <span class=\"comment\">// 优先级</span></span><br><span class=\"line\">                <span class=\"literal\">NULL</span>);                    <span class=\"comment\">// 任务句柄（无需则填 NULL）</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h4 id=\"轮询方式（简单场景，如回显）\"><a href=\"#轮询方式（简单场景，如回显）\" class=\"headerlink\" title=\"轮询方式（简单场景，如回显）\"></a>轮询方式（简单场景，如回显）</h4><ul>\n<li><p>适用于数据量小、交互频率低的场景，代码更简洁：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">app_main</span><span class=\"params\">(<span class=\"type\">void</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1. 配置 UART 参数（同事件驱动方式）</span></span><br><span class=\"line\">    <span class=\"type\">uart_config_t</span> uart_config = &#123;</span><br><span class=\"line\">        .baud_rate = <span class=\"number\">115200</span>,</span><br><span class=\"line\">        .data_bits = UART_DATA_8_BITS,</span><br><span class=\"line\">        .parity = UART_PARITY_DISABLE,</span><br><span class=\"line\">        .stop_bits = UART_STOP_BITS_1,</span><br><span class=\"line\">        .flow_ctrl = UART_HW_FLOWCTRL_DISABLE,</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    ESP_ERROR_CHECK(uart_param_config(USER_UART_NUM, &amp;uart_config));</span><br><span class=\"line\">    ESP_ERROR_CHECK(uart_set_pin(USER_UART_NUM, <span class=\"number\">17</span>, <span class=\"number\">16</span>, UART_PIN_NO_CHANGE, UART_PIN_NO_CHANGE));</span><br><span class=\"line\">    ESP_ERROR_CHECK(uart_driver_install(USER_UART_NUM, <span class=\"number\">1024</span>, <span class=\"number\">1024</span>, <span class=\"number\">0</span>, <span class=\"literal\">NULL</span>, <span class=\"number\">0</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 2. 轮询读取数据并回显</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 读取数据（超时 50ms，无数据则返回 0）</span></span><br><span class=\"line\">        <span class=\"type\">int</span> read_len = uart_read_bytes(USER_UART_NUM, uart_rx_buffer, <span class=\"number\">1024</span>, pdMS_TO_TICKS(<span class=\"number\">50</span>));</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (read_len &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 回显数据</span></span><br><span class=\"line\">            uart_write_bytes(USER_UART_NUM, uart_rx_buffer, read_len);</span><br><span class=\"line\">            ESP_LOGI(TAG, <span class=\"string\">&quot;轮询接收数据长度：%d&quot;</span>, read_len);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 短暂延迟，释放 CPU（避免触发看门狗）</span></span><br><span class=\"line\">        vTaskDelay(pdMS_TO_TICKS(<span class=\"number\">10</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"常见问题与解决方案\"><a href=\"#常见问题与解决方案\" class=\"headerlink\" title=\"常见问题与解决方案\"></a>常见问题与解决方案</h3><h4 id=\"触发-Task-Watchdog（任务看门狗）\"><a href=\"#触发-Task-Watchdog（任务看门狗）\" class=\"headerlink\" title=\"触发 Task Watchdog（任务看门狗）\"></a>触发 Task Watchdog（任务看门狗）</h4><ul>\n<li><strong>原因</strong>：<ol>\n<li>轮询方式中 <code>uart_read_bytes()</code> 超时过长，或无 <code>vTaskDelay()</code> 释放 CPU；</li>\n<li>事件驱动方式中 <code>xQueueReceive()</code> 使用 <code>portMAX_DELAY</code> 永久阻塞。</li>\n</ol>\n</li>\n<li><strong>解决方案</strong>：<ul>\n<li>轮询方式：在循环中添加 <code>vTaskDelay(pdMS_TO_TICKS(10))</code>；</li>\n<li>事件驱动方式：<code>xQueueReceive()</code> 超时设为有限值（如 <code>pdMS_TO_TICKS(100)</code>）。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"数据接收不完整或丢失\"><a href=\"#数据接收不完整或丢失\" class=\"headerlink\" title=\"数据接收不完整或丢失\"></a>数据接收不完整或丢失</h4><ul>\n<li><strong>原因</strong>：<ol>\n<li>接收缓冲区过小，无法容纳单次接收的数据；</li>\n<li><code>uart_read_bytes()</code> 超时过短，数据未完全接收；</li>\n<li>波特率不匹配（发送端与接收端波特率必须一致）。</li>\n</ol>\n</li>\n<li><strong>解决方案</strong>：<ul>\n<li>增大接收缓冲区（如 <code>UART_BUFFER_SIZE * 2</code>）；</li>\n<li>延长 <code>uart_read_bytes()</code> 超时时间（如 50~100ms）；</li>\n<li>确保发送端与 ESP32 UART 波特率、数据位、校验位完全一致。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"UART0-与串口打印冲突\"><a href=\"#UART0-与串口打印冲突\" class=\"headerlink\" title=\"UART0 与串口打印冲突\"></a>UART0 与串口打印冲突</h4><ul>\n<li><strong>原因</strong>：ESP32 默认将 <code>printf()</code> 映射到 UART0（引脚 TX&#x3D;1，RX&#x3D;3），若使用 UART0 通信会导致打印乱码。</li>\n<li><strong>解决方案</strong>：<ul>\n<li>优先使用 UART1 或 UART2 作为通信端口；</li>\n<li>若必须使用 UART0，需重新映射 <code>printf()</code> 到其他 UART（需修改 ESP-IDF 配置）。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"WIFI\"><a href=\"#WIFI\" class=\"headerlink\" title=\"WIFI\"></a>WIFI</h2><h3 id=\"ESP32下WIFI组件三种模式\"><a href=\"#ESP32下WIFI组件三种模式\" class=\"headerlink\" title=\"ESP32下WIFI组件三种模式\"></a>ESP32下WIFI组件三种模式</h3><ul>\n<li><p><strong>AP 模式</strong>：ESP32 自身作为接入点，其他设备（如手机、电脑）可连接 ESP32 创建的 WiFi 热点，适用于 “本地设备直连 ESP32” 场景（如配置 ESP32 参数）；</p>\n</li>\n<li><p><strong>AP+STA 混合模式</strong>：ESP32 同时作为接入点和客户端，既允许其他设备连接自身，又能接入外部路由器，适用于 “本地控制 + 远程联网” 复合场景（如智能家居设备）；</p>\n</li>\n<li><p><strong>STA 模式</strong>：仅作为客户端，专注于接入外部网络，是 ESP32 实现联网功能的最常用模式（如传感器数据上传云端、远程控制指令接收）。</p>\n</li>\n</ul>\n<h3 id=\"STA模式核心工作原理\"><a href=\"#STA模式核心工作原理\" class=\"headerlink\" title=\"STA模式核心工作原理\"></a>STA模式核心工作原理</h3><p>ESP32 的 STA 模式连接 WiFi 的过程遵循 IEEE 802.11 协议，核心流程可分为 4 个阶段，各阶段依赖 ESP-IDF 提供的 WiFi 驱动接口实现：</p>\n<ol>\n<li><p><strong>初始化阶段</strong>：</p>\n<ul>\n<li><p>初始化 WiFi 组件（调用esp_wifi_init()），配置 WiFi 工作模式为 STA（通过wifi_init_config_t结构体设置mode &#x3D; WIFI_MODE_STA）；</p>\n</li>\n<li><p>配置 TCP&#x2F;IP 协议栈（ESP-IDF 默认自动初始化，无需手动操作，支持 DHCP 自动获取 IP 或静态 IP 配置）。</p>\n</li>\n</ul>\n</li>\n<li><p><strong>配置连接参数阶段</strong>：</p>\n<ul>\n<li><p>定义wifi_config_t结构体，填入目标 AP 的<strong>SSID（WiFi 名称）</strong> 和<strong>Password（WiFi 密码）</strong>，确保参数与 AP 一致（区分 SSID 大小写，密码长度需符合 AP 要求，如 WPA2-PSK 密码通常为 8-63 位）；</p>\n</li>\n<li><p>通过esp_wifi_set_config(WIFI_IF_STA, &amp;wifi_config)将配置参数写入 ESP32 的 WiFi 接口。</p>\n</li>\n</ul>\n</li>\n<li><p><strong>启动与连接阶段</strong>：</p>\n<ul>\n<li><p>启动 STA 接口（esp_wifi_start()），ESP32 开始扫描周围 WiFi 信号；</p>\n</li>\n<li><p>自动匹配目标 AP 的 SSID，发起连接请求，与 AP 进行<strong>认证（如 WPA2-PSK 认证）</strong> 和<strong>关联</strong>；</p>\n</li>\n<li><p>若认证通过，ESP32 通过 DHCP 向 AP 请求 IP 地址（默认开启 DHCP 客户端），获取到 IP、子网掩码、网关后，完成 “物理连接→网络层连接” 的全流程。</p>\n</li>\n</ul>\n</li>\n<li><p><strong>状态监测阶段</strong>：</p>\n<ul>\n<li><p>ESP32 通过<strong>事件回调机制</strong>（esp_event_loop_create_default()创建事件循环，esp_event_handler_instance_register()注册事件处理函数）反馈连接状态；</p>\n</li>\n<li><p>关键事件包括：WIFI_EVENT_STA_START（STA 接口启动成功）、WIFI_EVENT_STA_CONNECTED（与 AP 物理连接成功）、IP_EVENT_STA_GOT_IP（获取 IP 地址，联网完成）、WIFI_EVENT_STA_DISCONNECTED（与 AP 断开连接）。</p>\n</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"实现步骤\"><a href=\"#实现步骤\" class=\"headerlink\" title=\"实现步骤\"></a>实现步骤</h4><h5 id=\"重写事件处理函数（核心）\"><a href=\"#重写事件处理函数（核心）\" class=\"headerlink\" title=\"重写事件处理函数（核心）\"></a>重写事件处理函数（核心）</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief WiFi事件与IP事件处理回调函数（核心逻辑）</span></span><br><span class=\"line\"><span class=\"comment\"> * @param arg：用户自定义参数，本代码未使用，传入NULL即可</span></span><br><span class=\"line\"><span class=\"comment\"> * @param event_base：事件基础类型，用于区分是WiFi相关事件（WIFI_EVENT）还是IP相关事件（IP_EVENT）</span></span><br><span class=\"line\"><span class=\"comment\"> * @param event_id：具体事件ID，标识当前触发的是该事件类型下的哪一种具体事件</span></span><br><span class=\"line\"><span class=\"comment\"> * @param event_data：事件关联的数据指针，如IP事件中可获取分配的IP地址信息</span></span><br><span class=\"line\"><span class=\"comment\"> * 功能：响应ESP32 WiFi模块的关键事件，更新连接状态、触发重连逻辑、通知外部状态变化</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title function_\">event_handler</span><span class=\"params\">(<span class=\"type\">void</span> *arg, <span class=\"type\">esp_event_base_t</span> event_base,</span></span><br><span class=\"line\"><span class=\"params\">                          <span class=\"type\">int32_t</span> event_id, <span class=\"type\">void</span> *event_data)</span></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"实现-STA-模式初始化函数\"><a href=\"#实现-STA-模式初始化函数\" class=\"headerlink\" title=\"实现 STA 模式初始化函数\"></a>实现 STA 模式初始化函数</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 引入所需头文件：自定义WiFi管理模块头文件、ESP32 WiFi驱动库、事件处理库</span></span><br><span class=\"line\"><span class=\"comment\">// 日志打印库、FreeRTOS实时操作系统任务调度库、标准输入输出库</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;wifi_manager.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;esp_wifi.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;esp_event.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;esp_log.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;nvs_flash.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;freertos/FreeRTOS.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;freertos/task.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> WIFI_SSID <span class=\"string\">&quot;2078&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> WIFI_PASSWORD <span class=\"string\">&quot;12345678&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 静态全局变量：WiFi状态回调函数指针，用于将WiFi连接/断开状态通知给外部调用者</span></span><br><span class=\"line\"><span class=\"comment\">// 外部需通过wifi_manager_init函数传入自定义回调，接收WIFI_STATE_CONNECTED/WIFI_STATE_DISCONNECTED状态</span></span><br><span class=\"line\"><span class=\"type\">static</span> p_wifi_state_cb wifi_state_cb = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 宏定义：STA模式下最大重连次数，限制重连次数避免无限循环占用CPU资源</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> MAX_CONNECT_RETRY 10</span></span><br><span class=\"line\"><span class=\"comment\">// 宏定义：日志标签，串口打印时用于区分该模块的日志，方便调试定位</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> TAG <span class=\"string\">&quot;wifi_manager&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 静态全局变量：记录STA模式当前的重连尝试次数，初始值为0，每次重连失败自增1</span></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> sta_connect_cnt = <span class=\"number\">0</span>; <span class=\"comment\">// 重连次数</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 静态全局变量：标记STA模式是否已成功连接到目标AP，true表示已连接，false表示未连接/已断开</span></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">bool</span> is_sta_connected = <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief WiFi事件与IP事件处理回调函数（核心逻辑）</span></span><br><span class=\"line\"><span class=\"comment\"> * @param arg：用户自定义参数，本代码未使用，传入NULL即可</span></span><br><span class=\"line\"><span class=\"comment\"> * @param event_base：事件基础类型，用于区分是WiFi相关事件（WIFI_EVENT）还是IP相关事件（IP_EVENT）</span></span><br><span class=\"line\"><span class=\"comment\"> * @param event_id：具体事件ID，标识当前触发的是该事件类型下的哪一种具体事件</span></span><br><span class=\"line\"><span class=\"comment\"> * @param event_data：事件关联的数据指针，如IP事件中可获取分配的IP地址信息</span></span><br><span class=\"line\"><span class=\"comment\"> * 功能：响应ESP32 WiFi模块的关键事件，更新连接状态、触发重连逻辑、通知外部状态变化</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title function_\">event_handler</span><span class=\"params\">(<span class=\"type\">void</span> *arg, <span class=\"type\">esp_event_base_t</span> event_base,</span></span><br><span class=\"line\"><span class=\"params\">                          <span class=\"type\">int32_t</span> event_id, <span class=\"type\">void</span> *event_data)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 判断事件类型为WiFi相关事件（WIFI_EVENT）</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (event_base == WIFI_EVENT)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 根据具体事件ID处理不同场景</span></span><br><span class=\"line\">        <span class=\"keyword\">switch</span> (event_id)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 事件：STA接口启动成功（调用esp_wifi_start()后触发此事件）</span></span><br><span class=\"line\">        <span class=\"keyword\">case</span> WIFI_EVENT_STA_START:</span><br><span class=\"line\">            <span class=\"comment\">// 启动成功后，主动调用esp_wifi_connect()发起WiFi连接请求</span></span><br><span class=\"line\">            esp_wifi_connect();</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 事件：STA与已连接的AP断开连接（如信号弱、密码错误、路由器重启等）</span></span><br><span class=\"line\">        <span class=\"keyword\">case</span> WIFI_EVENT_STA_DISCONNECTED:</span><br><span class=\"line\">            <span class=\"comment\">// 若之前处于已连接状态，先更新连接状态并通知外部</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (is_sta_connected)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                is_sta_connected = <span class=\"literal\">false</span>; <span class=\"comment\">// 将连接状态标记为未连接</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (wifi_state_cb)        <span class=\"comment\">// 若外部注册了回调函数，触发&quot;断开连接&quot;状态通知</span></span><br><span class=\"line\">                    wifi_state_cb(WIFI_STATE_DISCONNECTED);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 检查当前重连次数是否小于最大重连次数，若未达到则继续重试</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (sta_connect_cnt &lt; MAX_CONNECT_RETRY)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                sta_connect_cnt++;  <span class=\"comment\">// 重连次数自增1</span></span><br><span class=\"line\">                esp_wifi_connect(); <span class=\"comment\">// 发起新一轮连接请求</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 若已达到最大重连次数，不再重试（避免无限重连）</span></span><br><span class=\"line\">            wifi_state_cb(WIFI_STATE_DISCONNECTED);</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 其他未定义的WiFi事件，暂不处理，直接break</span></span><br><span class=\"line\">        <span class=\"keyword\">default</span>:</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 判断事件类型为IP相关事件（IP_EVENT）</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (event_base == IP_EVENT)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 事件：STA成功从DHCP服务器获取到IP地址（标志网络层连接完成）</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (event_id == IP_EVENT_STA_GOT_IP)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 打印日志提示已获取IP地址，便于调试确认</span></span><br><span class=\"line\">            ESP_LOGI(TAG, <span class=\"string\">&quot;Got IP address&quot;</span>);</span><br><span class=\"line\">            sta_connect_cnt = <span class=\"number\">0</span>;     <span class=\"comment\">// 重置重连次数</span></span><br><span class=\"line\">            is_sta_connected = <span class=\"literal\">true</span>; <span class=\"comment\">// 将连接状态标记为已连接</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (wifi_state_cb)       <span class=\"comment\">// 若外部注册了回调函数，触发&quot;连接成功&quot;状态通知</span></span><br><span class=\"line\">                wifi_state_cb(WIFI_STATE_CONNECTED);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief WiFi管理器初始化函数（STA模式初始化入口）</span></span><br><span class=\"line\"><span class=\"comment\"> * @param f：外部传入的WiFi状态回调函数，用于接收连接/断开状态通知</span></span><br><span class=\"line\"><span class=\"comment\"> * 功能：初始化ESP32网络接口、事件循环、WiFi驱动，配置STA模式并启动WiFi模块</span></span><br><span class=\"line\"><span class=\"comment\"> * 注意：使用WiFi功能前必须先调用此函数完成初始化，建议在app_main()中优先执行</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">wifi_manager_init</span><span class=\"params\">(p_wifi_state_cb f)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1. 初始化NVS（ESP32存储WiFi配置的依赖组件，必须先初始化）</span></span><br><span class=\"line\">    <span class=\"type\">esp_err_t</span> ret = nvs_flash_init();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ret == ESP_ERR_NVS_NO_FREE_PAGES || ret == ESP_ERR_NVS_NEW_VERSION_FOUND)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        ESP_ERROR_CHECK(nvs_flash_erase()); <span class=\"comment\">// 若NVS有问题，先擦除再初始化</span></span><br><span class=\"line\">        ret = nvs_flash_init();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 2. 初始化ESP32网络接口（TCP/IP协议栈初始化，必须在WiFi初始化前执行）</span></span><br><span class=\"line\">    ESP_ERROR_CHECK(esp_netif_init());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 3. 创建默认的事件循环（用于处理WiFi和IP事件）</span></span><br><span class=\"line\">    ESP_ERROR_CHECK(esp_event_loop_create_default());</span><br><span class=\"line\">    esp_netif_create_default_wifi_sta(); <span class=\"comment\">// 使用默认的STA模式网络接口</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 4. 初始化WiFi驱动：使用WIFI_INIT_CONFIG_DEFAULT()获取默认配置（包含时钟、中断等参数）</span></span><br><span class=\"line\">    <span class=\"type\">wifi_init_config_t</span> cfg = WIFI_INIT_CONFIG_DEFAULT();</span><br><span class=\"line\">    ESP_ERROR_CHECK(esp_wifi_init(&amp;cfg)); <span class=\"comment\">// 执行WiFi驱动初始化，若失败则触发错误检查</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 5. 注册事件处理函数：监听WiFi事件和IP事件</span></span><br><span class=\"line\">    <span class=\"comment\">// 5.1注册WiFi事件监听器：监听所有WiFi事件（ESP_EVENT_ANY_ID），触发时调用event_handler处理</span></span><br><span class=\"line\">    ESP_ERROR_CHECK(esp_event_handler_instance_register(WIFI_EVENT,</span><br><span class=\"line\">                                                        ESP_EVENT_ANY_ID,</span><br><span class=\"line\">                                                        &amp;event_handler,</span><br><span class=\"line\">                                                        <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">                                                        <span class=\"literal\">NULL</span>));</span><br><span class=\"line\">    <span class=\"comment\">// 5.2注册IP事件监听器：仅监听&quot;STA获取IP&quot;事件（IP_EVENT_STA_GOT_IP）</span></span><br><span class=\"line\">    ESP_ERROR_CHECK(esp_event_handler_instance_register(IP_EVENT,</span><br><span class=\"line\">                                                        IP_EVENT_STA_GOT_IP,</span><br><span class=\"line\">                                                        &amp;event_handler,</span><br><span class=\"line\">                                                        <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">                                                        <span class=\"literal\">NULL</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 6. 保存外部传入的状态回调函数，后续状态变化时通过此函数通知外部</span></span><br><span class=\"line\">    wifi_state_cb = f;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">wifi_config_t</span> wifi_config = &#123;</span><br><span class=\"line\">        .sta = &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 配置STA的认证模式为WPA2-PSK（主流家用/工业路由器默认加密方式）</span></span><br><span class=\"line\">            .threshold.authmode = WIFI_AUTH_WPA2_PSK,</span><br><span class=\"line\">            .ssid = WIFI_SSID,</span><br><span class=\"line\">            .password = WIFI_PASSWORD,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 7. 配置WiFi工作模式为纯STA模式（仅作为客户端连接外部AP，不开启AP模式）</span></span><br><span class=\"line\">    ESP_ERROR_CHECK(esp_wifi_set_mode(WIFI_MODE_STA));</span><br><span class=\"line\">    ESP_ERROR_CHECK(esp_wifi_set_config(WIFI_IF_STA, &amp;wifi_config)); <span class=\"comment\">// 写入配置</span></span><br><span class=\"line\">    <span class=\"comment\">// 8. 启动WiFi模块（启动后会触发WIFI_EVENT_STA_START事件，进而发起连接）</span></span><br><span class=\"line\">    ESP_ERROR_CHECK(esp_wifi_start());</span><br><span class=\"line\">    ESP_LOGI(TAG, <span class=\"string\">&quot;STA initialization done&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n","excerpt":"","more":"<h2 id=\"ESP32环境搭建\"><a href=\"#ESP32环境搭建\" class=\"headerlink\" title=\"ESP32环境搭建\"></a>ESP32环境搭建</h2><h3 id=\"WSL2安装与配置\"><a href=\"#WSL2安装与配置\" class=\"headerlink\" title=\"WSL2安装与配置\"></a>WSL2安装与配置</h3><p>推荐查阅官方文档说明：<a href=\"https://learn.microsoft.com/zh-cn/windows/wsl/install\">安装 WSL | Microsoft Learn</a></p>\n<h4 id=\"手动下载安装包\"><a href=\"#手动下载安装包\" class=\"headerlink\" title=\"手动下载安装包\"></a>手动下载安装包</h4><ol>\n<li><p>访问 WSL 的 GitHub Releases 页面 <a href=\"https://github.com/microsoft/WSL/releases\">https://github.com/microsoft/WSL/releases</a></p>\n</li>\n<li><p>查找并下载最新版本的 .msi 安装包（例如 wsl.2.1.5.0.x64.msi）</p>\n</li>\n</ol>\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091112594.png\" alt=\"image-20250909111242531\"></p>\n<h4 id=\"配置控制面板\"><a href=\"#配置控制面板\" class=\"headerlink\" title=\"配置控制面板\"></a>配置控制面板</h4><p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091115919.png\" alt=\"image-20250909111552848\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091116357.png\" alt=\"image-20250909111621317\"></p>\n<blockquote>\n<p>有些Windows 11新系统会没有<code>虚拟机平台</code>这个选项 没有关系！！！！</p>\n<p>配置完后重新启动电脑</p>\n</blockquote>\n<h4 id=\"管理员身份运行Windows-PowerShell\"><a href=\"#管理员身份运行Windows-PowerShell\" class=\"headerlink\" title=\"管理员身份运行Windows PowerShell\"></a>管理员身份运行Windows PowerShell</h4><p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091108898.png\" alt=\"img\"></p>\n<h4 id=\"安装Ubuntu\"><a href=\"#安装Ubuntu\" class=\"headerlink\" title=\"安装Ubuntu\"></a>安装Ubuntu</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsl --install</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091108464.png\" alt=\"img\"></p>\n<blockquote>\n<p>如有可选 则选择Uuntu 如 <code>wsl --install -d Ubuntu</code></p>\n</blockquote>\n<h4 id=\"等待安装完成后重启电脑打开Ubuntu\"><a href=\"#等待安装完成后重启电脑打开Ubuntu\" class=\"headerlink\" title=\"等待安装完成后重启电脑打开Ubuntu\"></a>等待安装完成后重启电脑打开Ubuntu</h4><p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091121963.png\" alt=\"image-20250909112101810\"></p>\n<h4 id=\"输入账号密码\"><a href=\"#输入账号密码\" class=\"headerlink\" title=\"输入账号密码\"></a>输入账号密码</h4><p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091121306.png\" alt=\"img\"></p>\n<h4 id=\"更新软件源\"><a href=\"#更新软件源\" class=\"headerlink\" title=\"更新软件源\"></a>更新软件源</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">sudo</span> apt update</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091124279.png\" alt=\"img\"></p>\n<h4 id=\"更新完后输入下方指令，下载espidf依赖库和工具\"><a href=\"#更新完后输入下方指令，下载espidf依赖库和工具\" class=\"headerlink\" title=\"更新完后输入下方指令，下载espidf依赖库和工具\"></a>更新完后输入下方指令，下载espidf依赖库和工具</h4><blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">sudo</span> apt-get install git wget flex bison gperf python3 python3-pip python3-venv cmake ninja-build ccache libffi-dev libssl-dev dfu-util libusb-1.0-0</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091126525.png\" alt=\"img\"></p>\n<h4 id=\"输入y\"><a href=\"#输入y\" class=\"headerlink\" title=\"输入y\"></a>输入y</h4><p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091127364.png\" alt=\"image-20250909112720315\"></p>\n<h3 id=\"VScode配置\"><a href=\"#VScode配置\" class=\"headerlink\" title=\"VScode配置\"></a>VScode配置</h3><h4 id=\"选择连接到WSL\"><a href=\"#选择连接到WSL\" class=\"headerlink\" title=\"选择连接到WSL\"></a>选择连接到WSL</h4><p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091129218.png\" alt=\"img\"></p>\n<h4 id=\"插件安装\"><a href=\"#插件安装\" class=\"headerlink\" title=\"插件安装\"></a>插件安装</h4><blockquote>\n<ul>\n<li>安装<code>Chinese</code>插件</li>\n<li>安装<code>C/C++</code>插件</li>\n<li>安装<code>ESP-IDF</code>插件</li>\n</ul>\n</blockquote>\n<h4 id=\"在linux账户新建文件用于存放espidf内容，方便后续管理\"><a href=\"#在linux账户新建文件用于存放espidf内容，方便后续管理\" class=\"headerlink\" title=\"在linux账户新建文件用于存放espidf内容，方便后续管理\"></a>在linux账户新建文件用于存放espidf内容，方便后续管理</h4><p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091135250.png\" alt=\"image-20250909113527188\"></p>\n<h4 id=\"ESP-IDF安装\"><a href=\"#ESP-IDF安装\" class=\"headerlink\" title=\"ESP-IDF安装\"></a>ESP-IDF安装</h4><p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091131190.png\" alt=\"img\"></p>\n<h4 id=\"在安装路径中选择自己新建的文件夹\"><a href=\"#在安装路径中选择自己新建的文件夹\" class=\"headerlink\" title=\"在安装路径中选择自己新建的文件夹\"></a>在安装路径中选择自己新建的文件夹</h4><p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091135132.png\" alt=\"img\"></p>\n<blockquote>\n<p>如果出现下图这个情况</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091137839.png\" alt=\"img\"></p>\n<p>那就运行一下下面的指令 </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">sudo</span> <span class=\"built_in\">chown</span> -R <span class=\"variable\">$USER</span>:<span class=\"variable\">$USER</span> /home/你的用户名/你的IDF文件名/</span><br><span class=\"line\"><span class=\"built_in\">chmod</span> -R 755 /home/你的用户名/你的IDF文件名/</span><br></pre></td></tr></table></figure>\n</blockquote>\n<h4 id=\"安装完成之后先搞个工程测试一下编译能不能正常\"><a href=\"#安装完成之后先搞个工程测试一下编译能不能正常\" class=\"headerlink\" title=\"安装完成之后先搞个工程测试一下编译能不能正常\"></a>安装完成之后先搞个工程测试一下编译能不能正常</h4><p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091140479.png\" alt=\"img\"></p>\n<h4 id=\"选择文件夹来存放代码\"><a href=\"#选择文件夹来存放代码\" class=\"headerlink\" title=\"选择文件夹来存放代码\"></a>选择文件夹来存放代码</h4><p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091143918.png\" alt=\"img\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091143292.png\" alt=\"img\"></p>\n<h4 id=\"设置环境\"><a href=\"#设置环境\" class=\"headerlink\" title=\"设置环境\"></a>设置环境</h4><h5 id=\"设置IDF-tools环境（豆包四条命令搞定）\"><a href=\"#设置IDF-tools环境（豆包四条命令搞定）\" class=\"headerlink\" title=\"设置IDF_tools环境（豆包四条命令搞定）\"></a>设置IDF_tools环境（豆包四条命令搞定）</h5><blockquote>\n<p>注意下方命令中：</p>\n<p><code>~/ESP_IDF/v5.5.1/esp-idf</code>：你的IDF文件夹路径 要一直引入到<code>esp-idf</code></p>\n<p><code>~/ESP_IDF/Tools</code>：你的IDF_Tools文件夹路径</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&#x27;export IDF_PATH=~/ESP_IDF/v5.5.1/esp-idf&#x27;</span> &gt;&gt; ~/.bashrc</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&#x27;export IDF_TOOLS_PATH=~/ESP_IDF/Tools&#x27;</span> &gt;&gt; ~/.bashrc</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&#x27;source ~/ESP_IDF/v5.5.1/esp-idf/export.sh&#x27;</span> &gt;&gt; ~/.bashrc</span><br><span class=\"line\"><span class=\"built_in\">source</span> ~/.bashrc  <span class=\"comment\"># 立即生效</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>成功的话 重启<code>vscode</code>就会自动出现<code>idf</code>的命令</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509092218229.png\" alt=\"image-20250909221836025\"></p>\n</blockquote>\n<h5 id=\"若上面还不行-则根据报错情况执行下面\"><a href=\"#若上面还不行-则根据报错情况执行下面\" class=\"headerlink\" title=\"若上面还不行 则根据报错情况执行下面\"></a>若上面还不行 则根据报错情况执行下面</h5><h6 id=\"场景-1：运行-export-sh-时报-“Python-虚拟环境不存在”\"><a href=\"#场景-1：运行-export-sh-时报-“Python-虚拟环境不存在”\" class=\"headerlink\" title=\"场景 1：运行 ./export.sh 时报 “Python 虚拟环境不存在”\"></a>场景 1：运行 <code>./export.sh</code> 时报 “Python 虚拟环境不存在”</h6><p><code>报错信息</code></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ERROR: ESP-IDF Python virtual environment <span class=\"string\">&quot;<span class=\"variable\">$HOME</span>/ESP_IDF/Tools/python_env/idf5.5_py3.12_env/bin/python&quot;</span> not found. Please run the install script to <span class=\"built_in\">set</span> it up before proceeding.</span><br></pre></td></tr></table></figure>\n\n<p><code>原因</code></p>\n<p>未执行 ESP-IDF 安装脚本，Python 虚拟环境未创建。</p>\n<p><code>解决方案</code></p>\n<p>必须先运行安装脚本，自动创建虚拟环境和安装依赖：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 进入 ESP-IDF 根目录（替换为你的实际路径）</span></span><br><span class=\"line\"><span class=\"built_in\">cd</span> ~/ESP_IDF/v5.5.1/esp-idf</span><br><span class=\"line\"><span class=\"comment\"># 执行安装脚本（Linux/macOS 用 install.sh，Windows 用 install.bat）</span></span><br><span class=\"line\">./install.sh</span><br><span class=\"line\"><span class=\"comment\"># 安装完成后再执行 export.sh 导出环境</span></span><br><span class=\"line\">. ./export.sh</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"场景-2：运行-install-sh-时-“下载工具包卡住”\"><a href=\"#场景-2：运行-install-sh-时-“下载工具包卡住”\" class=\"headerlink\" title=\"场景 2：运行 ./install.sh 时 “下载工具包卡住”\"></a>场景 2：运行 <code>./install.sh</code> 时 “下载工具包卡住”</h6><p><code>报错表现</code></p>\n<p>安装过程中卡在某一工具包下载（如 <code>riscv32-esp-elf-gdb</code>），进度条不动或反复重试。</p>\n<p><code>原因</code></p>\n<p>ESP-IDF 工具包托管在 GitHub，国内网络访问速度慢或不稳定，导致下载中断。</p>\n<ol>\n<li><p><strong>用国内镜像加速（推荐）</strong><br>配置 <code>IDF_GITHUB_ASSETS</code> 环境变量，将下载源切换为 Espressif 国内镜像，无需手动下载：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 临时生效，每次打开终端需重新执行（或写入 shell 配置文件）</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> IDF_GITHUB_ASSETS=<span class=\"string\">&quot;dl.espressif.com/github_assets&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># 重新运行安装脚本</span></span><br><span class=\"line\">./install.sh</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h4 id=\"烧录文件\"><a href=\"#烧录文件\" class=\"headerlink\" title=\"烧录文件\"></a>烧录文件</h4><h5 id=\"下载wsl-usb-manager-exe\"><a href=\"#下载wsl-usb-manager-exe\" class=\"headerlink\" title=\"下载wsl-usb-manager.exe\"></a>下载wsl-usb-manager.exe</h5><blockquote>\n<p><a href=\"https://mextra.netlify.app/download/ESP32/wsl-usb-manager.exe\">wsl-usb-manager.exe </a></p>\n</blockquote>\n<h5 id=\"插上ESP32S3\"><a href=\"#插上ESP32S3\" class=\"headerlink\" title=\"插上ESP32S3\"></a>插上ESP32S3</h5><p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091454477.jpg\" alt=\"059f326e4709ef71f539677c5da784c2\"></p>\n<h5 id=\"配置WSL-USB\"><a href=\"#配置WSL-USB\" class=\"headerlink\" title=\"配置WSL USB\"></a>配置WSL USB</h5><h6 id=\"管理员身份打开Windows-PowerShell\"><a href=\"#管理员身份打开Windows-PowerShell\" class=\"headerlink\" title=\"管理员身份打开Windows PowerShell\"></a>管理员身份打开Windows PowerShell</h6><blockquote>\n<p>输入<code>winget install usbipd</code>，然后输入<code>y</code>（<code>看情况选择开不开魔法</code>，不开也能20s左右下载安装完）</p>\n</blockquote>\n<p>这个指令是安装usbipd-win工具，用于将windows系统的usb设备共享给wsl环境。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509092343890.png\" alt=\"img\"></p>\n<p>安装好之后 更改权限</p>\n<blockquote>\n<ul>\n<li><p>输入<code>sudo usermod -aG dialout 你的用户名</code></p>\n</li>\n<li><p>然后<code>重启电脑</code></p>\n</li>\n<li><p>输入<code>groups</code>验证一下</p>\n<ul>\n<li>如果输出中包含 <code>dialout</code> 或 <code>uucp</code>，则表示设置成功，之后就可以正常访问串口了。</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<h5 id=\"进入WSL-USB选择端口并烧录\"><a href=\"#进入WSL-USB选择端口并烧录\" class=\"headerlink\" title=\"进入WSL USB选择端口并烧录\"></a>进入WSL USB选择端口并烧录</h5><p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091457549.png\" alt=\"image-20250909145724459\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091500732.png\" alt=\"image-20250909150034639\"></p>\n<p>以上环境参考：<a href=\"https://blog.csdn.net/QL_SD/article/details/150216599?spm=1001.2014.3001.5502\">（二）vscode搭建espidf环境，配置wsl2_wsl 编译idf项目-CSDN博客</a></p>\n<p>感谢<a href=\"https://blog.csdn.net/QL_SD\">QL.ql</a>大博主</p>\n<h2 id=\"ESP32基础知识\"><a href=\"#ESP32基础知识\" class=\"headerlink\" title=\"ESP32基础知识\"></a>ESP32基础知识</h2><p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091737219.png\" alt=\"image-20250909173749995\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091738212.png\" alt=\"image-20250909173836126\"></p>\n<h3 id=\"使用命令行创建工程\"><a href=\"#使用命令行创建工程\" class=\"headerlink\" title=\"使用命令行创建工程\"></a>使用命令行创建工程</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">idf.py create-project 工程名</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"打开vscode-切换到新建的工程\"><a href=\"#打开vscode-切换到新建的工程\" class=\"headerlink\" title=\"打开vscode 切换到新建的工程\"></a>打开vscode 切换到新建的工程</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> ~/ESP_Code/刚刚的工程名</span><br><span class=\"line\">code .</span><br><span class=\"line\"></span><br><span class=\"line\">按`ctrl+<span class=\"built_in\">shift</span>+p` 寻找add 添加idf路径</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>在写代码时候 如果出现宏没定义 则重新设置一下芯片型号 稍等一会就会出现</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509101009919.png\" alt=\"image-20250910100948617\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509101026730.png\" alt=\"image-20250910102600612\"></p>\n<p>如果想要删除文件夹 则运行以下命令</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> ..</span><br><span class=\"line\"><span class=\"built_in\">rm</span> -rf 文件夹</span><br></pre></td></tr></table></figure>\n\n<p>必备头文件</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;freertos/FreeRTOS.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;freertos/task.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;esp_log.h&quot;</span></span></span><br></pre></td></tr></table></figure>\n\n</blockquote>\n<h3 id=\"CMakeList-txt使用说明\"><a href=\"#CMakeList-txt使用说明\" class=\"headerlink\" title=\"CMakeList.txt使用说明\"></a>CMakeList.txt使用说明</h3><p>一般CmakeList.txt呈现下面的结构</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">main</span><br><span class=\"line\">    main.c</span><br><span class=\"line\">    CMakeList.txt</span><br><span class=\"line\">CMakeList.txt</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"创建自定义文件夹\"><a href=\"#创建自定义文件夹\" class=\"headerlink\" title=\"创建自定义文件夹\"></a>创建自定义文件夹</h4><blockquote>\n<p>如</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">components</span><br><span class=\"line\">    led</span><br><span class=\"line\">    \tled.c</span><br><span class=\"line\">    \tled.h</span><br><span class=\"line\">    \tCMakeList.txt</span><br><span class=\"line\">main</span><br><span class=\"line\">    main.c</span><br><span class=\"line\">    CMakeList.txt</span><br></pre></td></tr></table></figure>\n\n<p>在这个目录下 则<code>components/led</code>文件夹下的<code>CMakeList.txt</code>，可以这么写</p>\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">idf_component_register(SRCS <span class=\"string\">&quot;led.c&quot;</span></span><br><span class=\"line\">                    INCLUDE_DIRS <span class=\"string\">&quot;.&quot;</span></span><br><span class=\"line\">                    REQUIRES esp_driver_gpio</span><br><span class=\"line\">                    )</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p><code>SRCS</code>：<code>.c</code>文件 多个用空格隔开</p>\n</li>\n<li><p><code>INCLUDE_DIRS</code>：文件名 多个同样用空格隔开</p>\n</li>\n<li><p><code>REQUIRES</code>：引入ESP官方的组件库<code>components</code> ，名字为官方<code>idf</code>下的<code>components</code>文件夹下的文件夹名 如此处的<code>esp_driver_gpio</code></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509121840992.png\" alt=\"image-20250912184005520\"></p>\n</li>\n</ul>\n<p>而若要引用 则<code>main</code>文件夹下的<code>CMakeList.txt</code> 可以这么写</p>\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">idf_component_register(SRCS <span class=\"string\">&quot;main.c&quot;</span> <span class=\"string\">&quot;../components/led/led.c&quot;</span></span><br><span class=\"line\">                    INCLUDE_DIRS <span class=\"string\">&quot;.&quot;</span> <span class=\"string\">&quot;../components&quot;</span>)</span><br></pre></td></tr></table></figure>\n</blockquote>\n<h3 id=\"FreeRTOS-ESP32-基础API\"><a href=\"#FreeRTOS-ESP32-基础API\" class=\"headerlink\" title=\"FreeRTOS-ESP32 基础API\"></a>FreeRTOS-ESP32 基础API</h3><h4 id=\"任务创建\"><a href=\"#任务创建\" class=\"headerlink\" title=\"任务创建\"></a>任务创建</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BaseType_t <span class=\"title function_\">xTaskCreatePinnedToCore</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">\tTaskFunction_t pvTaskCode,\t\t\t\t<span class=\"comment\">//任务函数指针，原型是voidfun(void*param)</span></span></span><br><span class=\"line\"><span class=\"params\">\t<span class=\"type\">const</span> <span class=\"type\">char</span> *constpcName,\t\t\t\t<span class=\"comment\">//任务的名称，打印调试可能会有用</span></span></span><br><span class=\"line\"><span class=\"params\">\t<span class=\"type\">const</span> <span class=\"type\">uint32_t</span> usStackDepth,\t\t\t<span class=\"comment\">//指定的任务堆栈空间大小（字节）</span></span></span><br><span class=\"line\"><span class=\"params\">\t<span class=\"type\">void</span> *constpvParameters,\t\t\t\t<span class=\"comment\">//任务参数</span></span></span><br><span class=\"line\"><span class=\"params\">\tUBaseType_t uxPriority,\t\t\t\t\t<span class=\"comment\">//优先级，数字越大，优先级越大，0到(configMAX_PRIORITIES-1) 即0-24</span></span></span><br><span class=\"line\"><span class=\"params\">\tTaskHandle_t *constpvCreatedTask,\t\t <span class=\"comment\">//传回来的任务句柄</span></span></span><br><span class=\"line\"><span class=\"params\">\t<span class=\"type\">const</span> BaseType_t xCoreID)</span>\t\t\t\t<span class=\"comment\">//分配在哪个内核上运行 ESP32是双核 所以可以选0或1</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>ESP32的任务堆栈空间大小<code>usStackDepth</code>与原生FreeRTOS不一样</p>\n<ul>\n<li>原生FreeRTOS的任务堆栈空间大小单位是<code>字</code>，即目标平台若是32位 则为4个字节</li>\n<li>ESP32的任务堆栈空间大小单位是<code>字节</code>，最小是<code>2048</code></li>\n</ul>\n</blockquote>\n<h4 id=\"阻塞函数（少用-可替代）\"><a href=\"#阻塞函数（少用-可替代）\" class=\"headerlink\" title=\"阻塞函数（少用 可替代）\"></a>阻塞函数（少用 可替代）</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//粗略延时xTicksToDelay个周期 </span></span><br><span class=\"line\"><span class=\"comment\">//使用该函数后 任务进入阻塞 等延时结束且调度到来才会再次运行</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">vTaskDelay</span><span class=\"params\">(<span class=\"type\">const</span> TickType_t xTicksToDelay)</span>\t</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//用于表示精确的解除阻塞时间    </span></span><br><span class=\"line\"><span class=\"comment\">//即使任务的执行时间超过了周期时间，它也能自动调整延迟时间，保证任务的周期性运行</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">vTaskDelayUntil</span><span class=\"params\">(TickType_t *pxPreviousWakeTime,<span class=\"type\">const</span> TickType_t xTimeIncrement)</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"打印调试\"><a href=\"#打印调试\" class=\"headerlink\" title=\"打印调试\"></a>打印调试</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;freertos/FreeRTOS.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;freertos/task.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;esp_log.h&quot;</span></span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">taskA</span><span class=\"params\">(<span class=\"type\">void</span> *param)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        ESP_LOGI(<span class=\"string\">&quot;TaskA&quot;</span>, <span class=\"string\">&quot;Hello from Task A%d&quot;</span>, <span class=\"number\">1</span>);<span class=\"comment\">//前面是一个TAG标签，后面是打印内容 他会自动回车换行</span></span><br><span class=\"line\">        vTaskDelay(pdMS_TO_TICKS(<span class=\"number\">500</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">app_main</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    xTaskCreatePinnedToCore(taskA, <span class=\"string\">&quot;TaskA&quot;</span>, <span class=\"number\">2048</span>, <span class=\"literal\">NULL</span>, <span class=\"number\">5</span>, <span class=\"literal\">NULL</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">\t</span><br></pre></td></tr></table></figure>\n\n<p>效果如图</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509101016442.png\" alt=\"image-20250910101607354\"></p>\n<h4 id=\"队列\"><a href=\"#队列\" class=\"headerlink\" title=\"队列\"></a>队列</h4><blockquote>\n<p>队列特性：先进先出</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">QueueHandle_t queue_handle = <span class=\"literal\">NULL</span>; <span class=\"comment\">// 创建队列句柄</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 创建一个队列</span></span><br><span class=\"line\"><span class=\"comment\"> * @param uxQueueLength 队列长度</span></span><br><span class=\"line\"><span class=\"comment\"> * @param uxItemSize 每个元素的大小(单位是字节)</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">QueueHandle_t <span class=\"title function_\">xQueueCreate</span><span class=\"params\">(UBaseType_t uxQueueLength, UBaseType_t uxItemSize)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 向队列头部发送数据</span></span><br><span class=\"line\"><span class=\"comment\"> * @param xQueue 队列句柄</span></span><br><span class=\"line\"><span class=\"comment\"> * @param pvItemToQueue 要发送的数据的指针</span></span><br><span class=\"line\"><span class=\"comment\"> * @param xTicksToWait 等待的时间(单位是tick)</span></span><br><span class=\"line\"><span class=\"comment\"> * @return 如果在等待时间内发送成功返回pdTRUE，否则返回errQUEUE_FULL</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">BaseType_t <span class=\"title function_\">xQueueSend</span><span class=\"params\">(QueueHandle_t xQueue, <span class=\"type\">const</span> <span class=\"type\">void</span> *pvItemToQueue, TickType_t xTicksToWait)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 向队列尾部发送数据（新数据放在队尾）</span></span><br><span class=\"line\"><span class=\"comment\"> * @param xQueue 队列句柄</span></span><br><span class=\"line\"><span class=\"comment\"> * @param pvItemToQueue 要发送的数据的指针</span></span><br><span class=\"line\"><span class=\"comment\"> * @param xTicksToWait 等待的时间</span></span><br><span class=\"line\"><span class=\"comment\"> * @return pdTRUE 如果发送成功</span></span><br><span class=\"line\"><span class=\"comment\"> *         errQUEUE_FULL 如果队列已满，发送失败</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">BaseType_t <span class=\"title function_\">xQueueSendToBack</span><span class=\"params\">(QueueHandle_t xQueue, <span class=\"type\">const</span> <span class=\"type\">void</span> *pvItemToQueue, TickType_t xTicksToWait)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 从队列中接收数据</span></span><br><span class=\"line\"><span class=\"comment\"> * @param xQueue 队列句柄</span></span><br><span class=\"line\"><span class=\"comment\"> * @param pvBuffer 用于存储接收数据的缓冲区</span></span><br><span class=\"line\"><span class=\"comment\"> * @param xTicksToWait 等待数据的最大时间，以系统节拍为单位</span></span><br><span class=\"line\"><span class=\"comment\"> * @return pdPASS 表示接收成功，errQUEUE_EMPTY 表示队列为空且等待超时，接收失败。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">BaseType_t <span class=\"title function_\">xQueueReceive</span><span class=\"params\">(QueueHandle_t xQueue, <span class=\"type\">void</span> *pvBuffer, TickType_t xTicksToWait)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 该函数在中断中使用，从队列发送数据 这个函数的行为和普通的 xQueueSend 有差异，且不允许阻塞（等待）</span></span><br><span class=\"line\"><span class=\"comment\"> * @param xQueue 队列句柄</span></span><br><span class=\"line\"><span class=\"comment\"> * @param pvItemToQueue 要发送的数据</span></span><br><span class=\"line\"><span class=\"comment\"> * @param pxHigherPriorityTaskWoken 如果发送数据后，有更高优先级的任务被唤醒，则该参数会被置为pdTRUE</span></span><br><span class=\"line\"><span class=\"comment\"> * @return 如果发送成功，返回pdTRUE，否则返回errQUEUE_FULL</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">BaseType_t <span class=\"title function_\">xQueueSendFromISR</span><span class=\"params\">(QueueHandle_t xQueue, <span class=\"type\">const</span> <span class=\"type\">void</span> *pvItemToQueue, BaseType_t *pxHigherPriorityTaskWoken)</span>;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"调用示例\"><a href=\"#调用示例\" class=\"headerlink\" title=\"调用示例\"></a>调用示例</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;freertos/FreeRTOS.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;freertos/task.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;freertos/queue.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;esp_log.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">QueueHandle_t queue_handle = <span class=\"literal\">NULL</span>; <span class=\"comment\">// 定义一个队列句柄</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"type\">int</span> value;</span><br><span class=\"line\">&#125; <span class=\"type\">queue_date_t</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">taskA</span><span class=\"params\">(<span class=\"type\">void</span> *param)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 从队列里面接收数据，并打印</span></span><br><span class=\"line\">    <span class=\"type\">queue_date_t</span> data;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (xQueueReceive(queue_handle, &amp;data, <span class=\"number\">100</span>) == pdTRUE) <span class=\"comment\">// 从队列中接收数据，阻塞等待</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            ESP_LOGI(<span class=\"string\">&quot;re_queue&quot;</span>, <span class=\"string\">&quot;receive queue value:%d&quot;</span>, data.value); <span class=\"comment\">// 前面是一个TAG标签，后面是打印内容 他会自动回车换行</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">taskB</span><span class=\"params\">(<span class=\"type\">void</span> *param)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">queue_date_t</span> data;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(&amp;data, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(data));</span><br><span class=\"line\">    <span class=\"comment\">// 每隔1s向队列里面发送数据</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        xQueueSendToBack(queue_handle, &amp;data, <span class=\"number\">100</span>); <span class=\"comment\">// 向队列中发送数据，阻塞等待</span></span><br><span class=\"line\">        vTaskDelay(pdMS_TO_TICKS(<span class=\"number\">1000</span>));            <span class=\"comment\">// 延时1s</span></span><br><span class=\"line\">        data.value++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">app_main</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    queue_handle = xQueueCreate(<span class=\"number\">10</span>, <span class=\"keyword\">sizeof</span>(<span class=\"type\">queue_date_t</span>)); <span class=\"comment\">// 创建一个队列，队列长度为10，每个元素的大小为queue_date_t结构体的大小</span></span><br><span class=\"line\">    xTaskCreatePinnedToCore(taskA, <span class=\"string\">&quot;re_queue&quot;</span>, <span class=\"number\">2048</span>, <span class=\"literal\">NULL</span>, <span class=\"number\">3</span>, <span class=\"literal\">NULL</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">    xTaskCreatePinnedToCore(taskB, <span class=\"string\">&quot;se_queue&quot;</span>, <span class=\"number\">2048</span>, <span class=\"literal\">NULL</span>, <span class=\"number\">3</span>, <span class=\"literal\">NULL</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509101107988.png\" alt=\"image-20250910110704875\"></p>\n</blockquote>\n<h4 id=\"信号量\"><a href=\"#信号量\" class=\"headerlink\" title=\"信号量\"></a>信号量</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 创建一个二值信号量</span></span><br><span class=\"line\"><span class=\"comment\"> * @return SemaphoreHandle_t 信号量句柄</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">SemaphoreHandle_t <span class=\"title function_\">xSemaphoreCreateBinary</span><span class=\"params\">(<span class=\"type\">void</span>)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 创建一个计数信号量</span></span><br><span class=\"line\"><span class=\"comment\"> * @param uxMaxCount 计数信号量的最大值</span></span><br><span class=\"line\"><span class=\"comment\"> * @param uxInitialCount 计数信号量的初始值</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">SemaphoreHandle_t <span class=\"title function_\">xSemaphoreCreateCounting</span><span class=\"params\">(UBaseType_t uxMaxCount, UBaseType_t uxInitialCount)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 创建一个互斥锁</span></span><br><span class=\"line\"><span class=\"comment\"> * @return SemaphoreHandle_t 互斥锁句柄</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">SemaphoreHandle_t <span class=\"title function_\">xSemaphoreCreateMutex</span><span class=\"params\">(<span class=\"type\">void</span>)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 取得一个信号量</span></span><br><span class=\"line\"><span class=\"comment\"> * @param xSemaphore 信号量句柄</span></span><br><span class=\"line\"><span class=\"comment\"> * @param xTicksToWait 等待信号量的时间，单位为ticks</span></span><br><span class=\"line\"><span class=\"comment\"> * @return 如果成功取得信号量则返回pdTRUE，否则返回pdFALSE</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">BaseType_t <span class=\"title function_\">xSemaphoreTake</span><span class=\"params\">(SemaphoreHandle_t xSemaphore, TickType_t xTicksToWait)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 释放一个信号量</span></span><br><span class=\"line\"><span class=\"comment\"> * @param xSemaphore 信号量句柄</span></span><br><span class=\"line\"><span class=\"comment\"> * @return 如果成功释放信号量则返回pdTRUE，否则返回pdFALSE</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">BaseType_t <span class=\"title function_\">xSemaphoreGive</span><span class=\"params\">(SemaphoreHandle_t xSemaphore)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 删除一个信号量</span></span><br><span class=\"line\"><span class=\"comment\"> * @param xSemaphore 要删除的信号量句柄</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">vSemaphoreDelete</span><span class=\"params\">(SemaphoreHandle_t xSemaphore)</span>;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"调用示例-1\"><a href=\"#调用示例-1\" class=\"headerlink\" title=\"调用示例\"></a>调用示例</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;freertos/FreeRTOS.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;freertos/task.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;freertos/queue.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;freertos/semphr.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;esp_log.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">SemaphoreHandle_t mutex_handle;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">taskA</span><span class=\"params\">(<span class=\"type\">void</span> *param)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        vTaskDelay(pdMS_TO_TICKS(<span class=\"number\">1000</span>));</span><br><span class=\"line\">        xSemaphoreTake(mutex_handle, portMAX_DELAY);</span><br><span class=\"line\">        ESP_LOGI(<span class=\"string\">&quot;TASK_A&quot;</span>, <span class=\"string\">&quot;Task A is running&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        xSemaphoreGive(mutex_handle);</span><br><span class=\"line\">        vTaskDelay(pdMS_TO_TICKS(<span class=\"number\">10</span>)); <span class=\"comment\">// 给其他任务机会</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">taskB</span><span class=\"params\">(<span class=\"type\">void</span> *param)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        vTaskDelay(pdMS_TO_TICKS(<span class=\"number\">500</span>));</span><br><span class=\"line\">        xSemaphoreTake(mutex_handle, portMAX_DELAY);</span><br><span class=\"line\">        ESP_LOGI(<span class=\"string\">&quot;TASK_B&quot;</span>, <span class=\"string\">&quot;Task B is running&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        xSemaphoreGive(mutex_handle);</span><br><span class=\"line\">        vTaskDelay(pdMS_TO_TICKS(<span class=\"number\">10</span>)); <span class=\"comment\">// 给其他任务机会</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">app_main</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    mutex_handle = xSemaphoreCreateMutex();</span><br><span class=\"line\">    xTaskCreatePinnedToCore(taskA, <span class=\"string\">&quot;taskA&quot;</span>, <span class=\"number\">2048</span>, <span class=\"literal\">NULL</span>, <span class=\"number\">6</span>, <span class=\"literal\">NULL</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">    xTaskCreatePinnedToCore(taskB, <span class=\"string\">&quot;taskB&quot;</span>, <span class=\"number\">2048</span>, <span class=\"literal\">NULL</span>, <span class=\"number\">4</span>, <span class=\"literal\">NULL</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意释放信号量的时候 一般会给个延时 不加的话任务会马上回到<code>while(1)</code>初始的时候 反应出来的现象就是一直是A任务运行</p>\n<p>原因：RTOS任务调度需要时间 并且最少只能是10ms 已测试</p>\n</blockquote>\n<h4 id=\"事件组\"><a href=\"#事件组\" class=\"headerlink\" title=\"事件组\"></a>事件组</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 创建事件组</span></span><br><span class=\"line\"><span class=\"comment\"> * @return EventGroupHandle_t 事件组句柄</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">EventGroupHandle_t <span class=\"title function_\">xEventGroupCreate</span><span class=\"params\">(<span class=\"type\">void</span>)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 设置事件位</span></span><br><span class=\"line\"><span class=\"comment\"> * @param xEventGroup 事件组句柄</span></span><br><span class=\"line\"><span class=\"comment\"> * @param uxBitsToSet 要设置的事件位</span></span><br><span class=\"line\"><span class=\"comment\"> * @return 设置后事件组的值</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">EventBits_t <span class=\"title function_\">xEventGroupSetBits</span><span class=\"params\">(EventGroupHandle_t xEventGroup, <span class=\"type\">const</span> EventBits_t uxBitsToSet)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 事件组等待位函数</span></span><br><span class=\"line\"><span class=\"comment\"> * @param xEventGroup 事件组句柄</span></span><br><span class=\"line\"><span class=\"comment\"> * @param uxBitsToWaitFor 等待的事件位</span></span><br><span class=\"line\"><span class=\"comment\"> * @param xClearOnExit 退出时是否清除事件位 pdTRUE or pdFALSE</span></span><br><span class=\"line\"><span class=\"comment\"> * @param xWaitForAllBits 是否等待所有位 pdTRUE or pdFALSE</span></span><br><span class=\"line\"><span class=\"comment\"> * @param xTicksToWait 等待的最大时间</span></span><br><span class=\"line\"><span class=\"comment\"> * @return 返回实际获得的事件位</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">EventBits_t <span class=\"title function_\">xEventGroupWaitBits</span><span class=\"params\">(<span class=\"type\">const</span> EventGroupHandle_t xEventGroup,</span></span><br><span class=\"line\"><span class=\"params\">                                <span class=\"type\">const</span> EventBits_t uxBitsToWaitFor,</span></span><br><span class=\"line\"><span class=\"params\">                                <span class=\"type\">const</span> BaseType_t xClearOnExit,</span></span><br><span class=\"line\"><span class=\"params\">                                <span class=\"type\">const</span> BaseType_t xWaitForAllBits,</span></span><br><span class=\"line\"><span class=\"params\">                                TickType_t xTicksToWait)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 清除事件组指定事件位</span></span><br><span class=\"line\"><span class=\"comment\"> * @param xEventGroup 事件组句柄</span></span><br><span class=\"line\"><span class=\"comment\"> * @param uxBitsToClear 要清除的事件位</span></span><br><span class=\"line\"><span class=\"comment\"> * @return 清除前的事件组位值</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">EventBits_t <span class=\"title function_\">xEventGroupClearBits</span><span class=\"params\">(EventGroupHandle_t xEventGroup, <span class=\"type\">const</span> EventBits_t uxBitsToClear)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 以下使用消息直达机制*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 任务通知函数</span></span><br><span class=\"line\"><span class=\"comment\"> * @param xTaskToNotify 任务句柄</span></span><br><span class=\"line\"><span class=\"comment\"> * @param ulValue 发送的值</span></span><br><span class=\"line\"><span class=\"comment\"> * @param eAction 发送的动作 </span></span><br><span class=\"line\"><span class=\"comment\"> *                eNoAction 不改变任务的通知值(即不更新 会一直发送初始值)</span></span><br><span class=\"line\"><span class=\"comment\"> *                eSetBits 将ulValue的值按位或 到任务的通知值中 </span></span><br><span class=\"line\"><span class=\"comment\"> *                eIncrement 将任务的通知值加1</span></span><br><span class=\"line\"><span class=\"comment\"> *                eSetValueWithOverwrite 将任务的通知值设置为ulValue</span></span><br><span class=\"line\"><span class=\"comment\"> *                eSetValueWithoutOverwrite 如果任务的通知值为0，则将其设置为ulValue，否则不改变任务的通知值</span></span><br><span class=\"line\"><span class=\"comment\"> * @return 如果通知成功返回pdPASS，否则返回errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">BaseType_t <span class=\"title function_\">xTaskNotify</span><span class=\"params\">(TaskHandle_t xTaskToNotify,</span></span><br><span class=\"line\"><span class=\"params\">                       <span class=\"type\">uint32_t</span> ulValue,</span></span><br><span class=\"line\"><span class=\"params\">                       eNotifyAction eAction)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 将任务设置为等待接收通知</span></span><br><span class=\"line\"><span class=\"comment\"> * @param ulBitsToClearOnEntry 进入等待前要清除的位</span></span><br><span class=\"line\"><span class=\"comment\"> * @param ulBitsToClearOnExit 退出等待后要清除的位</span></span><br><span class=\"line\"><span class=\"comment\"> * @param pulNotificationValue 指向接收通知值的指针</span></span><br><span class=\"line\"><span class=\"comment\"> * @param xTicksToWait 等待通知的最大时间（以滴答为单位）</span></span><br><span class=\"line\"><span class=\"comment\"> * @return 如果在指定的等待时间内收到通知，则返回pdTRUE；否则返回</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">BaseType_t <span class=\"title function_\">xTaskNotifyWait</span><span class=\"params\">(<span class=\"type\">uint32_t</span> ulBitsToClearOnEntry,</span></span><br><span class=\"line\"><span class=\"params\">                           <span class=\"type\">uint32_t</span> ulBitsToClearOnExit,</span></span><br><span class=\"line\"><span class=\"params\">                           <span class=\"type\">uint32_t</span> *pulNotificationValue,</span></span><br><span class=\"line\"><span class=\"params\">                           TickType_t xTicksToWait)</span>;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"调用示例-2\"><a href=\"#调用示例-2\" class=\"headerlink\" title=\"调用示例\"></a>调用示例</h5><h6 id=\"事件组设置\"><a href=\"#事件组设置\" class=\"headerlink\" title=\"事件组设置\"></a>事件组设置</h6><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;freertos/FreeRTOS.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;freertos/task.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;freertos/queue.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;freertos/semphr.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;freertos/event_groups.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;esp_log.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> EVENT_BIT_0 BIT0</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> EVENT_BIT_1 BIT1</span></span><br><span class=\"line\"></span><br><span class=\"line\">EventGroupHandle_t event_handle;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">taskA</span><span class=\"params\">(<span class=\"type\">void</span> *param)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 定时1s向任务B发送事件消息</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        xEventGroupSetBits(event_handle, EVENT_BIT_0);</span><br><span class=\"line\">        vTaskDelay(pdMS_TO_TICKS(<span class=\"number\">1000</span>));</span><br><span class=\"line\">        xEventGroupSetBits(event_handle, EVENT_BIT_1);</span><br><span class=\"line\">        vTaskDelay(pdMS_TO_TICKS(<span class=\"number\">1000</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">taskB</span><span class=\"params\">(<span class=\"type\">void</span> *param)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    EventBits_t ev;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        ev = xEventGroupWaitBits(event_handle, EVENT_BIT_0 | EVENT_BIT_1, pdTRUE, pdFALSE, pdMS_TO_TICKS(<span class=\"number\">5000</span>));</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ev &amp; EVENT_BIT_0)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            ESP_LOGI(<span class=\"string\">&quot;ev&quot;</span>, <span class=\"string\">&quot;ev get event0&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ev &amp; EVENT_BIT_1)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            ESP_LOGI(<span class=\"string\">&quot;ev&quot;</span>, <span class=\"string\">&quot;ev get event1&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">app_main</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    event_handle = xEventGroupCreate();</span><br><span class=\"line\">    xTaskCreatePinnedToCore(taskA, <span class=\"string\">&quot;taskA&quot;</span>, <span class=\"number\">2048</span>, <span class=\"literal\">NULL</span>, <span class=\"number\">3</span>, <span class=\"literal\">NULL</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">    xTaskCreatePinnedToCore(taskB, <span class=\"string\">&quot;taskB&quot;</span>, <span class=\"number\">2048</span>, <span class=\"literal\">NULL</span>, <span class=\"number\">3</span>, <span class=\"literal\">NULL</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"消息直达\"><a href=\"#消息直达\" class=\"headerlink\" title=\"消息直达\"></a>消息直达</h6><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;freertos/FreeRTOS.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;freertos/task.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;freertos/queue.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;freertos/semphr.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;freertos/event_groups.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;esp_log.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> TaskHandle_t taskA_handle;</span><br><span class=\"line\"><span class=\"type\">static</span> TaskHandle_t taskB_handle;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">taskA</span><span class=\"params\">(<span class=\"type\">void</span> *param)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 定时1s向任务B发送事件消息</span></span><br><span class=\"line\">    <span class=\"type\">uint32_t</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">    vTaskDelay(pdMS_TO_TICKS(<span class=\"number\">100</span>));</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        xTaskNotify(taskB_handle, count, eSetValueWithoutOverwrite);</span><br><span class=\"line\">        count++;</span><br><span class=\"line\">        vTaskDelay(pdMS_TO_TICKS(<span class=\"number\">1000</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">taskB</span><span class=\"params\">(<span class=\"type\">void</span> *param)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">uint32_t</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        xTaskNotifyWait(<span class=\"number\">0</span>, <span class=\"number\">0</span>, &amp;count, portMAX_DELAY);</span><br><span class=\"line\">        ESP_LOGI(<span class=\"string\">&quot;taskB&quot;</span>, <span class=\"string\">&quot;Notify count: %lu&quot;</span>, count);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">app_main</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    xTaskCreatePinnedToCore(taskA, <span class=\"string\">&quot;taskA&quot;</span>, <span class=\"number\">2048</span>, <span class=\"literal\">NULL</span>, <span class=\"number\">3</span>, &amp;taskA_handle, <span class=\"number\">1</span>);</span><br><span class=\"line\">    xTaskCreatePinnedToCore(taskB, <span class=\"string\">&quot;taskB&quot;</span>, <span class=\"number\">2048</span>, <span class=\"literal\">NULL</span>, <span class=\"number\">3</span>, &amp;taskB_handle, <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"ESP-IDF中的FreeRTOS与原生区别\"><a href=\"#ESP-IDF中的FreeRTOS与原生区别\" class=\"headerlink\" title=\"ESP-IDF中的FreeRTOS与原生区别\"></a>ESP-IDF中的FreeRTOS与原生区别</h4><blockquote>\n<ol>\n<li>ESP32是多核的 所以可以完全实现程序并发执行 即不是单核那种 低优先级的任务因为高优先级任务存在而执行不了</li>\n<li>esp-idf自动创建五个任务<ul>\n<li>空闲任务（每个核都会创建一个，<code>优先级为0</code>）</li>\n<li>FreeRTOS定时器任务（<code>优先级为1</code>）</li>\n<li>app_main任务（我们的应用入口，<code>优先级为1</code>）</li>\n<li>IPC任务（每个核创建一个，用于多核协调，<code>优先级为24</code>）</li>\n<li>ESP定时器任务（负责ESP32定时器回调，<code>优先级为22</code>）</li>\n</ul>\n</li>\n<li>esp-idf不使用原生FreeRTOS的内存堆管理，实现了自己的堆</li>\n<li>创建任务使用<code>xTaskCreatePinnedToCore()</code> 可以指定用哪个核创建任务<ul>\n<li>负责处理<code>无线网络的任务（如WiFi蓝牙）</code>将被固定到<code>CPU0</code>，即<code>PRO_CPU</code></li>\n<li>处理<code>应用程序</code>其余部分任务将被固定到<code>CPU1</code>，即<code>APP_CPU</code></li>\n</ul>\n</li>\n<li>如果任务中用到浮点运算，则创建任务的时候必须指定具体运行在哪个核上，不能由系统自动安排</li>\n</ol>\n</blockquote>\n<h2 id=\"GPIO配置\"><a href=\"#GPIO配置\" class=\"headerlink\" title=\"GPIO配置\"></a>GPIO配置</h2><h3 id=\"引脚基础配置\"><a href=\"#引脚基础配置\" class=\"headerlink\" title=\"引脚基础配置\"></a>引脚基础配置</h3><h4 id=\"gpio-config-：批量配置-GPIO（核心入口）\"><a href=\"#gpio-config-：批量配置-GPIO（核心入口）\" class=\"headerlink\" title=\"gpio_config()：批量配置 GPIO（核心入口）\"></a><code>gpio_config()</code>：批量配置 GPIO（核心入口）</h4><ul>\n<li><p><strong>函数原型</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">esp_err_t</span> <span class=\"title function_\">gpio_config</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">gpio_config_t</span> *pGPIOConfig)</span>;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>作用</strong>：一次性配置一组 GPIO 的模式、上下拉、中断类型（覆盖该引脚当前所有配置）。</p>\n</li>\n<li><p><strong>参数</strong>：<code>pGPIOConfig</code>：指向 <code>gpio_config_t</code> 结构体的指针（需提前初始化）。</p>\n</li>\n<li><p><strong>返回值</strong>：<code>ESP_OK</code>（成功）、<code>ESP_ERR_INVALID_ARG</code>（参数错误，如引脚无效）。</p>\n</li>\n<li><p><strong>示例</strong>：配置 GPIO2、GPIO3 为输出模式，禁用上下拉和中断：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">gpio_config_t</span> io_conf = &#123;</span><br><span class=\"line\">    .pin_bit_mask = (<span class=\"number\">1ULL</span> &lt;&lt; GPIO_NUM_2) | (<span class=\"number\">1ULL</span> &lt;&lt; GPIO_NUM_3),  <span class=\"comment\">// 仅配置 GPIO2</span></span><br><span class=\"line\">    .mode = GPIO_MODE_OUTPUT,</span><br><span class=\"line\">    .pull_up_en = GPIO_PULLUP_DISABLE,</span><br><span class=\"line\">    .pull_down_en = GPIO_PULLDOWN_DISABLE,</span><br><span class=\"line\">    .intr_type = GPIO_INTR_DISABLE</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">gpio_config(&amp;io_conf);  <span class=\"comment\">// 执行配置</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n<blockquote>\n<p><code>intr_type</code> :</p>\n<ul>\n<li><code>GPIO_INTR_DISABLE</code>：禁用中断</li>\n<li><code>GPIO_INTR_POSEDGE</code>：上升沿触发</li>\n<li><code>GPIO_INTR_NEGEDGE</code>：下降沿触发</li>\n<li><code>GPIO_INTR_ANYEDGE</code>：双边沿触发</li>\n<li><code>GPIO_INTR_LOW_LEVEL</code>：低电平触发</li>\n<li><code>GPIO_INTR_HIGH_LEVEL</code>：高电平触发</li>\n</ul>\n</blockquote>\n<h4 id=\"gpio-reset-pin-：重置引脚为默认状态\"><a href=\"#gpio-reset-pin-：重置引脚为默认状态\" class=\"headerlink\" title=\"gpio_reset_pin()：重置引脚为默认状态\"></a><code>gpio_reset_pin()</code>：重置引脚为默认状态</h4><ul>\n<li><p><strong>函数原型</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">esp_err_t</span> <span class=\"title function_\">gpio_reset_pin</span><span class=\"params\">(<span class=\"type\">gpio_num_t</span> gpio_num)</span>;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>作用</strong>：将指定 GPIO 重置为默认状态（输入模式、禁用上下拉、禁用中断、选择 GPIO 功能）。</p>\n</li>\n<li><p><strong>参数</strong>：<code>gpio_num</code>：要重置的 GPIO 编号（如 <code>GPIO_NUM_4</code>）。</p>\n</li>\n<li><p><strong>示例</strong>：重置 GPIO4，恢复初始状态：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gpio_reset_pin(GPIO_NUM_4);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h4 id=\"gpio-set-direction-：单独设置引脚方向\"><a href=\"#gpio-set-direction-：单独设置引脚方向\" class=\"headerlink\" title=\"gpio_set_direction()：单独设置引脚方向\"></a><code>gpio_set_direction()</code>：单独设置引脚方向</h4><ul>\n<li><p><strong>函数原型</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">esp_err_t</span> <span class=\"title function_\">gpio_set_direction</span><span class=\"params\">(<span class=\"type\">gpio_num_t</span> gpio_num, <span class=\"type\">gpio_mode_t</span> mode)</span>;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>作用</strong>：单独修改某个 GPIO 的模式（输入 &#x2F; 输出 &#x2F; 输入输出），覆盖当前模式。</p>\n</li>\n<li><p><strong>参数</strong></p>\n<ul>\n<li><code>gpio_num</code>：目标 GPIO 编号。</li>\n<li><code>mode</code>：目标模式（如 <code>GPIO_MODE_INPUT</code>）。</li>\n</ul>\n</li>\n<li><p><strong>示例</strong>：将已配置的 GPIO2 改为输入模式</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gpio_set_direction(GPIO_NUM_2, GPIO_MODE_INPUT);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h4 id=\"配置上下拉函数（gpio-pullup-en-gpio-pulldown-en）\"><a href=\"#配置上下拉函数（gpio-pullup-en-gpio-pulldown-en）\" class=\"headerlink\" title=\"配置上下拉函数（gpio_pullup_en&#x2F;gpio_pulldown_en）\"></a>配置上下拉函数（<code>gpio_pullup_en</code>&#x2F;<code>gpio_pulldown_en</code>）</h4><ul>\n<li><p><strong>函数原型</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">esp_err_t</span> <span class=\"title function_\">gpio_pullup_en</span><span class=\"params\">(<span class=\"type\">gpio_num_t</span> gpio_num)</span>;    <span class=\"comment\">// 启用上拉</span></span><br><span class=\"line\"><span class=\"type\">esp_err_t</span> <span class=\"title function_\">gpio_pullup_dis</span><span class=\"params\">(<span class=\"type\">gpio_num_t</span> gpio_num)</span>;   <span class=\"comment\">// 禁用上拉</span></span><br><span class=\"line\"><span class=\"type\">esp_err_t</span> <span class=\"title function_\">gpio_pulldown_en</span><span class=\"params\">(<span class=\"type\">gpio_num_t</span> gpio_num)</span>;  <span class=\"comment\">// 启用下拉</span></span><br><span class=\"line\"><span class=\"type\">esp_err_t</span> <span class=\"title function_\">gpio_pulldown_dis</span><span class=\"params\">(<span class=\"type\">gpio_num_t</span> gpio_num)</span>; <span class=\"comment\">// 禁用下拉</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>作用</strong>：比 <code>gpio_set_pull_mode</code> 更直观，单独控制上拉 &#x2F; 下拉的启用 &#x2F; 禁用。</p>\n</li>\n<li><p><strong>示例</strong>：启用 GPIO0 下拉，禁用上拉：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gpio_pulldown_en(GPIO_NUM_0);</span><br><span class=\"line\">gpio_pullup_dis(GPIO_NUM_0);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"引脚电平控制函数\"><a href=\"#引脚电平控制函数\" class=\"headerlink\" title=\"引脚电平控制函数\"></a>引脚电平控制函数</h3><h4 id=\"gpio-set-level-：设置输出电平\"><a href=\"#gpio-set-level-：设置输出电平\" class=\"headerlink\" title=\"gpio_set_level()：设置输出电平\"></a><code>gpio_set_level()</code>：设置输出电平</h4><ul>\n<li><p><strong>函数原型</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">esp_err_t</span> <span class=\"title function_\">gpio_set_level</span><span class=\"params\">(<span class=\"type\">gpio_num_t</span> gpio_num, <span class=\"type\">uint32_t</span> level)</span>;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>作用</strong>：给输出模式的 GPIO 设置高 &#x2F; 低电平（仅输出模式有效）。</p>\n</li>\n<li><p><strong>参数</strong>：</p>\n<ul>\n<li><code>level</code>：<code>0</code>（低电平）、<code>1</code>（高电平）。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"gpio-get-level-：读取输入电平\"><a href=\"#gpio-get-level-：读取输入电平\" class=\"headerlink\" title=\"gpio_get_level()：读取输入电平\"></a><code>gpio_get_level()</code>：读取输入电平</h4><ul>\n<li><p><strong>函数原型</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">gpio_get_level</span><span class=\"params\">(<span class=\"type\">gpio_num_t</span> gpio_num)</span>;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>作用</strong>：读取 GPIO 的当前输入电平（需引脚为输入 &#x2F; 输入输出模式，否则返回 0）。</p>\n</li>\n<li><p><strong>返回值</strong>：<code>0</code>（低电平）、<code>1</code>（高电平）。</p>\n</li>\n</ul>\n<h2 id=\"LEDC库学习笔记\"><a href=\"#LEDC库学习笔记\" class=\"headerlink\" title=\"LEDC库学习笔记\"></a>LEDC库学习笔记</h2><blockquote>\n<p><strong>定义</strong>：LEDC（Light Emitting Diode Controller）是 ESP32 内置的 LED 控制器，核心功能是生成 PWM（脉冲宽度调制）信号，不仅用于 LED 亮度调节，还可驱动电机、舵机等需 PWM 信号的设备。</p>\n<p><strong>核心优势</strong>：无需手动编写定时器中断逻辑，ESP-IDF 提供完整库接口，配置简单、信号稳定</p>\n<p><strong>注意</strong>：LEDC 控制器有自己<code>专属的 4 个定时器</code>（<code>LEDC_TIMER_0</code> ~ <code>LEDC_TIMER_3</code>），这些定时器是 LEDC 模块内部集成的，专门用于生成 PWM 信号。</p>\n<p>与<code>通用定时器（TIMER_0 ~ TIMER_3）</code>完全分离</p>\n</blockquote>\n<h3 id=\"LEDC关键概念\"><a href=\"#LEDC关键概念\" class=\"headerlink\" title=\"LEDC关键概念\"></a>LEDC关键概念</h3><table>\n<thead>\n<tr>\n<th>概念</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>通道（Channel）</td>\n<td>ESP32 有 16 个独立通道，每个通道可独立配置 PWM 参数（频率、占空比），并映射到 1 个 GPIO 引脚输出信号。</td>\n</tr>\n<tr>\n<td>定时器（Timer）</td>\n<td>每个通道需绑定定时器，定时器决定 PWM 频率（由预分频和计数范围计算），多个通道可共享同一定时器（频率相同）。</td>\n</tr>\n<tr>\n<td>频率（Frequency）</td>\n<td>PWM 信号周期的倒数（单位：Hz），如 50Hz（舵机常用，对应 20ms 周期）、1000Hz（LED 常用，避免人眼闪烁）。</td>\n</tr>\n<tr>\n<td>占空比（Duty Cycle）</td>\n<td>PWM 高电平持续时间与周期的比值（0<del>100%），LEDC 中用数值表示（如 12 位分辨率对应 0</del>4095）。</td>\n</tr>\n<tr>\n<td>分辨率（Duty Resolution）</td>\n<td>占空比的可调精度，范围 <code>LEDC_TIMER_1_BIT</code><del><code>LEDC_TIMER_20_BIT</code>，如 12 位表示占空比可设为 0</del>4095（共 4096 级）。</td>\n</tr>\n<tr>\n<td>速度模式</td>\n<td>分 <code>LEDC_LOW_SPEED_MODE</code>（低速模式）和 <code>LEDC_HIGH_SPEED_MODE</code>（高速模式），高速模式支持更高 PWM 频率。</td>\n</tr>\n</tbody></table>\n<h3 id=\"常用API（需包含头文件-driver-ledc-h）\"><a href=\"#常用API（需包含头文件-driver-ledc-h）\" class=\"headerlink\" title=\"常用API（需包含头文件 driver/ledc.h）\"></a>常用API（需包含头文件 <code>driver/ledc.h</code>）</h3><h4 id=\"定时器初始化\"><a href=\"#定时器初始化\" class=\"headerlink\" title=\"定时器初始化\"></a>定时器初始化</h4><ul>\n<li><p><strong>作用</strong>：初始化 LEDC 定时器，设置频率、分辨率等核心参数。</p>\n</li>\n<li><p>函数原型</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">esp_err_t</span> <span class=\"title function_\">ledc_timer_config</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">ledc_timer_config_t</span> *timer_conf)</span>;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>参数结构体 <code>ledc_timer_config_t</code> 说明</strong>：</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>取值 &#x2F; 说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>speed_mode</code></td>\n<td>速度模式：<code>LEDC_LOW_SPEED_MODE</code> 或 <code>LEDC_HIGH_SPEED_MODE</code></td>\n</tr>\n<tr>\n<td><code>duty_resolution</code></td>\n<td>占空比分辨率：<code>LEDC_TIMER_1_BIT</code> ~ <code>LEDC_TIMER_20_BIT</code>（如 12 位选 <code>LEDC_TIMER_12_BIT</code>）</td>\n</tr>\n<tr>\n<td><code>timer_num</code></td>\n<td>定时器编号：<code>LEDC_TIMER_0</code> ~ <code>LEDC_TIMER_3</code>（共 4 个定时器）</td>\n</tr>\n<tr>\n<td><code>freq_hz</code></td>\n<td>PWM 频率（如 50、1000，单位：Hz）</td>\n</tr>\n<tr>\n<td><code>clk_cfg</code></td>\n<td>时钟源：通常用 <code>LEDC_AUTO_CLK</code>（自动选择最优时钟）</td>\n</tr>\n</tbody></table>\n</li>\n<li><p><strong>示例</strong>：配置 1000Hz、12 位分辨率的定时器 0（低速模式）</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">ledc_timer_config_t</span> timer_conf = &#123;</span><br><span class=\"line\">    .speed_mode = LEDC_LOW_SPEED_MODE,</span><br><span class=\"line\">    .duty_resolution = LEDC_TIMER_12_BIT,  <span class=\"comment\">// 0~4095 级占空比</span></span><br><span class=\"line\">    .timer_num = LEDC_TIMER_0,</span><br><span class=\"line\">    .freq_hz = <span class=\"number\">1000</span>,                       <span class=\"comment\">// 1000Hz 频率</span></span><br><span class=\"line\">    .clk_cfg = LEDC_AUTO_CLK</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">ledc_timer_config(&amp;timer_conf);  <span class=\"comment\">// 执行配置</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n<h4 id=\"通道配置：ledc-channel-config\"><a href=\"#通道配置：ledc-channel-config\" class=\"headerlink\" title=\"通道配置：ledc_channel_config()\"></a>通道配置：<code>ledc_channel_config()</code></h4><h4 id=\"通道配置：ledc-channel-config-1\"><a href=\"#通道配置：ledc-channel-config-1\" class=\"headerlink\" title=\"通道配置：ledc_channel_config()\"></a>通道配置：<code>ledc_channel_config()</code></h4><ul>\n<li><p><strong>作用</strong>：将 LEDC 通道绑定到定时器和 GPIO 引脚，设置初始占空比。</p>\n</li>\n<li><p><strong>函数原型</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">esp_err_t</span> <span class=\"title function_\">ledc_channel_config</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">ledc_channel_config_t</span> *channel_conf)</span>;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>参数结构体</strong> <code>ledc_channel_config_t</code> <strong>说明</strong></p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>取值 &#x2F; 说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>speed_mode</code></td>\n<td>需与绑定的定时器速度模式一致（如 <code>LEDC_LOW_SPEED_MODE</code>）</td>\n</tr>\n<tr>\n<td><code>channel</code></td>\n<td>通道编号：<code>LEDC_CHANNEL_0</code> ~ <code>LEDC_CHANNEL_15</code>（共 16 个通道）</td>\n</tr>\n<tr>\n<td><code>timer_sel</code></td>\n<td>绑定的定时器编号（如 <code>LEDC_TIMER_0</code>）</td>\n</tr>\n<tr>\n<td><code>intr_type</code></td>\n<td>中断类型：通常设 <code>LEDC_INTR_DISABLE</code>（禁用中断）</td>\n</tr>\n<tr>\n<td><code>gpio_num</code></td>\n<td>输出 PWM 的 GPIO 引脚（如 <code>GPIO_NUM_2</code>、<code>GPIO_NUM_4</code>）</td>\n</tr>\n<tr>\n<td><code>duty</code></td>\n<td>初始占空比（0 ~ 分辨率最大值，如 12 位初始为 0 表示 LED 灭）</td>\n</tr>\n<tr>\n<td><code>hpoint</code></td>\n<td>脉冲起点偏移：通常设 0（无偏移）</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>示例</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">ledc_channel_config_t</span> channel_conf = &#123;</span><br><span class=\"line\">    .speed_mode = LEDC_LOW_SPEED_MODE,</span><br><span class=\"line\">    .channel = LEDC_CHANNEL_0,</span><br><span class=\"line\">    .timer_sel = LEDC_TIMER_0,  <span class=\"comment\">// 绑定定时器 0</span></span><br><span class=\"line\">    .intr_type = LEDC_INTR_DISABLE,</span><br><span class=\"line\">    .gpio_num = GPIO_NUM_2,     <span class=\"comment\">// GPIO2 输出 PWM</span></span><br><span class=\"line\">    .duty = <span class=\"number\">0</span>,                  <span class=\"comment\">// 初始占空比 0（LED 不亮）</span></span><br><span class=\"line\">    .hpoint = <span class=\"number\">0</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">ledc_channel_config(&amp;channel_conf);  <span class=\"comment\">// 执行配置</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n<h4 id=\"3-占空比修改：ledc-set-duty-ledc-update-duty\"><a href=\"#3-占空比修改：ledc-set-duty-ledc-update-duty\" class=\"headerlink\" title=\"3. 占空比修改：ledc_set_duty() + ledc_update_duty()\"></a>3. 占空比修改：<code>ledc_set_duty()</code> + <code>ledc_update_duty()</code></h4><ul>\n<li><p><strong>作用</strong>：动态调整通道的 PWM 占空比（<code>ledc_set_duty</code> 仅修改寄存器，<code>ledc_update_duty</code> 使修改生效）。</p>\n</li>\n<li><p><strong>函数原型</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1. 设置占空比（不立即生效）</span></span><br><span class=\"line\"><span class=\"type\">esp_err_t</span> <span class=\"title function_\">ledc_set_duty</span><span class=\"params\">(<span class=\"type\">ledc_mode_t</span> speed_mode, <span class=\"type\">ledc_channel_t</span> channel, <span class=\"type\">uint32_t</span> duty)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 2. 使占空比生效</span></span><br><span class=\"line\"><span class=\"type\">esp_err_t</span> <span class=\"title function_\">ledc_update_duty</span><span class=\"params\">(<span class=\"type\">ledc_mode_t</span> speed_mode, <span class=\"type\">ledc_channel_t</span> channel)</span>;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>参数说明</strong></p>\n<ul>\n<li><code>speed_mode</code>：速度模式（与通道一致）</li>\n<li><code>channel</code>：目标通道编号</li>\n<li><code>duty</code>：目标占空比（0 ~ 分辨率最大值）</li>\n</ul>\n</li>\n<li><p><strong>示例</strong>：将通道 0 占空比设为 50%（12 位分辨率对应 2048）</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 12 位分辨率下，50% 占空比 = 4096 / 2 = 2048</span></span><br><span class=\"line\">ledc_set_duty(LEDC_LOW_SPEED_MODE, LEDC_CHANNEL_0, <span class=\"number\">2048</span>);</span><br><span class=\"line\">ledc_update_duty(LEDC_LOW_SPEED_MODE, LEDC_CHANNEL_0);  <span class=\"comment\">// 占空比生效</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n<h4 id=\"4-硬件渐变：ledc-fade-系列函数\"><a href=\"#4-硬件渐变：ledc-fade-系列函数\" class=\"headerlink\" title=\"4. 硬件渐变：ledc_fade_* 系列函数\"></a>4. 硬件渐变：<code>ledc_fade_*</code> 系列函数</h4><ul>\n<li><p><strong>作用</strong>：实现硬件自动渐变（无需软件循环），适合 LED 呼吸灯、平滑调光等场景。</p>\n</li>\n<li><p><strong>核心函数</strong>：</p>\n<table>\n<thead>\n<tr>\n<th>函数</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>ledc_fade_func_install()</code></td>\n<td>初始化渐变功能（需开启中断，参数 0 表示不使用中断回调）</td>\n</tr>\n<tr>\n<td><code>ledc_set_fade_with_time()</code></td>\n<td>配置渐变参数（目标占空比、渐变时间）</td>\n</tr>\n<tr>\n<td><code>ledc_fade_start()</code></td>\n<td>启动渐变（可选择阻塞 &#x2F; 非阻塞模式）</td>\n</tr>\n<tr>\n<td><code>ledc_cb_register()</code></td>\n<td>注册 LEDC 回调函数</td>\n</tr>\n</tbody></table>\n</li>\n<li><p><strong>函数原型</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1. 初始化渐变功能</span></span><br><span class=\"line\"><span class=\"type\">esp_err_t</span> <span class=\"title function_\">ledc_fade_func_install</span><span class=\"params\">(<span class=\"type\">int</span> intr_alloc_flags)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 2. 配置渐变：在指定时间内从当前占空比渐变到目标占空比</span></span><br><span class=\"line\"><span class=\"type\">esp_err_t</span> <span class=\"title function_\">ledc_set_fade_with_time</span><span class=\"params\">(<span class=\"type\">ledc_mode_t</span> speed_mode, <span class=\"type\">ledc_channel_t</span> channel, <span class=\"type\">uint32_t</span> target_duty, <span class=\"type\">uint32_t</span> fade_time_ms)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 3. 启动渐变</span></span><br><span class=\"line\"><span class=\"type\">esp_err_t</span> <span class=\"title function_\">ledc_fade_start</span><span class=\"params\">(<span class=\"type\">ledc_mode_t</span> speed_mode, <span class=\"type\">ledc_channel_t</span> channel, <span class=\"type\">ledc_fade_mode_t</span> fade_mode)</span>;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>参数说明</strong>：</p>\n<ul>\n<li><code>intr_alloc_flags</code>：中断分配标志（设 0 即可）</li>\n<li><code>target_duty</code>：渐变目标占空比</li>\n<li><code>fade_time_ms</code>：渐变总时间（单位：ms）</li>\n<li><code>fade_mode</code>：渐变模式：<code>LEDC_FADE_WAIT_DONE</code>（阻塞，等待渐变完成返回）&#x2F; <code>LEDC_FADE_NO_WAIT</code>（非阻塞）</li>\n</ul>\n</li>\n<li><p><strong>示例</strong>：2 秒内从当前占空比渐变到最大亮度（12 位对应 4095）</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1. 初始化渐变功能</span></span><br><span class=\"line\">ledc_fade_func_install(<span class=\"number\">0</span>);  <span class=\"comment\">// 不使用中断回调</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2. 配置渐变：2000ms（2秒）内渐变到 4095（最大亮度）</span></span><br><span class=\"line\">ledc_set_fade_with_time(LEDC_LOW_SPEED_MODE, </span><br><span class=\"line\">                        LEDC_CHANNEL_0, </span><br><span class=\"line\">                        <span class=\"number\">4095</span>,        <span class=\"comment\">// 目标占空比（最大）</span></span><br><span class=\"line\">                        <span class=\"number\">2000</span>);       <span class=\"comment\">// 渐变时间（ms）</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 3. 启动渐变（阻塞模式，等待渐变完成后再执行后续代码）</span></span><br><span class=\"line\">ledc_fade_start(LEDC_LOW_SPEED_MODE, LEDC_CHANNEL_0, LEDC_FADE_WAIT_DONE);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h5 id=\"启用中断模式\"><a href=\"#启用中断模式\" class=\"headerlink\" title=\"启用中断模式\"></a>启用中断模式</h5><ul>\n<li><p><strong>函数原型</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">esp_err_t</span> <span class=\"title function_\">ledc_cb_register</span><span class=\"params\">(<span class=\"type\">ledc_mode_t</span> speed_mode, <span class=\"type\">ledc_channel_t</span> channel, <span class=\"type\">ledc_cbs_t</span> *cbs, <span class=\"type\">void</span> *user_arg)</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>参数结构体</strong> <code>ledc_cbs_t</code> <strong>说明</strong></p>\n<ul>\n<li><code>fade_cb</code>：需要注册的中断回调函数</li>\n</ul>\n</li>\n<li><p><strong>示例</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;freertos/FreeRTOS.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;freertos/task.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;driver/gpio.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;driver/ledc.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LED_GPIO GPIO_NUM_18</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> FULL_EV_BIT BIT0</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> EMPTY_EV_BIT BIT1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> EventGroupHandle_t led_fade_handle;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief 重写LEDC完成回调函数</span></span><br><span class=\"line\"><span class=\"comment\"> * @note IRAM_ATTR 修饰符表示该函数在IRAM中执行，中断服务程序中不能调用RAM中的函数</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">bool</span> IRAM_ATTR <span class=\"title function_\">ledc_finish_cb</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">ledc_cb_param_t</span> *param, <span class=\"type\">void</span> *user_arg)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    BaseType_t taskWoken;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (param-&gt;duty)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        xEventGroupSetBitsFromISR(led_fade_handle, FULL_EV_BIT, &amp;taskWoken);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        xEventGroupSetBitsFromISR(led_fade_handle, EMPTY_EV_BIT, &amp;taskWoken);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> taskWoken;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">led_run_task</span><span class=\"params\">(<span class=\"type\">void</span> *param)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    EventBits_t ev;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        ev = xEventGroupWaitBits(led_fade_handle, FULL_EV_BIT | EMPTY_EV_BIT, pdTRUE, pdFALSE, pdMS_TO_TICKS(<span class=\"number\">5000</span>));</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ev &amp; FULL_EV_BIT)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            ledc_set_fade_with_time(LEDC_LOW_SPEED_MODE, LEDC_CHANNEL_0, <span class=\"number\">0</span>, <span class=\"number\">2000</span>);</span><br><span class=\"line\">            ledc_fade_start(LEDC_LOW_SPEED_MODE, LEDC_CHANNEL_0, LEDC_FADE_NO_WAIT);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ev &amp; EMPTY_EV_BIT)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            ledc_set_fade_with_time(LEDC_LOW_SPEED_MODE, LEDC_CHANNEL_0, <span class=\"number\">8191</span>, <span class=\"number\">2000</span>);</span><br><span class=\"line\">            ledc_fade_start(LEDC_LOW_SPEED_MODE, LEDC_CHANNEL_0, LEDC_FADE_NO_WAIT);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">ledc_cbs_t</span> ledc_cbs = &#123;</span><br><span class=\"line\">            .fade_cb = ledc_finish_cb,</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        ledc_cb_register(LEDC_LOW_SPEED_MODE, LEDC_CHANNEL_0, &amp;ledc_cbs, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">app_main</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// gpio_config_t led_cfg = &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//     .pin_bit_mask = (1 &lt;&lt; LED_GPIO),</span></span><br><span class=\"line\">    <span class=\"comment\">//     .pull_down_en = GPIO_PULLDOWN_DISABLE,</span></span><br><span class=\"line\">    <span class=\"comment\">//     .pull_up_en = GPIO_PULLUP_DISABLE,</span></span><br><span class=\"line\">    <span class=\"comment\">//     .intr_type = GPIO_INTR_DISABLE,</span></span><br><span class=\"line\">    <span class=\"comment\">//     .mode = GPIO_MODE_OUTPUT,</span></span><br><span class=\"line\">    <span class=\"comment\">// &#125;;</span></span><br><span class=\"line\">    <span class=\"comment\">// gpio_config(&amp;led_cfg);</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">ledc_timer_config_t</span> ledc_timer = &#123;</span><br><span class=\"line\">        .speed_mode = LEDC_LOW_SPEED_MODE,</span><br><span class=\"line\">        .timer_num = LEDC_TIMER_0,</span><br><span class=\"line\">        .clk_cfg = LEDC_AUTO_CLK,</span><br><span class=\"line\">        .freq_hz = <span class=\"number\">5000</span>,</span><br><span class=\"line\">        .duty_resolution = LEDC_TIMER_13_BIT, <span class=\"comment\">// 占空比分辨率 0-8191</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    ledc_timer_config(&amp;ledc_timer);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">ledc_channel_config_t</span> ledc_channel = &#123;</span><br><span class=\"line\">        .gpio_num = LED_GPIO,</span><br><span class=\"line\">        .channel = LEDC_CHANNEL_0,</span><br><span class=\"line\">        .duty = <span class=\"number\">0</span>,</span><br><span class=\"line\">        .speed_mode = LEDC_LOW_SPEED_MODE,</span><br><span class=\"line\">        .timer_sel = LEDC_TIMER_0,</span><br><span class=\"line\">        .intr_type = LEDC_INTR_DISABLE,</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    ledc_channel_config(&amp;ledc_channel);</span><br><span class=\"line\"></span><br><span class=\"line\">    ledc_fade_func_install(<span class=\"number\">0</span>); <span class=\"comment\">// 使能渐变 不需要自己手动调节占空比</span></span><br><span class=\"line\">    ledc_set_fade_with_time(LEDC_LOW_SPEED_MODE, LEDC_CHANNEL_0, <span class=\"number\">8191</span>, <span class=\"number\">2000</span>);</span><br><span class=\"line\">    ledc_fade_start(LEDC_LOW_SPEED_MODE, LEDC_CHANNEL_0, LEDC_FADE_NO_WAIT);</span><br><span class=\"line\"></span><br><span class=\"line\">    led_fade_handle = xEventGroupCreate();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">ledc_cbs_t</span> ledc_cbs = &#123;</span><br><span class=\"line\">        .fade_cb = ledc_finish_cb,</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    ledc_cb_register(LEDC_LOW_SPEED_MODE, LEDC_CHANNEL_0, &amp;ledc_cbs, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    xTaskCreatePinnedToCore(led_run_task, <span class=\"string\">&quot;led_run_task&quot;</span>, <span class=\"number\">2048</span>, <span class=\"literal\">NULL</span>, <span class=\"number\">3</span>, <span class=\"literal\">NULL</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"UART配置\"><a href=\"#UART配置\" class=\"headerlink\" title=\"UART配置\"></a>UART配置</h2><h3 id=\"ESP32-UART-硬件特性\"><a href=\"#ESP32-UART-硬件特性\" class=\"headerlink\" title=\"ESP32 UART 硬件特性\"></a>ESP32 UART 硬件特性</h3><ul>\n<li><strong>硬件资源</strong>：ESP32 内置 3 个 UART 接口（UART0、UART1、UART2），支持不同引脚映射</li>\n<li><strong>通信参数</strong>：可配置波特率（1200 ~ 5000000bps）、数据位（5 ~ 8 位）、校验位（无 &#x2F; 奇 &#x2F; 偶）、停止位（1&#x2F;1.5&#x2F;2 位）</li>\n<li><strong>缓冲区</strong>：每个 UART 支持硬件 FIFO 缓冲区，可通过软件配置环形缓冲区大小</li>\n<li><strong>事件驱动</strong>：支持通过 FreeRTOS 队列触发 UART 事件（数据接收、缓冲区满、溢出等）</li>\n</ul>\n<h3 id=\"关键API\"><a href=\"#关键API\" class=\"headerlink\" title=\"关键API\"></a>关键API</h3><table>\n<thead>\n<tr>\n<th>API 函数</th>\n<th>功能描述</th>\n<th>核心参数说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>uart_param_config()</code></td>\n<td>配置 UART 通信参数（波特率、数据位等）</td>\n<td>端口号、<code>uart_config_t</code> 结构体</td>\n</tr>\n<tr>\n<td><code>uart_set_pin()</code></td>\n<td>绑定 UART 信号到物理引脚</td>\n<td>端口号、TX 引脚、RX 引脚、RTS 引脚、CTS 引脚</td>\n</tr>\n<tr>\n<td><code>uart_driver_install()</code></td>\n<td>安装 UART 驱动并创建事件队列</td>\n<td>端口号、接收缓冲区大小、发送缓冲区大小、队列容量、队列句柄、标志</td>\n</tr>\n<tr>\n<td><code>uart_read_bytes()</code></td>\n<td>读取 UART 接收数据</td>\n<td>端口号、接收缓冲区、读取长度、超时时间</td>\n</tr>\n<tr>\n<td><code>uart_write_bytes()</code></td>\n<td>发送 UART 数据</td>\n<td>端口号、发送缓冲区、发送长度</td>\n</tr>\n<tr>\n<td><code>uart_flush_input()</code></td>\n<td>清空 UART 接收缓冲区</td>\n<td>端口号</td>\n</tr>\n<tr>\n<td><code>xQueueReceive()</code></td>\n<td>从事件队列接收 UART 事件</td>\n<td>队列句柄、事件存储变量地址、超时时间</td>\n</tr>\n<tr>\n<td><code>xTaskCreate()</code></td>\n<td>创建独立任务处理 UART 事件</td>\n<td>任务函数、任务名称、栈大小、优先级等</td>\n</tr>\n</tbody></table>\n<h3 id=\"基础配置\"><a href=\"#基础配置\" class=\"headerlink\" title=\"基础配置\"></a>基础配置</h3><h4 id=\"步骤-1：定义核心参数（宏定义）\"><a href=\"#步骤-1：定义核心参数（宏定义）\" class=\"headerlink\" title=\"步骤 1：定义核心参数（宏定义）\"></a>步骤 1：定义核心参数（宏定义）</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1. 定义 UART 端口号</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> USER_UART_NUM UART_NUM_1  <span class=\"comment\">// 避免 UART0 冲突（默认用于串口打印）</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> USER_UART_BAUD 115200  <span class=\"comment\">// 串口波特率设置</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2. 定义引脚（需根据硬件接线调整）</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> UART_TX_PIN 17  <span class=\"comment\">// TX 发送引脚</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> UART_RX_PIN 16  <span class=\"comment\">// RX 接收引脚</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 3. 定义缓冲区和队列参数</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> UART_BUFFER_SIZE 1024    <span class=\"comment\">// 数据缓冲区大小</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> UART_QUEUE_SIZE 10       <span class=\"comment\">// 事件队列容量（最多缓存 10 个事件）</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> UART_TASK_STACK_SIZE 4096<span class=\"comment\">// UART 处理任务栈大小</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> UART_TASK_PRIORITY 5     <span class=\"comment\">// UART 任务优先级（1~24，数值越大优先级越高）</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 4. 全局变量声明</span></span><br><span class=\"line\"><span class=\"type\">static</span> QueueHandle_t uart_event_queue;  <span class=\"comment\">// UART 事件队列句柄</span></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">uint8_t</span> uart_rx_buffer[UART_BUFFER_SIZE];  <span class=\"comment\">// 接收数据缓冲区</span></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">const</span> <span class=\"type\">char</span> *TAG = <span class=\"string\">&quot;UART_DEV&quot;</span>;    <span class=\"comment\">// 日志标签</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"步骤-2：配置-UART-硬件参数\"><a href=\"#步骤-2：配置-UART-硬件参数\" class=\"headerlink\" title=\"步骤 2：配置 UART 硬件参数\"></a>步骤 2：配置 UART 硬件参数</h4><p>通过 <code>uart_config_t</code> 结构体配置通信参数，再调用 <code>uart_param_config()</code> 生效：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 配置 UART 通信参数</span></span><br><span class=\"line\"><span class=\"type\">uart_config_t</span> uart_config = &#123;</span><br><span class=\"line\">    .baud_rate = USER_UART_BAUD,          <span class=\"comment\">// 波特率（常用：9600、115200、1000000）</span></span><br><span class=\"line\">    .data_bits = UART_DATA_8_BITS,<span class=\"comment\">// 数据位：8 位</span></span><br><span class=\"line\">    .parity = UART_PARITY_DISABLE,<span class=\"comment\">// 校验位：禁用</span></span><br><span class=\"line\">    .stop_bits = UART_STOP_BITS_1,<span class=\"comment\">// 停止位：1 位</span></span><br><span class=\"line\">    .flow_ctrl = UART_HW_FLOWCTRL_DISABLE,  <span class=\"comment\">// 硬件流控：禁用（无需 RTS/CTS 引脚）</span></span><br><span class=\"line\">    .source_clk = UART_SCLK_DEFAULT,         <span class=\"comment\">// 时钟源：默认</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 应用配置到指定 UART 端口</span></span><br><span class=\"line\">ESP_ERROR_CHECK(uart_param_config(USER_UART_NUM, &amp;uart_config));</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"步骤-3：绑定引脚并安装驱动-（如果用默认串口的话-则不需要绑定引脚）\"><a href=\"#步骤-3：绑定引脚并安装驱动-（如果用默认串口的话-则不需要绑定引脚）\" class=\"headerlink\" title=\"步骤 3：绑定引脚并安装驱动 （如果用默认串口的话 则不需要绑定引脚）\"></a>步骤 3：绑定引脚并安装驱动 （如果用默认串口的话 则不需要绑定引脚）</h4><ul>\n<li><strong>引脚绑定</strong>：通过 <code>uart_set_pin()</code> 将 UART 信号映射到 ESP32 物理引脚</li>\n<li><strong>驱动安装</strong>：调用 <code>uart_driver_install()</code> 初始化 UART 驱动，创建事件队列（可选）</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1. 绑定 UART 引脚（TX/RX，流控引脚填 UART_PIN_NO_CHANGE 表示禁用）</span></span><br><span class=\"line\">ESP_ERROR_CHECK(uart_set_pin(USER_UART_NUM, </span><br><span class=\"line\">                            UART_TX_PIN,  <span class=\"comment\">// TX 引脚</span></span><br><span class=\"line\">                            UART_RX_PIN,  <span class=\"comment\">// RX 引脚</span></span><br><span class=\"line\">                            UART_PIN_NO_CHANGE,  <span class=\"comment\">// RTS 引脚（禁用）</span></span><br><span class=\"line\">                            UART_PIN_NO_CHANGE)); <span class=\"comment\">// CTS 引脚（禁用）</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2. 安装 UART 驱动（参数依次：端口号、接收缓冲区大小、发送缓冲区大小、事件队列容量、队列句柄、标志）</span></span><br><span class=\"line\">ESP_ERROR_CHECK(uart_driver_install(USER_UART_NUM, </span><br><span class=\"line\">                                    UART_BUFFER_SIZE * <span class=\"number\">2</span>,  <span class=\"comment\">// 接收缓冲区（建议比单次接收大）</span></span><br><span class=\"line\">                                    UART_BUFFER_SIZE * <span class=\"number\">2</span>,  <span class=\"comment\">// 发送缓冲区</span></span><br><span class=\"line\">                                    UART_QUEUE_SIZE,       <span class=\"comment\">// 事件队列容量</span></span><br><span class=\"line\">                                    &amp;uart_event_queue,     <span class=\"comment\">// 事件队列句柄（传出）</span></span><br><span class=\"line\">                                    <span class=\"number\">0</span>));                   <span class=\"comment\">// 标志：0（默认）</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"ESP32-UART-数据处理方式\"><a href=\"#ESP32-UART-数据处理方式\" class=\"headerlink\" title=\"ESP32 UART 数据处理方式\"></a>ESP32 UART 数据处理方式</h3><table>\n<thead>\n<tr>\n<th>特性</th>\n<th>轮询方式（简单场景）</th>\n<th>事件驱动方式（高效场景）</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>核心函数</td>\n<td><code>uart_read_bytes()</code>、<code>uart_write_bytes()</code></td>\n<td><code>xQueueReceive()</code>（监听事件队列）</td>\n</tr>\n<tr>\n<td>适用场景</td>\n<td>简单回显、低频率数据交互</td>\n<td>高频率数据、多事件处理（如溢出）</td>\n</tr>\n<tr>\n<td>CPU 占用率</td>\n<td>较高（循环查询）</td>\n<td>较低（事件触发，无轮询）</td>\n</tr>\n<tr>\n<td>代码复杂度</td>\n<td>低</td>\n<td>中（需处理多事件类型）</td>\n</tr>\n<tr>\n<td>看门狗风险</td>\n<td>高（需避免长阻塞）</td>\n<td>低（事件队列超时释放 CPU）</td>\n</tr>\n</tbody></table>\n<h3 id=\"实战代码示例\"><a href=\"#实战代码示例\" class=\"headerlink\" title=\"实战代码示例\"></a>实战代码示例</h3><h4 id=\"事件驱动方式\"><a href=\"#事件驱动方式\" class=\"headerlink\" title=\"事件驱动方式\"></a>事件驱动方式</h4><ul>\n<li><p>通过 FreeRTOS 队列接收 UART 事件，按需处理数据接收、缓冲区满、溢出等场景：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;freertos/FreeRTOS.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;freertos/task.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;driver/uart.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;esp_log.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;driver/gpio.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// -------------- 1. 宏定义参数 --------------</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> USER_UART_NUM UART_NUM_1</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> USER_UART_BAUD 115200</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> UART_TX_PIN 17</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> UART_RX_PIN 16</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> UART_BUFFER_SIZE 1024</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> UART_QUEUE_SIZE 10</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> UART_TASK_STACK_SIZE 4096</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> UART_TASK_PRIORITY 5</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// -------------- 2. 全局变量 --------------</span></span><br><span class=\"line\"><span class=\"type\">static</span> QueueHandle_t uart_event_queue;</span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">uint8_t</span> uart_rx_buffer[UART_BUFFER_SIZE];</span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">const</span> <span class=\"type\">char</span> *TAG = <span class=\"string\">&quot;UART_DEV&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// -------------- 3. UART 事件处理任务 --------------</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">uart_event_task</span><span class=\"params\">(<span class=\"type\">void</span> *arg)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">uart_event_t</span> event;  <span class=\"comment\">// 存储 UART 事件的结构体</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 从事件队列接收事件（超时 100ms，避免阻塞触发看门狗）</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (xQueueReceive(uart_event_queue, &amp;event, pdMS_TO_TICKS(<span class=\"number\">100</span>)) == pdTRUE) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">switch</span> (event.type) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 1. 接收数据事件</span></span><br><span class=\"line\">                <span class=\"keyword\">case</span> UART_DATA:</span><br><span class=\"line\">                    ESP_LOGI(TAG, <span class=\"string\">&quot;收到数据，长度：%d 字节&quot;</span>, event.size);</span><br><span class=\"line\">                    <span class=\"comment\">// 读取数据到缓冲区（超时 50ms，确保数据完整性）</span></span><br><span class=\"line\">                    <span class=\"type\">int</span> read_len = uart_read_bytes(USER_UART_NUM, </span><br><span class=\"line\">                                                  uart_rx_buffer, </span><br><span class=\"line\">                                                  event.size, </span><br><span class=\"line\">                                                  pdMS_TO_TICKS(<span class=\"number\">50</span>));</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (read_len &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// 示例1：回显数据（发送收到的数据）</span></span><br><span class=\"line\">                        uart_write_bytes(USER_UART_NUM, uart_rx_buffer, read_len);</span><br><span class=\"line\">                        <span class=\"comment\">// 示例2：打印接收的数据（十六进制）</span></span><br><span class=\"line\">                        ESP_LOGI(TAG, <span class=\"string\">&quot;接收数据（hex）：&quot;</span>);</span><br><span class=\"line\">                        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; read_len; i++) &#123;</span><br><span class=\"line\">                            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%02X &quot;</span>, uart_rx_buffer[i]);</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// 2. 接收缓冲区满事件</span></span><br><span class=\"line\">                <span class=\"keyword\">case</span> UART_BUFFER_FULL:</span><br><span class=\"line\">                    ESP_LOGI(TAG, <span class=\"string\">&quot;接收缓冲区满，清空缓冲区&quot;</span>);</span><br><span class=\"line\">                    uart_flush_input(USER_UART_NUM);  <span class=\"comment\">// 清空接收缓冲区</span></span><br><span class=\"line\">                    xQueueReset(uart_event_queue);    <span class=\"comment\">// 重置事件队列</span></span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// 3. FIFO 溢出事件（硬件缓冲区溢出）</span></span><br><span class=\"line\">                <span class=\"keyword\">case</span> UART_FIFO_OVF:</span><br><span class=\"line\">                    ESP_LOGI(TAG, <span class=\"string\">&quot;UART FIFO 溢出，清空缓冲区&quot;</span>);</span><br><span class=\"line\">                    uart_flush_input(USER_UART_NUM);</span><br><span class=\"line\">                    xQueueReset(uart_event_queue);</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// 4. 帧错误事件（数据格式错误）</span></span><br><span class=\"line\">                <span class=\"keyword\">case</span> UART_FRAME_ERR:</span><br><span class=\"line\">                    ESP_LOGI(TAG, <span class=\"string\">&quot;帧错误（数据格式异常）&quot;</span>);</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// 5. 校验错误事件（启用校验时生效）</span></span><br><span class=\"line\">                <span class=\"keyword\">case</span> UART_PARITY_ERR:</span><br><span class=\"line\">                    ESP_LOGI(TAG, <span class=\"string\">&quot;校验错误（数据校验不匹配）&quot;</span>);</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// 其他未处理事件</span></span><br><span class=\"line\">                <span class=\"keyword\">default</span>:</span><br><span class=\"line\">                    ESP_LOGI(TAG, <span class=\"string\">&quot;未处理事件类型：%d&quot;</span>, event.type);</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// -------------- 4. 主函数初始化 --------------</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">app_main</span><span class=\"params\">(<span class=\"type\">void</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1. 配置 UART 硬件参数</span></span><br><span class=\"line\">    <span class=\"type\">uart_config_t</span> uart_config = &#123;</span><br><span class=\"line\">        .baud_rate = USER_UART_BAUD,</span><br><span class=\"line\">        .data_bits = UART_DATA_8_BITS,</span><br><span class=\"line\">        .parity = UART_PARITY_DISABLE,</span><br><span class=\"line\">        .stop_bits = UART_STOP_BITS_1,</span><br><span class=\"line\">        .flow_ctrl = UART_HW_FLOWCTRL_DISABLE,</span><br><span class=\"line\">        .source_clk = UART_SCLK_DEFAULT,</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    ESP_ERROR_CHECK(uart_param_config(USER_UART_NUM, &amp;uart_config));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 2. 绑定引脚</span></span><br><span class=\"line\">    ESP_ERROR_CHECK(uart_set_pin(USER_UART_NUM, </span><br><span class=\"line\">                                UART_TX_PIN, </span><br><span class=\"line\">                                UART_RX_PIN, </span><br><span class=\"line\">                                UART_PIN_NO_CHANGE, </span><br><span class=\"line\">                                UART_PIN_NO_CHANGE));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 3. 安装 UART 驱动并创建事件队列</span></span><br><span class=\"line\">    ESP_ERROR_CHECK(uart_driver_install(USER_UART_NUM, </span><br><span class=\"line\">                                        UART_BUFFER_SIZE * <span class=\"number\">2</span>, </span><br><span class=\"line\">                                        UART_BUFFER_SIZE * <span class=\"number\">2</span>, </span><br><span class=\"line\">                                        UART_QUEUE_SIZE, </span><br><span class=\"line\">                                        &amp;uart_event_queue, </span><br><span class=\"line\">                                        <span class=\"number\">0</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 4. 创建 UART 事件处理任务（独立任务，避免阻塞 main 任务）</span></span><br><span class=\"line\">    xTaskCreate(uart_event_task,          <span class=\"comment\">// 任务函数</span></span><br><span class=\"line\">                <span class=\"string\">&quot;uart_event_task&quot;</span>,        <span class=\"comment\">// 任务名称</span></span><br><span class=\"line\">                UART_TASK_STACK_SIZE,     <span class=\"comment\">// 栈大小</span></span><br><span class=\"line\">                <span class=\"literal\">NULL</span>,                     <span class=\"comment\">// 任务参数</span></span><br><span class=\"line\">                UART_TASK_PRIORITY,       <span class=\"comment\">// 优先级</span></span><br><span class=\"line\">                <span class=\"literal\">NULL</span>);                    <span class=\"comment\">// 任务句柄（无需则填 NULL）</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h4 id=\"轮询方式（简单场景，如回显）\"><a href=\"#轮询方式（简单场景，如回显）\" class=\"headerlink\" title=\"轮询方式（简单场景，如回显）\"></a>轮询方式（简单场景，如回显）</h4><ul>\n<li><p>适用于数据量小、交互频率低的场景，代码更简洁：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">app_main</span><span class=\"params\">(<span class=\"type\">void</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1. 配置 UART 参数（同事件驱动方式）</span></span><br><span class=\"line\">    <span class=\"type\">uart_config_t</span> uart_config = &#123;</span><br><span class=\"line\">        .baud_rate = <span class=\"number\">115200</span>,</span><br><span class=\"line\">        .data_bits = UART_DATA_8_BITS,</span><br><span class=\"line\">        .parity = UART_PARITY_DISABLE,</span><br><span class=\"line\">        .stop_bits = UART_STOP_BITS_1,</span><br><span class=\"line\">        .flow_ctrl = UART_HW_FLOWCTRL_DISABLE,</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    ESP_ERROR_CHECK(uart_param_config(USER_UART_NUM, &amp;uart_config));</span><br><span class=\"line\">    ESP_ERROR_CHECK(uart_set_pin(USER_UART_NUM, <span class=\"number\">17</span>, <span class=\"number\">16</span>, UART_PIN_NO_CHANGE, UART_PIN_NO_CHANGE));</span><br><span class=\"line\">    ESP_ERROR_CHECK(uart_driver_install(USER_UART_NUM, <span class=\"number\">1024</span>, <span class=\"number\">1024</span>, <span class=\"number\">0</span>, <span class=\"literal\">NULL</span>, <span class=\"number\">0</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 2. 轮询读取数据并回显</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 读取数据（超时 50ms，无数据则返回 0）</span></span><br><span class=\"line\">        <span class=\"type\">int</span> read_len = uart_read_bytes(USER_UART_NUM, uart_rx_buffer, <span class=\"number\">1024</span>, pdMS_TO_TICKS(<span class=\"number\">50</span>));</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (read_len &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 回显数据</span></span><br><span class=\"line\">            uart_write_bytes(USER_UART_NUM, uart_rx_buffer, read_len);</span><br><span class=\"line\">            ESP_LOGI(TAG, <span class=\"string\">&quot;轮询接收数据长度：%d&quot;</span>, read_len);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 短暂延迟，释放 CPU（避免触发看门狗）</span></span><br><span class=\"line\">        vTaskDelay(pdMS_TO_TICKS(<span class=\"number\">10</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"常见问题与解决方案\"><a href=\"#常见问题与解决方案\" class=\"headerlink\" title=\"常见问题与解决方案\"></a>常见问题与解决方案</h3><h4 id=\"触发-Task-Watchdog（任务看门狗）\"><a href=\"#触发-Task-Watchdog（任务看门狗）\" class=\"headerlink\" title=\"触发 Task Watchdog（任务看门狗）\"></a>触发 Task Watchdog（任务看门狗）</h4><ul>\n<li><strong>原因</strong>：<ol>\n<li>轮询方式中 <code>uart_read_bytes()</code> 超时过长，或无 <code>vTaskDelay()</code> 释放 CPU；</li>\n<li>事件驱动方式中 <code>xQueueReceive()</code> 使用 <code>portMAX_DELAY</code> 永久阻塞。</li>\n</ol>\n</li>\n<li><strong>解决方案</strong>：<ul>\n<li>轮询方式：在循环中添加 <code>vTaskDelay(pdMS_TO_TICKS(10))</code>；</li>\n<li>事件驱动方式：<code>xQueueReceive()</code> 超时设为有限值（如 <code>pdMS_TO_TICKS(100)</code>）。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"数据接收不完整或丢失\"><a href=\"#数据接收不完整或丢失\" class=\"headerlink\" title=\"数据接收不完整或丢失\"></a>数据接收不完整或丢失</h4><ul>\n<li><strong>原因</strong>：<ol>\n<li>接收缓冲区过小，无法容纳单次接收的数据；</li>\n<li><code>uart_read_bytes()</code> 超时过短，数据未完全接收；</li>\n<li>波特率不匹配（发送端与接收端波特率必须一致）。</li>\n</ol>\n</li>\n<li><strong>解决方案</strong>：<ul>\n<li>增大接收缓冲区（如 <code>UART_BUFFER_SIZE * 2</code>）；</li>\n<li>延长 <code>uart_read_bytes()</code> 超时时间（如 50~100ms）；</li>\n<li>确保发送端与 ESP32 UART 波特率、数据位、校验位完全一致。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"UART0-与串口打印冲突\"><a href=\"#UART0-与串口打印冲突\" class=\"headerlink\" title=\"UART0 与串口打印冲突\"></a>UART0 与串口打印冲突</h4><ul>\n<li><strong>原因</strong>：ESP32 默认将 <code>printf()</code> 映射到 UART0（引脚 TX&#x3D;1，RX&#x3D;3），若使用 UART0 通信会导致打印乱码。</li>\n<li><strong>解决方案</strong>：<ul>\n<li>优先使用 UART1 或 UART2 作为通信端口；</li>\n<li>若必须使用 UART0，需重新映射 <code>printf()</code> 到其他 UART（需修改 ESP-IDF 配置）。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"WIFI\"><a href=\"#WIFI\" class=\"headerlink\" title=\"WIFI\"></a>WIFI</h2><h3 id=\"ESP32下WIFI组件三种模式\"><a href=\"#ESP32下WIFI组件三种模式\" class=\"headerlink\" title=\"ESP32下WIFI组件三种模式\"></a>ESP32下WIFI组件三种模式</h3><ul>\n<li><p><strong>AP 模式</strong>：ESP32 自身作为接入点，其他设备（如手机、电脑）可连接 ESP32 创建的 WiFi 热点，适用于 “本地设备直连 ESP32” 场景（如配置 ESP32 参数）；</p>\n</li>\n<li><p><strong>AP+STA 混合模式</strong>：ESP32 同时作为接入点和客户端，既允许其他设备连接自身，又能接入外部路由器，适用于 “本地控制 + 远程联网” 复合场景（如智能家居设备）；</p>\n</li>\n<li><p><strong>STA 模式</strong>：仅作为客户端，专注于接入外部网络，是 ESP32 实现联网功能的最常用模式（如传感器数据上传云端、远程控制指令接收）。</p>\n</li>\n</ul>\n<h3 id=\"STA模式核心工作原理\"><a href=\"#STA模式核心工作原理\" class=\"headerlink\" title=\"STA模式核心工作原理\"></a>STA模式核心工作原理</h3><p>ESP32 的 STA 模式连接 WiFi 的过程遵循 IEEE 802.11 协议，核心流程可分为 4 个阶段，各阶段依赖 ESP-IDF 提供的 WiFi 驱动接口实现：</p>\n<ol>\n<li><p><strong>初始化阶段</strong>：</p>\n<ul>\n<li><p>初始化 WiFi 组件（调用esp_wifi_init()），配置 WiFi 工作模式为 STA（通过wifi_init_config_t结构体设置mode &#x3D; WIFI_MODE_STA）；</p>\n</li>\n<li><p>配置 TCP&#x2F;IP 协议栈（ESP-IDF 默认自动初始化，无需手动操作，支持 DHCP 自动获取 IP 或静态 IP 配置）。</p>\n</li>\n</ul>\n</li>\n<li><p><strong>配置连接参数阶段</strong>：</p>\n<ul>\n<li><p>定义wifi_config_t结构体，填入目标 AP 的<strong>SSID（WiFi 名称）</strong> 和<strong>Password（WiFi 密码）</strong>，确保参数与 AP 一致（区分 SSID 大小写，密码长度需符合 AP 要求，如 WPA2-PSK 密码通常为 8-63 位）；</p>\n</li>\n<li><p>通过esp_wifi_set_config(WIFI_IF_STA, &amp;wifi_config)将配置参数写入 ESP32 的 WiFi 接口。</p>\n</li>\n</ul>\n</li>\n<li><p><strong>启动与连接阶段</strong>：</p>\n<ul>\n<li><p>启动 STA 接口（esp_wifi_start()），ESP32 开始扫描周围 WiFi 信号；</p>\n</li>\n<li><p>自动匹配目标 AP 的 SSID，发起连接请求，与 AP 进行<strong>认证（如 WPA2-PSK 认证）</strong> 和<strong>关联</strong>；</p>\n</li>\n<li><p>若认证通过，ESP32 通过 DHCP 向 AP 请求 IP 地址（默认开启 DHCP 客户端），获取到 IP、子网掩码、网关后，完成 “物理连接→网络层连接” 的全流程。</p>\n</li>\n</ul>\n</li>\n<li><p><strong>状态监测阶段</strong>：</p>\n<ul>\n<li><p>ESP32 通过<strong>事件回调机制</strong>（esp_event_loop_create_default()创建事件循环，esp_event_handler_instance_register()注册事件处理函数）反馈连接状态；</p>\n</li>\n<li><p>关键事件包括：WIFI_EVENT_STA_START（STA 接口启动成功）、WIFI_EVENT_STA_CONNECTED（与 AP 物理连接成功）、IP_EVENT_STA_GOT_IP（获取 IP 地址，联网完成）、WIFI_EVENT_STA_DISCONNECTED（与 AP 断开连接）。</p>\n</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"实现步骤\"><a href=\"#实现步骤\" class=\"headerlink\" title=\"实现步骤\"></a>实现步骤</h4><h5 id=\"重写事件处理函数（核心）\"><a href=\"#重写事件处理函数（核心）\" class=\"headerlink\" title=\"重写事件处理函数（核心）\"></a>重写事件处理函数（核心）</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief WiFi事件与IP事件处理回调函数（核心逻辑）</span></span><br><span class=\"line\"><span class=\"comment\"> * @param arg：用户自定义参数，本代码未使用，传入NULL即可</span></span><br><span class=\"line\"><span class=\"comment\"> * @param event_base：事件基础类型，用于区分是WiFi相关事件（WIFI_EVENT）还是IP相关事件（IP_EVENT）</span></span><br><span class=\"line\"><span class=\"comment\"> * @param event_id：具体事件ID，标识当前触发的是该事件类型下的哪一种具体事件</span></span><br><span class=\"line\"><span class=\"comment\"> * @param event_data：事件关联的数据指针，如IP事件中可获取分配的IP地址信息</span></span><br><span class=\"line\"><span class=\"comment\"> * 功能：响应ESP32 WiFi模块的关键事件，更新连接状态、触发重连逻辑、通知外部状态变化</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title function_\">event_handler</span><span class=\"params\">(<span class=\"type\">void</span> *arg, <span class=\"type\">esp_event_base_t</span> event_base,</span></span><br><span class=\"line\"><span class=\"params\">                          <span class=\"type\">int32_t</span> event_id, <span class=\"type\">void</span> *event_data)</span></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"实现-STA-模式初始化函数\"><a href=\"#实现-STA-模式初始化函数\" class=\"headerlink\" title=\"实现 STA 模式初始化函数\"></a>实现 STA 模式初始化函数</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 引入所需头文件：自定义WiFi管理模块头文件、ESP32 WiFi驱动库、事件处理库</span></span><br><span class=\"line\"><span class=\"comment\">// 日志打印库、FreeRTOS实时操作系统任务调度库、标准输入输出库</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;wifi_manager.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;esp_wifi.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;esp_event.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;esp_log.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;nvs_flash.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;freertos/FreeRTOS.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;freertos/task.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> WIFI_SSID <span class=\"string\">&quot;2078&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> WIFI_PASSWORD <span class=\"string\">&quot;12345678&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 静态全局变量：WiFi状态回调函数指针，用于将WiFi连接/断开状态通知给外部调用者</span></span><br><span class=\"line\"><span class=\"comment\">// 外部需通过wifi_manager_init函数传入自定义回调，接收WIFI_STATE_CONNECTED/WIFI_STATE_DISCONNECTED状态</span></span><br><span class=\"line\"><span class=\"type\">static</span> p_wifi_state_cb wifi_state_cb = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 宏定义：STA模式下最大重连次数，限制重连次数避免无限循环占用CPU资源</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> MAX_CONNECT_RETRY 10</span></span><br><span class=\"line\"><span class=\"comment\">// 宏定义：日志标签，串口打印时用于区分该模块的日志，方便调试定位</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> TAG <span class=\"string\">&quot;wifi_manager&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 静态全局变量：记录STA模式当前的重连尝试次数，初始值为0，每次重连失败自增1</span></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> sta_connect_cnt = <span class=\"number\">0</span>; <span class=\"comment\">// 重连次数</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 静态全局变量：标记STA模式是否已成功连接到目标AP，true表示已连接，false表示未连接/已断开</span></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">bool</span> is_sta_connected = <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief WiFi事件与IP事件处理回调函数（核心逻辑）</span></span><br><span class=\"line\"><span class=\"comment\"> * @param arg：用户自定义参数，本代码未使用，传入NULL即可</span></span><br><span class=\"line\"><span class=\"comment\"> * @param event_base：事件基础类型，用于区分是WiFi相关事件（WIFI_EVENT）还是IP相关事件（IP_EVENT）</span></span><br><span class=\"line\"><span class=\"comment\"> * @param event_id：具体事件ID，标识当前触发的是该事件类型下的哪一种具体事件</span></span><br><span class=\"line\"><span class=\"comment\"> * @param event_data：事件关联的数据指针，如IP事件中可获取分配的IP地址信息</span></span><br><span class=\"line\"><span class=\"comment\"> * 功能：响应ESP32 WiFi模块的关键事件，更新连接状态、触发重连逻辑、通知外部状态变化</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title function_\">event_handler</span><span class=\"params\">(<span class=\"type\">void</span> *arg, <span class=\"type\">esp_event_base_t</span> event_base,</span></span><br><span class=\"line\"><span class=\"params\">                          <span class=\"type\">int32_t</span> event_id, <span class=\"type\">void</span> *event_data)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 判断事件类型为WiFi相关事件（WIFI_EVENT）</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (event_base == WIFI_EVENT)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 根据具体事件ID处理不同场景</span></span><br><span class=\"line\">        <span class=\"keyword\">switch</span> (event_id)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 事件：STA接口启动成功（调用esp_wifi_start()后触发此事件）</span></span><br><span class=\"line\">        <span class=\"keyword\">case</span> WIFI_EVENT_STA_START:</span><br><span class=\"line\">            <span class=\"comment\">// 启动成功后，主动调用esp_wifi_connect()发起WiFi连接请求</span></span><br><span class=\"line\">            esp_wifi_connect();</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 事件：STA与已连接的AP断开连接（如信号弱、密码错误、路由器重启等）</span></span><br><span class=\"line\">        <span class=\"keyword\">case</span> WIFI_EVENT_STA_DISCONNECTED:</span><br><span class=\"line\">            <span class=\"comment\">// 若之前处于已连接状态，先更新连接状态并通知外部</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (is_sta_connected)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                is_sta_connected = <span class=\"literal\">false</span>; <span class=\"comment\">// 将连接状态标记为未连接</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (wifi_state_cb)        <span class=\"comment\">// 若外部注册了回调函数，触发&quot;断开连接&quot;状态通知</span></span><br><span class=\"line\">                    wifi_state_cb(WIFI_STATE_DISCONNECTED);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 检查当前重连次数是否小于最大重连次数，若未达到则继续重试</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (sta_connect_cnt &lt; MAX_CONNECT_RETRY)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                sta_connect_cnt++;  <span class=\"comment\">// 重连次数自增1</span></span><br><span class=\"line\">                esp_wifi_connect(); <span class=\"comment\">// 发起新一轮连接请求</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 若已达到最大重连次数，不再重试（避免无限重连）</span></span><br><span class=\"line\">            wifi_state_cb(WIFI_STATE_DISCONNECTED);</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 其他未定义的WiFi事件，暂不处理，直接break</span></span><br><span class=\"line\">        <span class=\"keyword\">default</span>:</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 判断事件类型为IP相关事件（IP_EVENT）</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (event_base == IP_EVENT)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 事件：STA成功从DHCP服务器获取到IP地址（标志网络层连接完成）</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (event_id == IP_EVENT_STA_GOT_IP)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 打印日志提示已获取IP地址，便于调试确认</span></span><br><span class=\"line\">            ESP_LOGI(TAG, <span class=\"string\">&quot;Got IP address&quot;</span>);</span><br><span class=\"line\">            sta_connect_cnt = <span class=\"number\">0</span>;     <span class=\"comment\">// 重置重连次数</span></span><br><span class=\"line\">            is_sta_connected = <span class=\"literal\">true</span>; <span class=\"comment\">// 将连接状态标记为已连接</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (wifi_state_cb)       <span class=\"comment\">// 若外部注册了回调函数，触发&quot;连接成功&quot;状态通知</span></span><br><span class=\"line\">                wifi_state_cb(WIFI_STATE_CONNECTED);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @brief WiFi管理器初始化函数（STA模式初始化入口）</span></span><br><span class=\"line\"><span class=\"comment\"> * @param f：外部传入的WiFi状态回调函数，用于接收连接/断开状态通知</span></span><br><span class=\"line\"><span class=\"comment\"> * 功能：初始化ESP32网络接口、事件循环、WiFi驱动，配置STA模式并启动WiFi模块</span></span><br><span class=\"line\"><span class=\"comment\"> * 注意：使用WiFi功能前必须先调用此函数完成初始化，建议在app_main()中优先执行</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">wifi_manager_init</span><span class=\"params\">(p_wifi_state_cb f)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1. 初始化NVS（ESP32存储WiFi配置的依赖组件，必须先初始化）</span></span><br><span class=\"line\">    <span class=\"type\">esp_err_t</span> ret = nvs_flash_init();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ret == ESP_ERR_NVS_NO_FREE_PAGES || ret == ESP_ERR_NVS_NEW_VERSION_FOUND)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        ESP_ERROR_CHECK(nvs_flash_erase()); <span class=\"comment\">// 若NVS有问题，先擦除再初始化</span></span><br><span class=\"line\">        ret = nvs_flash_init();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 2. 初始化ESP32网络接口（TCP/IP协议栈初始化，必须在WiFi初始化前执行）</span></span><br><span class=\"line\">    ESP_ERROR_CHECK(esp_netif_init());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 3. 创建默认的事件循环（用于处理WiFi和IP事件）</span></span><br><span class=\"line\">    ESP_ERROR_CHECK(esp_event_loop_create_default());</span><br><span class=\"line\">    esp_netif_create_default_wifi_sta(); <span class=\"comment\">// 使用默认的STA模式网络接口</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 4. 初始化WiFi驱动：使用WIFI_INIT_CONFIG_DEFAULT()获取默认配置（包含时钟、中断等参数）</span></span><br><span class=\"line\">    <span class=\"type\">wifi_init_config_t</span> cfg = WIFI_INIT_CONFIG_DEFAULT();</span><br><span class=\"line\">    ESP_ERROR_CHECK(esp_wifi_init(&amp;cfg)); <span class=\"comment\">// 执行WiFi驱动初始化，若失败则触发错误检查</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 5. 注册事件处理函数：监听WiFi事件和IP事件</span></span><br><span class=\"line\">    <span class=\"comment\">// 5.1注册WiFi事件监听器：监听所有WiFi事件（ESP_EVENT_ANY_ID），触发时调用event_handler处理</span></span><br><span class=\"line\">    ESP_ERROR_CHECK(esp_event_handler_instance_register(WIFI_EVENT,</span><br><span class=\"line\">                                                        ESP_EVENT_ANY_ID,</span><br><span class=\"line\">                                                        &amp;event_handler,</span><br><span class=\"line\">                                                        <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">                                                        <span class=\"literal\">NULL</span>));</span><br><span class=\"line\">    <span class=\"comment\">// 5.2注册IP事件监听器：仅监听&quot;STA获取IP&quot;事件（IP_EVENT_STA_GOT_IP）</span></span><br><span class=\"line\">    ESP_ERROR_CHECK(esp_event_handler_instance_register(IP_EVENT,</span><br><span class=\"line\">                                                        IP_EVENT_STA_GOT_IP,</span><br><span class=\"line\">                                                        &amp;event_handler,</span><br><span class=\"line\">                                                        <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">                                                        <span class=\"literal\">NULL</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 6. 保存外部传入的状态回调函数，后续状态变化时通过此函数通知外部</span></span><br><span class=\"line\">    wifi_state_cb = f;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">wifi_config_t</span> wifi_config = &#123;</span><br><span class=\"line\">        .sta = &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 配置STA的认证模式为WPA2-PSK（主流家用/工业路由器默认加密方式）</span></span><br><span class=\"line\">            .threshold.authmode = WIFI_AUTH_WPA2_PSK,</span><br><span class=\"line\">            .ssid = WIFI_SSID,</span><br><span class=\"line\">            .password = WIFI_PASSWORD,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 7. 配置WiFi工作模式为纯STA模式（仅作为客户端连接外部AP，不开启AP模式）</span></span><br><span class=\"line\">    ESP_ERROR_CHECK(esp_wifi_set_mode(WIFI_MODE_STA));</span><br><span class=\"line\">    ESP_ERROR_CHECK(esp_wifi_set_config(WIFI_IF_STA, &amp;wifi_config)); <span class=\"comment\">// 写入配置</span></span><br><span class=\"line\">    <span class=\"comment\">// 8. 启动WiFi模块（启动后会触发WIFI_EVENT_STA_START事件，进而发起连接）</span></span><br><span class=\"line\">    ESP_ERROR_CHECK(esp_wifi_start());</span><br><span class=\"line\">    ESP_LOGI(TAG, <span class=\"string\">&quot;STA initialization done&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n"},{"title":"TI","date":"2025-05-28T12:40:37.000Z","cover":"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505282044781.jpg","_content":"\n## 初始化代码\n\n### 浮点单元（FPU）相关配置\n\n```C\nROM_FPUEnable(); / 使能浮点单元\nROM_FPULazyStackingEnable(); / 启用浮点延迟堆栈模式，减少中断响应延迟    \n```\n\n**浮点单元（FPU）**\n\n- 浮点单元是 Cortex-M4 芯片（如 Tiva-C）内的硬件模块，用于加速浮点运算（如浮点加法、乘法）。\n\n- 如果你的项目中使用了`带小数`的计算（如定点PID控制、FFT计算、浮点除法），硬件 FPU 的加速能力远远优于软件模拟。\n\n**Lazy Stacking 模式**\n\n- 启用延迟堆栈推入操作后，在中断期间，只有确实需要使用浮点硬件时，才会将浮点寄存器保存到堆栈，从而减少中断响应时间和堆栈占用空间。\n\n### **实际开发中怎么使用和修改**\n\n#### ?  启用还是禁用  FPU：\n\n- 如果项目中`不涉及浮点运算`，可以省略这两个函数的调用以节省资源\n\n#### 启用延迟堆栈的条件：\n\n- 如果中断中涉及浮点运算，建议`启用 Lazy Stacking` 优化性能。\n\n- 但需要注意堆栈深度：<span style=\"text-decoration:line-through;\">中断嵌套可能导致浮点堆栈溢出</span>，调试时<span style=\"color:#66FFFF;\">增加栈尺寸</span>。\n\n## 时钟系统配置\n\n```C\nROM_SysCtlClockSet(SYSCTL_SYSDIV_2_5 | SYSCTL_USE_PLL | SYSCTL_XTAL_16MHZ | SYSCTL_OSC_MAIN); / 配置系统时钟\n```\n\n- <span style=\"color:#3399FF;\">参数说明</span>：\n\n1. `SYSCTL_SYSDIV_2_5`：\n   - 设置系统分频比， 2.5 是分频因子。\n   - 假设外部晶振频率为 16MHz，PLL 经过倍频后输出为 400MHz， 2.5 分频下得到时钟频率：400 ÷ 2.5 = 80MHz 。\n\n2. `SYSCTL_USE_PLL`：\n   - 指定使用 PLL（锁相环）作为系统时钟的倍频源。\n\n3. `SYSCTL_XTAL_16MHZ`：\n   - 配置外部晶振的规格为 16MHz，这需要与硬件实际晶振频率相匹配。\n\n4. `SYSCTL_OSC_MAIN`：\n   - 指定使用外部主振荡器作为系统的时钟输入源。\n\n### 实际开发中怎么使用和修改\n\n#### **如何修改分频比和主频**：\n\n- 如果需要更改 MCU 的主频（系统时钟频率），只需调整分频因子：\n\n  ```C\n  ROM_SysCtlClockSet(SYSCTL_SYSDIV_4 | SYSCTL_USE_PLL | SYSCTL_XTAL_16MHZ | SYSCTL_OSC_MAIN);\n  ```\n\n  示例中，分频比改为 4 ，主频变为 400 ÷ 4 = 100MHz 。\n\n#### 如果硬件使用其他晶振\n\n- 如果使用 8MHz 的晶振，应修改 `SYSCTL_XTAL_16MHZ` 为 `SYSCTL_XTAL_8MHZ` ：\n\n  ```C\n  ROM_SysCtlClockSet(SYSCTL_SYSDIV_2_5 | SYSCTL_USE_PLL | SYSCTL_XTAL_8MHZ | SYSCTL_OSC_MAIN);\n  ```\n\n#### 切换时钟源\n\n- 如果不使用外部晶振，可以切换为 **内部振荡器** (Precision Internal Oscillator, PIOSC)：\n\n  ```C\n  ROM_SysCtlClockSet(SYSCTL_SYSDIV_2_5 | SYSCTL_USE_PLL | SYSCTL_OSC_INT);\n  ```\n\n## 外设（GPIO）启用和配置\n\n```C\nROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOF); / 启用 GPIOF 外设\nROM_GPIOPinTypeGPIOOutput(GPIO_PORTF_BASE, GPIO_PIN_5); / 配置 GPIOF 5 为推挽输出\nROM_GPIOPinTypeGPIOOutput(GPIO_PORTF_BASE, GPIO_PIN_6); / 配置 GPIOF 6 为推挽输出\nROM_GPIOPinTypeGPIOOutput(GPIO_PORTF_BASE, GPIO_PIN_4); / 配置 GPIOF 4 为推挽输出\n```\n\n#### **GPIO 配置解析**\n\n1. **使能时钟**：\n\n   ```C\n   ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOF);\n   ```\n\n- 使能`GPIOF`外设的时钟\n- 每个外设模块在使用前都必须先使能其时钟，否则无法访问寄存器\n\n2. **配置推挽输出**：\n\n   ```C\n   ROM_GPIOPinTypeGPIOOutput(GPIO_PORTF_BASE, GPIO_PIN_X);\n   ```\n\n- 将`GPIOF`的某个引脚配置为`推挽输出`\n\n3. **配置输入模式**\n\n   ```C\n   ROM_GPIOPinTypeGPIOInput(GPIO_PORTF_BASE, GPIO_PIN_5);\n   ```\n\n- 将`PF5`引脚配置为输入\n\n### 串口代码\n\n```C\nROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOA); / 启用 GPIOA 外设\nROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_UART0); / 启用 UART0 外设\n```\n\n#### 配置UART引脚模式\n\n```C\nROM_GPIOPinConfigure(GPIO_PA0_U0RX); / 配置 GPIOA 引脚 0 为 UART0 RX\nROM_GPIOPinConfigure(GPIO_PA1_U0TX); / 配置 GPIOA 引脚 1 为 UART0 TX\nROM_GPIOPinTypeUART(GPIO_PORTA_BASE, GPIO_PIN_0 | GPIO_PIN_1); / 配置 GPIO PA0 和 PA1 为UART 模式\n```\n\n- <span style=\"color:#3399FF;\">参数说明</span>：\n\n1. `ROM_GPIOPinConfigure(pinConfig)`：\n   - 将某个 GPIO 引脚映射为对应外设的功能模式，例如 UART RX（接收）或 UART TX（发送）模式\n   - `GPIO_PA0_U0RX`和 `GPIO_PA1_U0TX` 分别表示将 GPIOA 的 0 和 1 引脚映射到 UART0 的 RX 和 TX信号。\n\n2. `ROM_GPIOPinTypeUART()`：\n   - 配置对应引脚为 UART 模式（主功能），指示这些引脚负责 UART 的输入和输出。\n\n3. **引脚复用说明**：\n\n   - 某些 GPIO 引脚具备多种功能（如 UART、SPI、I2C 等），可以通过 `ROM_GPIOPinConfigure() `设置引脚的复用功能。\n\n   - 数据手册中会列出默认出厂配置（如 GPIOA0、GPIOA1 默认是普通 I/O）以及复用编号\n\n#### 配置UART0模块\n\n```C\nUARTStdioConfig(0, 115200, 16000000); / 配置 UART0，设置波特率为 115200，时钟频率为 16MHz\nUARTClockSourceSet(UART0_BASE, UART_CLOCK_PIOSC); / 将 UART0 的时钟源设为内部精确振荡器PIOSC\n```\n\n`UARTStdioConfig() 详解：`\n\n- 用于配置 UART 模块的一些核心参数，例如 UART 通信模块的编号、默认的通信波特率、UART 时钟频率。\n\n1. <span style=\"color:#3399FF;\">参数说明</span>：\n\n- `0` ：指定 UART 模块编号， 0 对应 UART0。\n- `115200` ：波特率，表示每秒传输 115200 个比特。\n- `16000000` ：UART 输入时钟频率（以 Hz 为单位），这里指定为 16MHz。\n\n2. 作用：\n   - 根据设置的波特率和时钟频率， `UARTStdioConfig` 会自动计算并配置 UART 波特率控制寄存器，从而实现正确的通信速率。\n3. **默认时钟源（**PIOSC **内部振荡器）**\n\n```C\nUARTClockSourceSet(UART0_BASE, UART_CLOCK_PIOSC); / 使用 PIOSC（16 MHz）作为时钟源\n```\n\n- PIOSC 是 Tiva-C 系统内置的精确振荡器，频率为 16 MHz。\n- 替代方案：你可以改用系统主时钟（如 PLL）作为 UART 的时钟源。\n\n","source":"_posts/TI.md","raw":"---\ntitle: TI\ndate: 2025-05-28 20:40:37\ncover: \"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505282044781.jpg\"\ntags:\n  - TI\ncategories: MCU\n---\n\n## 初始化代码\n\n### 浮点单元（FPU）相关配置\n\n```C\nROM_FPUEnable(); / 使能浮点单元\nROM_FPULazyStackingEnable(); / 启用浮点延迟堆栈模式，减少中断响应延迟    \n```\n\n**浮点单元（FPU）**\n\n- 浮点单元是 Cortex-M4 芯片（如 Tiva-C）内的硬件模块，用于加速浮点运算（如浮点加法、乘法）。\n\n- 如果你的项目中使用了`带小数`的计算（如定点PID控制、FFT计算、浮点除法），硬件 FPU 的加速能力远远优于软件模拟。\n\n**Lazy Stacking 模式**\n\n- 启用延迟堆栈推入操作后，在中断期间，只有确实需要使用浮点硬件时，才会将浮点寄存器保存到堆栈，从而减少中断响应时间和堆栈占用空间。\n\n### **实际开发中怎么使用和修改**\n\n#### ?  启用还是禁用  FPU：\n\n- 如果项目中`不涉及浮点运算`，可以省略这两个函数的调用以节省资源\n\n#### 启用延迟堆栈的条件：\n\n- 如果中断中涉及浮点运算，建议`启用 Lazy Stacking` 优化性能。\n\n- 但需要注意堆栈深度：<span style=\"text-decoration:line-through;\">中断嵌套可能导致浮点堆栈溢出</span>，调试时<span style=\"color:#66FFFF;\">增加栈尺寸</span>。\n\n## 时钟系统配置\n\n```C\nROM_SysCtlClockSet(SYSCTL_SYSDIV_2_5 | SYSCTL_USE_PLL | SYSCTL_XTAL_16MHZ | SYSCTL_OSC_MAIN); / 配置系统时钟\n```\n\n- <span style=\"color:#3399FF;\">参数说明</span>：\n\n1. `SYSCTL_SYSDIV_2_5`：\n   - 设置系统分频比， 2.5 是分频因子。\n   - 假设外部晶振频率为 16MHz，PLL 经过倍频后输出为 400MHz， 2.5 分频下得到时钟频率：400 ÷ 2.5 = 80MHz 。\n\n2. `SYSCTL_USE_PLL`：\n   - 指定使用 PLL（锁相环）作为系统时钟的倍频源。\n\n3. `SYSCTL_XTAL_16MHZ`：\n   - 配置外部晶振的规格为 16MHz，这需要与硬件实际晶振频率相匹配。\n\n4. `SYSCTL_OSC_MAIN`：\n   - 指定使用外部主振荡器作为系统的时钟输入源。\n\n### 实际开发中怎么使用和修改\n\n#### **如何修改分频比和主频**：\n\n- 如果需要更改 MCU 的主频（系统时钟频率），只需调整分频因子：\n\n  ```C\n  ROM_SysCtlClockSet(SYSCTL_SYSDIV_4 | SYSCTL_USE_PLL | SYSCTL_XTAL_16MHZ | SYSCTL_OSC_MAIN);\n  ```\n\n  示例中，分频比改为 4 ，主频变为 400 ÷ 4 = 100MHz 。\n\n#### 如果硬件使用其他晶振\n\n- 如果使用 8MHz 的晶振，应修改 `SYSCTL_XTAL_16MHZ` 为 `SYSCTL_XTAL_8MHZ` ：\n\n  ```C\n  ROM_SysCtlClockSet(SYSCTL_SYSDIV_2_5 | SYSCTL_USE_PLL | SYSCTL_XTAL_8MHZ | SYSCTL_OSC_MAIN);\n  ```\n\n#### 切换时钟源\n\n- 如果不使用外部晶振，可以切换为 **内部振荡器** (Precision Internal Oscillator, PIOSC)：\n\n  ```C\n  ROM_SysCtlClockSet(SYSCTL_SYSDIV_2_5 | SYSCTL_USE_PLL | SYSCTL_OSC_INT);\n  ```\n\n## 外设（GPIO）启用和配置\n\n```C\nROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOF); / 启用 GPIOF 外设\nROM_GPIOPinTypeGPIOOutput(GPIO_PORTF_BASE, GPIO_PIN_5); / 配置 GPIOF 5 为推挽输出\nROM_GPIOPinTypeGPIOOutput(GPIO_PORTF_BASE, GPIO_PIN_6); / 配置 GPIOF 6 为推挽输出\nROM_GPIOPinTypeGPIOOutput(GPIO_PORTF_BASE, GPIO_PIN_4); / 配置 GPIOF 4 为推挽输出\n```\n\n#### **GPIO 配置解析**\n\n1. **使能时钟**：\n\n   ```C\n   ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOF);\n   ```\n\n- 使能`GPIOF`外设的时钟\n- 每个外设模块在使用前都必须先使能其时钟，否则无法访问寄存器\n\n2. **配置推挽输出**：\n\n   ```C\n   ROM_GPIOPinTypeGPIOOutput(GPIO_PORTF_BASE, GPIO_PIN_X);\n   ```\n\n- 将`GPIOF`的某个引脚配置为`推挽输出`\n\n3. **配置输入模式**\n\n   ```C\n   ROM_GPIOPinTypeGPIOInput(GPIO_PORTF_BASE, GPIO_PIN_5);\n   ```\n\n- 将`PF5`引脚配置为输入\n\n### 串口代码\n\n```C\nROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOA); / 启用 GPIOA 外设\nROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_UART0); / 启用 UART0 外设\n```\n\n#### 配置UART引脚模式\n\n```C\nROM_GPIOPinConfigure(GPIO_PA0_U0RX); / 配置 GPIOA 引脚 0 为 UART0 RX\nROM_GPIOPinConfigure(GPIO_PA1_U0TX); / 配置 GPIOA 引脚 1 为 UART0 TX\nROM_GPIOPinTypeUART(GPIO_PORTA_BASE, GPIO_PIN_0 | GPIO_PIN_1); / 配置 GPIO PA0 和 PA1 为UART 模式\n```\n\n- <span style=\"color:#3399FF;\">参数说明</span>：\n\n1. `ROM_GPIOPinConfigure(pinConfig)`：\n   - 将某个 GPIO 引脚映射为对应外设的功能模式，例如 UART RX（接收）或 UART TX（发送）模式\n   - `GPIO_PA0_U0RX`和 `GPIO_PA1_U0TX` 分别表示将 GPIOA 的 0 和 1 引脚映射到 UART0 的 RX 和 TX信号。\n\n2. `ROM_GPIOPinTypeUART()`：\n   - 配置对应引脚为 UART 模式（主功能），指示这些引脚负责 UART 的输入和输出。\n\n3. **引脚复用说明**：\n\n   - 某些 GPIO 引脚具备多种功能（如 UART、SPI、I2C 等），可以通过 `ROM_GPIOPinConfigure() `设置引脚的复用功能。\n\n   - 数据手册中会列出默认出厂配置（如 GPIOA0、GPIOA1 默认是普通 I/O）以及复用编号\n\n#### 配置UART0模块\n\n```C\nUARTStdioConfig(0, 115200, 16000000); / 配置 UART0，设置波特率为 115200，时钟频率为 16MHz\nUARTClockSourceSet(UART0_BASE, UART_CLOCK_PIOSC); / 将 UART0 的时钟源设为内部精确振荡器PIOSC\n```\n\n`UARTStdioConfig() 详解：`\n\n- 用于配置 UART 模块的一些核心参数，例如 UART 通信模块的编号、默认的通信波特率、UART 时钟频率。\n\n1. <span style=\"color:#3399FF;\">参数说明</span>：\n\n- `0` ：指定 UART 模块编号， 0 对应 UART0。\n- `115200` ：波特率，表示每秒传输 115200 个比特。\n- `16000000` ：UART 输入时钟频率（以 Hz 为单位），这里指定为 16MHz。\n\n2. 作用：\n   - 根据设置的波特率和时钟频率， `UARTStdioConfig` 会自动计算并配置 UART 波特率控制寄存器，从而实现正确的通信速率。\n3. **默认时钟源（**PIOSC **内部振荡器）**\n\n```C\nUARTClockSourceSet(UART0_BASE, UART_CLOCK_PIOSC); / 使用 PIOSC（16 MHz）作为时钟源\n```\n\n- PIOSC 是 Tiva-C 系统内置的精确振荡器，频率为 16 MHz。\n- 替代方案：你可以改用系统主时钟（如 PLL）作为 UART 的时钟源。\n\n","slug":"TI","published":1,"updated":"2025-09-17T04:12:24.000Z","comments":1,"layout":"post","photos":[],"_id":"cmk8pg6xl000r6sk9527u942s","content":"<h2 id=\"初始化代码\"><a href=\"#初始化代码\" class=\"headerlink\" title=\"初始化代码\"></a>初始化代码</h2><h3 id=\"浮点单元（FPU）相关配置\"><a href=\"#浮点单元（FPU）相关配置\" class=\"headerlink\" title=\"浮点单元（FPU）相关配置\"></a>浮点单元（FPU）相关配置</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ROM_FPUEnable(); / 使能浮点单元</span><br><span class=\"line\">ROM_FPULazyStackingEnable(); / 启用浮点延迟堆栈模式，减少中断响应延迟    </span><br></pre></td></tr></table></figure>\n\n<p><strong>浮点单元（FPU）</strong></p>\n<ul>\n<li><p>浮点单元是 Cortex-M4 芯片（如 Tiva-C）内的硬件模块，用于加速浮点运算（如浮点加法、乘法）。</p>\n</li>\n<li><p>如果你的项目中使用了<code>带小数</code>的计算（如定点PID控制、FFT计算、浮点除法），硬件 FPU 的加速能力远远优于软件模拟。</p>\n</li>\n</ul>\n<p><strong>Lazy Stacking 模式</strong></p>\n<ul>\n<li>启用延迟堆栈推入操作后，在中断期间，只有确实需要使用浮点硬件时，才会将浮点寄存器保存到堆栈，从而减少中断响应时间和堆栈占用空间。</li>\n</ul>\n<h3 id=\"实际开发中怎么使用和修改\"><a href=\"#实际开发中怎么使用和修改\" class=\"headerlink\" title=\"实际开发中怎么使用和修改\"></a><strong>实际开发中怎么使用和修改</strong></h3><h4 id=\"启用还是禁用-FPU：\"><a href=\"#启用还是禁用-FPU：\" class=\"headerlink\" title=\"?  启用还是禁用  FPU：\"></a>?  启用还是禁用  FPU：</h4><ul>\n<li>如果项目中<code>不涉及浮点运算</code>，可以省略这两个函数的调用以节省资源</li>\n</ul>\n<h4 id=\"启用延迟堆栈的条件：\"><a href=\"#启用延迟堆栈的条件：\" class=\"headerlink\" title=\"启用延迟堆栈的条件：\"></a>启用延迟堆栈的条件：</h4><ul>\n<li><p>如果中断中涉及浮点运算，建议<code>启用 Lazy Stacking</code> 优化性能。</p>\n</li>\n<li><p>但需要注意堆栈深度：<span style=\"text-decoration:line-through;\">中断嵌套可能导致浮点堆栈溢出</span>，调试时<span style=\"color:#66FFFF;\">增加栈尺寸</span>。</p>\n</li>\n</ul>\n<h2 id=\"时钟系统配置\"><a href=\"#时钟系统配置\" class=\"headerlink\" title=\"时钟系统配置\"></a>时钟系统配置</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ROM_SysCtlClockSet(SYSCTL_SYSDIV_2_5 | SYSCTL_USE_PLL | SYSCTL_XTAL_16MHZ | SYSCTL_OSC_MAIN); / 配置系统时钟</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><span style=\"color:#3399FF;\">参数说明</span>：</li>\n</ul>\n<ol>\n<li><p><code>SYSCTL_SYSDIV_2_5</code>：</p>\n<ul>\n<li>设置系统分频比， 2.5 是分频因子。</li>\n<li>假设外部晶振频率为 16MHz，PLL 经过倍频后输出为 400MHz， 2.5 分频下得到时钟频率：400 ÷ 2.5 &#x3D; 80MHz 。</li>\n</ul>\n</li>\n<li><p><code>SYSCTL_USE_PLL</code>：</p>\n<ul>\n<li>指定使用 PLL（锁相环）作为系统时钟的倍频源。</li>\n</ul>\n</li>\n<li><p><code>SYSCTL_XTAL_16MHZ</code>：</p>\n<ul>\n<li>配置外部晶振的规格为 16MHz，这需要与硬件实际晶振频率相匹配。</li>\n</ul>\n</li>\n<li><p><code>SYSCTL_OSC_MAIN</code>：</p>\n<ul>\n<li>指定使用外部主振荡器作为系统的时钟输入源。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"实际开发中怎么使用和修改-1\"><a href=\"#实际开发中怎么使用和修改-1\" class=\"headerlink\" title=\"实际开发中怎么使用和修改\"></a>实际开发中怎么使用和修改</h3><h4 id=\"如何修改分频比和主频：\"><a href=\"#如何修改分频比和主频：\" class=\"headerlink\" title=\"如何修改分频比和主频：\"></a><strong>如何修改分频比和主频</strong>：</h4><ul>\n<li><p>如果需要更改 MCU 的主频（系统时钟频率），只需调整分频因子：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ROM_SysCtlClockSet(SYSCTL_SYSDIV_4 | SYSCTL_USE_PLL | SYSCTL_XTAL_16MHZ | SYSCTL_OSC_MAIN);</span><br></pre></td></tr></table></figure>\n\n<p>示例中，分频比改为 4 ，主频变为 400 ÷ 4 &#x3D; 100MHz 。</p>\n</li>\n</ul>\n<h4 id=\"如果硬件使用其他晶振\"><a href=\"#如果硬件使用其他晶振\" class=\"headerlink\" title=\"如果硬件使用其他晶振\"></a>如果硬件使用其他晶振</h4><ul>\n<li><p>如果使用 8MHz 的晶振，应修改 <code>SYSCTL_XTAL_16MHZ</code> 为 <code>SYSCTL_XTAL_8MHZ</code> ：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ROM_SysCtlClockSet(SYSCTL_SYSDIV_2_5 | SYSCTL_USE_PLL | SYSCTL_XTAL_8MHZ | SYSCTL_OSC_MAIN);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h4 id=\"切换时钟源\"><a href=\"#切换时钟源\" class=\"headerlink\" title=\"切换时钟源\"></a>切换时钟源</h4><ul>\n<li><p>如果不使用外部晶振，可以切换为 <strong>内部振荡器</strong> (Precision Internal Oscillator, PIOSC)：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ROM_SysCtlClockSet(SYSCTL_SYSDIV_2_5 | SYSCTL_USE_PLL | SYSCTL_OSC_INT);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"外设（GPIO）启用和配置\"><a href=\"#外设（GPIO）启用和配置\" class=\"headerlink\" title=\"外设（GPIO）启用和配置\"></a>外设（GPIO）启用和配置</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOF); / 启用 GPIOF 外设</span><br><span class=\"line\">ROM_GPIOPinTypeGPIOOutput(GPIO_PORTF_BASE, GPIO_PIN_5); / 配置 GPIOF <span class=\"number\">5</span> 为推挽输出</span><br><span class=\"line\">ROM_GPIOPinTypeGPIOOutput(GPIO_PORTF_BASE, GPIO_PIN_6); / 配置 GPIOF <span class=\"number\">6</span> 为推挽输出</span><br><span class=\"line\">ROM_GPIOPinTypeGPIOOutput(GPIO_PORTF_BASE, GPIO_PIN_4); / 配置 GPIOF <span class=\"number\">4</span> 为推挽输出</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"GPIO-配置解析\"><a href=\"#GPIO-配置解析\" class=\"headerlink\" title=\"GPIO 配置解析\"></a><strong>GPIO 配置解析</strong></h4><ol>\n<li><p><strong>使能时钟</strong>：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOF);</span><br></pre></td></tr></table></figure></li>\n</ol>\n<ul>\n<li>使能<code>GPIOF</code>外设的时钟</li>\n<li>每个外设模块在使用前都必须先使能其时钟，否则无法访问寄存器</li>\n</ul>\n<ol start=\"2\">\n<li><p><strong>配置推挽输出</strong>：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ROM_GPIOPinTypeGPIOOutput(GPIO_PORTF_BASE, GPIO_PIN_X);</span><br></pre></td></tr></table></figure></li>\n</ol>\n<ul>\n<li>将<code>GPIOF</code>的某个引脚配置为<code>推挽输出</code></li>\n</ul>\n<ol start=\"3\">\n<li><p><strong>配置输入模式</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ROM_GPIOPinTypeGPIOInput(GPIO_PORTF_BASE, GPIO_PIN_5);</span><br></pre></td></tr></table></figure></li>\n</ol>\n<ul>\n<li>将<code>PF5</code>引脚配置为输入</li>\n</ul>\n<h3 id=\"串口代码\"><a href=\"#串口代码\" class=\"headerlink\" title=\"串口代码\"></a>串口代码</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOA); / 启用 GPIOA 外设</span><br><span class=\"line\">ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_UART0); / 启用 UART0 外设</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"配置UART引脚模式\"><a href=\"#配置UART引脚模式\" class=\"headerlink\" title=\"配置UART引脚模式\"></a>配置UART引脚模式</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ROM_GPIOPinConfigure(GPIO_PA0_U0RX); / 配置 GPIOA 引脚 <span class=\"number\">0</span> 为 UART0 RX</span><br><span class=\"line\"><span class=\"title function_\">ROM_GPIOPinConfigure</span><span class=\"params\">(GPIO_PA1_U0TX)</span>; / 配置 GPIOA 引脚 <span class=\"number\">1</span> 为 UART0 TX</span><br><span class=\"line\"><span class=\"title function_\">ROM_GPIOPinTypeUART</span><span class=\"params\">(GPIO_PORTA_BASE, GPIO_PIN_0 | GPIO_PIN_1)</span>; / 配置 GPIO PA0 和 PA1 为UART 模式</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><span style=\"color:#3399FF;\">参数说明</span>：</li>\n</ul>\n<ol>\n<li><p><code>ROM_GPIOPinConfigure(pinConfig)</code>：</p>\n<ul>\n<li>将某个 GPIO 引脚映射为对应外设的功能模式，例如 UART RX（接收）或 UART TX（发送）模式</li>\n<li><code>GPIO_PA0_U0RX</code>和 <code>GPIO_PA1_U0TX</code> 分别表示将 GPIOA 的 0 和 1 引脚映射到 UART0 的 RX 和 TX信号。</li>\n</ul>\n</li>\n<li><p><code>ROM_GPIOPinTypeUART()</code>：</p>\n<ul>\n<li>配置对应引脚为 UART 模式（主功能），指示这些引脚负责 UART 的输入和输出。</li>\n</ul>\n</li>\n<li><p><strong>引脚复用说明</strong>：</p>\n<ul>\n<li><p>某些 GPIO 引脚具备多种功能（如 UART、SPI、I2C 等），可以通过 <code>ROM_GPIOPinConfigure() </code>设置引脚的复用功能。</p>\n</li>\n<li><p>数据手册中会列出默认出厂配置（如 GPIOA0、GPIOA1 默认是普通 I&#x2F;O）以及复用编号</p>\n</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"配置UART0模块\"><a href=\"#配置UART0模块\" class=\"headerlink\" title=\"配置UART0模块\"></a>配置UART0模块</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">UARTStdioConfig(<span class=\"number\">0</span>, <span class=\"number\">115200</span>, <span class=\"number\">16000000</span>); / 配置 UART0，设置波特率为 <span class=\"number\">115200</span>，时钟频率为 <span class=\"number\">16</span>MHz</span><br><span class=\"line\"><span class=\"title function_\">UARTClockSourceSet</span><span class=\"params\">(UART0_BASE, UART_CLOCK_PIOSC)</span>; / 将 UART0 的时钟源设为内部精确振荡器PIOSC</span><br></pre></td></tr></table></figure>\n\n<p><code>UARTStdioConfig() 详解：</code></p>\n<ul>\n<li>用于配置 UART 模块的一些核心参数，例如 UART 通信模块的编号、默认的通信波特率、UART 时钟频率。</li>\n</ul>\n<ol>\n<li><span style=\"color:#3399FF;\">参数说明</span>：</li>\n</ol>\n<ul>\n<li><code>0</code> ：指定 UART 模块编号， 0 对应 UART0。</li>\n<li><code>115200</code> ：波特率，表示每秒传输 115200 个比特。</li>\n<li><code>16000000</code> ：UART 输入时钟频率（以 Hz 为单位），这里指定为 16MHz。</li>\n</ul>\n<ol start=\"2\">\n<li>作用：<ul>\n<li>根据设置的波特率和时钟频率， <code>UARTStdioConfig</code> 会自动计算并配置 UART 波特率控制寄存器，从而实现正确的通信速率。</li>\n</ul>\n</li>\n<li><strong>默认时钟源（</strong>PIOSC <strong>内部振荡器）</strong></li>\n</ol>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">UARTClockSourceSet(UART0_BASE, UART_CLOCK_PIOSC); / 使用 PIOSC（<span class=\"number\">16</span> MHz）作为时钟源</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>PIOSC 是 Tiva-C 系统内置的精确振荡器，频率为 16 MHz。</li>\n<li>替代方案：你可以改用系统主时钟（如 PLL）作为 UART 的时钟源。</li>\n</ul>\n","excerpt":"","more":"<h2 id=\"初始化代码\"><a href=\"#初始化代码\" class=\"headerlink\" title=\"初始化代码\"></a>初始化代码</h2><h3 id=\"浮点单元（FPU）相关配置\"><a href=\"#浮点单元（FPU）相关配置\" class=\"headerlink\" title=\"浮点单元（FPU）相关配置\"></a>浮点单元（FPU）相关配置</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ROM_FPUEnable(); / 使能浮点单元</span><br><span class=\"line\">ROM_FPULazyStackingEnable(); / 启用浮点延迟堆栈模式，减少中断响应延迟    </span><br></pre></td></tr></table></figure>\n\n<p><strong>浮点单元（FPU）</strong></p>\n<ul>\n<li><p>浮点单元是 Cortex-M4 芯片（如 Tiva-C）内的硬件模块，用于加速浮点运算（如浮点加法、乘法）。</p>\n</li>\n<li><p>如果你的项目中使用了<code>带小数</code>的计算（如定点PID控制、FFT计算、浮点除法），硬件 FPU 的加速能力远远优于软件模拟。</p>\n</li>\n</ul>\n<p><strong>Lazy Stacking 模式</strong></p>\n<ul>\n<li>启用延迟堆栈推入操作后，在中断期间，只有确实需要使用浮点硬件时，才会将浮点寄存器保存到堆栈，从而减少中断响应时间和堆栈占用空间。</li>\n</ul>\n<h3 id=\"实际开发中怎么使用和修改\"><a href=\"#实际开发中怎么使用和修改\" class=\"headerlink\" title=\"实际开发中怎么使用和修改\"></a><strong>实际开发中怎么使用和修改</strong></h3><h4 id=\"启用还是禁用-FPU：\"><a href=\"#启用还是禁用-FPU：\" class=\"headerlink\" title=\"?  启用还是禁用  FPU：\"></a>?  启用还是禁用  FPU：</h4><ul>\n<li>如果项目中<code>不涉及浮点运算</code>，可以省略这两个函数的调用以节省资源</li>\n</ul>\n<h4 id=\"启用延迟堆栈的条件：\"><a href=\"#启用延迟堆栈的条件：\" class=\"headerlink\" title=\"启用延迟堆栈的条件：\"></a>启用延迟堆栈的条件：</h4><ul>\n<li><p>如果中断中涉及浮点运算，建议<code>启用 Lazy Stacking</code> 优化性能。</p>\n</li>\n<li><p>但需要注意堆栈深度：<span style=\"text-decoration:line-through;\">中断嵌套可能导致浮点堆栈溢出</span>，调试时<span style=\"color:#66FFFF;\">增加栈尺寸</span>。</p>\n</li>\n</ul>\n<h2 id=\"时钟系统配置\"><a href=\"#时钟系统配置\" class=\"headerlink\" title=\"时钟系统配置\"></a>时钟系统配置</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ROM_SysCtlClockSet(SYSCTL_SYSDIV_2_5 | SYSCTL_USE_PLL | SYSCTL_XTAL_16MHZ | SYSCTL_OSC_MAIN); / 配置系统时钟</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><span style=\"color:#3399FF;\">参数说明</span>：</li>\n</ul>\n<ol>\n<li><p><code>SYSCTL_SYSDIV_2_5</code>：</p>\n<ul>\n<li>设置系统分频比， 2.5 是分频因子。</li>\n<li>假设外部晶振频率为 16MHz，PLL 经过倍频后输出为 400MHz， 2.5 分频下得到时钟频率：400 ÷ 2.5 &#x3D; 80MHz 。</li>\n</ul>\n</li>\n<li><p><code>SYSCTL_USE_PLL</code>：</p>\n<ul>\n<li>指定使用 PLL（锁相环）作为系统时钟的倍频源。</li>\n</ul>\n</li>\n<li><p><code>SYSCTL_XTAL_16MHZ</code>：</p>\n<ul>\n<li>配置外部晶振的规格为 16MHz，这需要与硬件实际晶振频率相匹配。</li>\n</ul>\n</li>\n<li><p><code>SYSCTL_OSC_MAIN</code>：</p>\n<ul>\n<li>指定使用外部主振荡器作为系统的时钟输入源。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"实际开发中怎么使用和修改-1\"><a href=\"#实际开发中怎么使用和修改-1\" class=\"headerlink\" title=\"实际开发中怎么使用和修改\"></a>实际开发中怎么使用和修改</h3><h4 id=\"如何修改分频比和主频：\"><a href=\"#如何修改分频比和主频：\" class=\"headerlink\" title=\"如何修改分频比和主频：\"></a><strong>如何修改分频比和主频</strong>：</h4><ul>\n<li><p>如果需要更改 MCU 的主频（系统时钟频率），只需调整分频因子：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ROM_SysCtlClockSet(SYSCTL_SYSDIV_4 | SYSCTL_USE_PLL | SYSCTL_XTAL_16MHZ | SYSCTL_OSC_MAIN);</span><br></pre></td></tr></table></figure>\n\n<p>示例中，分频比改为 4 ，主频变为 400 ÷ 4 &#x3D; 100MHz 。</p>\n</li>\n</ul>\n<h4 id=\"如果硬件使用其他晶振\"><a href=\"#如果硬件使用其他晶振\" class=\"headerlink\" title=\"如果硬件使用其他晶振\"></a>如果硬件使用其他晶振</h4><ul>\n<li><p>如果使用 8MHz 的晶振，应修改 <code>SYSCTL_XTAL_16MHZ</code> 为 <code>SYSCTL_XTAL_8MHZ</code> ：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ROM_SysCtlClockSet(SYSCTL_SYSDIV_2_5 | SYSCTL_USE_PLL | SYSCTL_XTAL_8MHZ | SYSCTL_OSC_MAIN);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h4 id=\"切换时钟源\"><a href=\"#切换时钟源\" class=\"headerlink\" title=\"切换时钟源\"></a>切换时钟源</h4><ul>\n<li><p>如果不使用外部晶振，可以切换为 <strong>内部振荡器</strong> (Precision Internal Oscillator, PIOSC)：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ROM_SysCtlClockSet(SYSCTL_SYSDIV_2_5 | SYSCTL_USE_PLL | SYSCTL_OSC_INT);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"外设（GPIO）启用和配置\"><a href=\"#外设（GPIO）启用和配置\" class=\"headerlink\" title=\"外设（GPIO）启用和配置\"></a>外设（GPIO）启用和配置</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOF); / 启用 GPIOF 外设</span><br><span class=\"line\">ROM_GPIOPinTypeGPIOOutput(GPIO_PORTF_BASE, GPIO_PIN_5); / 配置 GPIOF <span class=\"number\">5</span> 为推挽输出</span><br><span class=\"line\">ROM_GPIOPinTypeGPIOOutput(GPIO_PORTF_BASE, GPIO_PIN_6); / 配置 GPIOF <span class=\"number\">6</span> 为推挽输出</span><br><span class=\"line\">ROM_GPIOPinTypeGPIOOutput(GPIO_PORTF_BASE, GPIO_PIN_4); / 配置 GPIOF <span class=\"number\">4</span> 为推挽输出</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"GPIO-配置解析\"><a href=\"#GPIO-配置解析\" class=\"headerlink\" title=\"GPIO 配置解析\"></a><strong>GPIO 配置解析</strong></h4><ol>\n<li><p><strong>使能时钟</strong>：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOF);</span><br></pre></td></tr></table></figure></li>\n</ol>\n<ul>\n<li>使能<code>GPIOF</code>外设的时钟</li>\n<li>每个外设模块在使用前都必须先使能其时钟，否则无法访问寄存器</li>\n</ul>\n<ol start=\"2\">\n<li><p><strong>配置推挽输出</strong>：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ROM_GPIOPinTypeGPIOOutput(GPIO_PORTF_BASE, GPIO_PIN_X);</span><br></pre></td></tr></table></figure></li>\n</ol>\n<ul>\n<li>将<code>GPIOF</code>的某个引脚配置为<code>推挽输出</code></li>\n</ul>\n<ol start=\"3\">\n<li><p><strong>配置输入模式</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ROM_GPIOPinTypeGPIOInput(GPIO_PORTF_BASE, GPIO_PIN_5);</span><br></pre></td></tr></table></figure></li>\n</ol>\n<ul>\n<li>将<code>PF5</code>引脚配置为输入</li>\n</ul>\n<h3 id=\"串口代码\"><a href=\"#串口代码\" class=\"headerlink\" title=\"串口代码\"></a>串口代码</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOA); / 启用 GPIOA 外设</span><br><span class=\"line\">ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_UART0); / 启用 UART0 外设</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"配置UART引脚模式\"><a href=\"#配置UART引脚模式\" class=\"headerlink\" title=\"配置UART引脚模式\"></a>配置UART引脚模式</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ROM_GPIOPinConfigure(GPIO_PA0_U0RX); / 配置 GPIOA 引脚 <span class=\"number\">0</span> 为 UART0 RX</span><br><span class=\"line\"><span class=\"title function_\">ROM_GPIOPinConfigure</span><span class=\"params\">(GPIO_PA1_U0TX)</span>; / 配置 GPIOA 引脚 <span class=\"number\">1</span> 为 UART0 TX</span><br><span class=\"line\"><span class=\"title function_\">ROM_GPIOPinTypeUART</span><span class=\"params\">(GPIO_PORTA_BASE, GPIO_PIN_0 | GPIO_PIN_1)</span>; / 配置 GPIO PA0 和 PA1 为UART 模式</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><span style=\"color:#3399FF;\">参数说明</span>：</li>\n</ul>\n<ol>\n<li><p><code>ROM_GPIOPinConfigure(pinConfig)</code>：</p>\n<ul>\n<li>将某个 GPIO 引脚映射为对应外设的功能模式，例如 UART RX（接收）或 UART TX（发送）模式</li>\n<li><code>GPIO_PA0_U0RX</code>和 <code>GPIO_PA1_U0TX</code> 分别表示将 GPIOA 的 0 和 1 引脚映射到 UART0 的 RX 和 TX信号。</li>\n</ul>\n</li>\n<li><p><code>ROM_GPIOPinTypeUART()</code>：</p>\n<ul>\n<li>配置对应引脚为 UART 模式（主功能），指示这些引脚负责 UART 的输入和输出。</li>\n</ul>\n</li>\n<li><p><strong>引脚复用说明</strong>：</p>\n<ul>\n<li><p>某些 GPIO 引脚具备多种功能（如 UART、SPI、I2C 等），可以通过 <code>ROM_GPIOPinConfigure() </code>设置引脚的复用功能。</p>\n</li>\n<li><p>数据手册中会列出默认出厂配置（如 GPIOA0、GPIOA1 默认是普通 I&#x2F;O）以及复用编号</p>\n</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"配置UART0模块\"><a href=\"#配置UART0模块\" class=\"headerlink\" title=\"配置UART0模块\"></a>配置UART0模块</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">UARTStdioConfig(<span class=\"number\">0</span>, <span class=\"number\">115200</span>, <span class=\"number\">16000000</span>); / 配置 UART0，设置波特率为 <span class=\"number\">115200</span>，时钟频率为 <span class=\"number\">16</span>MHz</span><br><span class=\"line\"><span class=\"title function_\">UARTClockSourceSet</span><span class=\"params\">(UART0_BASE, UART_CLOCK_PIOSC)</span>; / 将 UART0 的时钟源设为内部精确振荡器PIOSC</span><br></pre></td></tr></table></figure>\n\n<p><code>UARTStdioConfig() 详解：</code></p>\n<ul>\n<li>用于配置 UART 模块的一些核心参数，例如 UART 通信模块的编号、默认的通信波特率、UART 时钟频率。</li>\n</ul>\n<ol>\n<li><span style=\"color:#3399FF;\">参数说明</span>：</li>\n</ol>\n<ul>\n<li><code>0</code> ：指定 UART 模块编号， 0 对应 UART0。</li>\n<li><code>115200</code> ：波特率，表示每秒传输 115200 个比特。</li>\n<li><code>16000000</code> ：UART 输入时钟频率（以 Hz 为单位），这里指定为 16MHz。</li>\n</ul>\n<ol start=\"2\">\n<li>作用：<ul>\n<li>根据设置的波特率和时钟频率， <code>UARTStdioConfig</code> 会自动计算并配置 UART 波特率控制寄存器，从而实现正确的通信速率。</li>\n</ul>\n</li>\n<li><strong>默认时钟源（</strong>PIOSC <strong>内部振荡器）</strong></li>\n</ol>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">UARTClockSourceSet(UART0_BASE, UART_CLOCK_PIOSC); / 使用 PIOSC（<span class=\"number\">16</span> MHz）作为时钟源</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>PIOSC 是 Tiva-C 系统内置的精确振荡器，频率为 16 MHz。</li>\n<li>替代方案：你可以改用系统主时钟（如 PLL）作为 UART 的时钟源。</li>\n</ul>\n"},{"title":"hexo命令","date":"2025-05-20T14:18:09.000Z","sticky":true,"cover":"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/hexo.jpg","_content":"\n## 发布新文章\n```C\nhexo new \"文章名\"\nhexo clean\nhexo g\nhexo s   // 生成本地静态看一下效果\nhexo d   // 发布到github public 仓库\n\ntcb hosting deploy ./public / -e cloud1-6gbla9jv5f0ef83e  //部署到腾讯云  如果提示未登录就使用tcb login\n```\n`输入完上面的命令后，在vscode推送源码仓库到github上`\n\n## 连接远程仓库\n\n```C\ngit init\ngit remote add origin [dizhi]\ngit checkout -b main                  \n```\n\n## 推送代码\n\n```c\ngit add .\ngit commit -m \"\"\ngit push --force origin main \t#后续可以直接用git push\n```\n\n## 如何建立一个多人写作的git仓库？\n\n### 1. **新建Git仓库**\n\n- **在本地创建仓库**：\n\n  ```bash\n  mkdir my_project\n  cd my_project\n  git init\n  ```\n\n- **或者在GitHub/GitLab等平台创建仓库**：如果你使用的是GitHub、GitLab等托管服务，可以直接在网页端创建仓库，然后克隆到本地：\n\n  ```bash\n  git clone https://github.com/your-username/my_project.git\n  cd my_project\n  ```\n\n### 2. **他人参与协作**\n\n- **邀请他人访问仓库**：\n\n  - 如果是GitHub，可以在仓库设置中添加协作者（Collaborator）。\n  - 如果是GitLab，可以在项目成员管理中添加成员。\n\n- **他人克隆仓库**：\n\n  ```bash\n  git clone https://github.com/your-username/my_project.git\n  cd my_project\n  ```\n\n### 3. **他人创建分支并上传代码**\n\n- **他人创建分支**：\n\n  ```bash\n  git checkout -b fenzhiname\n  ```\n\n  `fenzhinamme指的是自定义分支名`\n\n- **他人修改代码并提交**：\n\n  ```bash\n  git add .\n  git commit -m \"Add new feature\"\n  ```\n\n- **他人将分支推送到远程仓库**：\n\n  ```bash\n  git push origin fenzhiname\n  ```\n\n### 4. **你合并分支**\n\n- **同步并重置 main**：\n\n  ```bash\n  git fetch origin\n  git checkout main\n  git reset --hard origin/main\n  ```\n\n- **合并**：\n\n  ```bash\n  git merge origin/wpy_app --allow-unrelated-histories\n  ```\n\n- **解决冲突（如果有）并推送**：\n\n  ```bash\n  git push origin main\n  ```\n\n  \n","source":"_posts/hexo命令.md","raw":"---\ntitle: hexo命令\ndate: 2025-05-20 22:18:09\nsticky: true\ncover: \"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/hexo.jpg\"\ntags:\n  - git\n---\n\n## 发布新文章\n```C\nhexo new \"文章名\"\nhexo clean\nhexo g\nhexo s   // 生成本地静态看一下效果\nhexo d   // 发布到github public 仓库\n\ntcb hosting deploy ./public / -e cloud1-6gbla9jv5f0ef83e  //部署到腾讯云  如果提示未登录就使用tcb login\n```\n`输入完上面的命令后，在vscode推送源码仓库到github上`\n\n## 连接远程仓库\n\n```C\ngit init\ngit remote add origin [dizhi]\ngit checkout -b main                  \n```\n\n## 推送代码\n\n```c\ngit add .\ngit commit -m \"\"\ngit push --force origin main \t#后续可以直接用git push\n```\n\n## 如何建立一个多人写作的git仓库？\n\n### 1. **新建Git仓库**\n\n- **在本地创建仓库**：\n\n  ```bash\n  mkdir my_project\n  cd my_project\n  git init\n  ```\n\n- **或者在GitHub/GitLab等平台创建仓库**：如果你使用的是GitHub、GitLab等托管服务，可以直接在网页端创建仓库，然后克隆到本地：\n\n  ```bash\n  git clone https://github.com/your-username/my_project.git\n  cd my_project\n  ```\n\n### 2. **他人参与协作**\n\n- **邀请他人访问仓库**：\n\n  - 如果是GitHub，可以在仓库设置中添加协作者（Collaborator）。\n  - 如果是GitLab，可以在项目成员管理中添加成员。\n\n- **他人克隆仓库**：\n\n  ```bash\n  git clone https://github.com/your-username/my_project.git\n  cd my_project\n  ```\n\n### 3. **他人创建分支并上传代码**\n\n- **他人创建分支**：\n\n  ```bash\n  git checkout -b fenzhiname\n  ```\n\n  `fenzhinamme指的是自定义分支名`\n\n- **他人修改代码并提交**：\n\n  ```bash\n  git add .\n  git commit -m \"Add new feature\"\n  ```\n\n- **他人将分支推送到远程仓库**：\n\n  ```bash\n  git push origin fenzhiname\n  ```\n\n### 4. **你合并分支**\n\n- **同步并重置 main**：\n\n  ```bash\n  git fetch origin\n  git checkout main\n  git reset --hard origin/main\n  ```\n\n- **合并**：\n\n  ```bash\n  git merge origin/wpy_app --allow-unrelated-histories\n  ```\n\n- **解决冲突（如果有）并推送**：\n\n  ```bash\n  git push origin main\n  ```\n\n  \n","slug":"hexo命令","published":1,"updated":"2026-01-10T19:28:44.000Z","comments":1,"layout":"post","photos":[],"_id":"cmk8pg6xl000s6sk9d08s88bb","content":"<h2 id=\"发布新文章\"><a href=\"#发布新文章\" class=\"headerlink\" title=\"发布新文章\"></a>发布新文章</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo new <span class=\"string\">&quot;文章名&quot;</span></span><br><span class=\"line\">hexo clean</span><br><span class=\"line\">hexo g</span><br><span class=\"line\">hexo s   <span class=\"comment\">// 生成本地静态看一下效果</span></span><br><span class=\"line\">hexo d   <span class=\"comment\">// 发布到github public 仓库</span></span><br><span class=\"line\"></span><br><span class=\"line\">tcb hosting deploy ./public / -e cloud1<span class=\"number\">-6</span>gbla9jv5f0ef83e  <span class=\"comment\">//部署到腾讯云  如果提示未登录就使用tcb login</span></span><br></pre></td></tr></table></figure>\n<p><code>输入完上面的命令后，在vscode推送源码仓库到github上</code></p>\n<h2 id=\"连接远程仓库\"><a href=\"#连接远程仓库\" class=\"headerlink\" title=\"连接远程仓库\"></a>连接远程仓库</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git init</span><br><span class=\"line\">git remote add origin [dizhi]</span><br><span class=\"line\">git checkout -b main                  </span><br></pre></td></tr></table></figure>\n\n<h2 id=\"推送代码\"><a href=\"#推送代码\" class=\"headerlink\" title=\"推送代码\"></a>推送代码</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add .</span><br><span class=\"line\">git commit -m <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">git push --force origin main \t#后续可以直接用git push</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"如何建立一个多人写作的git仓库？\"><a href=\"#如何建立一个多人写作的git仓库？\" class=\"headerlink\" title=\"如何建立一个多人写作的git仓库？\"></a>如何建立一个多人写作的git仓库？</h2><h3 id=\"1-新建Git仓库\"><a href=\"#1-新建Git仓库\" class=\"headerlink\" title=\"1. 新建Git仓库\"></a>1. <strong>新建Git仓库</strong></h3><ul>\n<li><p><strong>在本地创建仓库</strong>：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">mkdir</span> my_project</span><br><span class=\"line\"><span class=\"built_in\">cd</span> my_project</span><br><span class=\"line\">git init</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>或者在GitHub&#x2F;GitLab等平台创建仓库</strong>：如果你使用的是GitHub、GitLab等托管服务，可以直接在网页端创建仓库，然后克隆到本地：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/your-username/my_project.git</span><br><span class=\"line\"><span class=\"built_in\">cd</span> my_project</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"2-他人参与协作\"><a href=\"#2-他人参与协作\" class=\"headerlink\" title=\"2. 他人参与协作\"></a>2. <strong>他人参与协作</strong></h3><ul>\n<li><p><strong>邀请他人访问仓库</strong>：</p>\n<ul>\n<li>如果是GitHub，可以在仓库设置中添加协作者（Collaborator）。</li>\n<li>如果是GitLab，可以在项目成员管理中添加成员。</li>\n</ul>\n</li>\n<li><p><strong>他人克隆仓库</strong>：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/your-username/my_project.git</span><br><span class=\"line\"><span class=\"built_in\">cd</span> my_project</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"3-他人创建分支并上传代码\"><a href=\"#3-他人创建分支并上传代码\" class=\"headerlink\" title=\"3. 他人创建分支并上传代码\"></a>3. <strong>他人创建分支并上传代码</strong></h3><ul>\n<li><p><strong>他人创建分支</strong>：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout -b fenzhiname</span><br></pre></td></tr></table></figure>\n\n<p><code>fenzhinamme指的是自定义分支名</code></p>\n</li>\n<li><p><strong>他人修改代码并提交</strong>：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add .</span><br><span class=\"line\">git commit -m <span class=\"string\">&quot;Add new feature&quot;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>他人将分支推送到远程仓库</strong>：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push origin fenzhiname</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"4-你合并分支\"><a href=\"#4-你合并分支\" class=\"headerlink\" title=\"4. 你合并分支\"></a>4. <strong>你合并分支</strong></h3><ul>\n<li><p><strong>同步并重置 main</strong>：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git fetch origin</span><br><span class=\"line\">git checkout main</span><br><span class=\"line\">git reset --hard origin/main</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>合并</strong>：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git merge origin/wpy_app --allow-unrelated-histories</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>解决冲突（如果有）并推送</strong>：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push origin main</span><br></pre></td></tr></table></figure></li>\n</ul>\n","excerpt":"","more":"<h2 id=\"发布新文章\"><a href=\"#发布新文章\" class=\"headerlink\" title=\"发布新文章\"></a>发布新文章</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo new <span class=\"string\">&quot;文章名&quot;</span></span><br><span class=\"line\">hexo clean</span><br><span class=\"line\">hexo g</span><br><span class=\"line\">hexo s   <span class=\"comment\">// 生成本地静态看一下效果</span></span><br><span class=\"line\">hexo d   <span class=\"comment\">// 发布到github public 仓库</span></span><br><span class=\"line\"></span><br><span class=\"line\">tcb hosting deploy ./public / -e cloud1<span class=\"number\">-6</span>gbla9jv5f0ef83e  <span class=\"comment\">//部署到腾讯云  如果提示未登录就使用tcb login</span></span><br></pre></td></tr></table></figure>\n<p><code>输入完上面的命令后，在vscode推送源码仓库到github上</code></p>\n<h2 id=\"连接远程仓库\"><a href=\"#连接远程仓库\" class=\"headerlink\" title=\"连接远程仓库\"></a>连接远程仓库</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git init</span><br><span class=\"line\">git remote add origin [dizhi]</span><br><span class=\"line\">git checkout -b main                  </span><br></pre></td></tr></table></figure>\n\n<h2 id=\"推送代码\"><a href=\"#推送代码\" class=\"headerlink\" title=\"推送代码\"></a>推送代码</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add .</span><br><span class=\"line\">git commit -m <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">git push --force origin main \t#后续可以直接用git push</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"如何建立一个多人写作的git仓库？\"><a href=\"#如何建立一个多人写作的git仓库？\" class=\"headerlink\" title=\"如何建立一个多人写作的git仓库？\"></a>如何建立一个多人写作的git仓库？</h2><h3 id=\"1-新建Git仓库\"><a href=\"#1-新建Git仓库\" class=\"headerlink\" title=\"1. 新建Git仓库\"></a>1. <strong>新建Git仓库</strong></h3><ul>\n<li><p><strong>在本地创建仓库</strong>：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">mkdir</span> my_project</span><br><span class=\"line\"><span class=\"built_in\">cd</span> my_project</span><br><span class=\"line\">git init</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>或者在GitHub&#x2F;GitLab等平台创建仓库</strong>：如果你使用的是GitHub、GitLab等托管服务，可以直接在网页端创建仓库，然后克隆到本地：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/your-username/my_project.git</span><br><span class=\"line\"><span class=\"built_in\">cd</span> my_project</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"2-他人参与协作\"><a href=\"#2-他人参与协作\" class=\"headerlink\" title=\"2. 他人参与协作\"></a>2. <strong>他人参与协作</strong></h3><ul>\n<li><p><strong>邀请他人访问仓库</strong>：</p>\n<ul>\n<li>如果是GitHub，可以在仓库设置中添加协作者（Collaborator）。</li>\n<li>如果是GitLab，可以在项目成员管理中添加成员。</li>\n</ul>\n</li>\n<li><p><strong>他人克隆仓库</strong>：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/your-username/my_project.git</span><br><span class=\"line\"><span class=\"built_in\">cd</span> my_project</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"3-他人创建分支并上传代码\"><a href=\"#3-他人创建分支并上传代码\" class=\"headerlink\" title=\"3. 他人创建分支并上传代码\"></a>3. <strong>他人创建分支并上传代码</strong></h3><ul>\n<li><p><strong>他人创建分支</strong>：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout -b fenzhiname</span><br></pre></td></tr></table></figure>\n\n<p><code>fenzhinamme指的是自定义分支名</code></p>\n</li>\n<li><p><strong>他人修改代码并提交</strong>：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add .</span><br><span class=\"line\">git commit -m <span class=\"string\">&quot;Add new feature&quot;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>他人将分支推送到远程仓库</strong>：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push origin fenzhiname</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"4-你合并分支\"><a href=\"#4-你合并分支\" class=\"headerlink\" title=\"4. 你合并分支\"></a>4. <strong>你合并分支</strong></h3><ul>\n<li><p><strong>同步并重置 main</strong>：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git fetch origin</span><br><span class=\"line\">git checkout main</span><br><span class=\"line\">git reset --hard origin/main</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>合并</strong>：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git merge origin/wpy_app --allow-unrelated-histories</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>解决冲突（如果有）并推送</strong>：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push origin main</span><br></pre></td></tr></table></figure></li>\n</ul>\n"},{"title":"linux","date":"2025-09-23T12:17:17.000Z","_content":"","source":"_posts/linux.md","raw":"---\ntitle: linux\ndate: 2025-09-23 20:17:17\ntags:\n---\n","slug":"linux","published":1,"updated":"2025-09-23T12:17:18.000Z","comments":1,"layout":"post","photos":[],"_id":"cmk8pg6xm000t6sk949w6ddpt","content":"","excerpt":"","more":""},{"title":"RT_Thread","date":"2025-05-21T12:26:03.000Z","cover":"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505212030199.png","layout":"page","_content":"\n## 时钟管理\n\n### 时钟节拍产生与获取\n\n时钟节拍依赖于硬件中的定时器。你可以把定时器看作是⼀个不停计时的装置，它每隔⼀段时间就会提醒系统“滴答”⼀次。<span style=\"text-decoration:underline;\">每当定时器中断发⽣时，RT-Thread 会调⽤ rt_tick_increase()函数，系统时间增加 1 个节拍</span>。`就像家中的闹钟响⼀次，时间就过去了⼀分钟⼀样。`\n\n> 其中rt_tick_increase()函数中有rt_tick类似于HAL库中的uwTick，可以直接调用 获取系统时间\n\n## 定时器管理\n\n### 硬件定时器 vs 软件定时器\n\n1. <span style=\"color:#FF3399;\">硬件定时器</span>：就像厨房⾥的倒计时器，它是由硬件直接提供的。硬件定时器精度⾮常⾼，可以达到纳秒级，适合⼀些对时间要求⾮常严格的任务，⽐如控制电机的旋转时间。\n2. <span style=\"color:#FF3399;\">软件定时器</span>：可以理解为⼿机上的计时 App。它依赖于操作系统的时钟节拍来⼯作，它的时间间隔精度由 OS Tick 决定。例如，如果 OS Tick 是 10ms，那么软件定时器只能精确到 10ms。虽然精度不如硬件定时器⾼，但它更灵活、容易使⽤。\n\n### RTT定时器分类\n\n- <span style=\"color:#FF3399;\">单次触发定时器</span>：就像倒计时⼀次的闹钟，响⼀次后就停⽌。例如，设定⼀个 5 秒的倒计时，时间到了闹钟响⼀次就结束了。\n- <span style=\"color:#FF3399;\">周期触发定时器</span>：就像那些每天早上 7 点重复响起的闹钟。每隔⼀段时间，它会周期性地触发事件，直到你⼿动关闭它。\n\n根据定时器回调函数执⾏的上下⽂环境，定时器还可以分为两种模式：\n\n- <span style=\"color:#FF3399;\">硬件模式 </span>(HARD_TIMER)：定时器的回调函数在<span style=\"text-decoration:underline;\">中断上下⽂</span>中执⾏`就像闹钟响起时你⽴刻跳起来⼀样`它反应⾮常快，但要求处理时间短。\n- <span style=\"color:#FF3399;\">软件模式</span> (SOFT_TIMER)：回调函数在<span style=\"text-decoration:underline;\">系统的 timer 线程中</span>执⾏，相当于`有⼈提醒你“闹钟响了”`，然后你再去执⾏⼀些动作。这个模式可以做更复杂的操作，因为它不是在中断中执⾏。\n\n### 控制定时器\n\n`通过该函数你可以随时改变定时器触发方式以及定时器时间`\n\n![image-20250521221429133](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505212214569.png)\n\n### 高精度延时\n\n`使用该函数可以实现微妙级的精确延时，适合高精度时间控制场合`\n\n![image-20250521221525259](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505212215044.png)\n\n## 线程创建\n\n![image-20250521203425658](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505212034310.png)\n\n- `name`：线程名字\n- `entry`：线程入口函数\n- `parameter`：传递给线程的参数\n- `stack_size`：线程栈大小\n- `priority`：线程优先级\n- `tick`：时间片\n\n### 详细步骤\n\n1. 声明一个pcb结构体 `static rt_thread_t tid1 = RT_NULL;`\n2. 编写线程入口函数 `static void thread1_entry(void *parameter)`，参数为必需，其为传递给线程的参数\n3. 利用`rt_thread_create`函数赋值给所声明的pcb结构体tid1\n4. 利用``rt_thread_startup(tid1)``函数启动线程\n\n### 实现示例\n\n```C\nstatic void thread1_proc(void *parameter)\n{\n    while(1)\n    {\n        /*实际功能*/\n        rt_thread_mdelay(1000);//休息1秒\n    }\n}\nint thread1_init(void)\n{\n    rt_thread_t tid1 =  rt_thread_create(\"thread1_proc\",thread1_proc,RT_NULL,1024,10,20);\n    if(tid1 != RT_NULL)\n    {\n        rt_thread_startup(tid1);\n    }\n    return RT_EOK;\n}\nINIT_COMPONENT_EXPORT(thread1_init);   //用这个宏就不需要另外再去注册\n```\n\n> <span style=\"font-style:italic;\">rt_thread_mdelay(1000)的工作机制：</span>\n>\n> <span style=\"font-style:italic;\">1、当 rt_thread_mdelay 被调⽤时，当前线程会进⼊ RT_THREAD_SUSPEND 状态（<span style=\"color:#CC00CC;\">挂起</span>状态）。</span>\n>\n> <span style=\"font-style:italic;\">2、调度器开始运⾏其他优先级相同或更⾼的线程。</span>\n>\n> <span style=\"font-style:italic;\">3、 <span style=\"text-decoration:underline;\">延时时间结束后，线程从 挂起状态 转变为 就绪状态</span> ，等待系统再次调度该线程。</span>\n>\n> <span style=\"font-style:italic;\">PS：若此时无其他线程，则CPU就处于释放状态</span>\n\n![image-20250521205640868](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505212056766.png)\n\n## 线程间同步\n\n### 信号量\n\n信号量可以理解为电影院的座位数（<span style=\"color:#FF0000;\">资源数量</span>）。当所有座位都满了，新的观众（线程）就需要等前⾯的观众离开（释放资源）才能进⼊。当有空位时，观众可以进⼊。`信号量通过控制资源的数量来管理多个线程对资源的访问`\n\n#### 工作机制\n\n- `获取信号量`：当资源可⽤时，线程可以获取信号量，<span style=\"color:#FF0000;\">信号量的值减1</span>。<span style=\"background:#66FFFF;\">如果信号量的值为0，线程就会等待，直到资源释放</span>\n\n- `释放信号量`：使⽤完资源后，线程释放信号量，<span style=\"color:#FF0000;\">信号量的值加1</span>，允许其他线程访问资源\n\n##### 创建信号量\n\n```c\n/*动态分配内存并创建信号量*/\nrt_sem_t rt_sem_create(const char *name, rt_uint32_t value, rt_uint8_t flag);\n/*静态分配内存并创建信号量*/\nrt_err_t rt_sem_init(rt_sem_t sem, const char *name, rt_uint32_t value,rt_uint8_t flag);\n```\n\n- <span style=\"color:#3399FF;\">参数说明</span>：\n\n- `name`：信号量的名字（可以为 `RT_NULL` 表⽰匿名信号量）。\n\n- `value`：信号量的初始值，表⽰信号量当前持有的资源数量（`例如初始值为 0 表⽰等待事件，为 1 表⽰互斥量，或者更⼤值表⽰资源计数`）。\n\n- `flag`：PC 对象的属性标志，常⽤值：\n- `RT_IPC_FLAG_PRIO` ：<span style=\"color:#FF0000;\">优先级</span>等待⽅式，等待线程按照优先级顺序排列。\n  \n- `RT_IPC_FLAG_FIFO` ：<span style=\"color:#FF0000;\">先⼊先出</span>等待⽅式，等待线程按照进⼊顺序排列。\n\n##### 获取信号量\n\n⽤于获取信号量（P 操作），线程会尝试获取信号量，`如果信号量的计数值为 0，线程会进⼊等待状态`，直到信号量被释放或超时。\n\n```c\nrt_err_t rt_sem_take(rt_sem_t sem, rt_int32_t time);\n```\n\n- <span style=\"color:#3399FF;\">参数说明</span>：\n\n- `sem`：信号量的句柄。\n\n- `time`：超时时间（单位为系统 tick），表⽰最⼤等待时间。如果设置为 `RT_WAITING_FOREVER` ，线程会⼀直等待\n\n##### 释放信号量\n\n⽤于释放信号量（V 操作），**增加**信号量的计数值，`并唤醒等待该信号量的线程`。\n\n```c\nrt_err_t rt_sem_release(rt_sem_t sem);\n```\n\n#### 应用示例\n\n```c\n#include <rtthread.h>\n\nrt_sem_t sem = RT_NULL;\n\nvoid thread1(void *parameter)\n{\n   rt_kprintf(\"线程1：等待线程2发送信号\\n\");\n\n   /*等待信号量，超时时间为永久等待*/\n   rt_sem_take(sem,RT_WAITING_FOREVER);\n\n   rt_kprintf(\"线程1：收到线程2的信号，继续执行....\\n\");\n}\n\nvoid thread2(void *parameter)\n{\n   rt_kprintf(\"线程2：执行一些操作\\n\");\n   /*模拟执行一些动作*/\n   rt_thread_mdelay(2000);\n   rt_kprintf(\"线程2：操作完成，发送信号给线程1\\n\");\n   /*释放信号量 通知线程1*/\n   rt_sem_release(sem);\n}\n\nint main(void)\n{\n    rt_thread_t tid1 = RT_NULL;\n    rt_thread_t tid2 = RT_NULL;\n\n    sem = rt_sem_create(\"sem\", 0, RT_IPC_FLAG_PRIO);\n    tid1 = rt_thread_create(\"tid1\", thread1, RT_NULL, 1024, 25, 100);\n    tid2 = rt_thread_create(\"tid2\", thread2, RT_NULL, 1024, 25, 100);\n\n    if(tid1 != RT_NULL) rt_thread_startup(tid1);\n    if(tid2 != RT_NULL) rt_thread_startup(tid2);\n    return 0;\n}\n```\n\n#### 使用场景\n\n1. 任务同步（多任务协调执行顺序）\n2. 任务互斥(使用`互斥量` 保证同一时间只有一个线程 访问公共资源)\n3. 事件触发\n4. 限量资源管理\n\n### **互斥量（Mutex）**\n\n#### **工作机制**\n\n互斥量确保同⼀时刻**只有⼀个线程能够访问共享资源**：\n\n- `获取互斥量`：当⼀个线程获取到互斥量时，其他线程不能访问该资源，直到互斥量被释放。\n- `释放互斥量`：当线程释放互斥量后，其他等待的线程才能访问资源\n\n##### **创建互斥量**\n\n```c\n/*动态创建一个互斥量*/\nrt_mutex_t rt_mutex_create(const char *name, rt_uint8_t flag);\n/*静态创建一个互斥量*/\nrt_err_t rt_mutex_init(rt_mutex_t mutex, const char *name, rt_uint8_t flag);\n```\n\n- <span style=\"color:#3399FF;\">参数说明</span>：\n- `name`：互斥量的名字（可以为 `RT_NULL` 表⽰匿名互斥量）。\n- `flag`：IPC 对象的属性标志，通常使⽤ `RT_IPC_FLAG_PRIO` 表⽰优先级等待。\n\n##### **获取互斥量**\n\n⽤于获取互斥量，线程通过调⽤此函数进⼊临界区。`如果互斥量已经被其他线程获取，当前线程会进⼊等待状态，直到获取成功或超时。`\n\n```c\nrt_err_t rt_mutex_take(rt_mutex_t mutex, rt_int32_t time);\n```\n\n- <span style=\"color:#3399FF;\">参数说明</span>：\n- `mutex`：互斥量的句柄。\n- `time`：超时时间（单位为系统 tick），可以指定等待时⻓或 `RT_WAITING_FOREVER`表⽰永远等待。\n\n##### 释放互斥量\n\n⽤于释放互斥量（V 操作），**增加**互斥量的计数值，并唤醒等待该互斥量的线程。\n\n```c\nrt_err_t rt_mutex_release(rt_mutex_t mutex);\n```\n\n#### **应用示例**\n\n```c\n#include <rtthread.h>\n\nrt_mutex_t mutex = RT_NULL;\nrt_uint32_t cnt = 0;\n\nvoid thread1(void *parameter)\n{\n   //rt_kprintf(\"线程1：等待线程2发送信号\\n\");\n   while(1)\n   {\n       rt_mutex_take(mutex,RT_WAITING_FOREVER);\n       cnt++;\n       rt_thread_mdelay(1000);\n       rt_kprintf(\"线程1 cnt = %d \\n\",cnt);\n       rt_mutex_release(mutex);\n   }\n}\n\nvoid thread2(void *parameter)\n{\n   //rt_kprintf(\"线程2：执行一些操作\\n\");\n    while(1)\n    {\n        rt_mutex_take(mutex,RT_WAITING_FOREVER);\n        cnt++;\n        rt_thread_mdelay(1000);\n        rt_kprintf(\"线程2 cnt = %d \\n\",cnt);\n        rt_mutex_release(mutex);\n    }\n}\n\nint main(void)\n{\n    rt_thread_t tid1 = RT_NULL;\n    rt_thread_t tid2 = RT_NULL;\n\n    mutex = rt_mutex_create(\"mutex\", RT_IPC_FLAG_PRIO);\n    tid1 = rt_thread_create(\"tid1\", thread1, RT_NULL, 1024, 25, 100);\n    tid2 = rt_thread_create(\"tid2\", thread2, RT_NULL, 1024, 25, 100);\n\n    if(tid1 != RT_NULL) rt_thread_startup(tid1);\n    if(tid2 != RT_NULL) rt_thread_startup(tid2);\n    return 0;\n}\n\n```\n\n### **任务同步与任务互斥差异**\n\n![image-20250522203011255](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505222030206.png)\n\n### **事件集**\n\n事件集可以看作公交⻋站的场景。线程可以等待多个事件发⽣，`⽐如等待公交⻋或等待同伴到达。如果满⾜某个或某⼏个条件，线程将被唤醒继续执⾏。`\n\n#### **工作机制**\n\n事件集⽤于线程间的同步，可以让线程等待⼀个或多个事件的触发：\n\n- `逻辑与（AND)`：线程等待多个事件同时发⽣才被唤醒。\n- `逻辑或（OR）`：线程只需等待其中⼀个事件发⽣即可被唤醒。 \n\n##### **创建事件对象**\n\n```c\n/*动态创建一个对象*/\nrt_event_t rt_event_create(const char *name, rt_uint8_t flag);\n/*静态创建一个对象*/\nrt_err_t rt_event_init(rt_event_t event, const char *name, rt_uint8_t flag); \n```\n\n- <span style=\"color:#3399FF;\">参数说明</span>：\n- `name`：事件对象的名字（可以为 `RT_NULL` 表⽰匿名事件对象）。\n- `flag`：IPC 对象的属性标志，⼀般使⽤ `RT_IPC_FLAG_PRIO` 表⽰优先级等待，或`RT_IPC_FLAG_FIFO` 表⽰先进先出等待。\n\n##### **发送(触发)事件**\n\n```c\nrt_err_t rt_event_send(rt_event_t event, rt_uint32_t set);\n```\n\n- <span style=\"color:#3399FF;\">参数说明</span>：\n- `event`：事件对象的句柄。\n- `set`：事件标志，设置哪⼏位事件标志被触发 `可以⽤ 1 << n 来表⽰第 n 位的事件。`\n\n##### **接收(等待)事件**\n\n```c\nrt_err_t rt_event_recv(rt_event_t event, rt_uint32_t set, rt_uint8_t option, rt_int32_t timeout, rt_uint32_t *recved);\n```\n\n- <span style=\"color:#3399FF;\">参数说明</span>：\n- `event`：事件对象的句柄。\n- `set`：需要等待的事件标志 `例如 1 << 3 | 1 << 5 表⽰同时等待第3位和第5位的事件`\n- `option` ：等待选项，常⻅选项包括：\n  - `RT_EVENT_FLAG_AND` ：<span style=\"color:#3399FF;\">所有</span>指定的事件标志都满⾜时才唤醒线程。\n  - `RT_EVENT_FLAG_OR` ：<span style=\"color:#3399FF;\">只要有⼀个</span>指定的事件标志满⾜就唤醒线程。\n  - `RT_EVENT_FLAG_CLEAR` ：<span style=\"color:#3399FF;\">收到</span>事件标志后<span style=\"color:#3399FF;\">清除</span>这些事件标志。\n- `timeout` ：超时时间（单位为系统 tick），可以为 `RT_WAITING_FOREVER` 表⽰永远等待。\n- `recved` ：输出参数，返回实际接收到的事件标志\n\n#### **应用示例**\n\n```c\n#include <rtthread.h>\n\nrt_event_t event = RT_NULL;\n/*线程1：等待事件*/\nvoid thread1(void *parameter)\n{\n   rt_uint32_t recei;\n   rt_kprintf(\"线程1：等待公交车3或5到来...\\n\");\n\n   rt_event_recv(event, (1 << 3 | 1 << 5), RT_EVENT_FLAG_OR | RT_EVENT_FLAG_CLEAR, RT_WAITING_FOREVER, &recei);\n\n   rt_kprintf(\"线程1：公交车 %d 到站，出发！....\\n\",recei);\n}\n/*线程2：发送事件（公交车到站）*/\nvoid thread2(void *parameter)\n{\n   rt_thread_mdelay(1000);//模拟公交车到站\n   rt_kprintf(\"线程2：公交车3到站\\n\");\n   rt_event_send(event, (1 << 3));\n}\n\nint main(void)\n{\n    rt_thread_t tid1 = RT_NULL;\n    rt_thread_t tid2 = RT_NULL;\n\n    event = rt_event_create(\"event\", RT_IPC_FLAG_PRIO);\n    tid1 = rt_thread_create(\"tid1\", thread1, RT_NULL, 1024, 25, 100);\n    tid2 = rt_thread_create(\"tid2\", thread2, RT_NULL, 1024, 25, 100);\n\n    if(tid1 != RT_NULL) rt_thread_startup(tid1);\n    if(tid2 != RT_NULL) rt_thread_startup(tid2);\n    return 0;\n}\n```\n\n## **线程间通信**\n\n裸机编程中经常使用全局变量进行功能间的通信（标志）：某些功能由于特定的操作改变全局变量的值，另一个功能对此全局变量进行读取，根据读取到的全局变量执行相应的操作来达到通信协作的目的。RTT提供了邮箱、消息队列和信号等工具来完成这样的类似操作\n\n### **邮箱**\n\n#### 工作机制\n\n邮箱的特点：开销低、效率高、支持一对多\n\n邮箱中一封邮件**只能容纳固定的4字节信息**（针对32位操作系统，指针大小为4字节，一封邮件恰好能容纳一个指针），所以典型的邮箱也被称为交换消息\n\n> 一般如果邮箱中<span style=\"color:#3399FF;\">存在邮件</span>且收取邮件时的<span style=\"color:#3399FF;\">超时时间为0</span>，邮件的收取过程是<span style=\"font-weight:bold;\">非阻塞</span>的\n>\n> 但邮箱中<span style=\"color:#3399FF;\">不存在邮件</span>且<span style=\"color:#3399FF;\">超时时间不为0</span>时，邮件收取过程就是<span style=\"font-weight:bold;\">阻塞</span>的，邮件收取阻塞的情况下只能由线程进行邮件的收取。\n\n- `邮件发送阻塞`：一个线程向邮箱发送邮件时：\n  - 如果邮箱未满，则把邮件复制到邮箱中\n  - 如果邮箱已满，则<span style=\"color:#3399FF;\">发送线程挂起</span>并等待邮箱有空间时将其唤醒再发送邮件 或 直接返回`-RT_EFULL`\n\n- `邮件接收阻塞`：一个线程从邮箱中接收邮件时：\n  - 如果邮箱已空，接收线程可以挂起直到收到新的邮件被唤醒 `也可以设置超时时间并进行等待`\n  - 如果达到设置的超时时间<span style=\"color:#00FFFF;\">但邮箱仍未收到邮件</span>时，超时线程将被唤醒并返回`-RT_ETIMEOUT`；\n  - 如果邮箱中存在邮件，则接收线程赋值邮箱中的邮件到接收缓存\n\n##### **创建邮箱**\n\n```C\n/*创建动态邮箱*/\nrt_mailbox_t rt_mb_create (const char* name, rt_size_t size, rt_uint8_t flag);\n/*创建静态邮箱*/\nrt_err_t rt_mb_init(rt_mailbox_t mb,const char* name,void* msgpool,rt_size_t size,rt_uint8_t flag)\n```\n\n- <span style=\"color:#3399FF;\">参数说明</span>：\n- `mb`：邮箱对象的句柄。\n- `name`：邮箱容量(几封邮件)\n- `size` ：邮箱容量(几封邮件)。\n- `flag` ：邮箱标志，它可以取如下数值：`一般除非应用程序非常在意先来后到，不然都采用PRIO确保线程实时性`\n  - `RT_IPC_FLAG_FIFO` ：非实时调度方式 先来后到\n  - `RT_IPC_FLAG_PRIO` ：实时调度方式 优先级\n- `msgpool` ：缓冲区指针。\n- `recved` ：输出参数，返回实际接收到的事件标志\n\n##### **删除或脱离邮箱**\n\n```C\n/*删除动态邮箱create*/\nrt_err_t rt_mb_delete (rt_mailbox_t mb);\n/*删除静态邮箱init*/\nrt_err_t rt_mb_detach(rt_mailbox_t mb);\n\n//返回值：RT_EOK 成功\n```\n\n- <span style=\"color:#3399FF;\">参数说明</span>：\n- `mb`：邮箱对象的句柄。\n\n> 调用删除函数时，内核会<span style=\"color:#00FFFF;\">先唤醒所有</span>挂在该邮箱上的线程（线程返回值是`RT_ERROR`），然后<span style=\"color:#00FFFF;\">再释放</span>邮箱使用的<span style=\"color:#00FFFF;\">内存</span>，最后<span style=\"color:#00FFFF;\">删除邮箱对象</span>\n\n##### **发送邮件**\n\n```c\n/*1.直接发送邮件*/\n/*！！！！！记得value需要强转rt_uint32_t！！！！！*/\nrt_err_t rt_mb_send (rt_mailbox_t mb, rt_uint32_t value);\n/**************返回值*****************/\nRT_EOK        发送成功\n-RT_EFULL      邮箱已经满了\n\n/*2.等待方式发送邮件*/\n/*@note 若邮箱已满，则根据设定的timeout等待邮箱中因为收取邮件而空出空间\n/*@note 若超时时间到达依然没有空出时间，此时发送线程被唤醒并返回错误码\n*/\nrt_err_t rt_mb_send_wait (rt_mailbox_t mb,rt_uint32_t value,rt_int32_t timeout);\n/**************返回值*****************/\nRT_EOK        发送成功\n-RT_ETIMEOUT     超时\n-RT_ERROR    失败，返回错误\n\n/*3.发送紧急邮件*/\n/*@note 发送紧急邮件时，邮件被直接插队放入了邮件队首,这样就能最优先接收到并做出处理\n*/\nrt_err_t rt_mb_urgent (rt_mailbox_t mb, rt_ubase_t value);\n/**************返回值*****************/\nRT_EOK       发送成功\n-RT_EFULL    邮箱已满\n```\n\n- <span style=\"color:#3399FF;\">参数说明</span>：\n- `mb`：邮箱对象的句柄。\n- `value` ：发送的邮件内容。\n- `timeout` ：超时时间。\n\n##### **接收邮件**\n\n```C\n/*@note 只有当接收者接收的邮箱中有邮件时，接收者才能立即取到邮件并返回 RT_EOK 的返回值\n否则接收线程会根据超时时间设置，或挂起在邮箱的等待线程队列上，或直接返回。\n！！！！！记得value需要强转rt_uint32_t！！！！！\n*/\nrt_err_t rt_mb_recv (rt_mailbox_t mb, rt_uint32_t* value, rt_int32_t timeout);\n/**************返回值*****************/\nRT_EOK        接收成功\n-RT_ETIMEOUT     超时\n-RT_ERROR    失败，返回错误\n```\n\n- <span style=\"color:#3399FF;\">参数说明</span>：\n- `mb`：邮箱对象的句柄。\n- `value` ：邮件内容`(定义一个变量来接收 记得强转)`\n- `timeout` ：超时时间。\n\n#### **应用示例**\n\n```C\n#include <rtthread.h>\n\n/*创建邮箱*/\nrt_mailbox_t mb;\n\n/*线程1：发送邮箱*/\nvoid thread_entry1(void *parameter)\n{\n    char msg = 'A';//发送'A'作为邮件\n    rt_kprintf(\"线程1：发送邮件...\\n\");\n    //发送邮件  因为邮箱固定4字节 所以需要强转\n    rt_mb_send(mb, (rt_uint32_t)msg);\n}\n/*线程2：接收邮件*/\nvoid thread_entry2(void *parameter)\n{\n   char msg;\n   rt_kprintf(\"线程2：等待接收邮件...\\n\");\n   //若邮箱内为空  则执行的是阻塞式的等待接收邮件\n   rt_mb_recv(mb, (rt_uint32_t)&msg, RT_WAITING_FOREVER);//接收邮件\n   rt_kprintf(\"线程2：收到邮件：%c\\n\",msg);\n}\n\nint main(void)\n{\n    /*创建一个容量为4的4封邮箱(大小为4*4)) */\n    mb = rt_mb_create(\"mb\", 4, RT_IPC_FLAG_PRIO);\n    /*创建两个线程 */\n    rt_thread_t tid1 = rt_thread_create(\"t1\", thread_entry1, RT_NULL, 1024, 10,\n    10);\n    rt_thread_t tid2 = rt_thread_create(\"t2\", thread_entry2, RT_NULL, 1024, 10,\n    10);\n    /* 启动线程 */\n    rt_thread_startup(tid1);\n    rt_thread_startup(tid2);\n    return 0;\n}\n```\n\n### **消息队列**\n\n消息队列是另一种常用的线程间通讯方式，是邮箱的扩展。他可以动态分配内存，对比邮箱局限的4字节存储特性，更适合用来传输复杂大量数据或进行任务队列管理\n\n#### **工作机制**\n\n##### **创建消息队列**\n\n```C\n/*创建动态消息队列*/\nrt_mq_t rt_mq_create(const char* name, rt_size_t msg_size,rt_size_t max_msgs, rt_uint8_t flag);\n\n/*创建静态消息队列*/\n/*@note 一般放于读数据段或未初始化数据段中。在使用这类静态消息队列对象前，需要进行初始化\n*/\nrt_err_t rt_mq_init(rt_mq_t mq, const char* name,void *msgpool,rt_size_t msg_size,rt_size_t pool_size, rt_uint8_t flag);\n```\n\n- <span style=\"color:#3399FF;\">参数说明</span>：\n\n- `name `：消息队列的名称。\n\n- `msg_size ` ：消息队列中一条消息的最大长度，<span style=\"color:#00FFFF;\">单位字节</span>。\n\n- `msg_msgs`：消息队列的最大个数(消息个数)。\n\n- `flag` ：消息队列采用的等待方式，它可以取如下数值：`一般除非应用程序非常在意先来后到，不然都采用PRIO确保线程实时性`\n\n  - `RT_IPC_FLAG_FIFO`：非实时调度方式 先来后到\n\n  - `RT_IPC_FLAG_PRIO`：实时调度方式 优先级\n\n- `mq` ：消息队列对象的句柄。\n\n- `msgpool`：指向存放消息的缓冲区的指针。\n\n- `pool_size` ：存放消息的缓冲区大小\n\n##### **删除或脱离消息队列**\n\n```C\n/*删除动态消息队列create*/\nrt_err_t rt_mq_delete(rt_mq_t mq);\n/*删除静态消息队列init*/\nrt_err_t rt_mq_detach(rt_mq_t mq);\n//返回值：RT_EOK 成功\n```\n\n- <span style=\"color:#3399FF;\">参数说明</span>：\n- `mq`：消息队列对象的句柄\n\n> 删除消息队列时，如果<span style=\"color:#00FFFF;\">有线程</span>被挂起在该消息队列等待队列上，则内核<span style=\"color:#00FFFF;\">先唤醒挂起</span>在该消息等待队列上的所有线程（线程返回值是 `- RT_ERROR`），然后再<span style=\"color:#00FFFF;\">释放</span>消息队列使用的内存，最后<span style=\"color:#00FFFF;\">删除</span>消息队列对象\n\n##### **发送消息**\n\n```C\n/*1.直接发送消息*/\nrt_err_t rt_mq_send (rt_mq_t mq, void* buffer, rt_size_t size);\n/**************返回值*****************/\nRT_EOK        发送成功\n-RT_EFULL      消息队列已经满了\n-RT_ERROR       失败(发送消息长度>队列的最大长度)\n\n/*2.等待方式发送消息*/\n/*@note 若消息队列已满，则根据设定的timeout等待\n/*@note 若超时时间到达依然没有空出时间，此时发送线程被唤醒并返回错误码\n*/\nrt_err_t rt_mq_send_wait(rt_mq_t mq,const void *buffer,rt_size_t size,rt_int32_t  timeout);\n/**************返回值*****************/\nRT_EOK        发送成功\n-RT_ETIMEOUT     超时\n-RT_ERROR    失败(发送消息长度>队列的最大长度)\n\n/*3.发送紧急消息*/\n/*@note 发送紧急消息时，邮件被直接插队放入了消息队列队首,这样就能最优先接收到并做出处理\n*/\nrt_err_t rt_mq_urgent(rt_mq_t mq, void* buffer, rt_size_t size);\n/**************返回值*****************/\nRT_EOK       发送成功\n-RT_EFULL    消息队列已经满了\n-RT_ERROR    失败(发送消息长度>队列的最大长度)\n```\n\n- <span style=\"color:#3399FF;\">参数说明</span>：\n- `mq`：消息队列对象的句柄\n- `buffer` ：发送的消息内容。\n- `size` ：消息大小。\n- `timeout` ：超时时间。\n\n##### **接收消息**\n\n```C\n/*@note 只有当消息队列中有消息时，接收者才能立即取到邮件并返回 RT_EOK 的返回值\n否则接收线程会根据超时时间设置，或挂起在邮箱的等待线程队列上，或直接返回。\n*/\nrt_ssize_t rt_mq_recv (rt_mq_t mq, void* buffer,rt_size_t size,rt_int32_t timeout);\n/**************返回值*****************/\nRT_EOK             成功收到\n-RT_ETIMEOUT             超时\n-RT_ERROR            失败，返回错误\n```\n\n- <span style=\"color:#3399FF;\">参数说明</span>：\n- `mq`：消息队列对象的句柄\n- `buffer` ：发送的消息内容。\n- `size` ：消息大小。\n- `timeout` ：超时时间\n\n#### **应用示例**\n\n```C\n#include <rtthread.h>\n\n/*创建消息队列*/\nrt_mq_t mq;\n\n/*线程1：发送消息*/\nvoid thread_entry1(void *parameter)\n{\n    char msg[] = \"Hello, RT-Thread!\";//发送'A'作为邮件\n    rt_kprintf(\"线程1：发送消息...\\n\");\n    //发送消息到消息队列\n    rt_mq_send(mq, msg,sizeof(msg));\n}\n/*线程2：接收邮件*/\nvoid thread_entry2(void *parameter)\n{\n   char buffer[32];\n   rt_kprintf(\"线程2：等待接收消息...\\n\");\n   //若消息队列内无消息  则执行的是阻塞式的等待接收消息\n   rt_mq_recv(mq, buffer,sizeof(buffer), RT_WAITING_FOREVER);//接收消息\n   rt_kprintf(\"线程2：收到消息：%s\\n\",buffer);\n}\n\nint main(void)\n{\n    /*创建一个消息队列，容量为4，消息大小为32字节 */\n    mq = rt_mq_create(\"mq\", 32, 4, RT_IPC_FLAG_PRIO);\n    /*创建两个线程 */\n    rt_thread_t tid1 = rt_thread_create(\"t1\", thread_entry1, RT_NULL, 1024, 10,\n    10);\n    rt_thread_t tid2 = rt_thread_create(\"t2\", thread_entry2, RT_NULL, 1024, 10,\n    10);\n    /* 启动线程 */\n    rt_thread_startup(tid1);\n    rt_thread_startup(tid2);\n    return 0;\n}\n\n```\n\n### **信号**\n\n`信号（又称为软中断信号）`，在软件层次上是对中断机制的一种模拟。常用于通知线程发生了某个事件。线程收到信号时会根据信号类型执行相应的操作\n\n- 与消息队列区别：\n\n1. <span style=\"color:#00FFFF;\">信号仅携带控制信息，不包含数据</span>\n\n2. 信号不保证顺序性，<span style=\"color:#00FFFF;\">信号发生时立即通知线程</span>\n\n3. 消息队列则有顺序性（通常是PRIO）\n\n#### **工作机制**\n\n##### **线程中安装信号**\n\n```C\n/*\nt_sighandler_t[] 表示一个函数指针数组\nt_sighandler_t handler[] 是一个 变量声明\n二者是不一样的！\n*/\nrt_sighandler_t rt_signal_install(int signo, rt_sighandler_t[] handler);\n/**************返回值*****************/\nSIG_ERR                错误的信号\n安装信号前的handler值    成功\n```\n\n- <span style=\"color:#3399FF;\">参数说明</span>：\n- `signo `：信号值（只有 `SIGUSR1` 和 `SIGUSR2` 是开放给用户使用的）。\n- `buffer` ：发送的消息内容。\n- `handler` ：设置对信号值的处理方式。\n\n>  在信号安装时设定 handler 参数，决定了该信号的不同的处理方法。处理方法可以分为三种：\n>\n> 1. 类似`中断`的处理方式，参数指向当信号发生时用户`自定义的处理函数`， 在内部写入处理方式，由该函数来处理。\n>\n> 2. 参数设为 `SIG_IGN`，忽略某个信号，`对该信号不做任何处理`，就像未发生过一样。\n>\n> 3. 参数设为 `SIG_DFL`，系统会调用默认的处理函数`_signal_default_handler()`。\n\n##### **阻塞信号与解除阻塞**\n\n```C\n/*信号阻塞(屏蔽信号) 该信号不会递答安装此信号的线程*/\nvoid rt_signal_mask(int signo);\n/*解除信号阻塞\n使用此函数可以对其中一些信号给予 “关注”，那么发送这些信号都会引发该线程的软中断\n*/\nvoid rt_signal_unmask(int signo);\n```\n\n- <span style=\"color:#3399FF;\">参数说明</span>：\n- `signo`：信号值\n\n##### **发送信号**\n\n```C\n/*需要异常处理时，可以给安装了信号的线程发送信号*/\nint rt_thread_kill(rt_thread_t tid, int sig);\n/**************返回值*****************/\nRT_EOK        发送成功\n-RT_EINVAL    参数错误\n```\n\n- <span style=\"color:#3399FF;\">参数说明</span>：\n- `tid`：接收信号的线程。\n- `sig `：信号值。\n\n#### **应用示例**\n\n```C\n#include <rtthread.h>\n\n#define THREAD_PRIORITY         25\n#define THREAD_STACK_SIZE       512\n#define THREAD_TIMESLICE        5\n\nstatic rt_thread_t tid1 = RT_NULL;\n\n/* 线程 1 的信号处理函数 */\nvoid thread1_signal_handler(int sig)\n{\n    rt_kprintf(\"thread1 received signal %d\\n\", sig);\n}\n\n/* 线程 1 的入口函数 */\nstatic void thread1_entry(void *parameter)\n{\n    int cnt = 0;\n\n    /* 安装信号 */\n    rt_signal_install(SIGUSR1, thread1_signal_handler);\n    rt_signal_unmask(SIGUSR1);\n\n    /* 运行 10 次 */\n    while (cnt < 10)\n    {\n        /* 线程 1 采用低优先级运行，一直打印计数值 */\n        rt_kprintf(\"thread1 count : %d\\n\", cnt);\n\n        cnt++;\n        rt_thread_mdelay(100);\n    }\n}\n\n/* 信号示例的初始化 */\nint signal_sample(void)\n{\n    /* 创建线程 1 */\n    tid1 = rt_thread_create(\"thread1\",thread1_entry, RT_NULL,THREAD_STACK_SIZE, THREAD_PRIORITY, THREAD_TIMESLICE);\n\n    if (tid1 != RT_NULL)\n        rt_thread_startup(tid1);\n\n    rt_thread_mdelay(300);\n\n    /* 发送信号 SIGUSR1 给线程 1 */\n    rt_thread_kill(tid1, SIGUSR1);\n\n    return 0;\n}\n\n```\n\n## **框架移植**\n\n```C\n//bsp_system.h中引入以下四个头文件\n#include <rtthread.h>\n#include <rtdevice.h>\n#include <drv_common.h>\n#include <board.h>\n```\n\n### **系统初始化宏定义**\n\n​    ![image-20250522214349807](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505222143758.png)\n\n```C\n/*1、板级初始化 fn为函数指针*/\nINIT_BOARD_EXPORT(fn)\n/*2、纯软件函数初始化 fn为函数指针*/\nINIT_PREV_EXPORT(fn)\n/*3、设备自动初始化，fn为函数指针*/\nINIT_DEVICE_EXPORT(fn)\n/*4、组件自动初始化，fn为函数指针*/\nINIT_COMPONENT_EXPORT(fn)\n/*5、系统环境自动初始化，fn为函数指针*/\nINIT_ENV_EXPORT(fn) \n/*6、应用自动初始化，fn为函数指针*/\nINIT_APP_EXPORT(fn)\n```\n\n### **ESP8266移植**\n\n> 将`uart_app.c`与`uart_app.h`移去 不使用！！！然后RTT打开控制台输出rt_kprintf，选择串口1\n\n   ![image-20250522214536841](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505222145092.png)\n\n![image-20250522220417747](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505222204947.png) ![image-20250522220447380](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505222204548.png)\n\n![image-20250522214750185](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505222147073.png)\n\n![image-20250522214705123](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505222147664.png)\n\n![image-20250522214840651](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505222148942.png)\n\n![image-20250522214859546](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505222149729.png)\n\n![image-20250522214917115](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505222149203.png)\n\n![image-20250522214947877](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505222149796.png)\n\n直接编译开启终端 下载观察现象，出现以下信息则连接成功\n\n​    ![image-20250522215015453](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505222150747.png)\n\n### **DHT11移植**\n\n#### **组件添加**\n\n​    ![image-20250522215146162](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505222151707.png)\n\n![image-20250522215207600](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505222152193.png)\n\n![image-20250522220342327](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505222203028.png)\n\n\n\n#### **proc代码构建**\n\n##### **创建sensor_app.c与.h**\n\n```C\n//引入必要库\n#include <sensor_app.h>\n#include <sensor.h>\n#include \"sensor_dallas_dht11.h\"\n```\n\n##### **注册设备**\n\n    ```C\n        rt_device_t dev = RT_NULL;\n        //创建传感器结构体对象\n        struct rt_sensor_data sensor_data;\n        rt_uint8_t get_data_freq = 1;///默认1hz\n        rt_size_t res;//返回值 如RT_EOK\n    \n        /*注册传感器*/\n        dev =  rt_device_find(\"temp_dht11\");//注意此处注册需要有前缀 如temp_(在sensor.c中)\n        if(dev == RT_NULL)\n        {\n            rt_kprintf(\"Not Found\\r\\n\");\n            return;\n        }\n        if(rt_device_open(dev, RT_DEVICE_FLAG_RDWR) != RT_EOK)\n        {\n            rt_kprintf(\"Open Error\\r\\n\");\n            return;\n        }\n    \n        rt_device_control(dev, RT_SENSOR_CTRL_SET_ODR, (void *)&get_data_freq);\n    ```\n\n##### **读取传感器数据**\n\n```C\n /*读取传感器*/\n    while(1)\n    {\n        res = rt_device_read(dev, 0, &sensor_data, 1);//第0位开始读一个\n        //读错了返回0\n        if(res == 0)\n        {\n            rt_kprintf(\"Read Error Res:%d\",res);//返回读取错误编号0\n            return;\n        }\n        else //读取成功\n        {\n            if(sensor_data.data.temp >= 0) //数据大于等于0 包括了温度与湿度\n            {\n                uint8_t temp = (sensor_data.data.temp & 0xffff);\n                uint8_t humi = (sensor_data.data.temp & 0xffff0000) >> 16;\n                rt_kprintf(\"temp:%d humi:%d\\r\\n\",temp,humi);\n            }\n        }\n        rt_thread_delay(1000);\n    }\n```\n\n##### **init代码构建**\n\n```C\nint sensor_init(void)\n{\n    struct rt_sensor_config cfg;//操作集结构体\n    /*注册设备 配置接口*/\n    cfg.intf.user_data = (void *)DHT11_PIN;//配置接口为IO口\n    rt_hw_dht11_init(\"dht11\", &cfg);\n\n    rt_thread_t sensor_thread = rt_thread_create(\"sensor_proc\", sensor_proc, RT_NULL, 1024, 10, 20);\n    if(sensor_thread != RT_NULL)\n    {\n        rt_thread_startup(sensor_thread);\n    }\n    return RT_EOK;\n}\nINIT_COMPONENT_EXPORT(sensor_init);\n```\n\n","source":"_posts/RT-Thread.md","raw":"---\ntitle: RT_Thread\ndate: 2025-05-21 20:26:03\ncover: \"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505212030199.png\"\ntags:\n  - 实时操作系统\n  - RTOS\n  - RT_Thread\nlayout: page\ncategories: MCU\n---\n\n## 时钟管理\n\n### 时钟节拍产生与获取\n\n时钟节拍依赖于硬件中的定时器。你可以把定时器看作是⼀个不停计时的装置，它每隔⼀段时间就会提醒系统“滴答”⼀次。<span style=\"text-decoration:underline;\">每当定时器中断发⽣时，RT-Thread 会调⽤ rt_tick_increase()函数，系统时间增加 1 个节拍</span>。`就像家中的闹钟响⼀次，时间就过去了⼀分钟⼀样。`\n\n> 其中rt_tick_increase()函数中有rt_tick类似于HAL库中的uwTick，可以直接调用 获取系统时间\n\n## 定时器管理\n\n### 硬件定时器 vs 软件定时器\n\n1. <span style=\"color:#FF3399;\">硬件定时器</span>：就像厨房⾥的倒计时器，它是由硬件直接提供的。硬件定时器精度⾮常⾼，可以达到纳秒级，适合⼀些对时间要求⾮常严格的任务，⽐如控制电机的旋转时间。\n2. <span style=\"color:#FF3399;\">软件定时器</span>：可以理解为⼿机上的计时 App。它依赖于操作系统的时钟节拍来⼯作，它的时间间隔精度由 OS Tick 决定。例如，如果 OS Tick 是 10ms，那么软件定时器只能精确到 10ms。虽然精度不如硬件定时器⾼，但它更灵活、容易使⽤。\n\n### RTT定时器分类\n\n- <span style=\"color:#FF3399;\">单次触发定时器</span>：就像倒计时⼀次的闹钟，响⼀次后就停⽌。例如，设定⼀个 5 秒的倒计时，时间到了闹钟响⼀次就结束了。\n- <span style=\"color:#FF3399;\">周期触发定时器</span>：就像那些每天早上 7 点重复响起的闹钟。每隔⼀段时间，它会周期性地触发事件，直到你⼿动关闭它。\n\n根据定时器回调函数执⾏的上下⽂环境，定时器还可以分为两种模式：\n\n- <span style=\"color:#FF3399;\">硬件模式 </span>(HARD_TIMER)：定时器的回调函数在<span style=\"text-decoration:underline;\">中断上下⽂</span>中执⾏`就像闹钟响起时你⽴刻跳起来⼀样`它反应⾮常快，但要求处理时间短。\n- <span style=\"color:#FF3399;\">软件模式</span> (SOFT_TIMER)：回调函数在<span style=\"text-decoration:underline;\">系统的 timer 线程中</span>执⾏，相当于`有⼈提醒你“闹钟响了”`，然后你再去执⾏⼀些动作。这个模式可以做更复杂的操作，因为它不是在中断中执⾏。\n\n### 控制定时器\n\n`通过该函数你可以随时改变定时器触发方式以及定时器时间`\n\n![image-20250521221429133](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505212214569.png)\n\n### 高精度延时\n\n`使用该函数可以实现微妙级的精确延时，适合高精度时间控制场合`\n\n![image-20250521221525259](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505212215044.png)\n\n## 线程创建\n\n![image-20250521203425658](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505212034310.png)\n\n- `name`：线程名字\n- `entry`：线程入口函数\n- `parameter`：传递给线程的参数\n- `stack_size`：线程栈大小\n- `priority`：线程优先级\n- `tick`：时间片\n\n### 详细步骤\n\n1. 声明一个pcb结构体 `static rt_thread_t tid1 = RT_NULL;`\n2. 编写线程入口函数 `static void thread1_entry(void *parameter)`，参数为必需，其为传递给线程的参数\n3. 利用`rt_thread_create`函数赋值给所声明的pcb结构体tid1\n4. 利用``rt_thread_startup(tid1)``函数启动线程\n\n### 实现示例\n\n```C\nstatic void thread1_proc(void *parameter)\n{\n    while(1)\n    {\n        /*实际功能*/\n        rt_thread_mdelay(1000);//休息1秒\n    }\n}\nint thread1_init(void)\n{\n    rt_thread_t tid1 =  rt_thread_create(\"thread1_proc\",thread1_proc,RT_NULL,1024,10,20);\n    if(tid1 != RT_NULL)\n    {\n        rt_thread_startup(tid1);\n    }\n    return RT_EOK;\n}\nINIT_COMPONENT_EXPORT(thread1_init);   //用这个宏就不需要另外再去注册\n```\n\n> <span style=\"font-style:italic;\">rt_thread_mdelay(1000)的工作机制：</span>\n>\n> <span style=\"font-style:italic;\">1、当 rt_thread_mdelay 被调⽤时，当前线程会进⼊ RT_THREAD_SUSPEND 状态（<span style=\"color:#CC00CC;\">挂起</span>状态）。</span>\n>\n> <span style=\"font-style:italic;\">2、调度器开始运⾏其他优先级相同或更⾼的线程。</span>\n>\n> <span style=\"font-style:italic;\">3、 <span style=\"text-decoration:underline;\">延时时间结束后，线程从 挂起状态 转变为 就绪状态</span> ，等待系统再次调度该线程。</span>\n>\n> <span style=\"font-style:italic;\">PS：若此时无其他线程，则CPU就处于释放状态</span>\n\n![image-20250521205640868](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505212056766.png)\n\n## 线程间同步\n\n### 信号量\n\n信号量可以理解为电影院的座位数（<span style=\"color:#FF0000;\">资源数量</span>）。当所有座位都满了，新的观众（线程）就需要等前⾯的观众离开（释放资源）才能进⼊。当有空位时，观众可以进⼊。`信号量通过控制资源的数量来管理多个线程对资源的访问`\n\n#### 工作机制\n\n- `获取信号量`：当资源可⽤时，线程可以获取信号量，<span style=\"color:#FF0000;\">信号量的值减1</span>。<span style=\"background:#66FFFF;\">如果信号量的值为0，线程就会等待，直到资源释放</span>\n\n- `释放信号量`：使⽤完资源后，线程释放信号量，<span style=\"color:#FF0000;\">信号量的值加1</span>，允许其他线程访问资源\n\n##### 创建信号量\n\n```c\n/*动态分配内存并创建信号量*/\nrt_sem_t rt_sem_create(const char *name, rt_uint32_t value, rt_uint8_t flag);\n/*静态分配内存并创建信号量*/\nrt_err_t rt_sem_init(rt_sem_t sem, const char *name, rt_uint32_t value,rt_uint8_t flag);\n```\n\n- <span style=\"color:#3399FF;\">参数说明</span>：\n\n- `name`：信号量的名字（可以为 `RT_NULL` 表⽰匿名信号量）。\n\n- `value`：信号量的初始值，表⽰信号量当前持有的资源数量（`例如初始值为 0 表⽰等待事件，为 1 表⽰互斥量，或者更⼤值表⽰资源计数`）。\n\n- `flag`：PC 对象的属性标志，常⽤值：\n- `RT_IPC_FLAG_PRIO` ：<span style=\"color:#FF0000;\">优先级</span>等待⽅式，等待线程按照优先级顺序排列。\n  \n- `RT_IPC_FLAG_FIFO` ：<span style=\"color:#FF0000;\">先⼊先出</span>等待⽅式，等待线程按照进⼊顺序排列。\n\n##### 获取信号量\n\n⽤于获取信号量（P 操作），线程会尝试获取信号量，`如果信号量的计数值为 0，线程会进⼊等待状态`，直到信号量被释放或超时。\n\n```c\nrt_err_t rt_sem_take(rt_sem_t sem, rt_int32_t time);\n```\n\n- <span style=\"color:#3399FF;\">参数说明</span>：\n\n- `sem`：信号量的句柄。\n\n- `time`：超时时间（单位为系统 tick），表⽰最⼤等待时间。如果设置为 `RT_WAITING_FOREVER` ，线程会⼀直等待\n\n##### 释放信号量\n\n⽤于释放信号量（V 操作），**增加**信号量的计数值，`并唤醒等待该信号量的线程`。\n\n```c\nrt_err_t rt_sem_release(rt_sem_t sem);\n```\n\n#### 应用示例\n\n```c\n#include <rtthread.h>\n\nrt_sem_t sem = RT_NULL;\n\nvoid thread1(void *parameter)\n{\n   rt_kprintf(\"线程1：等待线程2发送信号\\n\");\n\n   /*等待信号量，超时时间为永久等待*/\n   rt_sem_take(sem,RT_WAITING_FOREVER);\n\n   rt_kprintf(\"线程1：收到线程2的信号，继续执行....\\n\");\n}\n\nvoid thread2(void *parameter)\n{\n   rt_kprintf(\"线程2：执行一些操作\\n\");\n   /*模拟执行一些动作*/\n   rt_thread_mdelay(2000);\n   rt_kprintf(\"线程2：操作完成，发送信号给线程1\\n\");\n   /*释放信号量 通知线程1*/\n   rt_sem_release(sem);\n}\n\nint main(void)\n{\n    rt_thread_t tid1 = RT_NULL;\n    rt_thread_t tid2 = RT_NULL;\n\n    sem = rt_sem_create(\"sem\", 0, RT_IPC_FLAG_PRIO);\n    tid1 = rt_thread_create(\"tid1\", thread1, RT_NULL, 1024, 25, 100);\n    tid2 = rt_thread_create(\"tid2\", thread2, RT_NULL, 1024, 25, 100);\n\n    if(tid1 != RT_NULL) rt_thread_startup(tid1);\n    if(tid2 != RT_NULL) rt_thread_startup(tid2);\n    return 0;\n}\n```\n\n#### 使用场景\n\n1. 任务同步（多任务协调执行顺序）\n2. 任务互斥(使用`互斥量` 保证同一时间只有一个线程 访问公共资源)\n3. 事件触发\n4. 限量资源管理\n\n### **互斥量（Mutex）**\n\n#### **工作机制**\n\n互斥量确保同⼀时刻**只有⼀个线程能够访问共享资源**：\n\n- `获取互斥量`：当⼀个线程获取到互斥量时，其他线程不能访问该资源，直到互斥量被释放。\n- `释放互斥量`：当线程释放互斥量后，其他等待的线程才能访问资源\n\n##### **创建互斥量**\n\n```c\n/*动态创建一个互斥量*/\nrt_mutex_t rt_mutex_create(const char *name, rt_uint8_t flag);\n/*静态创建一个互斥量*/\nrt_err_t rt_mutex_init(rt_mutex_t mutex, const char *name, rt_uint8_t flag);\n```\n\n- <span style=\"color:#3399FF;\">参数说明</span>：\n- `name`：互斥量的名字（可以为 `RT_NULL` 表⽰匿名互斥量）。\n- `flag`：IPC 对象的属性标志，通常使⽤ `RT_IPC_FLAG_PRIO` 表⽰优先级等待。\n\n##### **获取互斥量**\n\n⽤于获取互斥量，线程通过调⽤此函数进⼊临界区。`如果互斥量已经被其他线程获取，当前线程会进⼊等待状态，直到获取成功或超时。`\n\n```c\nrt_err_t rt_mutex_take(rt_mutex_t mutex, rt_int32_t time);\n```\n\n- <span style=\"color:#3399FF;\">参数说明</span>：\n- `mutex`：互斥量的句柄。\n- `time`：超时时间（单位为系统 tick），可以指定等待时⻓或 `RT_WAITING_FOREVER`表⽰永远等待。\n\n##### 释放互斥量\n\n⽤于释放互斥量（V 操作），**增加**互斥量的计数值，并唤醒等待该互斥量的线程。\n\n```c\nrt_err_t rt_mutex_release(rt_mutex_t mutex);\n```\n\n#### **应用示例**\n\n```c\n#include <rtthread.h>\n\nrt_mutex_t mutex = RT_NULL;\nrt_uint32_t cnt = 0;\n\nvoid thread1(void *parameter)\n{\n   //rt_kprintf(\"线程1：等待线程2发送信号\\n\");\n   while(1)\n   {\n       rt_mutex_take(mutex,RT_WAITING_FOREVER);\n       cnt++;\n       rt_thread_mdelay(1000);\n       rt_kprintf(\"线程1 cnt = %d \\n\",cnt);\n       rt_mutex_release(mutex);\n   }\n}\n\nvoid thread2(void *parameter)\n{\n   //rt_kprintf(\"线程2：执行一些操作\\n\");\n    while(1)\n    {\n        rt_mutex_take(mutex,RT_WAITING_FOREVER);\n        cnt++;\n        rt_thread_mdelay(1000);\n        rt_kprintf(\"线程2 cnt = %d \\n\",cnt);\n        rt_mutex_release(mutex);\n    }\n}\n\nint main(void)\n{\n    rt_thread_t tid1 = RT_NULL;\n    rt_thread_t tid2 = RT_NULL;\n\n    mutex = rt_mutex_create(\"mutex\", RT_IPC_FLAG_PRIO);\n    tid1 = rt_thread_create(\"tid1\", thread1, RT_NULL, 1024, 25, 100);\n    tid2 = rt_thread_create(\"tid2\", thread2, RT_NULL, 1024, 25, 100);\n\n    if(tid1 != RT_NULL) rt_thread_startup(tid1);\n    if(tid2 != RT_NULL) rt_thread_startup(tid2);\n    return 0;\n}\n\n```\n\n### **任务同步与任务互斥差异**\n\n![image-20250522203011255](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505222030206.png)\n\n### **事件集**\n\n事件集可以看作公交⻋站的场景。线程可以等待多个事件发⽣，`⽐如等待公交⻋或等待同伴到达。如果满⾜某个或某⼏个条件，线程将被唤醒继续执⾏。`\n\n#### **工作机制**\n\n事件集⽤于线程间的同步，可以让线程等待⼀个或多个事件的触发：\n\n- `逻辑与（AND)`：线程等待多个事件同时发⽣才被唤醒。\n- `逻辑或（OR）`：线程只需等待其中⼀个事件发⽣即可被唤醒。 \n\n##### **创建事件对象**\n\n```c\n/*动态创建一个对象*/\nrt_event_t rt_event_create(const char *name, rt_uint8_t flag);\n/*静态创建一个对象*/\nrt_err_t rt_event_init(rt_event_t event, const char *name, rt_uint8_t flag); \n```\n\n- <span style=\"color:#3399FF;\">参数说明</span>：\n- `name`：事件对象的名字（可以为 `RT_NULL` 表⽰匿名事件对象）。\n- `flag`：IPC 对象的属性标志，⼀般使⽤ `RT_IPC_FLAG_PRIO` 表⽰优先级等待，或`RT_IPC_FLAG_FIFO` 表⽰先进先出等待。\n\n##### **发送(触发)事件**\n\n```c\nrt_err_t rt_event_send(rt_event_t event, rt_uint32_t set);\n```\n\n- <span style=\"color:#3399FF;\">参数说明</span>：\n- `event`：事件对象的句柄。\n- `set`：事件标志，设置哪⼏位事件标志被触发 `可以⽤ 1 << n 来表⽰第 n 位的事件。`\n\n##### **接收(等待)事件**\n\n```c\nrt_err_t rt_event_recv(rt_event_t event, rt_uint32_t set, rt_uint8_t option, rt_int32_t timeout, rt_uint32_t *recved);\n```\n\n- <span style=\"color:#3399FF;\">参数说明</span>：\n- `event`：事件对象的句柄。\n- `set`：需要等待的事件标志 `例如 1 << 3 | 1 << 5 表⽰同时等待第3位和第5位的事件`\n- `option` ：等待选项，常⻅选项包括：\n  - `RT_EVENT_FLAG_AND` ：<span style=\"color:#3399FF;\">所有</span>指定的事件标志都满⾜时才唤醒线程。\n  - `RT_EVENT_FLAG_OR` ：<span style=\"color:#3399FF;\">只要有⼀个</span>指定的事件标志满⾜就唤醒线程。\n  - `RT_EVENT_FLAG_CLEAR` ：<span style=\"color:#3399FF;\">收到</span>事件标志后<span style=\"color:#3399FF;\">清除</span>这些事件标志。\n- `timeout` ：超时时间（单位为系统 tick），可以为 `RT_WAITING_FOREVER` 表⽰永远等待。\n- `recved` ：输出参数，返回实际接收到的事件标志\n\n#### **应用示例**\n\n```c\n#include <rtthread.h>\n\nrt_event_t event = RT_NULL;\n/*线程1：等待事件*/\nvoid thread1(void *parameter)\n{\n   rt_uint32_t recei;\n   rt_kprintf(\"线程1：等待公交车3或5到来...\\n\");\n\n   rt_event_recv(event, (1 << 3 | 1 << 5), RT_EVENT_FLAG_OR | RT_EVENT_FLAG_CLEAR, RT_WAITING_FOREVER, &recei);\n\n   rt_kprintf(\"线程1：公交车 %d 到站，出发！....\\n\",recei);\n}\n/*线程2：发送事件（公交车到站）*/\nvoid thread2(void *parameter)\n{\n   rt_thread_mdelay(1000);//模拟公交车到站\n   rt_kprintf(\"线程2：公交车3到站\\n\");\n   rt_event_send(event, (1 << 3));\n}\n\nint main(void)\n{\n    rt_thread_t tid1 = RT_NULL;\n    rt_thread_t tid2 = RT_NULL;\n\n    event = rt_event_create(\"event\", RT_IPC_FLAG_PRIO);\n    tid1 = rt_thread_create(\"tid1\", thread1, RT_NULL, 1024, 25, 100);\n    tid2 = rt_thread_create(\"tid2\", thread2, RT_NULL, 1024, 25, 100);\n\n    if(tid1 != RT_NULL) rt_thread_startup(tid1);\n    if(tid2 != RT_NULL) rt_thread_startup(tid2);\n    return 0;\n}\n```\n\n## **线程间通信**\n\n裸机编程中经常使用全局变量进行功能间的通信（标志）：某些功能由于特定的操作改变全局变量的值，另一个功能对此全局变量进行读取，根据读取到的全局变量执行相应的操作来达到通信协作的目的。RTT提供了邮箱、消息队列和信号等工具来完成这样的类似操作\n\n### **邮箱**\n\n#### 工作机制\n\n邮箱的特点：开销低、效率高、支持一对多\n\n邮箱中一封邮件**只能容纳固定的4字节信息**（针对32位操作系统，指针大小为4字节，一封邮件恰好能容纳一个指针），所以典型的邮箱也被称为交换消息\n\n> 一般如果邮箱中<span style=\"color:#3399FF;\">存在邮件</span>且收取邮件时的<span style=\"color:#3399FF;\">超时时间为0</span>，邮件的收取过程是<span style=\"font-weight:bold;\">非阻塞</span>的\n>\n> 但邮箱中<span style=\"color:#3399FF;\">不存在邮件</span>且<span style=\"color:#3399FF;\">超时时间不为0</span>时，邮件收取过程就是<span style=\"font-weight:bold;\">阻塞</span>的，邮件收取阻塞的情况下只能由线程进行邮件的收取。\n\n- `邮件发送阻塞`：一个线程向邮箱发送邮件时：\n  - 如果邮箱未满，则把邮件复制到邮箱中\n  - 如果邮箱已满，则<span style=\"color:#3399FF;\">发送线程挂起</span>并等待邮箱有空间时将其唤醒再发送邮件 或 直接返回`-RT_EFULL`\n\n- `邮件接收阻塞`：一个线程从邮箱中接收邮件时：\n  - 如果邮箱已空，接收线程可以挂起直到收到新的邮件被唤醒 `也可以设置超时时间并进行等待`\n  - 如果达到设置的超时时间<span style=\"color:#00FFFF;\">但邮箱仍未收到邮件</span>时，超时线程将被唤醒并返回`-RT_ETIMEOUT`；\n  - 如果邮箱中存在邮件，则接收线程赋值邮箱中的邮件到接收缓存\n\n##### **创建邮箱**\n\n```C\n/*创建动态邮箱*/\nrt_mailbox_t rt_mb_create (const char* name, rt_size_t size, rt_uint8_t flag);\n/*创建静态邮箱*/\nrt_err_t rt_mb_init(rt_mailbox_t mb,const char* name,void* msgpool,rt_size_t size,rt_uint8_t flag)\n```\n\n- <span style=\"color:#3399FF;\">参数说明</span>：\n- `mb`：邮箱对象的句柄。\n- `name`：邮箱容量(几封邮件)\n- `size` ：邮箱容量(几封邮件)。\n- `flag` ：邮箱标志，它可以取如下数值：`一般除非应用程序非常在意先来后到，不然都采用PRIO确保线程实时性`\n  - `RT_IPC_FLAG_FIFO` ：非实时调度方式 先来后到\n  - `RT_IPC_FLAG_PRIO` ：实时调度方式 优先级\n- `msgpool` ：缓冲区指针。\n- `recved` ：输出参数，返回实际接收到的事件标志\n\n##### **删除或脱离邮箱**\n\n```C\n/*删除动态邮箱create*/\nrt_err_t rt_mb_delete (rt_mailbox_t mb);\n/*删除静态邮箱init*/\nrt_err_t rt_mb_detach(rt_mailbox_t mb);\n\n//返回值：RT_EOK 成功\n```\n\n- <span style=\"color:#3399FF;\">参数说明</span>：\n- `mb`：邮箱对象的句柄。\n\n> 调用删除函数时，内核会<span style=\"color:#00FFFF;\">先唤醒所有</span>挂在该邮箱上的线程（线程返回值是`RT_ERROR`），然后<span style=\"color:#00FFFF;\">再释放</span>邮箱使用的<span style=\"color:#00FFFF;\">内存</span>，最后<span style=\"color:#00FFFF;\">删除邮箱对象</span>\n\n##### **发送邮件**\n\n```c\n/*1.直接发送邮件*/\n/*！！！！！记得value需要强转rt_uint32_t！！！！！*/\nrt_err_t rt_mb_send (rt_mailbox_t mb, rt_uint32_t value);\n/**************返回值*****************/\nRT_EOK        发送成功\n-RT_EFULL      邮箱已经满了\n\n/*2.等待方式发送邮件*/\n/*@note 若邮箱已满，则根据设定的timeout等待邮箱中因为收取邮件而空出空间\n/*@note 若超时时间到达依然没有空出时间，此时发送线程被唤醒并返回错误码\n*/\nrt_err_t rt_mb_send_wait (rt_mailbox_t mb,rt_uint32_t value,rt_int32_t timeout);\n/**************返回值*****************/\nRT_EOK        发送成功\n-RT_ETIMEOUT     超时\n-RT_ERROR    失败，返回错误\n\n/*3.发送紧急邮件*/\n/*@note 发送紧急邮件时，邮件被直接插队放入了邮件队首,这样就能最优先接收到并做出处理\n*/\nrt_err_t rt_mb_urgent (rt_mailbox_t mb, rt_ubase_t value);\n/**************返回值*****************/\nRT_EOK       发送成功\n-RT_EFULL    邮箱已满\n```\n\n- <span style=\"color:#3399FF;\">参数说明</span>：\n- `mb`：邮箱对象的句柄。\n- `value` ：发送的邮件内容。\n- `timeout` ：超时时间。\n\n##### **接收邮件**\n\n```C\n/*@note 只有当接收者接收的邮箱中有邮件时，接收者才能立即取到邮件并返回 RT_EOK 的返回值\n否则接收线程会根据超时时间设置，或挂起在邮箱的等待线程队列上，或直接返回。\n！！！！！记得value需要强转rt_uint32_t！！！！！\n*/\nrt_err_t rt_mb_recv (rt_mailbox_t mb, rt_uint32_t* value, rt_int32_t timeout);\n/**************返回值*****************/\nRT_EOK        接收成功\n-RT_ETIMEOUT     超时\n-RT_ERROR    失败，返回错误\n```\n\n- <span style=\"color:#3399FF;\">参数说明</span>：\n- `mb`：邮箱对象的句柄。\n- `value` ：邮件内容`(定义一个变量来接收 记得强转)`\n- `timeout` ：超时时间。\n\n#### **应用示例**\n\n```C\n#include <rtthread.h>\n\n/*创建邮箱*/\nrt_mailbox_t mb;\n\n/*线程1：发送邮箱*/\nvoid thread_entry1(void *parameter)\n{\n    char msg = 'A';//发送'A'作为邮件\n    rt_kprintf(\"线程1：发送邮件...\\n\");\n    //发送邮件  因为邮箱固定4字节 所以需要强转\n    rt_mb_send(mb, (rt_uint32_t)msg);\n}\n/*线程2：接收邮件*/\nvoid thread_entry2(void *parameter)\n{\n   char msg;\n   rt_kprintf(\"线程2：等待接收邮件...\\n\");\n   //若邮箱内为空  则执行的是阻塞式的等待接收邮件\n   rt_mb_recv(mb, (rt_uint32_t)&msg, RT_WAITING_FOREVER);//接收邮件\n   rt_kprintf(\"线程2：收到邮件：%c\\n\",msg);\n}\n\nint main(void)\n{\n    /*创建一个容量为4的4封邮箱(大小为4*4)) */\n    mb = rt_mb_create(\"mb\", 4, RT_IPC_FLAG_PRIO);\n    /*创建两个线程 */\n    rt_thread_t tid1 = rt_thread_create(\"t1\", thread_entry1, RT_NULL, 1024, 10,\n    10);\n    rt_thread_t tid2 = rt_thread_create(\"t2\", thread_entry2, RT_NULL, 1024, 10,\n    10);\n    /* 启动线程 */\n    rt_thread_startup(tid1);\n    rt_thread_startup(tid2);\n    return 0;\n}\n```\n\n### **消息队列**\n\n消息队列是另一种常用的线程间通讯方式，是邮箱的扩展。他可以动态分配内存，对比邮箱局限的4字节存储特性，更适合用来传输复杂大量数据或进行任务队列管理\n\n#### **工作机制**\n\n##### **创建消息队列**\n\n```C\n/*创建动态消息队列*/\nrt_mq_t rt_mq_create(const char* name, rt_size_t msg_size,rt_size_t max_msgs, rt_uint8_t flag);\n\n/*创建静态消息队列*/\n/*@note 一般放于读数据段或未初始化数据段中。在使用这类静态消息队列对象前，需要进行初始化\n*/\nrt_err_t rt_mq_init(rt_mq_t mq, const char* name,void *msgpool,rt_size_t msg_size,rt_size_t pool_size, rt_uint8_t flag);\n```\n\n- <span style=\"color:#3399FF;\">参数说明</span>：\n\n- `name `：消息队列的名称。\n\n- `msg_size ` ：消息队列中一条消息的最大长度，<span style=\"color:#00FFFF;\">单位字节</span>。\n\n- `msg_msgs`：消息队列的最大个数(消息个数)。\n\n- `flag` ：消息队列采用的等待方式，它可以取如下数值：`一般除非应用程序非常在意先来后到，不然都采用PRIO确保线程实时性`\n\n  - `RT_IPC_FLAG_FIFO`：非实时调度方式 先来后到\n\n  - `RT_IPC_FLAG_PRIO`：实时调度方式 优先级\n\n- `mq` ：消息队列对象的句柄。\n\n- `msgpool`：指向存放消息的缓冲区的指针。\n\n- `pool_size` ：存放消息的缓冲区大小\n\n##### **删除或脱离消息队列**\n\n```C\n/*删除动态消息队列create*/\nrt_err_t rt_mq_delete(rt_mq_t mq);\n/*删除静态消息队列init*/\nrt_err_t rt_mq_detach(rt_mq_t mq);\n//返回值：RT_EOK 成功\n```\n\n- <span style=\"color:#3399FF;\">参数说明</span>：\n- `mq`：消息队列对象的句柄\n\n> 删除消息队列时，如果<span style=\"color:#00FFFF;\">有线程</span>被挂起在该消息队列等待队列上，则内核<span style=\"color:#00FFFF;\">先唤醒挂起</span>在该消息等待队列上的所有线程（线程返回值是 `- RT_ERROR`），然后再<span style=\"color:#00FFFF;\">释放</span>消息队列使用的内存，最后<span style=\"color:#00FFFF;\">删除</span>消息队列对象\n\n##### **发送消息**\n\n```C\n/*1.直接发送消息*/\nrt_err_t rt_mq_send (rt_mq_t mq, void* buffer, rt_size_t size);\n/**************返回值*****************/\nRT_EOK        发送成功\n-RT_EFULL      消息队列已经满了\n-RT_ERROR       失败(发送消息长度>队列的最大长度)\n\n/*2.等待方式发送消息*/\n/*@note 若消息队列已满，则根据设定的timeout等待\n/*@note 若超时时间到达依然没有空出时间，此时发送线程被唤醒并返回错误码\n*/\nrt_err_t rt_mq_send_wait(rt_mq_t mq,const void *buffer,rt_size_t size,rt_int32_t  timeout);\n/**************返回值*****************/\nRT_EOK        发送成功\n-RT_ETIMEOUT     超时\n-RT_ERROR    失败(发送消息长度>队列的最大长度)\n\n/*3.发送紧急消息*/\n/*@note 发送紧急消息时，邮件被直接插队放入了消息队列队首,这样就能最优先接收到并做出处理\n*/\nrt_err_t rt_mq_urgent(rt_mq_t mq, void* buffer, rt_size_t size);\n/**************返回值*****************/\nRT_EOK       发送成功\n-RT_EFULL    消息队列已经满了\n-RT_ERROR    失败(发送消息长度>队列的最大长度)\n```\n\n- <span style=\"color:#3399FF;\">参数说明</span>：\n- `mq`：消息队列对象的句柄\n- `buffer` ：发送的消息内容。\n- `size` ：消息大小。\n- `timeout` ：超时时间。\n\n##### **接收消息**\n\n```C\n/*@note 只有当消息队列中有消息时，接收者才能立即取到邮件并返回 RT_EOK 的返回值\n否则接收线程会根据超时时间设置，或挂起在邮箱的等待线程队列上，或直接返回。\n*/\nrt_ssize_t rt_mq_recv (rt_mq_t mq, void* buffer,rt_size_t size,rt_int32_t timeout);\n/**************返回值*****************/\nRT_EOK             成功收到\n-RT_ETIMEOUT             超时\n-RT_ERROR            失败，返回错误\n```\n\n- <span style=\"color:#3399FF;\">参数说明</span>：\n- `mq`：消息队列对象的句柄\n- `buffer` ：发送的消息内容。\n- `size` ：消息大小。\n- `timeout` ：超时时间\n\n#### **应用示例**\n\n```C\n#include <rtthread.h>\n\n/*创建消息队列*/\nrt_mq_t mq;\n\n/*线程1：发送消息*/\nvoid thread_entry1(void *parameter)\n{\n    char msg[] = \"Hello, RT-Thread!\";//发送'A'作为邮件\n    rt_kprintf(\"线程1：发送消息...\\n\");\n    //发送消息到消息队列\n    rt_mq_send(mq, msg,sizeof(msg));\n}\n/*线程2：接收邮件*/\nvoid thread_entry2(void *parameter)\n{\n   char buffer[32];\n   rt_kprintf(\"线程2：等待接收消息...\\n\");\n   //若消息队列内无消息  则执行的是阻塞式的等待接收消息\n   rt_mq_recv(mq, buffer,sizeof(buffer), RT_WAITING_FOREVER);//接收消息\n   rt_kprintf(\"线程2：收到消息：%s\\n\",buffer);\n}\n\nint main(void)\n{\n    /*创建一个消息队列，容量为4，消息大小为32字节 */\n    mq = rt_mq_create(\"mq\", 32, 4, RT_IPC_FLAG_PRIO);\n    /*创建两个线程 */\n    rt_thread_t tid1 = rt_thread_create(\"t1\", thread_entry1, RT_NULL, 1024, 10,\n    10);\n    rt_thread_t tid2 = rt_thread_create(\"t2\", thread_entry2, RT_NULL, 1024, 10,\n    10);\n    /* 启动线程 */\n    rt_thread_startup(tid1);\n    rt_thread_startup(tid2);\n    return 0;\n}\n\n```\n\n### **信号**\n\n`信号（又称为软中断信号）`，在软件层次上是对中断机制的一种模拟。常用于通知线程发生了某个事件。线程收到信号时会根据信号类型执行相应的操作\n\n- 与消息队列区别：\n\n1. <span style=\"color:#00FFFF;\">信号仅携带控制信息，不包含数据</span>\n\n2. 信号不保证顺序性，<span style=\"color:#00FFFF;\">信号发生时立即通知线程</span>\n\n3. 消息队列则有顺序性（通常是PRIO）\n\n#### **工作机制**\n\n##### **线程中安装信号**\n\n```C\n/*\nt_sighandler_t[] 表示一个函数指针数组\nt_sighandler_t handler[] 是一个 变量声明\n二者是不一样的！\n*/\nrt_sighandler_t rt_signal_install(int signo, rt_sighandler_t[] handler);\n/**************返回值*****************/\nSIG_ERR                错误的信号\n安装信号前的handler值    成功\n```\n\n- <span style=\"color:#3399FF;\">参数说明</span>：\n- `signo `：信号值（只有 `SIGUSR1` 和 `SIGUSR2` 是开放给用户使用的）。\n- `buffer` ：发送的消息内容。\n- `handler` ：设置对信号值的处理方式。\n\n>  在信号安装时设定 handler 参数，决定了该信号的不同的处理方法。处理方法可以分为三种：\n>\n> 1. 类似`中断`的处理方式，参数指向当信号发生时用户`自定义的处理函数`， 在内部写入处理方式，由该函数来处理。\n>\n> 2. 参数设为 `SIG_IGN`，忽略某个信号，`对该信号不做任何处理`，就像未发生过一样。\n>\n> 3. 参数设为 `SIG_DFL`，系统会调用默认的处理函数`_signal_default_handler()`。\n\n##### **阻塞信号与解除阻塞**\n\n```C\n/*信号阻塞(屏蔽信号) 该信号不会递答安装此信号的线程*/\nvoid rt_signal_mask(int signo);\n/*解除信号阻塞\n使用此函数可以对其中一些信号给予 “关注”，那么发送这些信号都会引发该线程的软中断\n*/\nvoid rt_signal_unmask(int signo);\n```\n\n- <span style=\"color:#3399FF;\">参数说明</span>：\n- `signo`：信号值\n\n##### **发送信号**\n\n```C\n/*需要异常处理时，可以给安装了信号的线程发送信号*/\nint rt_thread_kill(rt_thread_t tid, int sig);\n/**************返回值*****************/\nRT_EOK        发送成功\n-RT_EINVAL    参数错误\n```\n\n- <span style=\"color:#3399FF;\">参数说明</span>：\n- `tid`：接收信号的线程。\n- `sig `：信号值。\n\n#### **应用示例**\n\n```C\n#include <rtthread.h>\n\n#define THREAD_PRIORITY         25\n#define THREAD_STACK_SIZE       512\n#define THREAD_TIMESLICE        5\n\nstatic rt_thread_t tid1 = RT_NULL;\n\n/* 线程 1 的信号处理函数 */\nvoid thread1_signal_handler(int sig)\n{\n    rt_kprintf(\"thread1 received signal %d\\n\", sig);\n}\n\n/* 线程 1 的入口函数 */\nstatic void thread1_entry(void *parameter)\n{\n    int cnt = 0;\n\n    /* 安装信号 */\n    rt_signal_install(SIGUSR1, thread1_signal_handler);\n    rt_signal_unmask(SIGUSR1);\n\n    /* 运行 10 次 */\n    while (cnt < 10)\n    {\n        /* 线程 1 采用低优先级运行，一直打印计数值 */\n        rt_kprintf(\"thread1 count : %d\\n\", cnt);\n\n        cnt++;\n        rt_thread_mdelay(100);\n    }\n}\n\n/* 信号示例的初始化 */\nint signal_sample(void)\n{\n    /* 创建线程 1 */\n    tid1 = rt_thread_create(\"thread1\",thread1_entry, RT_NULL,THREAD_STACK_SIZE, THREAD_PRIORITY, THREAD_TIMESLICE);\n\n    if (tid1 != RT_NULL)\n        rt_thread_startup(tid1);\n\n    rt_thread_mdelay(300);\n\n    /* 发送信号 SIGUSR1 给线程 1 */\n    rt_thread_kill(tid1, SIGUSR1);\n\n    return 0;\n}\n\n```\n\n## **框架移植**\n\n```C\n//bsp_system.h中引入以下四个头文件\n#include <rtthread.h>\n#include <rtdevice.h>\n#include <drv_common.h>\n#include <board.h>\n```\n\n### **系统初始化宏定义**\n\n​    ![image-20250522214349807](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505222143758.png)\n\n```C\n/*1、板级初始化 fn为函数指针*/\nINIT_BOARD_EXPORT(fn)\n/*2、纯软件函数初始化 fn为函数指针*/\nINIT_PREV_EXPORT(fn)\n/*3、设备自动初始化，fn为函数指针*/\nINIT_DEVICE_EXPORT(fn)\n/*4、组件自动初始化，fn为函数指针*/\nINIT_COMPONENT_EXPORT(fn)\n/*5、系统环境自动初始化，fn为函数指针*/\nINIT_ENV_EXPORT(fn) \n/*6、应用自动初始化，fn为函数指针*/\nINIT_APP_EXPORT(fn)\n```\n\n### **ESP8266移植**\n\n> 将`uart_app.c`与`uart_app.h`移去 不使用！！！然后RTT打开控制台输出rt_kprintf，选择串口1\n\n   ![image-20250522214536841](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505222145092.png)\n\n![image-20250522220417747](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505222204947.png) ![image-20250522220447380](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505222204548.png)\n\n![image-20250522214750185](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505222147073.png)\n\n![image-20250522214705123](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505222147664.png)\n\n![image-20250522214840651](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505222148942.png)\n\n![image-20250522214859546](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505222149729.png)\n\n![image-20250522214917115](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505222149203.png)\n\n![image-20250522214947877](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505222149796.png)\n\n直接编译开启终端 下载观察现象，出现以下信息则连接成功\n\n​    ![image-20250522215015453](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505222150747.png)\n\n### **DHT11移植**\n\n#### **组件添加**\n\n​    ![image-20250522215146162](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505222151707.png)\n\n![image-20250522215207600](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505222152193.png)\n\n![image-20250522220342327](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505222203028.png)\n\n\n\n#### **proc代码构建**\n\n##### **创建sensor_app.c与.h**\n\n```C\n//引入必要库\n#include <sensor_app.h>\n#include <sensor.h>\n#include \"sensor_dallas_dht11.h\"\n```\n\n##### **注册设备**\n\n    ```C\n        rt_device_t dev = RT_NULL;\n        //创建传感器结构体对象\n        struct rt_sensor_data sensor_data;\n        rt_uint8_t get_data_freq = 1;///默认1hz\n        rt_size_t res;//返回值 如RT_EOK\n    \n        /*注册传感器*/\n        dev =  rt_device_find(\"temp_dht11\");//注意此处注册需要有前缀 如temp_(在sensor.c中)\n        if(dev == RT_NULL)\n        {\n            rt_kprintf(\"Not Found\\r\\n\");\n            return;\n        }\n        if(rt_device_open(dev, RT_DEVICE_FLAG_RDWR) != RT_EOK)\n        {\n            rt_kprintf(\"Open Error\\r\\n\");\n            return;\n        }\n    \n        rt_device_control(dev, RT_SENSOR_CTRL_SET_ODR, (void *)&get_data_freq);\n    ```\n\n##### **读取传感器数据**\n\n```C\n /*读取传感器*/\n    while(1)\n    {\n        res = rt_device_read(dev, 0, &sensor_data, 1);//第0位开始读一个\n        //读错了返回0\n        if(res == 0)\n        {\n            rt_kprintf(\"Read Error Res:%d\",res);//返回读取错误编号0\n            return;\n        }\n        else //读取成功\n        {\n            if(sensor_data.data.temp >= 0) //数据大于等于0 包括了温度与湿度\n            {\n                uint8_t temp = (sensor_data.data.temp & 0xffff);\n                uint8_t humi = (sensor_data.data.temp & 0xffff0000) >> 16;\n                rt_kprintf(\"temp:%d humi:%d\\r\\n\",temp,humi);\n            }\n        }\n        rt_thread_delay(1000);\n    }\n```\n\n##### **init代码构建**\n\n```C\nint sensor_init(void)\n{\n    struct rt_sensor_config cfg;//操作集结构体\n    /*注册设备 配置接口*/\n    cfg.intf.user_data = (void *)DHT11_PIN;//配置接口为IO口\n    rt_hw_dht11_init(\"dht11\", &cfg);\n\n    rt_thread_t sensor_thread = rt_thread_create(\"sensor_proc\", sensor_proc, RT_NULL, 1024, 10, 20);\n    if(sensor_thread != RT_NULL)\n    {\n        rt_thread_startup(sensor_thread);\n    }\n    return RT_EOK;\n}\nINIT_COMPONENT_EXPORT(sensor_init);\n```\n\n","slug":"RT-Thread","published":1,"updated":"2025-09-17T04:12:16.000Z","comments":1,"photos":[],"_id":"cmk8pg6xm000w6sk93pux042e","content":"<h2 id=\"时钟管理\"><a href=\"#时钟管理\" class=\"headerlink\" title=\"时钟管理\"></a>时钟管理</h2><h3 id=\"时钟节拍产生与获取\"><a href=\"#时钟节拍产生与获取\" class=\"headerlink\" title=\"时钟节拍产生与获取\"></a>时钟节拍产生与获取</h3><p>时钟节拍依赖于硬件中的定时器。你可以把定时器看作是⼀个不停计时的装置，它每隔⼀段时间就会提醒系统“滴答”⼀次。<span style=\"text-decoration:underline;\">每当定时器中断发⽣时，RT-Thread 会调⽤ rt_tick_increase()函数，系统时间增加 1 个节拍</span>。<code>就像家中的闹钟响⼀次，时间就过去了⼀分钟⼀样。</code></p>\n<blockquote>\n<p>其中rt_tick_increase()函数中有rt_tick类似于HAL库中的uwTick，可以直接调用 获取系统时间</p>\n</blockquote>\n<h2 id=\"定时器管理\"><a href=\"#定时器管理\" class=\"headerlink\" title=\"定时器管理\"></a>定时器管理</h2><h3 id=\"硬件定时器-vs-软件定时器\"><a href=\"#硬件定时器-vs-软件定时器\" class=\"headerlink\" title=\"硬件定时器 vs 软件定时器\"></a>硬件定时器 vs 软件定时器</h3><ol>\n<li><span style=\"color:#FF3399;\">硬件定时器</span>：就像厨房⾥的倒计时器，它是由硬件直接提供的。硬件定时器精度⾮常⾼，可以达到纳秒级，适合⼀些对时间要求⾮常严格的任务，⽐如控制电机的旋转时间。</li>\n<li><span style=\"color:#FF3399;\">软件定时器</span>：可以理解为⼿机上的计时 App。它依赖于操作系统的时钟节拍来⼯作，它的时间间隔精度由 OS Tick 决定。例如，如果 OS Tick 是 10ms，那么软件定时器只能精确到 10ms。虽然精度不如硬件定时器⾼，但它更灵活、容易使⽤。</li>\n</ol>\n<h3 id=\"RTT定时器分类\"><a href=\"#RTT定时器分类\" class=\"headerlink\" title=\"RTT定时器分类\"></a>RTT定时器分类</h3><ul>\n<li><span style=\"color:#FF3399;\">单次触发定时器</span>：就像倒计时⼀次的闹钟，响⼀次后就停⽌。例如，设定⼀个 5 秒的倒计时，时间到了闹钟响⼀次就结束了。</li>\n<li><span style=\"color:#FF3399;\">周期触发定时器</span>：就像那些每天早上 7 点重复响起的闹钟。每隔⼀段时间，它会周期性地触发事件，直到你⼿动关闭它。</li>\n</ul>\n<p>根据定时器回调函数执⾏的上下⽂环境，定时器还可以分为两种模式：</p>\n<ul>\n<li><span style=\"color:#FF3399;\">硬件模式 </span>(HARD_TIMER)：定时器的回调函数在<span style=\"text-decoration:underline;\">中断上下⽂</span>中执⾏<code>就像闹钟响起时你⽴刻跳起来⼀样</code>它反应⾮常快，但要求处理时间短。</li>\n<li><span style=\"color:#FF3399;\">软件模式</span> (SOFT_TIMER)：回调函数在<span style=\"text-decoration:underline;\">系统的 timer 线程中</span>执⾏，相当于<code>有⼈提醒你“闹钟响了”</code>，然后你再去执⾏⼀些动作。这个模式可以做更复杂的操作，因为它不是在中断中执⾏。</li>\n</ul>\n<h3 id=\"控制定时器\"><a href=\"#控制定时器\" class=\"headerlink\" title=\"控制定时器\"></a>控制定时器</h3><p><code>通过该函数你可以随时改变定时器触发方式以及定时器时间</code></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505212214569.png\" alt=\"image-20250521221429133\"></p>\n<h3 id=\"高精度延时\"><a href=\"#高精度延时\" class=\"headerlink\" title=\"高精度延时\"></a>高精度延时</h3><p><code>使用该函数可以实现微妙级的精确延时，适合高精度时间控制场合</code></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505212215044.png\" alt=\"image-20250521221525259\"></p>\n<h2 id=\"线程创建\"><a href=\"#线程创建\" class=\"headerlink\" title=\"线程创建\"></a>线程创建</h2><p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505212034310.png\" alt=\"image-20250521203425658\"></p>\n<ul>\n<li><code>name</code>：线程名字</li>\n<li><code>entry</code>：线程入口函数</li>\n<li><code>parameter</code>：传递给线程的参数</li>\n<li><code>stack_size</code>：线程栈大小</li>\n<li><code>priority</code>：线程优先级</li>\n<li><code>tick</code>：时间片</li>\n</ul>\n<h3 id=\"详细步骤\"><a href=\"#详细步骤\" class=\"headerlink\" title=\"详细步骤\"></a>详细步骤</h3><ol>\n<li>声明一个pcb结构体 <code>static rt_thread_t tid1 = RT_NULL;</code></li>\n<li>编写线程入口函数 <code>static void thread1_entry(void *parameter)</code>，参数为必需，其为传递给线程的参数</li>\n<li>利用<code>rt_thread_create</code>函数赋值给所声明的pcb结构体tid1</li>\n<li>利用<code>rt_thread_startup(tid1)</code>函数启动线程</li>\n</ol>\n<h3 id=\"实现示例\"><a href=\"#实现示例\" class=\"headerlink\" title=\"实现示例\"></a>实现示例</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title function_\">thread1_proc</span><span class=\"params\">(<span class=\"type\">void</span> *parameter)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">/*实际功能*/</span></span><br><span class=\"line\">        rt_thread_mdelay(<span class=\"number\">1000</span>);<span class=\"comment\">//休息1秒</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">thread1_init</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">rt_thread_t</span> tid1 =  rt_thread_create(<span class=\"string\">&quot;thread1_proc&quot;</span>,thread1_proc,RT_NULL,<span class=\"number\">1024</span>,<span class=\"number\">10</span>,<span class=\"number\">20</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(tid1 != RT_NULL)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        rt_thread_startup(tid1);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> RT_EOK;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">INIT_COMPONENT_EXPORT(thread1_init);   <span class=\"comment\">//用这个宏就不需要另外再去注册</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><span style=\"font-style:italic;\">rt_thread_mdelay(1000)的工作机制：</span></p>\n<p><span style=\"font-style:italic;\">1、当 rt_thread_mdelay 被调⽤时，当前线程会进⼊ RT_THREAD_SUSPEND 状态（<span style=\"color:#CC00CC;\">挂起</span>状态）。</span></p>\n<p><span style=\"font-style:italic;\">2、调度器开始运⾏其他优先级相同或更⾼的线程。</span></p>\n<p><span style=\"font-style:italic;\">3、 <span style=\"text-decoration:underline;\">延时时间结束后，线程从 挂起状态 转变为 就绪状态</span> ，等待系统再次调度该线程。</span></p>\n<p><span style=\"font-style:italic;\">PS：若此时无其他线程，则CPU就处于释放状态</span></p>\n</blockquote>\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505212056766.png\" alt=\"image-20250521205640868\"></p>\n<h2 id=\"线程间同步\"><a href=\"#线程间同步\" class=\"headerlink\" title=\"线程间同步\"></a>线程间同步</h2><h3 id=\"信号量\"><a href=\"#信号量\" class=\"headerlink\" title=\"信号量\"></a>信号量</h3><p>信号量可以理解为电影院的座位数（<span style=\"color:#FF0000;\">资源数量</span>）。当所有座位都满了，新的观众（线程）就需要等前⾯的观众离开（释放资源）才能进⼊。当有空位时，观众可以进⼊。<code>信号量通过控制资源的数量来管理多个线程对资源的访问</code></p>\n<h4 id=\"工作机制\"><a href=\"#工作机制\" class=\"headerlink\" title=\"工作机制\"></a>工作机制</h4><ul>\n<li><p><code>获取信号量</code>：当资源可⽤时，线程可以获取信号量，<span style=\"color:#FF0000;\">信号量的值减1</span>。<span style=\"background:#66FFFF;\">如果信号量的值为0，线程就会等待，直到资源释放</span></p>\n</li>\n<li><p><code>释放信号量</code>：使⽤完资源后，线程释放信号量，<span style=\"color:#FF0000;\">信号量的值加1</span>，允许其他线程访问资源</p>\n</li>\n</ul>\n<h5 id=\"创建信号量\"><a href=\"#创建信号量\" class=\"headerlink\" title=\"创建信号量\"></a>创建信号量</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*动态分配内存并创建信号量*/</span></span><br><span class=\"line\"><span class=\"type\">rt_sem_t</span> <span class=\"title function_\">rt_sem_create</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">char</span> *name, <span class=\"type\">rt_uint32_t</span> value, <span class=\"type\">rt_uint8_t</span> flag)</span>;</span><br><span class=\"line\"><span class=\"comment\">/*静态分配内存并创建信号量*/</span></span><br><span class=\"line\"><span class=\"type\">rt_err_t</span> <span class=\"title function_\">rt_sem_init</span><span class=\"params\">(<span class=\"type\">rt_sem_t</span> sem, <span class=\"type\">const</span> <span class=\"type\">char</span> *name, <span class=\"type\">rt_uint32_t</span> value,<span class=\"type\">rt_uint8_t</span> flag)</span>;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p><span style=\"color:#3399FF;\">参数说明</span>：</p>\n</li>\n<li><p><code>name</code>：信号量的名字（可以为 <code>RT_NULL</code> 表⽰匿名信号量）。</p>\n</li>\n<li><p><code>value</code>：信号量的初始值，表⽰信号量当前持有的资源数量（<code>例如初始值为 0 表⽰等待事件，为 1 表⽰互斥量，或者更⼤值表⽰资源计数</code>）。</p>\n</li>\n<li><p><code>flag</code>：PC 对象的属性标志，常⽤值：</p>\n</li>\n<li><p><code>RT_IPC_FLAG_PRIO</code> ：<span style=\"color:#FF0000;\">优先级</span>等待⽅式，等待线程按照优先级顺序排列。</p>\n</li>\n<li><p><code>RT_IPC_FLAG_FIFO</code> ：<span style=\"color:#FF0000;\">先⼊先出</span>等待⽅式，等待线程按照进⼊顺序排列。</p>\n</li>\n</ul>\n<h5 id=\"获取信号量\"><a href=\"#获取信号量\" class=\"headerlink\" title=\"获取信号量\"></a>获取信号量</h5><p>⽤于获取信号量（P 操作），线程会尝试获取信号量，<code>如果信号量的计数值为 0，线程会进⼊等待状态</code>，直到信号量被释放或超时。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">rt_err_t</span> <span class=\"title function_\">rt_sem_take</span><span class=\"params\">(<span class=\"type\">rt_sem_t</span> sem, <span class=\"type\">rt_int32_t</span> time)</span>;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p><span style=\"color:#3399FF;\">参数说明</span>：</p>\n</li>\n<li><p><code>sem</code>：信号量的句柄。</p>\n</li>\n<li><p><code>time</code>：超时时间（单位为系统 tick），表⽰最⼤等待时间。如果设置为 <code>RT_WAITING_FOREVER</code> ，线程会⼀直等待</p>\n</li>\n</ul>\n<h5 id=\"释放信号量\"><a href=\"#释放信号量\" class=\"headerlink\" title=\"释放信号量\"></a>释放信号量</h5><p>⽤于释放信号量（V 操作），<strong>增加</strong>信号量的计数值，<code>并唤醒等待该信号量的线程</code>。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">rt_err_t</span> <span class=\"title function_\">rt_sem_release</span><span class=\"params\">(<span class=\"type\">rt_sem_t</span> sem)</span>;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"应用示例\"><a href=\"#应用示例\" class=\"headerlink\" title=\"应用示例\"></a>应用示例</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;rtthread.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">rt_sem_t</span> sem = RT_NULL;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">thread1</span><span class=\"params\">(<span class=\"type\">void</span> *parameter)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   rt_kprintf(<span class=\"string\">&quot;线程1：等待线程2发送信号\\n&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">/*等待信号量，超时时间为永久等待*/</span></span><br><span class=\"line\">   rt_sem_take(sem,RT_WAITING_FOREVER);</span><br><span class=\"line\"></span><br><span class=\"line\">   rt_kprintf(<span class=\"string\">&quot;线程1：收到线程2的信号，继续执行....\\n&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">thread2</span><span class=\"params\">(<span class=\"type\">void</span> *parameter)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   rt_kprintf(<span class=\"string\">&quot;线程2：执行一些操作\\n&quot;</span>);</span><br><span class=\"line\">   <span class=\"comment\">/*模拟执行一些动作*/</span></span><br><span class=\"line\">   rt_thread_mdelay(<span class=\"number\">2000</span>);</span><br><span class=\"line\">   rt_kprintf(<span class=\"string\">&quot;线程2：操作完成，发送信号给线程1\\n&quot;</span>);</span><br><span class=\"line\">   <span class=\"comment\">/*释放信号量 通知线程1*/</span></span><br><span class=\"line\">   rt_sem_release(sem);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">rt_thread_t</span> tid1 = RT_NULL;</span><br><span class=\"line\">    <span class=\"type\">rt_thread_t</span> tid2 = RT_NULL;</span><br><span class=\"line\"></span><br><span class=\"line\">    sem = rt_sem_create(<span class=\"string\">&quot;sem&quot;</span>, <span class=\"number\">0</span>, RT_IPC_FLAG_PRIO);</span><br><span class=\"line\">    tid1 = rt_thread_create(<span class=\"string\">&quot;tid1&quot;</span>, thread1, RT_NULL, <span class=\"number\">1024</span>, <span class=\"number\">25</span>, <span class=\"number\">100</span>);</span><br><span class=\"line\">    tid2 = rt_thread_create(<span class=\"string\">&quot;tid2&quot;</span>, thread2, RT_NULL, <span class=\"number\">1024</span>, <span class=\"number\">25</span>, <span class=\"number\">100</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(tid1 != RT_NULL) rt_thread_startup(tid1);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(tid2 != RT_NULL) rt_thread_startup(tid2);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h4><ol>\n<li>任务同步（多任务协调执行顺序）</li>\n<li>任务互斥(使用<code>互斥量</code> 保证同一时间只有一个线程 访问公共资源)</li>\n<li>事件触发</li>\n<li>限量资源管理</li>\n</ol>\n<h3 id=\"互斥量（Mutex）\"><a href=\"#互斥量（Mutex）\" class=\"headerlink\" title=\"互斥量（Mutex）\"></a><strong>互斥量（Mutex）</strong></h3><h4 id=\"工作机制-1\"><a href=\"#工作机制-1\" class=\"headerlink\" title=\"工作机制\"></a><strong>工作机制</strong></h4><p>互斥量确保同⼀时刻<strong>只有⼀个线程能够访问共享资源</strong>：</p>\n<ul>\n<li><code>获取互斥量</code>：当⼀个线程获取到互斥量时，其他线程不能访问该资源，直到互斥量被释放。</li>\n<li><code>释放互斥量</code>：当线程释放互斥量后，其他等待的线程才能访问资源</li>\n</ul>\n<h5 id=\"创建互斥量\"><a href=\"#创建互斥量\" class=\"headerlink\" title=\"创建互斥量\"></a><strong>创建互斥量</strong></h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*动态创建一个互斥量*/</span></span><br><span class=\"line\"><span class=\"type\">rt_mutex_t</span> <span class=\"title function_\">rt_mutex_create</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">char</span> *name, <span class=\"type\">rt_uint8_t</span> flag)</span>;</span><br><span class=\"line\"><span class=\"comment\">/*静态创建一个互斥量*/</span></span><br><span class=\"line\"><span class=\"type\">rt_err_t</span> <span class=\"title function_\">rt_mutex_init</span><span class=\"params\">(<span class=\"type\">rt_mutex_t</span> mutex, <span class=\"type\">const</span> <span class=\"type\">char</span> *name, <span class=\"type\">rt_uint8_t</span> flag)</span>;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><span style=\"color:#3399FF;\">参数说明</span>：</li>\n<li><code>name</code>：互斥量的名字（可以为 <code>RT_NULL</code> 表⽰匿名互斥量）。</li>\n<li><code>flag</code>：IPC 对象的属性标志，通常使⽤ <code>RT_IPC_FLAG_PRIO</code> 表⽰优先级等待。</li>\n</ul>\n<h5 id=\"获取互斥量\"><a href=\"#获取互斥量\" class=\"headerlink\" title=\"获取互斥量\"></a><strong>获取互斥量</strong></h5><p>⽤于获取互斥量，线程通过调⽤此函数进⼊临界区。<code>如果互斥量已经被其他线程获取，当前线程会进⼊等待状态，直到获取成功或超时。</code></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">rt_err_t</span> <span class=\"title function_\">rt_mutex_take</span><span class=\"params\">(<span class=\"type\">rt_mutex_t</span> mutex, <span class=\"type\">rt_int32_t</span> time)</span>;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><span style=\"color:#3399FF;\">参数说明</span>：</li>\n<li><code>mutex</code>：互斥量的句柄。</li>\n<li><code>time</code>：超时时间（单位为系统 tick），可以指定等待时⻓或 <code>RT_WAITING_FOREVER</code>表⽰永远等待。</li>\n</ul>\n<h5 id=\"释放互斥量\"><a href=\"#释放互斥量\" class=\"headerlink\" title=\"释放互斥量\"></a>释放互斥量</h5><p>⽤于释放互斥量（V 操作），<strong>增加</strong>互斥量的计数值，并唤醒等待该互斥量的线程。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">rt_err_t</span> <span class=\"title function_\">rt_mutex_release</span><span class=\"params\">(<span class=\"type\">rt_mutex_t</span> mutex)</span>;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"应用示例-1\"><a href=\"#应用示例-1\" class=\"headerlink\" title=\"应用示例\"></a><strong>应用示例</strong></h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;rtthread.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">rt_mutex_t</span> mutex = RT_NULL;</span><br><span class=\"line\"><span class=\"type\">rt_uint32_t</span> cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">thread1</span><span class=\"params\">(<span class=\"type\">void</span> *parameter)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   <span class=\"comment\">//rt_kprintf(&quot;线程1：等待线程2发送信号\\n&quot;);</span></span><br><span class=\"line\">   <span class=\"keyword\">while</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">       rt_mutex_take(mutex,RT_WAITING_FOREVER);</span><br><span class=\"line\">       cnt++;</span><br><span class=\"line\">       rt_thread_mdelay(<span class=\"number\">1000</span>);</span><br><span class=\"line\">       rt_kprintf(<span class=\"string\">&quot;线程1 cnt = %d \\n&quot;</span>,cnt);</span><br><span class=\"line\">       rt_mutex_release(mutex);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">thread2</span><span class=\"params\">(<span class=\"type\">void</span> *parameter)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   <span class=\"comment\">//rt_kprintf(&quot;线程2：执行一些操作\\n&quot;);</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        rt_mutex_take(mutex,RT_WAITING_FOREVER);</span><br><span class=\"line\">        cnt++;</span><br><span class=\"line\">        rt_thread_mdelay(<span class=\"number\">1000</span>);</span><br><span class=\"line\">        rt_kprintf(<span class=\"string\">&quot;线程2 cnt = %d \\n&quot;</span>,cnt);</span><br><span class=\"line\">        rt_mutex_release(mutex);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">rt_thread_t</span> tid1 = RT_NULL;</span><br><span class=\"line\">    <span class=\"type\">rt_thread_t</span> tid2 = RT_NULL;</span><br><span class=\"line\"></span><br><span class=\"line\">    mutex = rt_mutex_create(<span class=\"string\">&quot;mutex&quot;</span>, RT_IPC_FLAG_PRIO);</span><br><span class=\"line\">    tid1 = rt_thread_create(<span class=\"string\">&quot;tid1&quot;</span>, thread1, RT_NULL, <span class=\"number\">1024</span>, <span class=\"number\">25</span>, <span class=\"number\">100</span>);</span><br><span class=\"line\">    tid2 = rt_thread_create(<span class=\"string\">&quot;tid2&quot;</span>, thread2, RT_NULL, <span class=\"number\">1024</span>, <span class=\"number\">25</span>, <span class=\"number\">100</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(tid1 != RT_NULL) rt_thread_startup(tid1);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(tid2 != RT_NULL) rt_thread_startup(tid2);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"任务同步与任务互斥差异\"><a href=\"#任务同步与任务互斥差异\" class=\"headerlink\" title=\"任务同步与任务互斥差异\"></a><strong>任务同步与任务互斥差异</strong></h3><p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505222030206.png\" alt=\"image-20250522203011255\"></p>\n<h3 id=\"事件集\"><a href=\"#事件集\" class=\"headerlink\" title=\"事件集\"></a><strong>事件集</strong></h3><p>事件集可以看作公交⻋站的场景。线程可以等待多个事件发⽣，<code>⽐如等待公交⻋或等待同伴到达。如果满⾜某个或某⼏个条件，线程将被唤醒继续执⾏。</code></p>\n<h4 id=\"工作机制-2\"><a href=\"#工作机制-2\" class=\"headerlink\" title=\"工作机制\"></a><strong>工作机制</strong></h4><p>事件集⽤于线程间的同步，可以让线程等待⼀个或多个事件的触发：</p>\n<ul>\n<li><code>逻辑与（AND)</code>：线程等待多个事件同时发⽣才被唤醒。</li>\n<li><code>逻辑或（OR）</code>：线程只需等待其中⼀个事件发⽣即可被唤醒。</li>\n</ul>\n<h5 id=\"创建事件对象\"><a href=\"#创建事件对象\" class=\"headerlink\" title=\"创建事件对象\"></a><strong>创建事件对象</strong></h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*动态创建一个对象*/</span></span><br><span class=\"line\"><span class=\"type\">rt_event_t</span> <span class=\"title function_\">rt_event_create</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">char</span> *name, <span class=\"type\">rt_uint8_t</span> flag)</span>;</span><br><span class=\"line\"><span class=\"comment\">/*静态创建一个对象*/</span></span><br><span class=\"line\"><span class=\"type\">rt_err_t</span> <span class=\"title function_\">rt_event_init</span><span class=\"params\">(<span class=\"type\">rt_event_t</span> event, <span class=\"type\">const</span> <span class=\"type\">char</span> *name, <span class=\"type\">rt_uint8_t</span> flag)</span>; </span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><span style=\"color:#3399FF;\">参数说明</span>：</li>\n<li><code>name</code>：事件对象的名字（可以为 <code>RT_NULL</code> 表⽰匿名事件对象）。</li>\n<li><code>flag</code>：IPC 对象的属性标志，⼀般使⽤ <code>RT_IPC_FLAG_PRIO</code> 表⽰优先级等待，或<code>RT_IPC_FLAG_FIFO</code> 表⽰先进先出等待。</li>\n</ul>\n<h5 id=\"发送-触发-事件\"><a href=\"#发送-触发-事件\" class=\"headerlink\" title=\"发送(触发)事件\"></a><strong>发送(触发)事件</strong></h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">rt_err_t</span> <span class=\"title function_\">rt_event_send</span><span class=\"params\">(<span class=\"type\">rt_event_t</span> event, <span class=\"type\">rt_uint32_t</span> <span class=\"built_in\">set</span>)</span>;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><span style=\"color:#3399FF;\">参数说明</span>：</li>\n<li><code>event</code>：事件对象的句柄。</li>\n<li><code>set</code>：事件标志，设置哪⼏位事件标志被触发 <code>可以⽤ 1 &lt;&lt; n 来表⽰第 n 位的事件。</code></li>\n</ul>\n<h5 id=\"接收-等待-事件\"><a href=\"#接收-等待-事件\" class=\"headerlink\" title=\"接收(等待)事件\"></a><strong>接收(等待)事件</strong></h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">rt_err_t</span> <span class=\"title function_\">rt_event_recv</span><span class=\"params\">(<span class=\"type\">rt_event_t</span> event, <span class=\"type\">rt_uint32_t</span> <span class=\"built_in\">set</span>, <span class=\"type\">rt_uint8_t</span> option, <span class=\"type\">rt_int32_t</span> timeout, <span class=\"type\">rt_uint32_t</span> *recved)</span>;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><span style=\"color:#3399FF;\">参数说明</span>：</li>\n<li><code>event</code>：事件对象的句柄。</li>\n<li><code>set</code>：需要等待的事件标志 <code>例如 1 &lt;&lt; 3 | 1 &lt;&lt; 5 表⽰同时等待第3位和第5位的事件</code></li>\n<li><code>option</code> ：等待选项，常⻅选项包括：<ul>\n<li><code>RT_EVENT_FLAG_AND</code> ：<span style=\"color:#3399FF;\">所有</span>指定的事件标志都满⾜时才唤醒线程。</li>\n<li><code>RT_EVENT_FLAG_OR</code> ：<span style=\"color:#3399FF;\">只要有⼀个</span>指定的事件标志满⾜就唤醒线程。</li>\n<li><code>RT_EVENT_FLAG_CLEAR</code> ：<span style=\"color:#3399FF;\">收到</span>事件标志后<span style=\"color:#3399FF;\">清除</span>这些事件标志。</li>\n</ul>\n</li>\n<li><code>timeout</code> ：超时时间（单位为系统 tick），可以为 <code>RT_WAITING_FOREVER</code> 表⽰永远等待。</li>\n<li><code>recved</code> ：输出参数，返回实际接收到的事件标志</li>\n</ul>\n<h4 id=\"应用示例-2\"><a href=\"#应用示例-2\" class=\"headerlink\" title=\"应用示例\"></a><strong>应用示例</strong></h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;rtthread.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">rt_event_t</span> event = RT_NULL;</span><br><span class=\"line\"><span class=\"comment\">/*线程1：等待事件*/</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">thread1</span><span class=\"params\">(<span class=\"type\">void</span> *parameter)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   <span class=\"type\">rt_uint32_t</span> recei;</span><br><span class=\"line\">   rt_kprintf(<span class=\"string\">&quot;线程1：等待公交车3或5到来...\\n&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">   rt_event_recv(event, (<span class=\"number\">1</span> &lt;&lt; <span class=\"number\">3</span> | <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">5</span>), RT_EVENT_FLAG_OR | RT_EVENT_FLAG_CLEAR, RT_WAITING_FOREVER, &amp;recei);</span><br><span class=\"line\"></span><br><span class=\"line\">   rt_kprintf(<span class=\"string\">&quot;线程1：公交车 %d 到站，出发！....\\n&quot;</span>,recei);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*线程2：发送事件（公交车到站）*/</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">thread2</span><span class=\"params\">(<span class=\"type\">void</span> *parameter)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   rt_thread_mdelay(<span class=\"number\">1000</span>);<span class=\"comment\">//模拟公交车到站</span></span><br><span class=\"line\">   rt_kprintf(<span class=\"string\">&quot;线程2：公交车3到站\\n&quot;</span>);</span><br><span class=\"line\">   rt_event_send(event, (<span class=\"number\">1</span> &lt;&lt; <span class=\"number\">3</span>));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">rt_thread_t</span> tid1 = RT_NULL;</span><br><span class=\"line\">    <span class=\"type\">rt_thread_t</span> tid2 = RT_NULL;</span><br><span class=\"line\"></span><br><span class=\"line\">    event = rt_event_create(<span class=\"string\">&quot;event&quot;</span>, RT_IPC_FLAG_PRIO);</span><br><span class=\"line\">    tid1 = rt_thread_create(<span class=\"string\">&quot;tid1&quot;</span>, thread1, RT_NULL, <span class=\"number\">1024</span>, <span class=\"number\">25</span>, <span class=\"number\">100</span>);</span><br><span class=\"line\">    tid2 = rt_thread_create(<span class=\"string\">&quot;tid2&quot;</span>, thread2, RT_NULL, <span class=\"number\">1024</span>, <span class=\"number\">25</span>, <span class=\"number\">100</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(tid1 != RT_NULL) rt_thread_startup(tid1);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(tid2 != RT_NULL) rt_thread_startup(tid2);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"线程间通信\"><a href=\"#线程间通信\" class=\"headerlink\" title=\"线程间通信\"></a><strong>线程间通信</strong></h2><p>裸机编程中经常使用全局变量进行功能间的通信（标志）：某些功能由于特定的操作改变全局变量的值，另一个功能对此全局变量进行读取，根据读取到的全局变量执行相应的操作来达到通信协作的目的。RTT提供了邮箱、消息队列和信号等工具来完成这样的类似操作</p>\n<h3 id=\"邮箱\"><a href=\"#邮箱\" class=\"headerlink\" title=\"邮箱\"></a><strong>邮箱</strong></h3><h4 id=\"工作机制-3\"><a href=\"#工作机制-3\" class=\"headerlink\" title=\"工作机制\"></a>工作机制</h4><p>邮箱的特点：开销低、效率高、支持一对多</p>\n<p>邮箱中一封邮件<strong>只能容纳固定的4字节信息</strong>（针对32位操作系统，指针大小为4字节，一封邮件恰好能容纳一个指针），所以典型的邮箱也被称为交换消息</p>\n<blockquote>\n<p>一般如果邮箱中<span style=\"color:#3399FF;\">存在邮件</span>且收取邮件时的<span style=\"color:#3399FF;\">超时时间为0</span>，邮件的收取过程是<span style=\"font-weight:bold;\">非阻塞</span>的</p>\n<p>但邮箱中<span style=\"color:#3399FF;\">不存在邮件</span>且<span style=\"color:#3399FF;\">超时时间不为0</span>时，邮件收取过程就是<span style=\"font-weight:bold;\">阻塞</span>的，邮件收取阻塞的情况下只能由线程进行邮件的收取。</p>\n</blockquote>\n<ul>\n<li><p><code>邮件发送阻塞</code>：一个线程向邮箱发送邮件时：</p>\n<ul>\n<li>如果邮箱未满，则把邮件复制到邮箱中</li>\n<li>如果邮箱已满，则<span style=\"color:#3399FF;\">发送线程挂起</span>并等待邮箱有空间时将其唤醒再发送邮件 或 直接返回<code>-RT_EFULL</code></li>\n</ul>\n</li>\n<li><p><code>邮件接收阻塞</code>：一个线程从邮箱中接收邮件时：</p>\n<ul>\n<li>如果邮箱已空，接收线程可以挂起直到收到新的邮件被唤醒 <code>也可以设置超时时间并进行等待</code></li>\n<li>如果达到设置的超时时间<span style=\"color:#00FFFF;\">但邮箱仍未收到邮件</span>时，超时线程将被唤醒并返回<code>-RT_ETIMEOUT</code>；</li>\n<li>如果邮箱中存在邮件，则接收线程赋值邮箱中的邮件到接收缓存</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"创建邮箱\"><a href=\"#创建邮箱\" class=\"headerlink\" title=\"创建邮箱\"></a><strong>创建邮箱</strong></h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*创建动态邮箱*/</span></span><br><span class=\"line\"><span class=\"type\">rt_mailbox_t</span> <span class=\"title function_\">rt_mb_create</span> <span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">char</span>* name, <span class=\"type\">rt_size_t</span> size, <span class=\"type\">rt_uint8_t</span> flag)</span>;</span><br><span class=\"line\"><span class=\"comment\">/*创建静态邮箱*/</span></span><br><span class=\"line\"><span class=\"type\">rt_err_t</span> <span class=\"title function_\">rt_mb_init</span><span class=\"params\">(<span class=\"type\">rt_mailbox_t</span> mb,<span class=\"type\">const</span> <span class=\"type\">char</span>* name,<span class=\"type\">void</span>* msgpool,<span class=\"type\">rt_size_t</span> size,<span class=\"type\">rt_uint8_t</span> flag)</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><span style=\"color:#3399FF;\">参数说明</span>：</li>\n<li><code>mb</code>：邮箱对象的句柄。</li>\n<li><code>name</code>：邮箱容量(几封邮件)</li>\n<li><code>size</code> ：邮箱容量(几封邮件)。</li>\n<li><code>flag</code> ：邮箱标志，它可以取如下数值：<code>一般除非应用程序非常在意先来后到，不然都采用PRIO确保线程实时性</code><ul>\n<li><code>RT_IPC_FLAG_FIFO</code> ：非实时调度方式 先来后到</li>\n<li><code>RT_IPC_FLAG_PRIO</code> ：实时调度方式 优先级</li>\n</ul>\n</li>\n<li><code>msgpool</code> ：缓冲区指针。</li>\n<li><code>recved</code> ：输出参数，返回实际接收到的事件标志</li>\n</ul>\n<h5 id=\"删除或脱离邮箱\"><a href=\"#删除或脱离邮箱\" class=\"headerlink\" title=\"删除或脱离邮箱\"></a><strong>删除或脱离邮箱</strong></h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*删除动态邮箱create*/</span></span><br><span class=\"line\"><span class=\"type\">rt_err_t</span> <span class=\"title function_\">rt_mb_delete</span> <span class=\"params\">(<span class=\"type\">rt_mailbox_t</span> mb)</span>;</span><br><span class=\"line\"><span class=\"comment\">/*删除静态邮箱init*/</span></span><br><span class=\"line\"><span class=\"type\">rt_err_t</span> <span class=\"title function_\">rt_mb_detach</span><span class=\"params\">(<span class=\"type\">rt_mailbox_t</span> mb)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//返回值：RT_EOK 成功</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><span style=\"color:#3399FF;\">参数说明</span>：</li>\n<li><code>mb</code>：邮箱对象的句柄。</li>\n</ul>\n<blockquote>\n<p>调用删除函数时，内核会<span style=\"color:#00FFFF;\">先唤醒所有</span>挂在该邮箱上的线程（线程返回值是<code>RT_ERROR</code>），然后<span style=\"color:#00FFFF;\">再释放</span>邮箱使用的<span style=\"color:#00FFFF;\">内存</span>，最后<span style=\"color:#00FFFF;\">删除邮箱对象</span></p>\n</blockquote>\n<h5 id=\"发送邮件\"><a href=\"#发送邮件\" class=\"headerlink\" title=\"发送邮件\"></a><strong>发送邮件</strong></h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*1.直接发送邮件*/</span></span><br><span class=\"line\"><span class=\"comment\">/*！！！！！记得value需要强转rt_uint32_t！！！！！*/</span></span><br><span class=\"line\"><span class=\"type\">rt_err_t</span> <span class=\"title function_\">rt_mb_send</span> <span class=\"params\">(<span class=\"type\">rt_mailbox_t</span> mb, <span class=\"type\">rt_uint32_t</span> value)</span>;</span><br><span class=\"line\"><span class=\"comment\">/**************返回值*****************/</span></span><br><span class=\"line\">RT_EOK        发送成功</span><br><span class=\"line\">-RT_EFULL      邮箱已经满了</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*2.等待方式发送邮件*/</span></span><br><span class=\"line\"><span class=\"comment\">/*@note 若邮箱已满，则根据设定的timeout等待邮箱中因为收取邮件而空出空间</span></span><br><span class=\"line\"><span class=\"comment\">/*@note 若超时时间到达依然没有空出时间，此时发送线程被唤醒并返回错误码</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"type\">rt_err_t</span> <span class=\"title function_\">rt_mb_send_wait</span> <span class=\"params\">(<span class=\"type\">rt_mailbox_t</span> mb,<span class=\"type\">rt_uint32_t</span> value,<span class=\"type\">rt_int32_t</span> timeout)</span>;</span><br><span class=\"line\"><span class=\"comment\">/**************返回值*****************/</span></span><br><span class=\"line\">RT_EOK        发送成功</span><br><span class=\"line\">-RT_ETIMEOUT     超时</span><br><span class=\"line\">-RT_ERROR    失败，返回错误</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*3.发送紧急邮件*/</span></span><br><span class=\"line\"><span class=\"comment\">/*@note 发送紧急邮件时，邮件被直接插队放入了邮件队首,这样就能最优先接收到并做出处理</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"type\">rt_err_t</span> <span class=\"title function_\">rt_mb_urgent</span> <span class=\"params\">(<span class=\"type\">rt_mailbox_t</span> mb, <span class=\"type\">rt_ubase_t</span> value)</span>;</span><br><span class=\"line\"><span class=\"comment\">/**************返回值*****************/</span></span><br><span class=\"line\">RT_EOK       发送成功</span><br><span class=\"line\">-RT_EFULL    邮箱已满</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><span style=\"color:#3399FF;\">参数说明</span>：</li>\n<li><code>mb</code>：邮箱对象的句柄。</li>\n<li><code>value</code> ：发送的邮件内容。</li>\n<li><code>timeout</code> ：超时时间。</li>\n</ul>\n<h5 id=\"接收邮件\"><a href=\"#接收邮件\" class=\"headerlink\" title=\"接收邮件\"></a><strong>接收邮件</strong></h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*@note 只有当接收者接收的邮箱中有邮件时，接收者才能立即取到邮件并返回 RT_EOK 的返回值</span></span><br><span class=\"line\"><span class=\"comment\">否则接收线程会根据超时时间设置，或挂起在邮箱的等待线程队列上，或直接返回。</span></span><br><span class=\"line\"><span class=\"comment\">！！！！！记得value需要强转rt_uint32_t！！！！！</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"type\">rt_err_t</span> <span class=\"title function_\">rt_mb_recv</span> <span class=\"params\">(<span class=\"type\">rt_mailbox_t</span> mb, <span class=\"type\">rt_uint32_t</span>* value, <span class=\"type\">rt_int32_t</span> timeout)</span>;</span><br><span class=\"line\"><span class=\"comment\">/**************返回值*****************/</span></span><br><span class=\"line\">RT_EOK        接收成功</span><br><span class=\"line\">-RT_ETIMEOUT     超时</span><br><span class=\"line\">-RT_ERROR    失败，返回错误</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><span style=\"color:#3399FF;\">参数说明</span>：</li>\n<li><code>mb</code>：邮箱对象的句柄。</li>\n<li><code>value</code> ：邮件内容<code>(定义一个变量来接收 记得强转)</code></li>\n<li><code>timeout</code> ：超时时间。</li>\n</ul>\n<h4 id=\"应用示例-3\"><a href=\"#应用示例-3\" class=\"headerlink\" title=\"应用示例\"></a><strong>应用示例</strong></h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;rtthread.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*创建邮箱*/</span></span><br><span class=\"line\"><span class=\"type\">rt_mailbox_t</span> mb;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*线程1：发送邮箱*/</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">thread_entry1</span><span class=\"params\">(<span class=\"type\">void</span> *parameter)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">char</span> msg = <span class=\"string\">&#x27;A&#x27;</span>;<span class=\"comment\">//发送&#x27;A&#x27;作为邮件</span></span><br><span class=\"line\">    rt_kprintf(<span class=\"string\">&quot;线程1：发送邮件...\\n&quot;</span>);</span><br><span class=\"line\">    <span class=\"comment\">//发送邮件  因为邮箱固定4字节 所以需要强转</span></span><br><span class=\"line\">    rt_mb_send(mb, (<span class=\"type\">rt_uint32_t</span>)msg);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*线程2：接收邮件*/</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">thread_entry2</span><span class=\"params\">(<span class=\"type\">void</span> *parameter)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   <span class=\"type\">char</span> msg;</span><br><span class=\"line\">   rt_kprintf(<span class=\"string\">&quot;线程2：等待接收邮件...\\n&quot;</span>);</span><br><span class=\"line\">   <span class=\"comment\">//若邮箱内为空  则执行的是阻塞式的等待接收邮件</span></span><br><span class=\"line\">   rt_mb_recv(mb, (<span class=\"type\">rt_uint32_t</span>)&amp;msg, RT_WAITING_FOREVER);<span class=\"comment\">//接收邮件</span></span><br><span class=\"line\">   rt_kprintf(<span class=\"string\">&quot;线程2：收到邮件：%c\\n&quot;</span>,msg);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">/*创建一个容量为4的4封邮箱(大小为4*4)) */</span></span><br><span class=\"line\">    mb = rt_mb_create(<span class=\"string\">&quot;mb&quot;</span>, <span class=\"number\">4</span>, RT_IPC_FLAG_PRIO);</span><br><span class=\"line\">    <span class=\"comment\">/*创建两个线程 */</span></span><br><span class=\"line\">    <span class=\"type\">rt_thread_t</span> tid1 = rt_thread_create(<span class=\"string\">&quot;t1&quot;</span>, thread_entry1, RT_NULL, <span class=\"number\">1024</span>, <span class=\"number\">10</span>,</span><br><span class=\"line\">    <span class=\"number\">10</span>);</span><br><span class=\"line\">    <span class=\"type\">rt_thread_t</span> tid2 = rt_thread_create(<span class=\"string\">&quot;t2&quot;</span>, thread_entry2, RT_NULL, <span class=\"number\">1024</span>, <span class=\"number\">10</span>,</span><br><span class=\"line\">    <span class=\"number\">10</span>);</span><br><span class=\"line\">    <span class=\"comment\">/* 启动线程 */</span></span><br><span class=\"line\">    rt_thread_startup(tid1);</span><br><span class=\"line\">    rt_thread_startup(tid2);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"消息队列\"><a href=\"#消息队列\" class=\"headerlink\" title=\"消息队列\"></a><strong>消息队列</strong></h3><p>消息队列是另一种常用的线程间通讯方式，是邮箱的扩展。他可以动态分配内存，对比邮箱局限的4字节存储特性，更适合用来传输复杂大量数据或进行任务队列管理</p>\n<h4 id=\"工作机制-4\"><a href=\"#工作机制-4\" class=\"headerlink\" title=\"工作机制\"></a><strong>工作机制</strong></h4><h5 id=\"创建消息队列\"><a href=\"#创建消息队列\" class=\"headerlink\" title=\"创建消息队列\"></a><strong>创建消息队列</strong></h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*创建动态消息队列*/</span></span><br><span class=\"line\"><span class=\"type\">rt_mq_t</span> <span class=\"title function_\">rt_mq_create</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">char</span>* name, <span class=\"type\">rt_size_t</span> msg_size,<span class=\"type\">rt_size_t</span> max_msgs, <span class=\"type\">rt_uint8_t</span> flag)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*创建静态消息队列*/</span></span><br><span class=\"line\"><span class=\"comment\">/*@note 一般放于读数据段或未初始化数据段中。在使用这类静态消息队列对象前，需要进行初始化</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"type\">rt_err_t</span> <span class=\"title function_\">rt_mq_init</span><span class=\"params\">(<span class=\"type\">rt_mq_t</span> mq, <span class=\"type\">const</span> <span class=\"type\">char</span>* name,<span class=\"type\">void</span> *msgpool,<span class=\"type\">rt_size_t</span> msg_size,<span class=\"type\">rt_size_t</span> pool_size, <span class=\"type\">rt_uint8_t</span> flag)</span>;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p><span style=\"color:#3399FF;\">参数说明</span>：</p>\n</li>\n<li><p><code>name </code>：消息队列的名称。</p>\n</li>\n<li><p><code>msg_size </code> ：消息队列中一条消息的最大长度，<span style=\"color:#00FFFF;\">单位字节</span>。</p>\n</li>\n<li><p><code>msg_msgs</code>：消息队列的最大个数(消息个数)。</p>\n</li>\n<li><p><code>flag</code> ：消息队列采用的等待方式，它可以取如下数值：<code>一般除非应用程序非常在意先来后到，不然都采用PRIO确保线程实时性</code></p>\n<ul>\n<li><p><code>RT_IPC_FLAG_FIFO</code>：非实时调度方式 先来后到</p>\n</li>\n<li><p><code>RT_IPC_FLAG_PRIO</code>：实时调度方式 优先级</p>\n</li>\n</ul>\n</li>\n<li><p><code>mq</code> ：消息队列对象的句柄。</p>\n</li>\n<li><p><code>msgpool</code>：指向存放消息的缓冲区的指针。</p>\n</li>\n<li><p><code>pool_size</code> ：存放消息的缓冲区大小</p>\n</li>\n</ul>\n<h5 id=\"删除或脱离消息队列\"><a href=\"#删除或脱离消息队列\" class=\"headerlink\" title=\"删除或脱离消息队列\"></a><strong>删除或脱离消息队列</strong></h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*删除动态消息队列create*/</span></span><br><span class=\"line\"><span class=\"type\">rt_err_t</span> <span class=\"title function_\">rt_mq_delete</span><span class=\"params\">(<span class=\"type\">rt_mq_t</span> mq)</span>;</span><br><span class=\"line\"><span class=\"comment\">/*删除静态消息队列init*/</span></span><br><span class=\"line\"><span class=\"type\">rt_err_t</span> <span class=\"title function_\">rt_mq_detach</span><span class=\"params\">(<span class=\"type\">rt_mq_t</span> mq)</span>;</span><br><span class=\"line\"><span class=\"comment\">//返回值：RT_EOK 成功</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><span style=\"color:#3399FF;\">参数说明</span>：</li>\n<li><code>mq</code>：消息队列对象的句柄</li>\n</ul>\n<blockquote>\n<p>删除消息队列时，如果<span style=\"color:#00FFFF;\">有线程</span>被挂起在该消息队列等待队列上，则内核<span style=\"color:#00FFFF;\">先唤醒挂起</span>在该消息等待队列上的所有线程（线程返回值是 <code>- RT_ERROR</code>），然后再<span style=\"color:#00FFFF;\">释放</span>消息队列使用的内存，最后<span style=\"color:#00FFFF;\">删除</span>消息队列对象</p>\n</blockquote>\n<h5 id=\"发送消息\"><a href=\"#发送消息\" class=\"headerlink\" title=\"发送消息\"></a><strong>发送消息</strong></h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*1.直接发送消息*/</span></span><br><span class=\"line\"><span class=\"type\">rt_err_t</span> <span class=\"title function_\">rt_mq_send</span> <span class=\"params\">(<span class=\"type\">rt_mq_t</span> mq, <span class=\"type\">void</span>* buffer, <span class=\"type\">rt_size_t</span> size)</span>;</span><br><span class=\"line\"><span class=\"comment\">/**************返回值*****************/</span></span><br><span class=\"line\">RT_EOK        发送成功</span><br><span class=\"line\">-RT_EFULL      消息队列已经满了</span><br><span class=\"line\">-RT_ERROR       失败(发送消息长度&gt;队列的最大长度)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*2.等待方式发送消息*/</span></span><br><span class=\"line\"><span class=\"comment\">/*@note 若消息队列已满，则根据设定的timeout等待</span></span><br><span class=\"line\"><span class=\"comment\">/*@note 若超时时间到达依然没有空出时间，此时发送线程被唤醒并返回错误码</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"type\">rt_err_t</span> <span class=\"title function_\">rt_mq_send_wait</span><span class=\"params\">(<span class=\"type\">rt_mq_t</span> mq,<span class=\"type\">const</span> <span class=\"type\">void</span> *buffer,<span class=\"type\">rt_size_t</span> size,<span class=\"type\">rt_int32_t</span>  timeout)</span>;</span><br><span class=\"line\"><span class=\"comment\">/**************返回值*****************/</span></span><br><span class=\"line\">RT_EOK        发送成功</span><br><span class=\"line\">-RT_ETIMEOUT     超时</span><br><span class=\"line\">-RT_ERROR    失败(发送消息长度&gt;队列的最大长度)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*3.发送紧急消息*/</span></span><br><span class=\"line\"><span class=\"comment\">/*@note 发送紧急消息时，邮件被直接插队放入了消息队列队首,这样就能最优先接收到并做出处理</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"type\">rt_err_t</span> <span class=\"title function_\">rt_mq_urgent</span><span class=\"params\">(<span class=\"type\">rt_mq_t</span> mq, <span class=\"type\">void</span>* buffer, <span class=\"type\">rt_size_t</span> size)</span>;</span><br><span class=\"line\"><span class=\"comment\">/**************返回值*****************/</span></span><br><span class=\"line\">RT_EOK       发送成功</span><br><span class=\"line\">-RT_EFULL    消息队列已经满了</span><br><span class=\"line\">-RT_ERROR    失败(发送消息长度&gt;队列的最大长度)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><span style=\"color:#3399FF;\">参数说明</span>：</li>\n<li><code>mq</code>：消息队列对象的句柄</li>\n<li><code>buffer</code> ：发送的消息内容。</li>\n<li><code>size</code> ：消息大小。</li>\n<li><code>timeout</code> ：超时时间。</li>\n</ul>\n<h5 id=\"接收消息\"><a href=\"#接收消息\" class=\"headerlink\" title=\"接收消息\"></a><strong>接收消息</strong></h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*@note 只有当消息队列中有消息时，接收者才能立即取到邮件并返回 RT_EOK 的返回值</span></span><br><span class=\"line\"><span class=\"comment\">否则接收线程会根据超时时间设置，或挂起在邮箱的等待线程队列上，或直接返回。</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"type\">rt_ssize_t</span> <span class=\"title function_\">rt_mq_recv</span> <span class=\"params\">(<span class=\"type\">rt_mq_t</span> mq, <span class=\"type\">void</span>* buffer,<span class=\"type\">rt_size_t</span> size,<span class=\"type\">rt_int32_t</span> timeout)</span>;</span><br><span class=\"line\"><span class=\"comment\">/**************返回值*****************/</span></span><br><span class=\"line\">RT_EOK             成功收到</span><br><span class=\"line\">-RT_ETIMEOUT             超时</span><br><span class=\"line\">-RT_ERROR            失败，返回错误</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><span style=\"color:#3399FF;\">参数说明</span>：</li>\n<li><code>mq</code>：消息队列对象的句柄</li>\n<li><code>buffer</code> ：发送的消息内容。</li>\n<li><code>size</code> ：消息大小。</li>\n<li><code>timeout</code> ：超时时间</li>\n</ul>\n<h4 id=\"应用示例-4\"><a href=\"#应用示例-4\" class=\"headerlink\" title=\"应用示例\"></a><strong>应用示例</strong></h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;rtthread.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*创建消息队列*/</span></span><br><span class=\"line\"><span class=\"type\">rt_mq_t</span> mq;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*线程1：发送消息*/</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">thread_entry1</span><span class=\"params\">(<span class=\"type\">void</span> *parameter)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">char</span> msg[] = <span class=\"string\">&quot;Hello, RT-Thread!&quot;</span>;<span class=\"comment\">//发送&#x27;A&#x27;作为邮件</span></span><br><span class=\"line\">    rt_kprintf(<span class=\"string\">&quot;线程1：发送消息...\\n&quot;</span>);</span><br><span class=\"line\">    <span class=\"comment\">//发送消息到消息队列</span></span><br><span class=\"line\">    rt_mq_send(mq, msg,<span class=\"keyword\">sizeof</span>(msg));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*线程2：接收邮件*/</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">thread_entry2</span><span class=\"params\">(<span class=\"type\">void</span> *parameter)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   <span class=\"type\">char</span> buffer[<span class=\"number\">32</span>];</span><br><span class=\"line\">   rt_kprintf(<span class=\"string\">&quot;线程2：等待接收消息...\\n&quot;</span>);</span><br><span class=\"line\">   <span class=\"comment\">//若消息队列内无消息  则执行的是阻塞式的等待接收消息</span></span><br><span class=\"line\">   rt_mq_recv(mq, buffer,<span class=\"keyword\">sizeof</span>(buffer), RT_WAITING_FOREVER);<span class=\"comment\">//接收消息</span></span><br><span class=\"line\">   rt_kprintf(<span class=\"string\">&quot;线程2：收到消息：%s\\n&quot;</span>,buffer);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">/*创建一个消息队列，容量为4，消息大小为32字节 */</span></span><br><span class=\"line\">    mq = rt_mq_create(<span class=\"string\">&quot;mq&quot;</span>, <span class=\"number\">32</span>, <span class=\"number\">4</span>, RT_IPC_FLAG_PRIO);</span><br><span class=\"line\">    <span class=\"comment\">/*创建两个线程 */</span></span><br><span class=\"line\">    <span class=\"type\">rt_thread_t</span> tid1 = rt_thread_create(<span class=\"string\">&quot;t1&quot;</span>, thread_entry1, RT_NULL, <span class=\"number\">1024</span>, <span class=\"number\">10</span>,</span><br><span class=\"line\">    <span class=\"number\">10</span>);</span><br><span class=\"line\">    <span class=\"type\">rt_thread_t</span> tid2 = rt_thread_create(<span class=\"string\">&quot;t2&quot;</span>, thread_entry2, RT_NULL, <span class=\"number\">1024</span>, <span class=\"number\">10</span>,</span><br><span class=\"line\">    <span class=\"number\">10</span>);</span><br><span class=\"line\">    <span class=\"comment\">/* 启动线程 */</span></span><br><span class=\"line\">    rt_thread_startup(tid1);</span><br><span class=\"line\">    rt_thread_startup(tid2);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"信号\"><a href=\"#信号\" class=\"headerlink\" title=\"信号\"></a><strong>信号</strong></h3><p><code>信号（又称为软中断信号）</code>，在软件层次上是对中断机制的一种模拟。常用于通知线程发生了某个事件。线程收到信号时会根据信号类型执行相应的操作</p>\n<ul>\n<li>与消息队列区别：</li>\n</ul>\n<ol>\n<li><p><span style=\"color:#00FFFF;\">信号仅携带控制信息，不包含数据</span></p>\n</li>\n<li><p>信号不保证顺序性，<span style=\"color:#00FFFF;\">信号发生时立即通知线程</span></p>\n</li>\n<li><p>消息队列则有顺序性（通常是PRIO）</p>\n</li>\n</ol>\n<h4 id=\"工作机制-5\"><a href=\"#工作机制-5\" class=\"headerlink\" title=\"工作机制\"></a><strong>工作机制</strong></h4><h5 id=\"线程中安装信号\"><a href=\"#线程中安装信号\" class=\"headerlink\" title=\"线程中安装信号\"></a><strong>线程中安装信号</strong></h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">t_sighandler_t[] 表示一个函数指针数组</span></span><br><span class=\"line\"><span class=\"comment\">t_sighandler_t handler[] 是一个 变量声明</span></span><br><span class=\"line\"><span class=\"comment\">二者是不一样的！</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"type\">rt_sighandler_t</span> <span class=\"title function_\">rt_signal_install</span><span class=\"params\">(<span class=\"type\">int</span> signo, <span class=\"type\">rt_sighandler_t</span>[] handler)</span>;</span><br><span class=\"line\"><span class=\"comment\">/**************返回值*****************/</span></span><br><span class=\"line\">SIG_ERR                错误的信号</span><br><span class=\"line\">安装信号前的handler值    成功</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><span style=\"color:#3399FF;\">参数说明</span>：</li>\n<li><code>signo </code>：信号值（只有 <code>SIGUSR1</code> 和 <code>SIGUSR2</code> 是开放给用户使用的）。</li>\n<li><code>buffer</code> ：发送的消息内容。</li>\n<li><code>handler</code> ：设置对信号值的处理方式。</li>\n</ul>\n<blockquote>\n<p> 在信号安装时设定 handler 参数，决定了该信号的不同的处理方法。处理方法可以分为三种：</p>\n<ol>\n<li><p>类似<code>中断</code>的处理方式，参数指向当信号发生时用户<code>自定义的处理函数</code>， 在内部写入处理方式，由该函数来处理。</p>\n</li>\n<li><p>参数设为 <code>SIG_IGN</code>，忽略某个信号，<code>对该信号不做任何处理</code>，就像未发生过一样。</p>\n</li>\n<li><p>参数设为 <code>SIG_DFL</code>，系统会调用默认的处理函数<code>_signal_default_handler()</code>。</p>\n</li>\n</ol>\n</blockquote>\n<h5 id=\"阻塞信号与解除阻塞\"><a href=\"#阻塞信号与解除阻塞\" class=\"headerlink\" title=\"阻塞信号与解除阻塞\"></a><strong>阻塞信号与解除阻塞</strong></h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*信号阻塞(屏蔽信号) 该信号不会递答安装此信号的线程*/</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">rt_signal_mask</span><span class=\"params\">(<span class=\"type\">int</span> signo)</span>;</span><br><span class=\"line\"><span class=\"comment\">/*解除信号阻塞</span></span><br><span class=\"line\"><span class=\"comment\">使用此函数可以对其中一些信号给予 “关注”，那么发送这些信号都会引发该线程的软中断</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">rt_signal_unmask</span><span class=\"params\">(<span class=\"type\">int</span> signo)</span>;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><span style=\"color:#3399FF;\">参数说明</span>：</li>\n<li><code>signo</code>：信号值</li>\n</ul>\n<h5 id=\"发送信号\"><a href=\"#发送信号\" class=\"headerlink\" title=\"发送信号\"></a><strong>发送信号</strong></h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*需要异常处理时，可以给安装了信号的线程发送信号*/</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">rt_thread_kill</span><span class=\"params\">(<span class=\"type\">rt_thread_t</span> tid, <span class=\"type\">int</span> sig)</span>;</span><br><span class=\"line\"><span class=\"comment\">/**************返回值*****************/</span></span><br><span class=\"line\">RT_EOK        发送成功</span><br><span class=\"line\">-RT_EINVAL    参数错误</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><span style=\"color:#3399FF;\">参数说明</span>：</li>\n<li><code>tid</code>：接收信号的线程。</li>\n<li><code>sig </code>：信号值。</li>\n</ul>\n<h4 id=\"应用示例-5\"><a href=\"#应用示例-5\" class=\"headerlink\" title=\"应用示例\"></a><strong>应用示例</strong></h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;rtthread.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> THREAD_PRIORITY         25</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> THREAD_STACK_SIZE       512</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> THREAD_TIMESLICE        5</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">rt_thread_t</span> tid1 = RT_NULL;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 线程 1 的信号处理函数 */</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">thread1_signal_handler</span><span class=\"params\">(<span class=\"type\">int</span> sig)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    rt_kprintf(<span class=\"string\">&quot;thread1 received signal %d\\n&quot;</span>, sig);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 线程 1 的入口函数 */</span></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title function_\">thread1_entry</span><span class=\"params\">(<span class=\"type\">void</span> *parameter)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* 安装信号 */</span></span><br><span class=\"line\">    rt_signal_install(SIGUSR1, thread1_signal_handler);</span><br><span class=\"line\">    rt_signal_unmask(SIGUSR1);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* 运行 10 次 */</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (cnt &lt; <span class=\"number\">10</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">/* 线程 1 采用低优先级运行，一直打印计数值 */</span></span><br><span class=\"line\">        rt_kprintf(<span class=\"string\">&quot;thread1 count : %d\\n&quot;</span>, cnt);</span><br><span class=\"line\"></span><br><span class=\"line\">        cnt++;</span><br><span class=\"line\">        rt_thread_mdelay(<span class=\"number\">100</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 信号示例的初始化 */</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">signal_sample</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">/* 创建线程 1 */</span></span><br><span class=\"line\">    tid1 = rt_thread_create(<span class=\"string\">&quot;thread1&quot;</span>,thread1_entry, RT_NULL,THREAD_STACK_SIZE, THREAD_PRIORITY, THREAD_TIMESLICE);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tid1 != RT_NULL)</span><br><span class=\"line\">        rt_thread_startup(tid1);</span><br><span class=\"line\"></span><br><span class=\"line\">    rt_thread_mdelay(<span class=\"number\">300</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* 发送信号 SIGUSR1 给线程 1 */</span></span><br><span class=\"line\">    rt_thread_kill(tid1, SIGUSR1);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"框架移植\"><a href=\"#框架移植\" class=\"headerlink\" title=\"框架移植\"></a><strong>框架移植</strong></h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//bsp_system.h中引入以下四个头文件</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;rtthread.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;rtdevice.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;drv_common.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;board.h&gt;</span></span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"系统初始化宏定义\"><a href=\"#系统初始化宏定义\" class=\"headerlink\" title=\"系统初始化宏定义\"></a><strong>系统初始化宏定义</strong></h3><p>​    <img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505222143758.png\" alt=\"image-20250522214349807\"></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*1、板级初始化 fn为函数指针*/</span></span><br><span class=\"line\">INIT_BOARD_EXPORT(fn)</span><br><span class=\"line\"><span class=\"comment\">/*2、纯软件函数初始化 fn为函数指针*/</span></span><br><span class=\"line\">INIT_PREV_EXPORT(fn)</span><br><span class=\"line\"><span class=\"comment\">/*3、设备自动初始化，fn为函数指针*/</span></span><br><span class=\"line\">INIT_DEVICE_EXPORT(fn)</span><br><span class=\"line\"><span class=\"comment\">/*4、组件自动初始化，fn为函数指针*/</span></span><br><span class=\"line\">INIT_COMPONENT_EXPORT(fn)</span><br><span class=\"line\"><span class=\"comment\">/*5、系统环境自动初始化，fn为函数指针*/</span></span><br><span class=\"line\">INIT_ENV_EXPORT(fn) </span><br><span class=\"line\"><span class=\"comment\">/*6、应用自动初始化，fn为函数指针*/</span></span><br><span class=\"line\">INIT_APP_EXPORT(fn)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"ESP8266移植\"><a href=\"#ESP8266移植\" class=\"headerlink\" title=\"ESP8266移植\"></a><strong>ESP8266移植</strong></h3><blockquote>\n<p>将<code>uart_app.c</code>与<code>uart_app.h</code>移去 不使用！！！然后RTT打开控制台输出rt_kprintf，选择串口1</p>\n</blockquote>\n<p>   <img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505222145092.png\" alt=\"image-20250522214536841\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505222204947.png\" alt=\"image-20250522220417747\"> <img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505222204548.png\" alt=\"image-20250522220447380\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505222147073.png\" alt=\"image-20250522214750185\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505222147664.png\" alt=\"image-20250522214705123\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505222148942.png\" alt=\"image-20250522214840651\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505222149729.png\" alt=\"image-20250522214859546\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505222149203.png\" alt=\"image-20250522214917115\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505222149796.png\" alt=\"image-20250522214947877\"></p>\n<p>直接编译开启终端 下载观察现象，出现以下信息则连接成功</p>\n<p>​    <img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505222150747.png\" alt=\"image-20250522215015453\"></p>\n<h3 id=\"DHT11移植\"><a href=\"#DHT11移植\" class=\"headerlink\" title=\"DHT11移植\"></a><strong>DHT11移植</strong></h3><h4 id=\"组件添加\"><a href=\"#组件添加\" class=\"headerlink\" title=\"组件添加\"></a><strong>组件添加</strong></h4><p>​    <img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505222151707.png\" alt=\"image-20250522215146162\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505222152193.png\" alt=\"image-20250522215207600\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505222203028.png\" alt=\"image-20250522220342327\"></p>\n<h4 id=\"proc代码构建\"><a href=\"#proc代码构建\" class=\"headerlink\" title=\"proc代码构建\"></a><strong>proc代码构建</strong></h4><h5 id=\"创建sensor-app-c与-h\"><a href=\"#创建sensor-app-c与-h\" class=\"headerlink\" title=\"创建sensor_app.c与.h\"></a><strong>创建sensor_app.c与.h</strong></h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//引入必要库</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sensor_app.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sensor.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;sensor_dallas_dht11.h&quot;</span></span></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"注册设备\"><a href=\"#注册设备\" class=\"headerlink\" title=\"注册设备\"></a><strong>注册设备</strong></h5><pre><code><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">rt_device_t</span> dev = RT_NULL;</span><br><span class=\"line\"><span class=\"comment\">//创建传感器结构体对象</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">rt_sensor_data</span> <span class=\"title\">sensor_data</span>;</span></span><br><span class=\"line\"><span class=\"type\">rt_uint8_t</span> get_data_freq = <span class=\"number\">1</span>;<span class=\"comment\">///默认1hz</span></span><br><span class=\"line\"><span class=\"type\">rt_size_t</span> res;<span class=\"comment\">//返回值 如RT_EOK</span></span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">/*注册传感器*/</span></span><br><span class=\"line\">dev =  rt_device_find(<span class=\"string\">&quot;temp_dht11&quot;</span>);<span class=\"comment\">//注意此处注册需要有前缀 如temp_(在sensor.c中)</span></span><br><span class=\"line\"><span class=\"keyword\">if</span>(dev == RT_NULL)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    rt_kprintf(<span class=\"string\">&quot;Not Found\\r\\n&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">if</span>(rt_device_open(dev, RT_DEVICE_FLAG_RDWR) != RT_EOK)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    rt_kprintf(<span class=\"string\">&quot;Open Error\\r\\n&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">rt_device_control(dev, RT_SENSOR_CTRL_SET_ODR, (<span class=\"type\">void</span> *)&amp;get_data_freq);</span><br></pre></td></tr></table></figure>\n</code></pre>\n<h5 id=\"读取传感器数据\"><a href=\"#读取传感器数据\" class=\"headerlink\" title=\"读取传感器数据\"></a><strong>读取传感器数据</strong></h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*读取传感器*/</span></span><br><span class=\"line\">   <span class=\"keyword\">while</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">       res = rt_device_read(dev, <span class=\"number\">0</span>, &amp;sensor_data, <span class=\"number\">1</span>);<span class=\"comment\">//第0位开始读一个</span></span><br><span class=\"line\">       <span class=\"comment\">//读错了返回0</span></span><br><span class=\"line\">       <span class=\"keyword\">if</span>(res == <span class=\"number\">0</span>)</span><br><span class=\"line\">       &#123;</span><br><span class=\"line\">           rt_kprintf(<span class=\"string\">&quot;Read Error Res:%d&quot;</span>,res);<span class=\"comment\">//返回读取错误编号0</span></span><br><span class=\"line\">           <span class=\"keyword\">return</span>;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">else</span> <span class=\"comment\">//读取成功</span></span><br><span class=\"line\">       &#123;</span><br><span class=\"line\">           <span class=\"keyword\">if</span>(sensor_data.data.temp &gt;= <span class=\"number\">0</span>) <span class=\"comment\">//数据大于等于0 包括了温度与湿度</span></span><br><span class=\"line\">           &#123;</span><br><span class=\"line\">               <span class=\"type\">uint8_t</span> temp = (sensor_data.data.temp &amp; <span class=\"number\">0xffff</span>);</span><br><span class=\"line\">               <span class=\"type\">uint8_t</span> humi = (sensor_data.data.temp &amp; <span class=\"number\">0xffff0000</span>) &gt;&gt; <span class=\"number\">16</span>;</span><br><span class=\"line\">               rt_kprintf(<span class=\"string\">&quot;temp:%d humi:%d\\r\\n&quot;</span>,temp,humi);</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       rt_thread_delay(<span class=\"number\">1000</span>);</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"init代码构建\"><a href=\"#init代码构建\" class=\"headerlink\" title=\"init代码构建\"></a><strong>init代码构建</strong></h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">sensor_init</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">rt_sensor_config</span> <span class=\"title\">cfg</span>;</span><span class=\"comment\">//操作集结构体</span></span><br><span class=\"line\">    <span class=\"comment\">/*注册设备 配置接口*/</span></span><br><span class=\"line\">    cfg.intf.user_data = (<span class=\"type\">void</span> *)DHT11_PIN;<span class=\"comment\">//配置接口为IO口</span></span><br><span class=\"line\">    rt_hw_dht11_init(<span class=\"string\">&quot;dht11&quot;</span>, &amp;cfg);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">rt_thread_t</span> sensor_thread = rt_thread_create(<span class=\"string\">&quot;sensor_proc&quot;</span>, sensor_proc, RT_NULL, <span class=\"number\">1024</span>, <span class=\"number\">10</span>, <span class=\"number\">20</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(sensor_thread != RT_NULL)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        rt_thread_startup(sensor_thread);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> RT_EOK;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">INIT_COMPONENT_EXPORT(sensor_init);</span><br></pre></td></tr></table></figure>\n\n","excerpt":"","more":"<h2 id=\"时钟管理\"><a href=\"#时钟管理\" class=\"headerlink\" title=\"时钟管理\"></a>时钟管理</h2><h3 id=\"时钟节拍产生与获取\"><a href=\"#时钟节拍产生与获取\" class=\"headerlink\" title=\"时钟节拍产生与获取\"></a>时钟节拍产生与获取</h3><p>时钟节拍依赖于硬件中的定时器。你可以把定时器看作是⼀个不停计时的装置，它每隔⼀段时间就会提醒系统“滴答”⼀次。<span style=\"text-decoration:underline;\">每当定时器中断发⽣时，RT-Thread 会调⽤ rt_tick_increase()函数，系统时间增加 1 个节拍</span>。<code>就像家中的闹钟响⼀次，时间就过去了⼀分钟⼀样。</code></p>\n<blockquote>\n<p>其中rt_tick_increase()函数中有rt_tick类似于HAL库中的uwTick，可以直接调用 获取系统时间</p>\n</blockquote>\n<h2 id=\"定时器管理\"><a href=\"#定时器管理\" class=\"headerlink\" title=\"定时器管理\"></a>定时器管理</h2><h3 id=\"硬件定时器-vs-软件定时器\"><a href=\"#硬件定时器-vs-软件定时器\" class=\"headerlink\" title=\"硬件定时器 vs 软件定时器\"></a>硬件定时器 vs 软件定时器</h3><ol>\n<li><span style=\"color:#FF3399;\">硬件定时器</span>：就像厨房⾥的倒计时器，它是由硬件直接提供的。硬件定时器精度⾮常⾼，可以达到纳秒级，适合⼀些对时间要求⾮常严格的任务，⽐如控制电机的旋转时间。</li>\n<li><span style=\"color:#FF3399;\">软件定时器</span>：可以理解为⼿机上的计时 App。它依赖于操作系统的时钟节拍来⼯作，它的时间间隔精度由 OS Tick 决定。例如，如果 OS Tick 是 10ms，那么软件定时器只能精确到 10ms。虽然精度不如硬件定时器⾼，但它更灵活、容易使⽤。</li>\n</ol>\n<h3 id=\"RTT定时器分类\"><a href=\"#RTT定时器分类\" class=\"headerlink\" title=\"RTT定时器分类\"></a>RTT定时器分类</h3><ul>\n<li><span style=\"color:#FF3399;\">单次触发定时器</span>：就像倒计时⼀次的闹钟，响⼀次后就停⽌。例如，设定⼀个 5 秒的倒计时，时间到了闹钟响⼀次就结束了。</li>\n<li><span style=\"color:#FF3399;\">周期触发定时器</span>：就像那些每天早上 7 点重复响起的闹钟。每隔⼀段时间，它会周期性地触发事件，直到你⼿动关闭它。</li>\n</ul>\n<p>根据定时器回调函数执⾏的上下⽂环境，定时器还可以分为两种模式：</p>\n<ul>\n<li><span style=\"color:#FF3399;\">硬件模式 </span>(HARD_TIMER)：定时器的回调函数在<span style=\"text-decoration:underline;\">中断上下⽂</span>中执⾏<code>就像闹钟响起时你⽴刻跳起来⼀样</code>它反应⾮常快，但要求处理时间短。</li>\n<li><span style=\"color:#FF3399;\">软件模式</span> (SOFT_TIMER)：回调函数在<span style=\"text-decoration:underline;\">系统的 timer 线程中</span>执⾏，相当于<code>有⼈提醒你“闹钟响了”</code>，然后你再去执⾏⼀些动作。这个模式可以做更复杂的操作，因为它不是在中断中执⾏。</li>\n</ul>\n<h3 id=\"控制定时器\"><a href=\"#控制定时器\" class=\"headerlink\" title=\"控制定时器\"></a>控制定时器</h3><p><code>通过该函数你可以随时改变定时器触发方式以及定时器时间</code></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505212214569.png\" alt=\"image-20250521221429133\"></p>\n<h3 id=\"高精度延时\"><a href=\"#高精度延时\" class=\"headerlink\" title=\"高精度延时\"></a>高精度延时</h3><p><code>使用该函数可以实现微妙级的精确延时，适合高精度时间控制场合</code></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505212215044.png\" alt=\"image-20250521221525259\"></p>\n<h2 id=\"线程创建\"><a href=\"#线程创建\" class=\"headerlink\" title=\"线程创建\"></a>线程创建</h2><p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505212034310.png\" alt=\"image-20250521203425658\"></p>\n<ul>\n<li><code>name</code>：线程名字</li>\n<li><code>entry</code>：线程入口函数</li>\n<li><code>parameter</code>：传递给线程的参数</li>\n<li><code>stack_size</code>：线程栈大小</li>\n<li><code>priority</code>：线程优先级</li>\n<li><code>tick</code>：时间片</li>\n</ul>\n<h3 id=\"详细步骤\"><a href=\"#详细步骤\" class=\"headerlink\" title=\"详细步骤\"></a>详细步骤</h3><ol>\n<li>声明一个pcb结构体 <code>static rt_thread_t tid1 = RT_NULL;</code></li>\n<li>编写线程入口函数 <code>static void thread1_entry(void *parameter)</code>，参数为必需，其为传递给线程的参数</li>\n<li>利用<code>rt_thread_create</code>函数赋值给所声明的pcb结构体tid1</li>\n<li>利用<code>rt_thread_startup(tid1)</code>函数启动线程</li>\n</ol>\n<h3 id=\"实现示例\"><a href=\"#实现示例\" class=\"headerlink\" title=\"实现示例\"></a>实现示例</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title function_\">thread1_proc</span><span class=\"params\">(<span class=\"type\">void</span> *parameter)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">/*实际功能*/</span></span><br><span class=\"line\">        rt_thread_mdelay(<span class=\"number\">1000</span>);<span class=\"comment\">//休息1秒</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">thread1_init</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">rt_thread_t</span> tid1 =  rt_thread_create(<span class=\"string\">&quot;thread1_proc&quot;</span>,thread1_proc,RT_NULL,<span class=\"number\">1024</span>,<span class=\"number\">10</span>,<span class=\"number\">20</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(tid1 != RT_NULL)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        rt_thread_startup(tid1);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> RT_EOK;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">INIT_COMPONENT_EXPORT(thread1_init);   <span class=\"comment\">//用这个宏就不需要另外再去注册</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><span style=\"font-style:italic;\">rt_thread_mdelay(1000)的工作机制：</span></p>\n<p><span style=\"font-style:italic;\">1、当 rt_thread_mdelay 被调⽤时，当前线程会进⼊ RT_THREAD_SUSPEND 状态（<span style=\"color:#CC00CC;\">挂起</span>状态）。</span></p>\n<p><span style=\"font-style:italic;\">2、调度器开始运⾏其他优先级相同或更⾼的线程。</span></p>\n<p><span style=\"font-style:italic;\">3、 <span style=\"text-decoration:underline;\">延时时间结束后，线程从 挂起状态 转变为 就绪状态</span> ，等待系统再次调度该线程。</span></p>\n<p><span style=\"font-style:italic;\">PS：若此时无其他线程，则CPU就处于释放状态</span></p>\n</blockquote>\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505212056766.png\" alt=\"image-20250521205640868\"></p>\n<h2 id=\"线程间同步\"><a href=\"#线程间同步\" class=\"headerlink\" title=\"线程间同步\"></a>线程间同步</h2><h3 id=\"信号量\"><a href=\"#信号量\" class=\"headerlink\" title=\"信号量\"></a>信号量</h3><p>信号量可以理解为电影院的座位数（<span style=\"color:#FF0000;\">资源数量</span>）。当所有座位都满了，新的观众（线程）就需要等前⾯的观众离开（释放资源）才能进⼊。当有空位时，观众可以进⼊。<code>信号量通过控制资源的数量来管理多个线程对资源的访问</code></p>\n<h4 id=\"工作机制\"><a href=\"#工作机制\" class=\"headerlink\" title=\"工作机制\"></a>工作机制</h4><ul>\n<li><p><code>获取信号量</code>：当资源可⽤时，线程可以获取信号量，<span style=\"color:#FF0000;\">信号量的值减1</span>。<span style=\"background:#66FFFF;\">如果信号量的值为0，线程就会等待，直到资源释放</span></p>\n</li>\n<li><p><code>释放信号量</code>：使⽤完资源后，线程释放信号量，<span style=\"color:#FF0000;\">信号量的值加1</span>，允许其他线程访问资源</p>\n</li>\n</ul>\n<h5 id=\"创建信号量\"><a href=\"#创建信号量\" class=\"headerlink\" title=\"创建信号量\"></a>创建信号量</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*动态分配内存并创建信号量*/</span></span><br><span class=\"line\"><span class=\"type\">rt_sem_t</span> <span class=\"title function_\">rt_sem_create</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">char</span> *name, <span class=\"type\">rt_uint32_t</span> value, <span class=\"type\">rt_uint8_t</span> flag)</span>;</span><br><span class=\"line\"><span class=\"comment\">/*静态分配内存并创建信号量*/</span></span><br><span class=\"line\"><span class=\"type\">rt_err_t</span> <span class=\"title function_\">rt_sem_init</span><span class=\"params\">(<span class=\"type\">rt_sem_t</span> sem, <span class=\"type\">const</span> <span class=\"type\">char</span> *name, <span class=\"type\">rt_uint32_t</span> value,<span class=\"type\">rt_uint8_t</span> flag)</span>;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p><span style=\"color:#3399FF;\">参数说明</span>：</p>\n</li>\n<li><p><code>name</code>：信号量的名字（可以为 <code>RT_NULL</code> 表⽰匿名信号量）。</p>\n</li>\n<li><p><code>value</code>：信号量的初始值，表⽰信号量当前持有的资源数量（<code>例如初始值为 0 表⽰等待事件，为 1 表⽰互斥量，或者更⼤值表⽰资源计数</code>）。</p>\n</li>\n<li><p><code>flag</code>：PC 对象的属性标志，常⽤值：</p>\n</li>\n<li><p><code>RT_IPC_FLAG_PRIO</code> ：<span style=\"color:#FF0000;\">优先级</span>等待⽅式，等待线程按照优先级顺序排列。</p>\n</li>\n<li><p><code>RT_IPC_FLAG_FIFO</code> ：<span style=\"color:#FF0000;\">先⼊先出</span>等待⽅式，等待线程按照进⼊顺序排列。</p>\n</li>\n</ul>\n<h5 id=\"获取信号量\"><a href=\"#获取信号量\" class=\"headerlink\" title=\"获取信号量\"></a>获取信号量</h5><p>⽤于获取信号量（P 操作），线程会尝试获取信号量，<code>如果信号量的计数值为 0，线程会进⼊等待状态</code>，直到信号量被释放或超时。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">rt_err_t</span> <span class=\"title function_\">rt_sem_take</span><span class=\"params\">(<span class=\"type\">rt_sem_t</span> sem, <span class=\"type\">rt_int32_t</span> time)</span>;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p><span style=\"color:#3399FF;\">参数说明</span>：</p>\n</li>\n<li><p><code>sem</code>：信号量的句柄。</p>\n</li>\n<li><p><code>time</code>：超时时间（单位为系统 tick），表⽰最⼤等待时间。如果设置为 <code>RT_WAITING_FOREVER</code> ，线程会⼀直等待</p>\n</li>\n</ul>\n<h5 id=\"释放信号量\"><a href=\"#释放信号量\" class=\"headerlink\" title=\"释放信号量\"></a>释放信号量</h5><p>⽤于释放信号量（V 操作），<strong>增加</strong>信号量的计数值，<code>并唤醒等待该信号量的线程</code>。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">rt_err_t</span> <span class=\"title function_\">rt_sem_release</span><span class=\"params\">(<span class=\"type\">rt_sem_t</span> sem)</span>;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"应用示例\"><a href=\"#应用示例\" class=\"headerlink\" title=\"应用示例\"></a>应用示例</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;rtthread.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">rt_sem_t</span> sem = RT_NULL;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">thread1</span><span class=\"params\">(<span class=\"type\">void</span> *parameter)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   rt_kprintf(<span class=\"string\">&quot;线程1：等待线程2发送信号\\n&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">/*等待信号量，超时时间为永久等待*/</span></span><br><span class=\"line\">   rt_sem_take(sem,RT_WAITING_FOREVER);</span><br><span class=\"line\"></span><br><span class=\"line\">   rt_kprintf(<span class=\"string\">&quot;线程1：收到线程2的信号，继续执行....\\n&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">thread2</span><span class=\"params\">(<span class=\"type\">void</span> *parameter)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   rt_kprintf(<span class=\"string\">&quot;线程2：执行一些操作\\n&quot;</span>);</span><br><span class=\"line\">   <span class=\"comment\">/*模拟执行一些动作*/</span></span><br><span class=\"line\">   rt_thread_mdelay(<span class=\"number\">2000</span>);</span><br><span class=\"line\">   rt_kprintf(<span class=\"string\">&quot;线程2：操作完成，发送信号给线程1\\n&quot;</span>);</span><br><span class=\"line\">   <span class=\"comment\">/*释放信号量 通知线程1*/</span></span><br><span class=\"line\">   rt_sem_release(sem);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">rt_thread_t</span> tid1 = RT_NULL;</span><br><span class=\"line\">    <span class=\"type\">rt_thread_t</span> tid2 = RT_NULL;</span><br><span class=\"line\"></span><br><span class=\"line\">    sem = rt_sem_create(<span class=\"string\">&quot;sem&quot;</span>, <span class=\"number\">0</span>, RT_IPC_FLAG_PRIO);</span><br><span class=\"line\">    tid1 = rt_thread_create(<span class=\"string\">&quot;tid1&quot;</span>, thread1, RT_NULL, <span class=\"number\">1024</span>, <span class=\"number\">25</span>, <span class=\"number\">100</span>);</span><br><span class=\"line\">    tid2 = rt_thread_create(<span class=\"string\">&quot;tid2&quot;</span>, thread2, RT_NULL, <span class=\"number\">1024</span>, <span class=\"number\">25</span>, <span class=\"number\">100</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(tid1 != RT_NULL) rt_thread_startup(tid1);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(tid2 != RT_NULL) rt_thread_startup(tid2);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h4><ol>\n<li>任务同步（多任务协调执行顺序）</li>\n<li>任务互斥(使用<code>互斥量</code> 保证同一时间只有一个线程 访问公共资源)</li>\n<li>事件触发</li>\n<li>限量资源管理</li>\n</ol>\n<h3 id=\"互斥量（Mutex）\"><a href=\"#互斥量（Mutex）\" class=\"headerlink\" title=\"互斥量（Mutex）\"></a><strong>互斥量（Mutex）</strong></h3><h4 id=\"工作机制-1\"><a href=\"#工作机制-1\" class=\"headerlink\" title=\"工作机制\"></a><strong>工作机制</strong></h4><p>互斥量确保同⼀时刻<strong>只有⼀个线程能够访问共享资源</strong>：</p>\n<ul>\n<li><code>获取互斥量</code>：当⼀个线程获取到互斥量时，其他线程不能访问该资源，直到互斥量被释放。</li>\n<li><code>释放互斥量</code>：当线程释放互斥量后，其他等待的线程才能访问资源</li>\n</ul>\n<h5 id=\"创建互斥量\"><a href=\"#创建互斥量\" class=\"headerlink\" title=\"创建互斥量\"></a><strong>创建互斥量</strong></h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*动态创建一个互斥量*/</span></span><br><span class=\"line\"><span class=\"type\">rt_mutex_t</span> <span class=\"title function_\">rt_mutex_create</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">char</span> *name, <span class=\"type\">rt_uint8_t</span> flag)</span>;</span><br><span class=\"line\"><span class=\"comment\">/*静态创建一个互斥量*/</span></span><br><span class=\"line\"><span class=\"type\">rt_err_t</span> <span class=\"title function_\">rt_mutex_init</span><span class=\"params\">(<span class=\"type\">rt_mutex_t</span> mutex, <span class=\"type\">const</span> <span class=\"type\">char</span> *name, <span class=\"type\">rt_uint8_t</span> flag)</span>;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><span style=\"color:#3399FF;\">参数说明</span>：</li>\n<li><code>name</code>：互斥量的名字（可以为 <code>RT_NULL</code> 表⽰匿名互斥量）。</li>\n<li><code>flag</code>：IPC 对象的属性标志，通常使⽤ <code>RT_IPC_FLAG_PRIO</code> 表⽰优先级等待。</li>\n</ul>\n<h5 id=\"获取互斥量\"><a href=\"#获取互斥量\" class=\"headerlink\" title=\"获取互斥量\"></a><strong>获取互斥量</strong></h5><p>⽤于获取互斥量，线程通过调⽤此函数进⼊临界区。<code>如果互斥量已经被其他线程获取，当前线程会进⼊等待状态，直到获取成功或超时。</code></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">rt_err_t</span> <span class=\"title function_\">rt_mutex_take</span><span class=\"params\">(<span class=\"type\">rt_mutex_t</span> mutex, <span class=\"type\">rt_int32_t</span> time)</span>;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><span style=\"color:#3399FF;\">参数说明</span>：</li>\n<li><code>mutex</code>：互斥量的句柄。</li>\n<li><code>time</code>：超时时间（单位为系统 tick），可以指定等待时⻓或 <code>RT_WAITING_FOREVER</code>表⽰永远等待。</li>\n</ul>\n<h5 id=\"释放互斥量\"><a href=\"#释放互斥量\" class=\"headerlink\" title=\"释放互斥量\"></a>释放互斥量</h5><p>⽤于释放互斥量（V 操作），<strong>增加</strong>互斥量的计数值，并唤醒等待该互斥量的线程。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">rt_err_t</span> <span class=\"title function_\">rt_mutex_release</span><span class=\"params\">(<span class=\"type\">rt_mutex_t</span> mutex)</span>;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"应用示例-1\"><a href=\"#应用示例-1\" class=\"headerlink\" title=\"应用示例\"></a><strong>应用示例</strong></h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;rtthread.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">rt_mutex_t</span> mutex = RT_NULL;</span><br><span class=\"line\"><span class=\"type\">rt_uint32_t</span> cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">thread1</span><span class=\"params\">(<span class=\"type\">void</span> *parameter)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   <span class=\"comment\">//rt_kprintf(&quot;线程1：等待线程2发送信号\\n&quot;);</span></span><br><span class=\"line\">   <span class=\"keyword\">while</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">       rt_mutex_take(mutex,RT_WAITING_FOREVER);</span><br><span class=\"line\">       cnt++;</span><br><span class=\"line\">       rt_thread_mdelay(<span class=\"number\">1000</span>);</span><br><span class=\"line\">       rt_kprintf(<span class=\"string\">&quot;线程1 cnt = %d \\n&quot;</span>,cnt);</span><br><span class=\"line\">       rt_mutex_release(mutex);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">thread2</span><span class=\"params\">(<span class=\"type\">void</span> *parameter)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   <span class=\"comment\">//rt_kprintf(&quot;线程2：执行一些操作\\n&quot;);</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        rt_mutex_take(mutex,RT_WAITING_FOREVER);</span><br><span class=\"line\">        cnt++;</span><br><span class=\"line\">        rt_thread_mdelay(<span class=\"number\">1000</span>);</span><br><span class=\"line\">        rt_kprintf(<span class=\"string\">&quot;线程2 cnt = %d \\n&quot;</span>,cnt);</span><br><span class=\"line\">        rt_mutex_release(mutex);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">rt_thread_t</span> tid1 = RT_NULL;</span><br><span class=\"line\">    <span class=\"type\">rt_thread_t</span> tid2 = RT_NULL;</span><br><span class=\"line\"></span><br><span class=\"line\">    mutex = rt_mutex_create(<span class=\"string\">&quot;mutex&quot;</span>, RT_IPC_FLAG_PRIO);</span><br><span class=\"line\">    tid1 = rt_thread_create(<span class=\"string\">&quot;tid1&quot;</span>, thread1, RT_NULL, <span class=\"number\">1024</span>, <span class=\"number\">25</span>, <span class=\"number\">100</span>);</span><br><span class=\"line\">    tid2 = rt_thread_create(<span class=\"string\">&quot;tid2&quot;</span>, thread2, RT_NULL, <span class=\"number\">1024</span>, <span class=\"number\">25</span>, <span class=\"number\">100</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(tid1 != RT_NULL) rt_thread_startup(tid1);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(tid2 != RT_NULL) rt_thread_startup(tid2);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"任务同步与任务互斥差异\"><a href=\"#任务同步与任务互斥差异\" class=\"headerlink\" title=\"任务同步与任务互斥差异\"></a><strong>任务同步与任务互斥差异</strong></h3><p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505222030206.png\" alt=\"image-20250522203011255\"></p>\n<h3 id=\"事件集\"><a href=\"#事件集\" class=\"headerlink\" title=\"事件集\"></a><strong>事件集</strong></h3><p>事件集可以看作公交⻋站的场景。线程可以等待多个事件发⽣，<code>⽐如等待公交⻋或等待同伴到达。如果满⾜某个或某⼏个条件，线程将被唤醒继续执⾏。</code></p>\n<h4 id=\"工作机制-2\"><a href=\"#工作机制-2\" class=\"headerlink\" title=\"工作机制\"></a><strong>工作机制</strong></h4><p>事件集⽤于线程间的同步，可以让线程等待⼀个或多个事件的触发：</p>\n<ul>\n<li><code>逻辑与（AND)</code>：线程等待多个事件同时发⽣才被唤醒。</li>\n<li><code>逻辑或（OR）</code>：线程只需等待其中⼀个事件发⽣即可被唤醒。</li>\n</ul>\n<h5 id=\"创建事件对象\"><a href=\"#创建事件对象\" class=\"headerlink\" title=\"创建事件对象\"></a><strong>创建事件对象</strong></h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*动态创建一个对象*/</span></span><br><span class=\"line\"><span class=\"type\">rt_event_t</span> <span class=\"title function_\">rt_event_create</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">char</span> *name, <span class=\"type\">rt_uint8_t</span> flag)</span>;</span><br><span class=\"line\"><span class=\"comment\">/*静态创建一个对象*/</span></span><br><span class=\"line\"><span class=\"type\">rt_err_t</span> <span class=\"title function_\">rt_event_init</span><span class=\"params\">(<span class=\"type\">rt_event_t</span> event, <span class=\"type\">const</span> <span class=\"type\">char</span> *name, <span class=\"type\">rt_uint8_t</span> flag)</span>; </span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><span style=\"color:#3399FF;\">参数说明</span>：</li>\n<li><code>name</code>：事件对象的名字（可以为 <code>RT_NULL</code> 表⽰匿名事件对象）。</li>\n<li><code>flag</code>：IPC 对象的属性标志，⼀般使⽤ <code>RT_IPC_FLAG_PRIO</code> 表⽰优先级等待，或<code>RT_IPC_FLAG_FIFO</code> 表⽰先进先出等待。</li>\n</ul>\n<h5 id=\"发送-触发-事件\"><a href=\"#发送-触发-事件\" class=\"headerlink\" title=\"发送(触发)事件\"></a><strong>发送(触发)事件</strong></h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">rt_err_t</span> <span class=\"title function_\">rt_event_send</span><span class=\"params\">(<span class=\"type\">rt_event_t</span> event, <span class=\"type\">rt_uint32_t</span> <span class=\"built_in\">set</span>)</span>;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><span style=\"color:#3399FF;\">参数说明</span>：</li>\n<li><code>event</code>：事件对象的句柄。</li>\n<li><code>set</code>：事件标志，设置哪⼏位事件标志被触发 <code>可以⽤ 1 &lt;&lt; n 来表⽰第 n 位的事件。</code></li>\n</ul>\n<h5 id=\"接收-等待-事件\"><a href=\"#接收-等待-事件\" class=\"headerlink\" title=\"接收(等待)事件\"></a><strong>接收(等待)事件</strong></h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">rt_err_t</span> <span class=\"title function_\">rt_event_recv</span><span class=\"params\">(<span class=\"type\">rt_event_t</span> event, <span class=\"type\">rt_uint32_t</span> <span class=\"built_in\">set</span>, <span class=\"type\">rt_uint8_t</span> option, <span class=\"type\">rt_int32_t</span> timeout, <span class=\"type\">rt_uint32_t</span> *recved)</span>;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><span style=\"color:#3399FF;\">参数说明</span>：</li>\n<li><code>event</code>：事件对象的句柄。</li>\n<li><code>set</code>：需要等待的事件标志 <code>例如 1 &lt;&lt; 3 | 1 &lt;&lt; 5 表⽰同时等待第3位和第5位的事件</code></li>\n<li><code>option</code> ：等待选项，常⻅选项包括：<ul>\n<li><code>RT_EVENT_FLAG_AND</code> ：<span style=\"color:#3399FF;\">所有</span>指定的事件标志都满⾜时才唤醒线程。</li>\n<li><code>RT_EVENT_FLAG_OR</code> ：<span style=\"color:#3399FF;\">只要有⼀个</span>指定的事件标志满⾜就唤醒线程。</li>\n<li><code>RT_EVENT_FLAG_CLEAR</code> ：<span style=\"color:#3399FF;\">收到</span>事件标志后<span style=\"color:#3399FF;\">清除</span>这些事件标志。</li>\n</ul>\n</li>\n<li><code>timeout</code> ：超时时间（单位为系统 tick），可以为 <code>RT_WAITING_FOREVER</code> 表⽰永远等待。</li>\n<li><code>recved</code> ：输出参数，返回实际接收到的事件标志</li>\n</ul>\n<h4 id=\"应用示例-2\"><a href=\"#应用示例-2\" class=\"headerlink\" title=\"应用示例\"></a><strong>应用示例</strong></h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;rtthread.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">rt_event_t</span> event = RT_NULL;</span><br><span class=\"line\"><span class=\"comment\">/*线程1：等待事件*/</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">thread1</span><span class=\"params\">(<span class=\"type\">void</span> *parameter)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   <span class=\"type\">rt_uint32_t</span> recei;</span><br><span class=\"line\">   rt_kprintf(<span class=\"string\">&quot;线程1：等待公交车3或5到来...\\n&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">   rt_event_recv(event, (<span class=\"number\">1</span> &lt;&lt; <span class=\"number\">3</span> | <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">5</span>), RT_EVENT_FLAG_OR | RT_EVENT_FLAG_CLEAR, RT_WAITING_FOREVER, &amp;recei);</span><br><span class=\"line\"></span><br><span class=\"line\">   rt_kprintf(<span class=\"string\">&quot;线程1：公交车 %d 到站，出发！....\\n&quot;</span>,recei);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*线程2：发送事件（公交车到站）*/</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">thread2</span><span class=\"params\">(<span class=\"type\">void</span> *parameter)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   rt_thread_mdelay(<span class=\"number\">1000</span>);<span class=\"comment\">//模拟公交车到站</span></span><br><span class=\"line\">   rt_kprintf(<span class=\"string\">&quot;线程2：公交车3到站\\n&quot;</span>);</span><br><span class=\"line\">   rt_event_send(event, (<span class=\"number\">1</span> &lt;&lt; <span class=\"number\">3</span>));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">rt_thread_t</span> tid1 = RT_NULL;</span><br><span class=\"line\">    <span class=\"type\">rt_thread_t</span> tid2 = RT_NULL;</span><br><span class=\"line\"></span><br><span class=\"line\">    event = rt_event_create(<span class=\"string\">&quot;event&quot;</span>, RT_IPC_FLAG_PRIO);</span><br><span class=\"line\">    tid1 = rt_thread_create(<span class=\"string\">&quot;tid1&quot;</span>, thread1, RT_NULL, <span class=\"number\">1024</span>, <span class=\"number\">25</span>, <span class=\"number\">100</span>);</span><br><span class=\"line\">    tid2 = rt_thread_create(<span class=\"string\">&quot;tid2&quot;</span>, thread2, RT_NULL, <span class=\"number\">1024</span>, <span class=\"number\">25</span>, <span class=\"number\">100</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(tid1 != RT_NULL) rt_thread_startup(tid1);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(tid2 != RT_NULL) rt_thread_startup(tid2);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"线程间通信\"><a href=\"#线程间通信\" class=\"headerlink\" title=\"线程间通信\"></a><strong>线程间通信</strong></h2><p>裸机编程中经常使用全局变量进行功能间的通信（标志）：某些功能由于特定的操作改变全局变量的值，另一个功能对此全局变量进行读取，根据读取到的全局变量执行相应的操作来达到通信协作的目的。RTT提供了邮箱、消息队列和信号等工具来完成这样的类似操作</p>\n<h3 id=\"邮箱\"><a href=\"#邮箱\" class=\"headerlink\" title=\"邮箱\"></a><strong>邮箱</strong></h3><h4 id=\"工作机制-3\"><a href=\"#工作机制-3\" class=\"headerlink\" title=\"工作机制\"></a>工作机制</h4><p>邮箱的特点：开销低、效率高、支持一对多</p>\n<p>邮箱中一封邮件<strong>只能容纳固定的4字节信息</strong>（针对32位操作系统，指针大小为4字节，一封邮件恰好能容纳一个指针），所以典型的邮箱也被称为交换消息</p>\n<blockquote>\n<p>一般如果邮箱中<span style=\"color:#3399FF;\">存在邮件</span>且收取邮件时的<span style=\"color:#3399FF;\">超时时间为0</span>，邮件的收取过程是<span style=\"font-weight:bold;\">非阻塞</span>的</p>\n<p>但邮箱中<span style=\"color:#3399FF;\">不存在邮件</span>且<span style=\"color:#3399FF;\">超时时间不为0</span>时，邮件收取过程就是<span style=\"font-weight:bold;\">阻塞</span>的，邮件收取阻塞的情况下只能由线程进行邮件的收取。</p>\n</blockquote>\n<ul>\n<li><p><code>邮件发送阻塞</code>：一个线程向邮箱发送邮件时：</p>\n<ul>\n<li>如果邮箱未满，则把邮件复制到邮箱中</li>\n<li>如果邮箱已满，则<span style=\"color:#3399FF;\">发送线程挂起</span>并等待邮箱有空间时将其唤醒再发送邮件 或 直接返回<code>-RT_EFULL</code></li>\n</ul>\n</li>\n<li><p><code>邮件接收阻塞</code>：一个线程从邮箱中接收邮件时：</p>\n<ul>\n<li>如果邮箱已空，接收线程可以挂起直到收到新的邮件被唤醒 <code>也可以设置超时时间并进行等待</code></li>\n<li>如果达到设置的超时时间<span style=\"color:#00FFFF;\">但邮箱仍未收到邮件</span>时，超时线程将被唤醒并返回<code>-RT_ETIMEOUT</code>；</li>\n<li>如果邮箱中存在邮件，则接收线程赋值邮箱中的邮件到接收缓存</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"创建邮箱\"><a href=\"#创建邮箱\" class=\"headerlink\" title=\"创建邮箱\"></a><strong>创建邮箱</strong></h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*创建动态邮箱*/</span></span><br><span class=\"line\"><span class=\"type\">rt_mailbox_t</span> <span class=\"title function_\">rt_mb_create</span> <span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">char</span>* name, <span class=\"type\">rt_size_t</span> size, <span class=\"type\">rt_uint8_t</span> flag)</span>;</span><br><span class=\"line\"><span class=\"comment\">/*创建静态邮箱*/</span></span><br><span class=\"line\"><span class=\"type\">rt_err_t</span> <span class=\"title function_\">rt_mb_init</span><span class=\"params\">(<span class=\"type\">rt_mailbox_t</span> mb,<span class=\"type\">const</span> <span class=\"type\">char</span>* name,<span class=\"type\">void</span>* msgpool,<span class=\"type\">rt_size_t</span> size,<span class=\"type\">rt_uint8_t</span> flag)</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><span style=\"color:#3399FF;\">参数说明</span>：</li>\n<li><code>mb</code>：邮箱对象的句柄。</li>\n<li><code>name</code>：邮箱容量(几封邮件)</li>\n<li><code>size</code> ：邮箱容量(几封邮件)。</li>\n<li><code>flag</code> ：邮箱标志，它可以取如下数值：<code>一般除非应用程序非常在意先来后到，不然都采用PRIO确保线程实时性</code><ul>\n<li><code>RT_IPC_FLAG_FIFO</code> ：非实时调度方式 先来后到</li>\n<li><code>RT_IPC_FLAG_PRIO</code> ：实时调度方式 优先级</li>\n</ul>\n</li>\n<li><code>msgpool</code> ：缓冲区指针。</li>\n<li><code>recved</code> ：输出参数，返回实际接收到的事件标志</li>\n</ul>\n<h5 id=\"删除或脱离邮箱\"><a href=\"#删除或脱离邮箱\" class=\"headerlink\" title=\"删除或脱离邮箱\"></a><strong>删除或脱离邮箱</strong></h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*删除动态邮箱create*/</span></span><br><span class=\"line\"><span class=\"type\">rt_err_t</span> <span class=\"title function_\">rt_mb_delete</span> <span class=\"params\">(<span class=\"type\">rt_mailbox_t</span> mb)</span>;</span><br><span class=\"line\"><span class=\"comment\">/*删除静态邮箱init*/</span></span><br><span class=\"line\"><span class=\"type\">rt_err_t</span> <span class=\"title function_\">rt_mb_detach</span><span class=\"params\">(<span class=\"type\">rt_mailbox_t</span> mb)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//返回值：RT_EOK 成功</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><span style=\"color:#3399FF;\">参数说明</span>：</li>\n<li><code>mb</code>：邮箱对象的句柄。</li>\n</ul>\n<blockquote>\n<p>调用删除函数时，内核会<span style=\"color:#00FFFF;\">先唤醒所有</span>挂在该邮箱上的线程（线程返回值是<code>RT_ERROR</code>），然后<span style=\"color:#00FFFF;\">再释放</span>邮箱使用的<span style=\"color:#00FFFF;\">内存</span>，最后<span style=\"color:#00FFFF;\">删除邮箱对象</span></p>\n</blockquote>\n<h5 id=\"发送邮件\"><a href=\"#发送邮件\" class=\"headerlink\" title=\"发送邮件\"></a><strong>发送邮件</strong></h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*1.直接发送邮件*/</span></span><br><span class=\"line\"><span class=\"comment\">/*！！！！！记得value需要强转rt_uint32_t！！！！！*/</span></span><br><span class=\"line\"><span class=\"type\">rt_err_t</span> <span class=\"title function_\">rt_mb_send</span> <span class=\"params\">(<span class=\"type\">rt_mailbox_t</span> mb, <span class=\"type\">rt_uint32_t</span> value)</span>;</span><br><span class=\"line\"><span class=\"comment\">/**************返回值*****************/</span></span><br><span class=\"line\">RT_EOK        发送成功</span><br><span class=\"line\">-RT_EFULL      邮箱已经满了</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*2.等待方式发送邮件*/</span></span><br><span class=\"line\"><span class=\"comment\">/*@note 若邮箱已满，则根据设定的timeout等待邮箱中因为收取邮件而空出空间</span></span><br><span class=\"line\"><span class=\"comment\">/*@note 若超时时间到达依然没有空出时间，此时发送线程被唤醒并返回错误码</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"type\">rt_err_t</span> <span class=\"title function_\">rt_mb_send_wait</span> <span class=\"params\">(<span class=\"type\">rt_mailbox_t</span> mb,<span class=\"type\">rt_uint32_t</span> value,<span class=\"type\">rt_int32_t</span> timeout)</span>;</span><br><span class=\"line\"><span class=\"comment\">/**************返回值*****************/</span></span><br><span class=\"line\">RT_EOK        发送成功</span><br><span class=\"line\">-RT_ETIMEOUT     超时</span><br><span class=\"line\">-RT_ERROR    失败，返回错误</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*3.发送紧急邮件*/</span></span><br><span class=\"line\"><span class=\"comment\">/*@note 发送紧急邮件时，邮件被直接插队放入了邮件队首,这样就能最优先接收到并做出处理</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"type\">rt_err_t</span> <span class=\"title function_\">rt_mb_urgent</span> <span class=\"params\">(<span class=\"type\">rt_mailbox_t</span> mb, <span class=\"type\">rt_ubase_t</span> value)</span>;</span><br><span class=\"line\"><span class=\"comment\">/**************返回值*****************/</span></span><br><span class=\"line\">RT_EOK       发送成功</span><br><span class=\"line\">-RT_EFULL    邮箱已满</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><span style=\"color:#3399FF;\">参数说明</span>：</li>\n<li><code>mb</code>：邮箱对象的句柄。</li>\n<li><code>value</code> ：发送的邮件内容。</li>\n<li><code>timeout</code> ：超时时间。</li>\n</ul>\n<h5 id=\"接收邮件\"><a href=\"#接收邮件\" class=\"headerlink\" title=\"接收邮件\"></a><strong>接收邮件</strong></h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*@note 只有当接收者接收的邮箱中有邮件时，接收者才能立即取到邮件并返回 RT_EOK 的返回值</span></span><br><span class=\"line\"><span class=\"comment\">否则接收线程会根据超时时间设置，或挂起在邮箱的等待线程队列上，或直接返回。</span></span><br><span class=\"line\"><span class=\"comment\">！！！！！记得value需要强转rt_uint32_t！！！！！</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"type\">rt_err_t</span> <span class=\"title function_\">rt_mb_recv</span> <span class=\"params\">(<span class=\"type\">rt_mailbox_t</span> mb, <span class=\"type\">rt_uint32_t</span>* value, <span class=\"type\">rt_int32_t</span> timeout)</span>;</span><br><span class=\"line\"><span class=\"comment\">/**************返回值*****************/</span></span><br><span class=\"line\">RT_EOK        接收成功</span><br><span class=\"line\">-RT_ETIMEOUT     超时</span><br><span class=\"line\">-RT_ERROR    失败，返回错误</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><span style=\"color:#3399FF;\">参数说明</span>：</li>\n<li><code>mb</code>：邮箱对象的句柄。</li>\n<li><code>value</code> ：邮件内容<code>(定义一个变量来接收 记得强转)</code></li>\n<li><code>timeout</code> ：超时时间。</li>\n</ul>\n<h4 id=\"应用示例-3\"><a href=\"#应用示例-3\" class=\"headerlink\" title=\"应用示例\"></a><strong>应用示例</strong></h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;rtthread.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*创建邮箱*/</span></span><br><span class=\"line\"><span class=\"type\">rt_mailbox_t</span> mb;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*线程1：发送邮箱*/</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">thread_entry1</span><span class=\"params\">(<span class=\"type\">void</span> *parameter)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">char</span> msg = <span class=\"string\">&#x27;A&#x27;</span>;<span class=\"comment\">//发送&#x27;A&#x27;作为邮件</span></span><br><span class=\"line\">    rt_kprintf(<span class=\"string\">&quot;线程1：发送邮件...\\n&quot;</span>);</span><br><span class=\"line\">    <span class=\"comment\">//发送邮件  因为邮箱固定4字节 所以需要强转</span></span><br><span class=\"line\">    rt_mb_send(mb, (<span class=\"type\">rt_uint32_t</span>)msg);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*线程2：接收邮件*/</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">thread_entry2</span><span class=\"params\">(<span class=\"type\">void</span> *parameter)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   <span class=\"type\">char</span> msg;</span><br><span class=\"line\">   rt_kprintf(<span class=\"string\">&quot;线程2：等待接收邮件...\\n&quot;</span>);</span><br><span class=\"line\">   <span class=\"comment\">//若邮箱内为空  则执行的是阻塞式的等待接收邮件</span></span><br><span class=\"line\">   rt_mb_recv(mb, (<span class=\"type\">rt_uint32_t</span>)&amp;msg, RT_WAITING_FOREVER);<span class=\"comment\">//接收邮件</span></span><br><span class=\"line\">   rt_kprintf(<span class=\"string\">&quot;线程2：收到邮件：%c\\n&quot;</span>,msg);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">/*创建一个容量为4的4封邮箱(大小为4*4)) */</span></span><br><span class=\"line\">    mb = rt_mb_create(<span class=\"string\">&quot;mb&quot;</span>, <span class=\"number\">4</span>, RT_IPC_FLAG_PRIO);</span><br><span class=\"line\">    <span class=\"comment\">/*创建两个线程 */</span></span><br><span class=\"line\">    <span class=\"type\">rt_thread_t</span> tid1 = rt_thread_create(<span class=\"string\">&quot;t1&quot;</span>, thread_entry1, RT_NULL, <span class=\"number\">1024</span>, <span class=\"number\">10</span>,</span><br><span class=\"line\">    <span class=\"number\">10</span>);</span><br><span class=\"line\">    <span class=\"type\">rt_thread_t</span> tid2 = rt_thread_create(<span class=\"string\">&quot;t2&quot;</span>, thread_entry2, RT_NULL, <span class=\"number\">1024</span>, <span class=\"number\">10</span>,</span><br><span class=\"line\">    <span class=\"number\">10</span>);</span><br><span class=\"line\">    <span class=\"comment\">/* 启动线程 */</span></span><br><span class=\"line\">    rt_thread_startup(tid1);</span><br><span class=\"line\">    rt_thread_startup(tid2);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"消息队列\"><a href=\"#消息队列\" class=\"headerlink\" title=\"消息队列\"></a><strong>消息队列</strong></h3><p>消息队列是另一种常用的线程间通讯方式，是邮箱的扩展。他可以动态分配内存，对比邮箱局限的4字节存储特性，更适合用来传输复杂大量数据或进行任务队列管理</p>\n<h4 id=\"工作机制-4\"><a href=\"#工作机制-4\" class=\"headerlink\" title=\"工作机制\"></a><strong>工作机制</strong></h4><h5 id=\"创建消息队列\"><a href=\"#创建消息队列\" class=\"headerlink\" title=\"创建消息队列\"></a><strong>创建消息队列</strong></h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*创建动态消息队列*/</span></span><br><span class=\"line\"><span class=\"type\">rt_mq_t</span> <span class=\"title function_\">rt_mq_create</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">char</span>* name, <span class=\"type\">rt_size_t</span> msg_size,<span class=\"type\">rt_size_t</span> max_msgs, <span class=\"type\">rt_uint8_t</span> flag)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*创建静态消息队列*/</span></span><br><span class=\"line\"><span class=\"comment\">/*@note 一般放于读数据段或未初始化数据段中。在使用这类静态消息队列对象前，需要进行初始化</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"type\">rt_err_t</span> <span class=\"title function_\">rt_mq_init</span><span class=\"params\">(<span class=\"type\">rt_mq_t</span> mq, <span class=\"type\">const</span> <span class=\"type\">char</span>* name,<span class=\"type\">void</span> *msgpool,<span class=\"type\">rt_size_t</span> msg_size,<span class=\"type\">rt_size_t</span> pool_size, <span class=\"type\">rt_uint8_t</span> flag)</span>;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p><span style=\"color:#3399FF;\">参数说明</span>：</p>\n</li>\n<li><p><code>name </code>：消息队列的名称。</p>\n</li>\n<li><p><code>msg_size </code> ：消息队列中一条消息的最大长度，<span style=\"color:#00FFFF;\">单位字节</span>。</p>\n</li>\n<li><p><code>msg_msgs</code>：消息队列的最大个数(消息个数)。</p>\n</li>\n<li><p><code>flag</code> ：消息队列采用的等待方式，它可以取如下数值：<code>一般除非应用程序非常在意先来后到，不然都采用PRIO确保线程实时性</code></p>\n<ul>\n<li><p><code>RT_IPC_FLAG_FIFO</code>：非实时调度方式 先来后到</p>\n</li>\n<li><p><code>RT_IPC_FLAG_PRIO</code>：实时调度方式 优先级</p>\n</li>\n</ul>\n</li>\n<li><p><code>mq</code> ：消息队列对象的句柄。</p>\n</li>\n<li><p><code>msgpool</code>：指向存放消息的缓冲区的指针。</p>\n</li>\n<li><p><code>pool_size</code> ：存放消息的缓冲区大小</p>\n</li>\n</ul>\n<h5 id=\"删除或脱离消息队列\"><a href=\"#删除或脱离消息队列\" class=\"headerlink\" title=\"删除或脱离消息队列\"></a><strong>删除或脱离消息队列</strong></h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*删除动态消息队列create*/</span></span><br><span class=\"line\"><span class=\"type\">rt_err_t</span> <span class=\"title function_\">rt_mq_delete</span><span class=\"params\">(<span class=\"type\">rt_mq_t</span> mq)</span>;</span><br><span class=\"line\"><span class=\"comment\">/*删除静态消息队列init*/</span></span><br><span class=\"line\"><span class=\"type\">rt_err_t</span> <span class=\"title function_\">rt_mq_detach</span><span class=\"params\">(<span class=\"type\">rt_mq_t</span> mq)</span>;</span><br><span class=\"line\"><span class=\"comment\">//返回值：RT_EOK 成功</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><span style=\"color:#3399FF;\">参数说明</span>：</li>\n<li><code>mq</code>：消息队列对象的句柄</li>\n</ul>\n<blockquote>\n<p>删除消息队列时，如果<span style=\"color:#00FFFF;\">有线程</span>被挂起在该消息队列等待队列上，则内核<span style=\"color:#00FFFF;\">先唤醒挂起</span>在该消息等待队列上的所有线程（线程返回值是 <code>- RT_ERROR</code>），然后再<span style=\"color:#00FFFF;\">释放</span>消息队列使用的内存，最后<span style=\"color:#00FFFF;\">删除</span>消息队列对象</p>\n</blockquote>\n<h5 id=\"发送消息\"><a href=\"#发送消息\" class=\"headerlink\" title=\"发送消息\"></a><strong>发送消息</strong></h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*1.直接发送消息*/</span></span><br><span class=\"line\"><span class=\"type\">rt_err_t</span> <span class=\"title function_\">rt_mq_send</span> <span class=\"params\">(<span class=\"type\">rt_mq_t</span> mq, <span class=\"type\">void</span>* buffer, <span class=\"type\">rt_size_t</span> size)</span>;</span><br><span class=\"line\"><span class=\"comment\">/**************返回值*****************/</span></span><br><span class=\"line\">RT_EOK        发送成功</span><br><span class=\"line\">-RT_EFULL      消息队列已经满了</span><br><span class=\"line\">-RT_ERROR       失败(发送消息长度&gt;队列的最大长度)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*2.等待方式发送消息*/</span></span><br><span class=\"line\"><span class=\"comment\">/*@note 若消息队列已满，则根据设定的timeout等待</span></span><br><span class=\"line\"><span class=\"comment\">/*@note 若超时时间到达依然没有空出时间，此时发送线程被唤醒并返回错误码</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"type\">rt_err_t</span> <span class=\"title function_\">rt_mq_send_wait</span><span class=\"params\">(<span class=\"type\">rt_mq_t</span> mq,<span class=\"type\">const</span> <span class=\"type\">void</span> *buffer,<span class=\"type\">rt_size_t</span> size,<span class=\"type\">rt_int32_t</span>  timeout)</span>;</span><br><span class=\"line\"><span class=\"comment\">/**************返回值*****************/</span></span><br><span class=\"line\">RT_EOK        发送成功</span><br><span class=\"line\">-RT_ETIMEOUT     超时</span><br><span class=\"line\">-RT_ERROR    失败(发送消息长度&gt;队列的最大长度)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*3.发送紧急消息*/</span></span><br><span class=\"line\"><span class=\"comment\">/*@note 发送紧急消息时，邮件被直接插队放入了消息队列队首,这样就能最优先接收到并做出处理</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"type\">rt_err_t</span> <span class=\"title function_\">rt_mq_urgent</span><span class=\"params\">(<span class=\"type\">rt_mq_t</span> mq, <span class=\"type\">void</span>* buffer, <span class=\"type\">rt_size_t</span> size)</span>;</span><br><span class=\"line\"><span class=\"comment\">/**************返回值*****************/</span></span><br><span class=\"line\">RT_EOK       发送成功</span><br><span class=\"line\">-RT_EFULL    消息队列已经满了</span><br><span class=\"line\">-RT_ERROR    失败(发送消息长度&gt;队列的最大长度)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><span style=\"color:#3399FF;\">参数说明</span>：</li>\n<li><code>mq</code>：消息队列对象的句柄</li>\n<li><code>buffer</code> ：发送的消息内容。</li>\n<li><code>size</code> ：消息大小。</li>\n<li><code>timeout</code> ：超时时间。</li>\n</ul>\n<h5 id=\"接收消息\"><a href=\"#接收消息\" class=\"headerlink\" title=\"接收消息\"></a><strong>接收消息</strong></h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*@note 只有当消息队列中有消息时，接收者才能立即取到邮件并返回 RT_EOK 的返回值</span></span><br><span class=\"line\"><span class=\"comment\">否则接收线程会根据超时时间设置，或挂起在邮箱的等待线程队列上，或直接返回。</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"type\">rt_ssize_t</span> <span class=\"title function_\">rt_mq_recv</span> <span class=\"params\">(<span class=\"type\">rt_mq_t</span> mq, <span class=\"type\">void</span>* buffer,<span class=\"type\">rt_size_t</span> size,<span class=\"type\">rt_int32_t</span> timeout)</span>;</span><br><span class=\"line\"><span class=\"comment\">/**************返回值*****************/</span></span><br><span class=\"line\">RT_EOK             成功收到</span><br><span class=\"line\">-RT_ETIMEOUT             超时</span><br><span class=\"line\">-RT_ERROR            失败，返回错误</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><span style=\"color:#3399FF;\">参数说明</span>：</li>\n<li><code>mq</code>：消息队列对象的句柄</li>\n<li><code>buffer</code> ：发送的消息内容。</li>\n<li><code>size</code> ：消息大小。</li>\n<li><code>timeout</code> ：超时时间</li>\n</ul>\n<h4 id=\"应用示例-4\"><a href=\"#应用示例-4\" class=\"headerlink\" title=\"应用示例\"></a><strong>应用示例</strong></h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;rtthread.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*创建消息队列*/</span></span><br><span class=\"line\"><span class=\"type\">rt_mq_t</span> mq;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*线程1：发送消息*/</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">thread_entry1</span><span class=\"params\">(<span class=\"type\">void</span> *parameter)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">char</span> msg[] = <span class=\"string\">&quot;Hello, RT-Thread!&quot;</span>;<span class=\"comment\">//发送&#x27;A&#x27;作为邮件</span></span><br><span class=\"line\">    rt_kprintf(<span class=\"string\">&quot;线程1：发送消息...\\n&quot;</span>);</span><br><span class=\"line\">    <span class=\"comment\">//发送消息到消息队列</span></span><br><span class=\"line\">    rt_mq_send(mq, msg,<span class=\"keyword\">sizeof</span>(msg));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*线程2：接收邮件*/</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">thread_entry2</span><span class=\"params\">(<span class=\"type\">void</span> *parameter)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   <span class=\"type\">char</span> buffer[<span class=\"number\">32</span>];</span><br><span class=\"line\">   rt_kprintf(<span class=\"string\">&quot;线程2：等待接收消息...\\n&quot;</span>);</span><br><span class=\"line\">   <span class=\"comment\">//若消息队列内无消息  则执行的是阻塞式的等待接收消息</span></span><br><span class=\"line\">   rt_mq_recv(mq, buffer,<span class=\"keyword\">sizeof</span>(buffer), RT_WAITING_FOREVER);<span class=\"comment\">//接收消息</span></span><br><span class=\"line\">   rt_kprintf(<span class=\"string\">&quot;线程2：收到消息：%s\\n&quot;</span>,buffer);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">/*创建一个消息队列，容量为4，消息大小为32字节 */</span></span><br><span class=\"line\">    mq = rt_mq_create(<span class=\"string\">&quot;mq&quot;</span>, <span class=\"number\">32</span>, <span class=\"number\">4</span>, RT_IPC_FLAG_PRIO);</span><br><span class=\"line\">    <span class=\"comment\">/*创建两个线程 */</span></span><br><span class=\"line\">    <span class=\"type\">rt_thread_t</span> tid1 = rt_thread_create(<span class=\"string\">&quot;t1&quot;</span>, thread_entry1, RT_NULL, <span class=\"number\">1024</span>, <span class=\"number\">10</span>,</span><br><span class=\"line\">    <span class=\"number\">10</span>);</span><br><span class=\"line\">    <span class=\"type\">rt_thread_t</span> tid2 = rt_thread_create(<span class=\"string\">&quot;t2&quot;</span>, thread_entry2, RT_NULL, <span class=\"number\">1024</span>, <span class=\"number\">10</span>,</span><br><span class=\"line\">    <span class=\"number\">10</span>);</span><br><span class=\"line\">    <span class=\"comment\">/* 启动线程 */</span></span><br><span class=\"line\">    rt_thread_startup(tid1);</span><br><span class=\"line\">    rt_thread_startup(tid2);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"信号\"><a href=\"#信号\" class=\"headerlink\" title=\"信号\"></a><strong>信号</strong></h3><p><code>信号（又称为软中断信号）</code>，在软件层次上是对中断机制的一种模拟。常用于通知线程发生了某个事件。线程收到信号时会根据信号类型执行相应的操作</p>\n<ul>\n<li>与消息队列区别：</li>\n</ul>\n<ol>\n<li><p><span style=\"color:#00FFFF;\">信号仅携带控制信息，不包含数据</span></p>\n</li>\n<li><p>信号不保证顺序性，<span style=\"color:#00FFFF;\">信号发生时立即通知线程</span></p>\n</li>\n<li><p>消息队列则有顺序性（通常是PRIO）</p>\n</li>\n</ol>\n<h4 id=\"工作机制-5\"><a href=\"#工作机制-5\" class=\"headerlink\" title=\"工作机制\"></a><strong>工作机制</strong></h4><h5 id=\"线程中安装信号\"><a href=\"#线程中安装信号\" class=\"headerlink\" title=\"线程中安装信号\"></a><strong>线程中安装信号</strong></h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">t_sighandler_t[] 表示一个函数指针数组</span></span><br><span class=\"line\"><span class=\"comment\">t_sighandler_t handler[] 是一个 变量声明</span></span><br><span class=\"line\"><span class=\"comment\">二者是不一样的！</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"type\">rt_sighandler_t</span> <span class=\"title function_\">rt_signal_install</span><span class=\"params\">(<span class=\"type\">int</span> signo, <span class=\"type\">rt_sighandler_t</span>[] handler)</span>;</span><br><span class=\"line\"><span class=\"comment\">/**************返回值*****************/</span></span><br><span class=\"line\">SIG_ERR                错误的信号</span><br><span class=\"line\">安装信号前的handler值    成功</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><span style=\"color:#3399FF;\">参数说明</span>：</li>\n<li><code>signo </code>：信号值（只有 <code>SIGUSR1</code> 和 <code>SIGUSR2</code> 是开放给用户使用的）。</li>\n<li><code>buffer</code> ：发送的消息内容。</li>\n<li><code>handler</code> ：设置对信号值的处理方式。</li>\n</ul>\n<blockquote>\n<p> 在信号安装时设定 handler 参数，决定了该信号的不同的处理方法。处理方法可以分为三种：</p>\n<ol>\n<li><p>类似<code>中断</code>的处理方式，参数指向当信号发生时用户<code>自定义的处理函数</code>， 在内部写入处理方式，由该函数来处理。</p>\n</li>\n<li><p>参数设为 <code>SIG_IGN</code>，忽略某个信号，<code>对该信号不做任何处理</code>，就像未发生过一样。</p>\n</li>\n<li><p>参数设为 <code>SIG_DFL</code>，系统会调用默认的处理函数<code>_signal_default_handler()</code>。</p>\n</li>\n</ol>\n</blockquote>\n<h5 id=\"阻塞信号与解除阻塞\"><a href=\"#阻塞信号与解除阻塞\" class=\"headerlink\" title=\"阻塞信号与解除阻塞\"></a><strong>阻塞信号与解除阻塞</strong></h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*信号阻塞(屏蔽信号) 该信号不会递答安装此信号的线程*/</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">rt_signal_mask</span><span class=\"params\">(<span class=\"type\">int</span> signo)</span>;</span><br><span class=\"line\"><span class=\"comment\">/*解除信号阻塞</span></span><br><span class=\"line\"><span class=\"comment\">使用此函数可以对其中一些信号给予 “关注”，那么发送这些信号都会引发该线程的软中断</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">rt_signal_unmask</span><span class=\"params\">(<span class=\"type\">int</span> signo)</span>;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><span style=\"color:#3399FF;\">参数说明</span>：</li>\n<li><code>signo</code>：信号值</li>\n</ul>\n<h5 id=\"发送信号\"><a href=\"#发送信号\" class=\"headerlink\" title=\"发送信号\"></a><strong>发送信号</strong></h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*需要异常处理时，可以给安装了信号的线程发送信号*/</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">rt_thread_kill</span><span class=\"params\">(<span class=\"type\">rt_thread_t</span> tid, <span class=\"type\">int</span> sig)</span>;</span><br><span class=\"line\"><span class=\"comment\">/**************返回值*****************/</span></span><br><span class=\"line\">RT_EOK        发送成功</span><br><span class=\"line\">-RT_EINVAL    参数错误</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><span style=\"color:#3399FF;\">参数说明</span>：</li>\n<li><code>tid</code>：接收信号的线程。</li>\n<li><code>sig </code>：信号值。</li>\n</ul>\n<h4 id=\"应用示例-5\"><a href=\"#应用示例-5\" class=\"headerlink\" title=\"应用示例\"></a><strong>应用示例</strong></h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;rtthread.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> THREAD_PRIORITY         25</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> THREAD_STACK_SIZE       512</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> THREAD_TIMESLICE        5</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">rt_thread_t</span> tid1 = RT_NULL;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 线程 1 的信号处理函数 */</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">thread1_signal_handler</span><span class=\"params\">(<span class=\"type\">int</span> sig)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    rt_kprintf(<span class=\"string\">&quot;thread1 received signal %d\\n&quot;</span>, sig);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 线程 1 的入口函数 */</span></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title function_\">thread1_entry</span><span class=\"params\">(<span class=\"type\">void</span> *parameter)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* 安装信号 */</span></span><br><span class=\"line\">    rt_signal_install(SIGUSR1, thread1_signal_handler);</span><br><span class=\"line\">    rt_signal_unmask(SIGUSR1);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* 运行 10 次 */</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (cnt &lt; <span class=\"number\">10</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">/* 线程 1 采用低优先级运行，一直打印计数值 */</span></span><br><span class=\"line\">        rt_kprintf(<span class=\"string\">&quot;thread1 count : %d\\n&quot;</span>, cnt);</span><br><span class=\"line\"></span><br><span class=\"line\">        cnt++;</span><br><span class=\"line\">        rt_thread_mdelay(<span class=\"number\">100</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 信号示例的初始化 */</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">signal_sample</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">/* 创建线程 1 */</span></span><br><span class=\"line\">    tid1 = rt_thread_create(<span class=\"string\">&quot;thread1&quot;</span>,thread1_entry, RT_NULL,THREAD_STACK_SIZE, THREAD_PRIORITY, THREAD_TIMESLICE);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tid1 != RT_NULL)</span><br><span class=\"line\">        rt_thread_startup(tid1);</span><br><span class=\"line\"></span><br><span class=\"line\">    rt_thread_mdelay(<span class=\"number\">300</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* 发送信号 SIGUSR1 给线程 1 */</span></span><br><span class=\"line\">    rt_thread_kill(tid1, SIGUSR1);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"框架移植\"><a href=\"#框架移植\" class=\"headerlink\" title=\"框架移植\"></a><strong>框架移植</strong></h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//bsp_system.h中引入以下四个头文件</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;rtthread.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;rtdevice.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;drv_common.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;board.h&gt;</span></span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"系统初始化宏定义\"><a href=\"#系统初始化宏定义\" class=\"headerlink\" title=\"系统初始化宏定义\"></a><strong>系统初始化宏定义</strong></h3><p>​    <img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505222143758.png\" alt=\"image-20250522214349807\"></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*1、板级初始化 fn为函数指针*/</span></span><br><span class=\"line\">INIT_BOARD_EXPORT(fn)</span><br><span class=\"line\"><span class=\"comment\">/*2、纯软件函数初始化 fn为函数指针*/</span></span><br><span class=\"line\">INIT_PREV_EXPORT(fn)</span><br><span class=\"line\"><span class=\"comment\">/*3、设备自动初始化，fn为函数指针*/</span></span><br><span class=\"line\">INIT_DEVICE_EXPORT(fn)</span><br><span class=\"line\"><span class=\"comment\">/*4、组件自动初始化，fn为函数指针*/</span></span><br><span class=\"line\">INIT_COMPONENT_EXPORT(fn)</span><br><span class=\"line\"><span class=\"comment\">/*5、系统环境自动初始化，fn为函数指针*/</span></span><br><span class=\"line\">INIT_ENV_EXPORT(fn) </span><br><span class=\"line\"><span class=\"comment\">/*6、应用自动初始化，fn为函数指针*/</span></span><br><span class=\"line\">INIT_APP_EXPORT(fn)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"ESP8266移植\"><a href=\"#ESP8266移植\" class=\"headerlink\" title=\"ESP8266移植\"></a><strong>ESP8266移植</strong></h3><blockquote>\n<p>将<code>uart_app.c</code>与<code>uart_app.h</code>移去 不使用！！！然后RTT打开控制台输出rt_kprintf，选择串口1</p>\n</blockquote>\n<p>   <img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505222145092.png\" alt=\"image-20250522214536841\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505222204947.png\" alt=\"image-20250522220417747\"> <img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505222204548.png\" alt=\"image-20250522220447380\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505222147073.png\" alt=\"image-20250522214750185\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505222147664.png\" alt=\"image-20250522214705123\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505222148942.png\" alt=\"image-20250522214840651\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505222149729.png\" alt=\"image-20250522214859546\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505222149203.png\" alt=\"image-20250522214917115\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505222149796.png\" alt=\"image-20250522214947877\"></p>\n<p>直接编译开启终端 下载观察现象，出现以下信息则连接成功</p>\n<p>​    <img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505222150747.png\" alt=\"image-20250522215015453\"></p>\n<h3 id=\"DHT11移植\"><a href=\"#DHT11移植\" class=\"headerlink\" title=\"DHT11移植\"></a><strong>DHT11移植</strong></h3><h4 id=\"组件添加\"><a href=\"#组件添加\" class=\"headerlink\" title=\"组件添加\"></a><strong>组件添加</strong></h4><p>​    <img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505222151707.png\" alt=\"image-20250522215146162\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505222152193.png\" alt=\"image-20250522215207600\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505222203028.png\" alt=\"image-20250522220342327\"></p>\n<h4 id=\"proc代码构建\"><a href=\"#proc代码构建\" class=\"headerlink\" title=\"proc代码构建\"></a><strong>proc代码构建</strong></h4><h5 id=\"创建sensor-app-c与-h\"><a href=\"#创建sensor-app-c与-h\" class=\"headerlink\" title=\"创建sensor_app.c与.h\"></a><strong>创建sensor_app.c与.h</strong></h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//引入必要库</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sensor_app.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sensor.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;sensor_dallas_dht11.h&quot;</span></span></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"注册设备\"><a href=\"#注册设备\" class=\"headerlink\" title=\"注册设备\"></a><strong>注册设备</strong></h5><pre><code><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">rt_device_t</span> dev = RT_NULL;</span><br><span class=\"line\"><span class=\"comment\">//创建传感器结构体对象</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">rt_sensor_data</span> <span class=\"title\">sensor_data</span>;</span></span><br><span class=\"line\"><span class=\"type\">rt_uint8_t</span> get_data_freq = <span class=\"number\">1</span>;<span class=\"comment\">///默认1hz</span></span><br><span class=\"line\"><span class=\"type\">rt_size_t</span> res;<span class=\"comment\">//返回值 如RT_EOK</span></span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">/*注册传感器*/</span></span><br><span class=\"line\">dev =  rt_device_find(<span class=\"string\">&quot;temp_dht11&quot;</span>);<span class=\"comment\">//注意此处注册需要有前缀 如temp_(在sensor.c中)</span></span><br><span class=\"line\"><span class=\"keyword\">if</span>(dev == RT_NULL)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    rt_kprintf(<span class=\"string\">&quot;Not Found\\r\\n&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">if</span>(rt_device_open(dev, RT_DEVICE_FLAG_RDWR) != RT_EOK)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    rt_kprintf(<span class=\"string\">&quot;Open Error\\r\\n&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">rt_device_control(dev, RT_SENSOR_CTRL_SET_ODR, (<span class=\"type\">void</span> *)&amp;get_data_freq);</span><br></pre></td></tr></table></figure>\n</code></pre>\n<h5 id=\"读取传感器数据\"><a href=\"#读取传感器数据\" class=\"headerlink\" title=\"读取传感器数据\"></a><strong>读取传感器数据</strong></h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*读取传感器*/</span></span><br><span class=\"line\">   <span class=\"keyword\">while</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">       res = rt_device_read(dev, <span class=\"number\">0</span>, &amp;sensor_data, <span class=\"number\">1</span>);<span class=\"comment\">//第0位开始读一个</span></span><br><span class=\"line\">       <span class=\"comment\">//读错了返回0</span></span><br><span class=\"line\">       <span class=\"keyword\">if</span>(res == <span class=\"number\">0</span>)</span><br><span class=\"line\">       &#123;</span><br><span class=\"line\">           rt_kprintf(<span class=\"string\">&quot;Read Error Res:%d&quot;</span>,res);<span class=\"comment\">//返回读取错误编号0</span></span><br><span class=\"line\">           <span class=\"keyword\">return</span>;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">else</span> <span class=\"comment\">//读取成功</span></span><br><span class=\"line\">       &#123;</span><br><span class=\"line\">           <span class=\"keyword\">if</span>(sensor_data.data.temp &gt;= <span class=\"number\">0</span>) <span class=\"comment\">//数据大于等于0 包括了温度与湿度</span></span><br><span class=\"line\">           &#123;</span><br><span class=\"line\">               <span class=\"type\">uint8_t</span> temp = (sensor_data.data.temp &amp; <span class=\"number\">0xffff</span>);</span><br><span class=\"line\">               <span class=\"type\">uint8_t</span> humi = (sensor_data.data.temp &amp; <span class=\"number\">0xffff0000</span>) &gt;&gt; <span class=\"number\">16</span>;</span><br><span class=\"line\">               rt_kprintf(<span class=\"string\">&quot;temp:%d humi:%d\\r\\n&quot;</span>,temp,humi);</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       rt_thread_delay(<span class=\"number\">1000</span>);</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"init代码构建\"><a href=\"#init代码构建\" class=\"headerlink\" title=\"init代码构建\"></a><strong>init代码构建</strong></h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">sensor_init</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">rt_sensor_config</span> <span class=\"title\">cfg</span>;</span><span class=\"comment\">//操作集结构体</span></span><br><span class=\"line\">    <span class=\"comment\">/*注册设备 配置接口*/</span></span><br><span class=\"line\">    cfg.intf.user_data = (<span class=\"type\">void</span> *)DHT11_PIN;<span class=\"comment\">//配置接口为IO口</span></span><br><span class=\"line\">    rt_hw_dht11_init(<span class=\"string\">&quot;dht11&quot;</span>, &amp;cfg);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">rt_thread_t</span> sensor_thread = rt_thread_create(<span class=\"string\">&quot;sensor_proc&quot;</span>, sensor_proc, RT_NULL, <span class=\"number\">1024</span>, <span class=\"number\">10</span>, <span class=\"number\">20</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(sensor_thread != RT_NULL)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        rt_thread_startup(sensor_thread);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> RT_EOK;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">INIT_COMPONENT_EXPORT(sensor_init);</span><br></pre></td></tr></table></figure>\n\n"},{"title":"电赛","date":"2025-06-08T05:22:05.000Z","cover":"https://fastly.jsdelivr.net/gh/2250272571/tuchuang@main/img/202506081324376.png","_content":"\n## PID\n\n![image-20250608132624784](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202506081334606.png)\n\n- 其中 e 为误差\n- P：正比  即控制摆动\n- I：积分 积累误差，可用来消除稳定误差 （比如无人机中，向下吹的风刚好是1米，但p中最后上升也是1米 即形成一种稳态）\n- D：微分 速度控制 可用来让系统快速停下来\n\n## 编码器\n\n### CubeMX配置\n\n![image-20250612212624882](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202506122126276.png)\n\n#### 参数解析\n\n1. Encoder Mode\n\n- `Encoder Mode TI1` ：只保留A相，滤除B相数据\n\n- `Encoder Mode TI2` ：只保留B相，滤除A相数据\n\n- `Encoder Mode TI1 and TI2`：A、B相都保留，数据波长会是第一、二模式的两倍\n\n  > 一般用于高精度场合 如小车\n\n### 代码编写\n\n#### 初始化\n\n```C\n  HAL_TIM_Encoder_Start(&htim3, TIM_CHANNEL_1); // 开启编码器A\n  HAL_TIM_Encoder_Start(&htim3, TIM_CHANNEL_2); // 开启编码器A\n```\n\n#### 获取编码器值\n\n> 记得先接上编码器的电源 他与电机是分开的电源  工作电压为3.3V~5V\n\n```C\ng_nMotor_Lef_Pulse = (short)(__HAL_TIM_GET_COUNTER(&htim3)); // 获取计数器值\n__HAL_TIM_SET_COUNTER(&htim3, 0);\t\t\t\t\t\t\t // 左编码器TIM3计数器清零\n```\n\n## 超声波\n\n### CubeMX配置\n\n![image-20250612213408605](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202506122134910.png)\n\n![image-20250612214851115](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202506122148018.png)\n\n### 初始化\n\n```C\nHcsr04Init(&htim11, TIM_CHANNEL_1); //  超声波模块初始化\n```\n\n### 注册回调函数与绑定定时器溢出回调函数\n\n```C\nvoid HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim)\n{\n\tif (htim->Instance == TIM11)\n\t\tHcsr04TimIcIsr(&htim11);\n}\n\nvoid HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)\n{\n  if (htim->Instance == TIM11)\n  {\n    Hcsr04TimOverflowIsr(&htim11);\n  }\n}\n```\n\n### 获取距离值\n\n```C\nHcsr04Start();\nprintf(\"distance:%.1f cm\\r\\n\", Hcsr04Read());\nHAL_Delay(300); // 可适当加些延时\n```\n\n## JY60陀螺仪\n\n### CubeMX配置\n\n![image-20250612215946547](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202506122159648.png)\n\n![image-20250612220017334](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202506122200718.png)\n\n### 初始化\n\n- 引入官方sdk `wit_c_sdk.h与wit_c_sdk.c`\n- 新建驱动文件 `jy60.c`与 `jy60.h`\n\n```C\njy60_init();\n/*\nvoid jy60_init(void)\n{\n\t\tWitInit(WIT_PROTOCOL_NORMAL, 0x50);\n\t\tWitSerialWriteRegister(SensorUartSend);\n\t\tWitRegisterCallBack(SensorDataUpdata);\n\t\tWitDelayMsRegister(Delayms);\n\t\tHAL_Delay(100);\n}\n*/\n```\n\n### 获取加速度、角速度、姿态角\n\n```C\njy60_read();\n/*\nvoid jy60_read(void)\n{\n\t\tif(s_cDataUpdate)\n\t\t{\n\t\t\tfor(uint8_t i = 0; i < 3; i++)\n\t\t\t{\n\t\t\t\tfAcc[i] = sReg[AX+i] / 32768.0f * 16.0f;\n\t\t\t\tfGyro[i] = sReg[GX+i] / 32768.0f * 2000.0f;\n\t\t\t\tfAngle[i] = sReg[Roll+i] / 32768.0f * 180.0f;\n\t\t\t}\n//\t\t\tuint8_t strff[21];\n//\t\t\t\n//\t\t\tsprintf(strff,\"%.2f\",fAngle[2]);\n//\t\t\t\n//\t\t\tOLED_ShowStr(0,3,strff,1);\n\t\t\tif(s_cDataUpdate & ACC_UPDATE)\n\t\t\t{\n//\t\t\t\tprintf(\"acc:%.3f %.3f %.3f\\r\\n\", fAcc[0], fAcc[1], fAcc[2]);\n\t\t\t\ts_cDataUpdate &= ~ACC_UPDATE;\n\t\t\t}\n\t\t\tif(s_cDataUpdate & GYRO_UPDATE)\n\t\t\t{\n//\t\t\t\tprintf(\"gyro:%.3f %.3f %.3f\\r\\n\", fGyro[0], fGyro[1], fGyro[2]);\n\t\t\t\ts_cDataUpdate &= ~GYRO_UPDATE;\n\t\t\t}\n\t\t\tif(s_cDataUpdate & ANGLE_UPDATE)\n\t\t\t{\n\t\t\t\tprintf(\"angle:%.3f %.3f %.3f\\r\\n\", fAngle[0], fAngle[1], fAngle[2]);\n\t\t\t\ts_cDataUpdate &= ~ANGLE_UPDATE;\n\t\t\t}\n\t\t\tif(s_cDataUpdate & MAG_UPDATE)\n\t\t\t{\n\t\t\t\t//printf(\"mag:%d %d %d\\r\\n\", sReg[HX], sReg[HY], sReg[HZ]);\n\t\t\t\ts_cDataUpdate &= ~MAG_UPDATE;\n\t\t\t}\n\t\t}\n\t\t\n}\n*/\n```\n\n| 变量名   | 含义                    | 单位            | 来源寄存器             |\n| -------- | ----------------------- | --------------- | ---------------------- |\n| `fAcc`   | 加速度（Accelerometer） | M/s²            | `AX`、`AY`、`AZ`       |\n| `fGyro`  | 角速度（Gyroscope）     | °/s（角度每秒） | `GX`、`GY`、`GZ`       |\n| `fAngle` | 姿态角（Angle）         | °（角度）       | `Roll`、`Pitch`、`Yaw` |\n\n| 下标 | fAcc       | fGyro      | fAngle          |\n| ---- | ---------- | ---------- | --------------- |\n| [0]  | X 轴加速度 | X 轴角速度 | 横滚角（Roll）  |\n| [1]  | Y 轴加速度 | Y 轴角速度 | 俯仰角（Pitch） |\n| [2]  | Z 轴加速度 | Z 轴角速度 | 偏航角（Yaw）   |\n\n### 数据分析\n\n```C\nfAcc[i] = sReg[AX+i] / 32768.0f * 16.0f;\nfGyro[i] = sReg[GX+i] / 32768.0f * 2000.0f;\nfAngle[i] = sReg[Roll+i] / 32768.0f * 180.0f;\n/*以上数据均来源于这里*/\n//后面的 * 16.0f 表示限幅 即 加速度范围为 ± 16M/s²\n```\n\n","source":"_posts/电赛.md","raw":"---\ntitle: 电赛\ndate: 2025-06-08 13:22:05\ncover: \"https://fastly.jsdelivr.net/gh/2250272571/tuchuang@main/img/202506081324376.png\"\ntags:\n  - 电赛准备\n---\n\n## PID\n\n![image-20250608132624784](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202506081334606.png)\n\n- 其中 e 为误差\n- P：正比  即控制摆动\n- I：积分 积累误差，可用来消除稳定误差 （比如无人机中，向下吹的风刚好是1米，但p中最后上升也是1米 即形成一种稳态）\n- D：微分 速度控制 可用来让系统快速停下来\n\n## 编码器\n\n### CubeMX配置\n\n![image-20250612212624882](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202506122126276.png)\n\n#### 参数解析\n\n1. Encoder Mode\n\n- `Encoder Mode TI1` ：只保留A相，滤除B相数据\n\n- `Encoder Mode TI2` ：只保留B相，滤除A相数据\n\n- `Encoder Mode TI1 and TI2`：A、B相都保留，数据波长会是第一、二模式的两倍\n\n  > 一般用于高精度场合 如小车\n\n### 代码编写\n\n#### 初始化\n\n```C\n  HAL_TIM_Encoder_Start(&htim3, TIM_CHANNEL_1); // 开启编码器A\n  HAL_TIM_Encoder_Start(&htim3, TIM_CHANNEL_2); // 开启编码器A\n```\n\n#### 获取编码器值\n\n> 记得先接上编码器的电源 他与电机是分开的电源  工作电压为3.3V~5V\n\n```C\ng_nMotor_Lef_Pulse = (short)(__HAL_TIM_GET_COUNTER(&htim3)); // 获取计数器值\n__HAL_TIM_SET_COUNTER(&htim3, 0);\t\t\t\t\t\t\t // 左编码器TIM3计数器清零\n```\n\n## 超声波\n\n### CubeMX配置\n\n![image-20250612213408605](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202506122134910.png)\n\n![image-20250612214851115](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202506122148018.png)\n\n### 初始化\n\n```C\nHcsr04Init(&htim11, TIM_CHANNEL_1); //  超声波模块初始化\n```\n\n### 注册回调函数与绑定定时器溢出回调函数\n\n```C\nvoid HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim)\n{\n\tif (htim->Instance == TIM11)\n\t\tHcsr04TimIcIsr(&htim11);\n}\n\nvoid HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)\n{\n  if (htim->Instance == TIM11)\n  {\n    Hcsr04TimOverflowIsr(&htim11);\n  }\n}\n```\n\n### 获取距离值\n\n```C\nHcsr04Start();\nprintf(\"distance:%.1f cm\\r\\n\", Hcsr04Read());\nHAL_Delay(300); // 可适当加些延时\n```\n\n## JY60陀螺仪\n\n### CubeMX配置\n\n![image-20250612215946547](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202506122159648.png)\n\n![image-20250612220017334](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202506122200718.png)\n\n### 初始化\n\n- 引入官方sdk `wit_c_sdk.h与wit_c_sdk.c`\n- 新建驱动文件 `jy60.c`与 `jy60.h`\n\n```C\njy60_init();\n/*\nvoid jy60_init(void)\n{\n\t\tWitInit(WIT_PROTOCOL_NORMAL, 0x50);\n\t\tWitSerialWriteRegister(SensorUartSend);\n\t\tWitRegisterCallBack(SensorDataUpdata);\n\t\tWitDelayMsRegister(Delayms);\n\t\tHAL_Delay(100);\n}\n*/\n```\n\n### 获取加速度、角速度、姿态角\n\n```C\njy60_read();\n/*\nvoid jy60_read(void)\n{\n\t\tif(s_cDataUpdate)\n\t\t{\n\t\t\tfor(uint8_t i = 0; i < 3; i++)\n\t\t\t{\n\t\t\t\tfAcc[i] = sReg[AX+i] / 32768.0f * 16.0f;\n\t\t\t\tfGyro[i] = sReg[GX+i] / 32768.0f * 2000.0f;\n\t\t\t\tfAngle[i] = sReg[Roll+i] / 32768.0f * 180.0f;\n\t\t\t}\n//\t\t\tuint8_t strff[21];\n//\t\t\t\n//\t\t\tsprintf(strff,\"%.2f\",fAngle[2]);\n//\t\t\t\n//\t\t\tOLED_ShowStr(0,3,strff,1);\n\t\t\tif(s_cDataUpdate & ACC_UPDATE)\n\t\t\t{\n//\t\t\t\tprintf(\"acc:%.3f %.3f %.3f\\r\\n\", fAcc[0], fAcc[1], fAcc[2]);\n\t\t\t\ts_cDataUpdate &= ~ACC_UPDATE;\n\t\t\t}\n\t\t\tif(s_cDataUpdate & GYRO_UPDATE)\n\t\t\t{\n//\t\t\t\tprintf(\"gyro:%.3f %.3f %.3f\\r\\n\", fGyro[0], fGyro[1], fGyro[2]);\n\t\t\t\ts_cDataUpdate &= ~GYRO_UPDATE;\n\t\t\t}\n\t\t\tif(s_cDataUpdate & ANGLE_UPDATE)\n\t\t\t{\n\t\t\t\tprintf(\"angle:%.3f %.3f %.3f\\r\\n\", fAngle[0], fAngle[1], fAngle[2]);\n\t\t\t\ts_cDataUpdate &= ~ANGLE_UPDATE;\n\t\t\t}\n\t\t\tif(s_cDataUpdate & MAG_UPDATE)\n\t\t\t{\n\t\t\t\t//printf(\"mag:%d %d %d\\r\\n\", sReg[HX], sReg[HY], sReg[HZ]);\n\t\t\t\ts_cDataUpdate &= ~MAG_UPDATE;\n\t\t\t}\n\t\t}\n\t\t\n}\n*/\n```\n\n| 变量名   | 含义                    | 单位            | 来源寄存器             |\n| -------- | ----------------------- | --------------- | ---------------------- |\n| `fAcc`   | 加速度（Accelerometer） | M/s²            | `AX`、`AY`、`AZ`       |\n| `fGyro`  | 角速度（Gyroscope）     | °/s（角度每秒） | `GX`、`GY`、`GZ`       |\n| `fAngle` | 姿态角（Angle）         | °（角度）       | `Roll`、`Pitch`、`Yaw` |\n\n| 下标 | fAcc       | fGyro      | fAngle          |\n| ---- | ---------- | ---------- | --------------- |\n| [0]  | X 轴加速度 | X 轴角速度 | 横滚角（Roll）  |\n| [1]  | Y 轴加速度 | Y 轴角速度 | 俯仰角（Pitch） |\n| [2]  | Z 轴加速度 | Z 轴角速度 | 偏航角（Yaw）   |\n\n### 数据分析\n\n```C\nfAcc[i] = sReg[AX+i] / 32768.0f * 16.0f;\nfGyro[i] = sReg[GX+i] / 32768.0f * 2000.0f;\nfAngle[i] = sReg[Roll+i] / 32768.0f * 180.0f;\n/*以上数据均来源于这里*/\n//后面的 * 16.0f 表示限幅 即 加速度范围为 ± 16M/s²\n```\n\n","slug":"电赛","published":1,"updated":"2025-06-12T14:17:36.000Z","comments":1,"layout":"post","photos":[],"_id":"cmk8pg6xn000y6sk92n1ohuiq","content":"<h2 id=\"PID\"><a href=\"#PID\" class=\"headerlink\" title=\"PID\"></a>PID</h2><p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202506081334606.png\" alt=\"image-20250608132624784\"></p>\n<ul>\n<li>其中 e 为误差</li>\n<li>P：正比  即控制摆动</li>\n<li>I：积分 积累误差，可用来消除稳定误差 （比如无人机中，向下吹的风刚好是1米，但p中最后上升也是1米 即形成一种稳态）</li>\n<li>D：微分 速度控制 可用来让系统快速停下来</li>\n</ul>\n<h2 id=\"编码器\"><a href=\"#编码器\" class=\"headerlink\" title=\"编码器\"></a>编码器</h2><h3 id=\"CubeMX配置\"><a href=\"#CubeMX配置\" class=\"headerlink\" title=\"CubeMX配置\"></a>CubeMX配置</h3><p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202506122126276.png\" alt=\"image-20250612212624882\"></p>\n<h4 id=\"参数解析\"><a href=\"#参数解析\" class=\"headerlink\" title=\"参数解析\"></a>参数解析</h4><ol>\n<li>Encoder Mode</li>\n</ol>\n<ul>\n<li><p><code>Encoder Mode TI1</code> ：只保留A相，滤除B相数据</p>\n</li>\n<li><p><code>Encoder Mode TI2</code> ：只保留B相，滤除A相数据</p>\n</li>\n<li><p><code>Encoder Mode TI1 and TI2</code>：A、B相都保留，数据波长会是第一、二模式的两倍</p>\n<blockquote>\n<p>一般用于高精度场合 如小车</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"代码编写\"><a href=\"#代码编写\" class=\"headerlink\" title=\"代码编写\"></a>代码编写</h3><h4 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HAL_TIM_Encoder_Start(&amp;htim3, TIM_CHANNEL_1); <span class=\"comment\">// 开启编码器A</span></span><br><span class=\"line\">HAL_TIM_Encoder_Start(&amp;htim3, TIM_CHANNEL_2); <span class=\"comment\">// 开启编码器A</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"获取编码器值\"><a href=\"#获取编码器值\" class=\"headerlink\" title=\"获取编码器值\"></a>获取编码器值</h4><blockquote>\n<p>记得先接上编码器的电源 他与电机是分开的电源  工作电压为3.3V~5V</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">g_nMotor_Lef_Pulse = (<span class=\"type\">short</span>)(__HAL_TIM_GET_COUNTER(&amp;htim3)); <span class=\"comment\">// 获取计数器值</span></span><br><span class=\"line\">__HAL_TIM_SET_COUNTER(&amp;htim3, <span class=\"number\">0</span>);\t\t\t\t\t\t\t <span class=\"comment\">// 左编码器TIM3计数器清零</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"超声波\"><a href=\"#超声波\" class=\"headerlink\" title=\"超声波\"></a>超声波</h2><h3 id=\"CubeMX配置-1\"><a href=\"#CubeMX配置-1\" class=\"headerlink\" title=\"CubeMX配置\"></a>CubeMX配置</h3><p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202506122134910.png\" alt=\"image-20250612213408605\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202506122148018.png\" alt=\"image-20250612214851115\"></p>\n<h3 id=\"初始化-1\"><a href=\"#初始化-1\" class=\"headerlink\" title=\"初始化\"></a>初始化</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Hcsr04Init(&amp;htim11, TIM_CHANNEL_1); <span class=\"comment\">//  超声波模块初始化</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"注册回调函数与绑定定时器溢出回调函数\"><a href=\"#注册回调函数与绑定定时器溢出回调函数\" class=\"headerlink\" title=\"注册回调函数与绑定定时器溢出回调函数\"></a>注册回调函数与绑定定时器溢出回调函数</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">HAL_TIM_IC_CaptureCallback</span><span class=\"params\">(TIM_HandleTypeDef *htim)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (htim-&gt;Instance == TIM11)</span><br><span class=\"line\">\t\tHcsr04TimIcIsr(&amp;htim11);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">HAL_TIM_PeriodElapsedCallback</span><span class=\"params\">(TIM_HandleTypeDef *htim)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (htim-&gt;Instance == TIM11)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    Hcsr04TimOverflowIsr(&amp;htim11);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"获取距离值\"><a href=\"#获取距离值\" class=\"headerlink\" title=\"获取距离值\"></a>获取距离值</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Hcsr04Start();</span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">&quot;distance:%.1f cm\\r\\n&quot;</span>, Hcsr04Read());</span><br><span class=\"line\">HAL_Delay(<span class=\"number\">300</span>); <span class=\"comment\">// 可适当加些延时</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"JY60陀螺仪\"><a href=\"#JY60陀螺仪\" class=\"headerlink\" title=\"JY60陀螺仪\"></a>JY60陀螺仪</h2><h3 id=\"CubeMX配置-2\"><a href=\"#CubeMX配置-2\" class=\"headerlink\" title=\"CubeMX配置\"></a>CubeMX配置</h3><p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202506122159648.png\" alt=\"image-20250612215946547\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202506122200718.png\" alt=\"image-20250612220017334\"></p>\n<h3 id=\"初始化-2\"><a href=\"#初始化-2\" class=\"headerlink\" title=\"初始化\"></a>初始化</h3><ul>\n<li>引入官方sdk <code>wit_c_sdk.h与wit_c_sdk.c</code></li>\n<li>新建驱动文件 <code>jy60.c</code>与 <code>jy60.h</code></li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jy60_init();</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">void jy60_init(void)</span></span><br><span class=\"line\"><span class=\"comment\">&#123;</span></span><br><span class=\"line\"><span class=\"comment\">\t\tWitInit(WIT_PROTOCOL_NORMAL, 0x50);</span></span><br><span class=\"line\"><span class=\"comment\">\t\tWitSerialWriteRegister(SensorUartSend);</span></span><br><span class=\"line\"><span class=\"comment\">\t\tWitRegisterCallBack(SensorDataUpdata);</span></span><br><span class=\"line\"><span class=\"comment\">\t\tWitDelayMsRegister(Delayms);</span></span><br><span class=\"line\"><span class=\"comment\">\t\tHAL_Delay(100);</span></span><br><span class=\"line\"><span class=\"comment\">&#125;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"获取加速度、角速度、姿态角\"><a href=\"#获取加速度、角速度、姿态角\" class=\"headerlink\" title=\"获取加速度、角速度、姿态角\"></a>获取加速度、角速度、姿态角</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jy60_read();</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">void jy60_read(void)</span></span><br><span class=\"line\"><span class=\"comment\">&#123;</span></span><br><span class=\"line\"><span class=\"comment\">\t\tif(s_cDataUpdate)</span></span><br><span class=\"line\"><span class=\"comment\">\t\t&#123;</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\tfor(uint8_t i = 0; i &lt; 3; i++)</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t&#123;</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\tfAcc[i] = sReg[AX+i] / 32768.0f * 16.0f;</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\tfGyro[i] = sReg[GX+i] / 32768.0f * 2000.0f;</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\tfAngle[i] = sReg[Roll+i] / 32768.0f * 180.0f;</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t&#125;</span></span><br><span class=\"line\"><span class=\"comment\">//\t\t\tuint8_t strff[21];</span></span><br><span class=\"line\"><span class=\"comment\">//\t\t\t</span></span><br><span class=\"line\"><span class=\"comment\">//\t\t\tsprintf(strff,&quot;%.2f&quot;,fAngle[2]);</span></span><br><span class=\"line\"><span class=\"comment\">//\t\t\t</span></span><br><span class=\"line\"><span class=\"comment\">//\t\t\tOLED_ShowStr(0,3,strff,1);</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\tif(s_cDataUpdate &amp; ACC_UPDATE)</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t&#123;</span></span><br><span class=\"line\"><span class=\"comment\">//\t\t\t\tprintf(&quot;acc:%.3f %.3f %.3f\\r\\n&quot;, fAcc[0], fAcc[1], fAcc[2]);</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\ts_cDataUpdate &amp;= ~ACC_UPDATE;</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t&#125;</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\tif(s_cDataUpdate &amp; GYRO_UPDATE)</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t&#123;</span></span><br><span class=\"line\"><span class=\"comment\">//\t\t\t\tprintf(&quot;gyro:%.3f %.3f %.3f\\r\\n&quot;, fGyro[0], fGyro[1], fGyro[2]);</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\ts_cDataUpdate &amp;= ~GYRO_UPDATE;</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t&#125;</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\tif(s_cDataUpdate &amp; ANGLE_UPDATE)</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t&#123;</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\tprintf(&quot;angle:%.3f %.3f %.3f\\r\\n&quot;, fAngle[0], fAngle[1], fAngle[2]);</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\ts_cDataUpdate &amp;= ~ANGLE_UPDATE;</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t&#125;</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\tif(s_cDataUpdate &amp; MAG_UPDATE)</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t&#123;</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\t//printf(&quot;mag:%d %d %d\\r\\n&quot;, sReg[HX], sReg[HY], sReg[HZ]);</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\ts_cDataUpdate &amp;= ~MAG_UPDATE;</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t&#125;</span></span><br><span class=\"line\"><span class=\"comment\">\t\t&#125;</span></span><br><span class=\"line\"><span class=\"comment\">\t\t</span></span><br><span class=\"line\"><span class=\"comment\">&#125;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th>变量名</th>\n<th>含义</th>\n<th>单位</th>\n<th>来源寄存器</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>fAcc</code></td>\n<td>加速度（Accelerometer）</td>\n<td>M&#x2F;s²</td>\n<td><code>AX</code>、<code>AY</code>、<code>AZ</code></td>\n</tr>\n<tr>\n<td><code>fGyro</code></td>\n<td>角速度（Gyroscope）</td>\n<td>°&#x2F;s（角度每秒）</td>\n<td><code>GX</code>、<code>GY</code>、<code>GZ</code></td>\n</tr>\n<tr>\n<td><code>fAngle</code></td>\n<td>姿态角（Angle）</td>\n<td>°（角度）</td>\n<td><code>Roll</code>、<code>Pitch</code>、<code>Yaw</code></td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th>下标</th>\n<th>fAcc</th>\n<th>fGyro</th>\n<th>fAngle</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>[0]</td>\n<td>X 轴加速度</td>\n<td>X 轴角速度</td>\n<td>横滚角（Roll）</td>\n</tr>\n<tr>\n<td>[1]</td>\n<td>Y 轴加速度</td>\n<td>Y 轴角速度</td>\n<td>俯仰角（Pitch）</td>\n</tr>\n<tr>\n<td>[2]</td>\n<td>Z 轴加速度</td>\n<td>Z 轴角速度</td>\n<td>偏航角（Yaw）</td>\n</tr>\n</tbody></table>\n<h3 id=\"数据分析\"><a href=\"#数据分析\" class=\"headerlink\" title=\"数据分析\"></a>数据分析</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fAcc[i] = sReg[AX+i] / <span class=\"number\">32768.0f</span> * <span class=\"number\">16.0f</span>;</span><br><span class=\"line\">fGyro[i] = sReg[GX+i] / <span class=\"number\">32768.0f</span> * <span class=\"number\">2000.0f</span>;</span><br><span class=\"line\">fAngle[i] = sReg[Roll+i] / <span class=\"number\">32768.0f</span> * <span class=\"number\">180.0f</span>;</span><br><span class=\"line\"><span class=\"comment\">/*以上数据均来源于这里*/</span></span><br><span class=\"line\"><span class=\"comment\">//后面的 * 16.0f 表示限幅 即 加速度范围为 ± 16M/s²</span></span><br></pre></td></tr></table></figure>\n\n","excerpt":"","more":"<h2 id=\"PID\"><a href=\"#PID\" class=\"headerlink\" title=\"PID\"></a>PID</h2><p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202506081334606.png\" alt=\"image-20250608132624784\"></p>\n<ul>\n<li>其中 e 为误差</li>\n<li>P：正比  即控制摆动</li>\n<li>I：积分 积累误差，可用来消除稳定误差 （比如无人机中，向下吹的风刚好是1米，但p中最后上升也是1米 即形成一种稳态）</li>\n<li>D：微分 速度控制 可用来让系统快速停下来</li>\n</ul>\n<h2 id=\"编码器\"><a href=\"#编码器\" class=\"headerlink\" title=\"编码器\"></a>编码器</h2><h3 id=\"CubeMX配置\"><a href=\"#CubeMX配置\" class=\"headerlink\" title=\"CubeMX配置\"></a>CubeMX配置</h3><p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202506122126276.png\" alt=\"image-20250612212624882\"></p>\n<h4 id=\"参数解析\"><a href=\"#参数解析\" class=\"headerlink\" title=\"参数解析\"></a>参数解析</h4><ol>\n<li>Encoder Mode</li>\n</ol>\n<ul>\n<li><p><code>Encoder Mode TI1</code> ：只保留A相，滤除B相数据</p>\n</li>\n<li><p><code>Encoder Mode TI2</code> ：只保留B相，滤除A相数据</p>\n</li>\n<li><p><code>Encoder Mode TI1 and TI2</code>：A、B相都保留，数据波长会是第一、二模式的两倍</p>\n<blockquote>\n<p>一般用于高精度场合 如小车</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"代码编写\"><a href=\"#代码编写\" class=\"headerlink\" title=\"代码编写\"></a>代码编写</h3><h4 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HAL_TIM_Encoder_Start(&amp;htim3, TIM_CHANNEL_1); <span class=\"comment\">// 开启编码器A</span></span><br><span class=\"line\">HAL_TIM_Encoder_Start(&amp;htim3, TIM_CHANNEL_2); <span class=\"comment\">// 开启编码器A</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"获取编码器值\"><a href=\"#获取编码器值\" class=\"headerlink\" title=\"获取编码器值\"></a>获取编码器值</h4><blockquote>\n<p>记得先接上编码器的电源 他与电机是分开的电源  工作电压为3.3V~5V</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">g_nMotor_Lef_Pulse = (<span class=\"type\">short</span>)(__HAL_TIM_GET_COUNTER(&amp;htim3)); <span class=\"comment\">// 获取计数器值</span></span><br><span class=\"line\">__HAL_TIM_SET_COUNTER(&amp;htim3, <span class=\"number\">0</span>);\t\t\t\t\t\t\t <span class=\"comment\">// 左编码器TIM3计数器清零</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"超声波\"><a href=\"#超声波\" class=\"headerlink\" title=\"超声波\"></a>超声波</h2><h3 id=\"CubeMX配置-1\"><a href=\"#CubeMX配置-1\" class=\"headerlink\" title=\"CubeMX配置\"></a>CubeMX配置</h3><p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202506122134910.png\" alt=\"image-20250612213408605\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202506122148018.png\" alt=\"image-20250612214851115\"></p>\n<h3 id=\"初始化-1\"><a href=\"#初始化-1\" class=\"headerlink\" title=\"初始化\"></a>初始化</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Hcsr04Init(&amp;htim11, TIM_CHANNEL_1); <span class=\"comment\">//  超声波模块初始化</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"注册回调函数与绑定定时器溢出回调函数\"><a href=\"#注册回调函数与绑定定时器溢出回调函数\" class=\"headerlink\" title=\"注册回调函数与绑定定时器溢出回调函数\"></a>注册回调函数与绑定定时器溢出回调函数</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">HAL_TIM_IC_CaptureCallback</span><span class=\"params\">(TIM_HandleTypeDef *htim)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (htim-&gt;Instance == TIM11)</span><br><span class=\"line\">\t\tHcsr04TimIcIsr(&amp;htim11);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">HAL_TIM_PeriodElapsedCallback</span><span class=\"params\">(TIM_HandleTypeDef *htim)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (htim-&gt;Instance == TIM11)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    Hcsr04TimOverflowIsr(&amp;htim11);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"获取距离值\"><a href=\"#获取距离值\" class=\"headerlink\" title=\"获取距离值\"></a>获取距离值</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Hcsr04Start();</span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">&quot;distance:%.1f cm\\r\\n&quot;</span>, Hcsr04Read());</span><br><span class=\"line\">HAL_Delay(<span class=\"number\">300</span>); <span class=\"comment\">// 可适当加些延时</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"JY60陀螺仪\"><a href=\"#JY60陀螺仪\" class=\"headerlink\" title=\"JY60陀螺仪\"></a>JY60陀螺仪</h2><h3 id=\"CubeMX配置-2\"><a href=\"#CubeMX配置-2\" class=\"headerlink\" title=\"CubeMX配置\"></a>CubeMX配置</h3><p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202506122159648.png\" alt=\"image-20250612215946547\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202506122200718.png\" alt=\"image-20250612220017334\"></p>\n<h3 id=\"初始化-2\"><a href=\"#初始化-2\" class=\"headerlink\" title=\"初始化\"></a>初始化</h3><ul>\n<li>引入官方sdk <code>wit_c_sdk.h与wit_c_sdk.c</code></li>\n<li>新建驱动文件 <code>jy60.c</code>与 <code>jy60.h</code></li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jy60_init();</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">void jy60_init(void)</span></span><br><span class=\"line\"><span class=\"comment\">&#123;</span></span><br><span class=\"line\"><span class=\"comment\">\t\tWitInit(WIT_PROTOCOL_NORMAL, 0x50);</span></span><br><span class=\"line\"><span class=\"comment\">\t\tWitSerialWriteRegister(SensorUartSend);</span></span><br><span class=\"line\"><span class=\"comment\">\t\tWitRegisterCallBack(SensorDataUpdata);</span></span><br><span class=\"line\"><span class=\"comment\">\t\tWitDelayMsRegister(Delayms);</span></span><br><span class=\"line\"><span class=\"comment\">\t\tHAL_Delay(100);</span></span><br><span class=\"line\"><span class=\"comment\">&#125;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"获取加速度、角速度、姿态角\"><a href=\"#获取加速度、角速度、姿态角\" class=\"headerlink\" title=\"获取加速度、角速度、姿态角\"></a>获取加速度、角速度、姿态角</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jy60_read();</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">void jy60_read(void)</span></span><br><span class=\"line\"><span class=\"comment\">&#123;</span></span><br><span class=\"line\"><span class=\"comment\">\t\tif(s_cDataUpdate)</span></span><br><span class=\"line\"><span class=\"comment\">\t\t&#123;</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\tfor(uint8_t i = 0; i &lt; 3; i++)</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t&#123;</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\tfAcc[i] = sReg[AX+i] / 32768.0f * 16.0f;</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\tfGyro[i] = sReg[GX+i] / 32768.0f * 2000.0f;</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\tfAngle[i] = sReg[Roll+i] / 32768.0f * 180.0f;</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t&#125;</span></span><br><span class=\"line\"><span class=\"comment\">//\t\t\tuint8_t strff[21];</span></span><br><span class=\"line\"><span class=\"comment\">//\t\t\t</span></span><br><span class=\"line\"><span class=\"comment\">//\t\t\tsprintf(strff,&quot;%.2f&quot;,fAngle[2]);</span></span><br><span class=\"line\"><span class=\"comment\">//\t\t\t</span></span><br><span class=\"line\"><span class=\"comment\">//\t\t\tOLED_ShowStr(0,3,strff,1);</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\tif(s_cDataUpdate &amp; ACC_UPDATE)</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t&#123;</span></span><br><span class=\"line\"><span class=\"comment\">//\t\t\t\tprintf(&quot;acc:%.3f %.3f %.3f\\r\\n&quot;, fAcc[0], fAcc[1], fAcc[2]);</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\ts_cDataUpdate &amp;= ~ACC_UPDATE;</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t&#125;</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\tif(s_cDataUpdate &amp; GYRO_UPDATE)</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t&#123;</span></span><br><span class=\"line\"><span class=\"comment\">//\t\t\t\tprintf(&quot;gyro:%.3f %.3f %.3f\\r\\n&quot;, fGyro[0], fGyro[1], fGyro[2]);</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\ts_cDataUpdate &amp;= ~GYRO_UPDATE;</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t&#125;</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\tif(s_cDataUpdate &amp; ANGLE_UPDATE)</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t&#123;</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\tprintf(&quot;angle:%.3f %.3f %.3f\\r\\n&quot;, fAngle[0], fAngle[1], fAngle[2]);</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\ts_cDataUpdate &amp;= ~ANGLE_UPDATE;</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t&#125;</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\tif(s_cDataUpdate &amp; MAG_UPDATE)</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t&#123;</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\t//printf(&quot;mag:%d %d %d\\r\\n&quot;, sReg[HX], sReg[HY], sReg[HZ]);</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\ts_cDataUpdate &amp;= ~MAG_UPDATE;</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t&#125;</span></span><br><span class=\"line\"><span class=\"comment\">\t\t&#125;</span></span><br><span class=\"line\"><span class=\"comment\">\t\t</span></span><br><span class=\"line\"><span class=\"comment\">&#125;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th>变量名</th>\n<th>含义</th>\n<th>单位</th>\n<th>来源寄存器</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>fAcc</code></td>\n<td>加速度（Accelerometer）</td>\n<td>M&#x2F;s²</td>\n<td><code>AX</code>、<code>AY</code>、<code>AZ</code></td>\n</tr>\n<tr>\n<td><code>fGyro</code></td>\n<td>角速度（Gyroscope）</td>\n<td>°&#x2F;s（角度每秒）</td>\n<td><code>GX</code>、<code>GY</code>、<code>GZ</code></td>\n</tr>\n<tr>\n<td><code>fAngle</code></td>\n<td>姿态角（Angle）</td>\n<td>°（角度）</td>\n<td><code>Roll</code>、<code>Pitch</code>、<code>Yaw</code></td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th>下标</th>\n<th>fAcc</th>\n<th>fGyro</th>\n<th>fAngle</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>[0]</td>\n<td>X 轴加速度</td>\n<td>X 轴角速度</td>\n<td>横滚角（Roll）</td>\n</tr>\n<tr>\n<td>[1]</td>\n<td>Y 轴加速度</td>\n<td>Y 轴角速度</td>\n<td>俯仰角（Pitch）</td>\n</tr>\n<tr>\n<td>[2]</td>\n<td>Z 轴加速度</td>\n<td>Z 轴角速度</td>\n<td>偏航角（Yaw）</td>\n</tr>\n</tbody></table>\n<h3 id=\"数据分析\"><a href=\"#数据分析\" class=\"headerlink\" title=\"数据分析\"></a>数据分析</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fAcc[i] = sReg[AX+i] / <span class=\"number\">32768.0f</span> * <span class=\"number\">16.0f</span>;</span><br><span class=\"line\">fGyro[i] = sReg[GX+i] / <span class=\"number\">32768.0f</span> * <span class=\"number\">2000.0f</span>;</span><br><span class=\"line\">fAngle[i] = sReg[Roll+i] / <span class=\"number\">32768.0f</span> * <span class=\"number\">180.0f</span>;</span><br><span class=\"line\"><span class=\"comment\">/*以上数据均来源于这里*/</span></span><br><span class=\"line\"><span class=\"comment\">//后面的 * 16.0f 表示限幅 即 加速度范围为 ± 16M/s²</span></span><br></pre></td></tr></table></figure>\n\n"},{"title":"freertos","date":"2025-09-05T07:48:39.000Z","sticky":true,"cover":"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071511987.png","layout":"page","_content":"\n## FreeRTOS基础\n\n### 获取系统时间\n\n```C\nTickType_t currentTicks;\nwhile(1)\n{\n     currentTicks = xTaskGetTickCount();\n     printf(\"[%lu]dev:%u,name:%s\\r\\n\", currentTicks, data->dev, data->data);\n}\n```\n\n\n\n### 堆和栈\n\n堆：一块空闲的内存 可以使用`malloc`申请内存 使用完后用`free`释放内存\n\n> 堆也可以理解为就是定义了一个堆大小的数组 然后定义一个长度 每次动态改变长度来申请空间（链表）\n>\n> 在`FreeRTOSConfig.h`中就有定义堆大小的宏`configTOTAL_HEAP_SIZE` 他被引用到 `heap.c`中的 `static uint8_t ucHeap[configTOTAL_HEAP_SIZE];`\n\n栈：一块内存空间，CPU的SP寄存器指向它，它可以用于函数调用、局部变量、`多任务系统里保存现场`\n\n> 栈是`FreeRTOS`中非常重要的概念，每个任务都有自己的栈\n\n###  FreeRTOS源码概述\n\n#### 目录结构\n\n![img](https://photos.100ask.net/renesas-docs/DShanMCU_RA6M5/FreeRTOS/chapter-6/image1.png)\n\n> 主要涉及3个目录：\n>\n> - `ra\\aws\\FreeRTOS\\FreeRTOS\\Source`：存放的是FreeRTOS的核心文件\n> - `ra_gen`：从main.c可以看到创建任务的函数调用过程\n> - `src`：使用RASC创建任务时，在src目录下生成任务的入口函数\n\n#### 核心文件\n\n> FreeRTOS的最核心文件只有2个：\n>\n> - `FreeRTOS/Source/tasks.c`\n> - `FreeRTOS/Source/list.c`\n\n其他文件的作用也一起列表如下：\n\n| **`FreeRTOS/Source/`下的文件** | **作用**                                      |\n| ------------------------------ | --------------------------------------------- |\n| `tasks.c`                      | 必需，任务操作                                |\n| `list.c`                       | 必须，列表                                    |\n| `queue.c`                      | 基本必需，提供队列操作、信号量(semaphore)操作 |\n| `timer.c`                      | 可选，software timer                          |\n| `event_groups.c`               | 可选，提供event group功能                     |\n\n#### 头文件相关\n\n##### 头文件目录\n\n> FreeRTOS需要3个头文件目录：\n>\n> - FreeRTOS本身的头文件：`ra\\aws\\FreeRTOS\\FreeRTOS\\Source\\include`\n> - 移植时用到的头文件：`ra\\fsp\\src\\rm_freertos_port\\portmacro.h`\n> - 含有配置文件`FreeRTOSConfig.h`的目录：`ra_cfg\\aws`\n\n##### 头文件\n\n列表如下：\n\n| **头文件**         | **作用**                                                     |\n| ------------------ | ------------------------------------------------------------ |\n| `FreeRTOSConfig.h` | FreeRTOS的配置文件，比如选择调度算法：`configUSE_PREEMPTION` 每个工程都必定含有`FreeRTOSConfig.h` |\n| `FreeRTOS.h`       | 使用FreeRTOS API函数时，<span style=\"font-weight:bold;\">必须</span>包含此文件。 在`FreeRTOS.h`之后，再去包含其他头文件，比如： `task.h`、`queue.h`、`semphr.h`、`event_group.h` |\n\n#### 独属于FreeRTOS的数据类型和编程规范\n\n##### 数据类型\n\n每个移植的版本都含有自己的 **`portmacro.h`** 头文件，里面定义了2个数据类型：\n\n1. `TickType_t`：\n   - 时钟计数单位 （可以是uint16_t 也可以是uint32_t）\n     当`FreeRTOSConfig.h`中定义`configUSE_16_BIT_TICKS时 TickType_t`则为uint16_t\n\n> 对于32位架构，建议把TickType_t配置为uint32_t\n\n2. `BaseType_t`:这是该架构最高效的数据类型(取决于CPU是多少位的架构)\n   - `BaseType_t`通常用作简单的返回值的类型，还有逻辑值，比如 **pdTRUE/pdFALSE**\n\n#####  变量名\n\n变量名的前缀 对应其类型 如：`pcName` (代表着他是一个指向char类型的指针p)\n\n| **变量名前缀** | **含义**                                                     |\n| -------------- | ------------------------------------------------------------ |\n| c              | char                                                         |\n| s              | int16_t，short                                               |\n| l              | int32_t，long                                                |\n| x              | BaseType_t， 其他非标准的类型：结构体、task handle、queue handle等 |\n| u              | unsigned                                                     |\n| p              | 指针                                                         |\n| uc             | uint8_t，unsigned char                                       |\n| pc             | char指针                                                     |\n\n##### 函数名\n\n函数名的前缀有2部分：返回值类型、在哪个文件定义。\n\n| **函数名前缀**                                           | **含义**                                     |\n| -------------------------------------------------------- | -------------------------------------------- |\n| v<span style=\"font-weight:bold;\">Task</span>PrioritySet  | 返回值类型：void 在`task.c`中定义            |\n| x<span style=\"font-weight:bold;\">Queue</span>Receive     | 返回值类型：BaseType_t 在`queue.c`中定义     |\n| pv<span style=\"font-weight:bold;\">Timer</span>GetTimerID | 返回值类型：pointer to void 在`tmer.c`中定义 |\n\n##### 宏的名\n\n宏的名字是大小，可以添加小写的前缀。前缀是用来表示：宏在<span style=\"font-weight:bold;\">哪个文件</span>中定义。\n\n| **宏的前缀**                                                 | **含义：在哪个文件里定义**  |\n| ------------------------------------------------------------ | --------------------------- |\n| port (比如<span style=\"font-weight:bold;\">port</span>MAX_DELAY) | `portable.h`或`portmacro.h` |\n| task (比如<span style=\"font-weight:bold;\">task</span>ENTER_CRITICAL()) | `task.h`                    |\n| pd (比如<span style=\"font-weight:bold;\">pd</span>TRUE)       | `projdefs.h`                |\n| config (比如<span style=\"font-weight:bold;\">config</span>USE_PREEMPTION) | `FreeRTOSConfig.h`          |\n| err (比如<span style=\"font-weight:bold;\">err</span>QUEUE_FULL) | `projdefs.h`                |\n\n通用的宏定义如下：\n\n| **宏**    | **值** |\n| --------- | ------ |\n| `pdTRUE`  | 1      |\n| `pdFALSE` | 0      |\n| `pdPASS`  | 1      |\n| `pdFAIL`  | 0      |\n\n### 内存管理\n\n>  FreeRTOS中内存管理的接口函数为：`pvPortMalloc` 、`vPortFree`，对应于C库的`malloc`、`free`。 文件在`FreeRTOS/Source/portable/MemMang`下，它也是放在`portable目录`下，表示你可以提供自己的函数。\n>\n> 源码中默认提供了5个文件，对应内存管理的5种方法。\n\n| **文件**         | **优点**                                           | **缺点**                                             |\n| ---------------- | -------------------------------------------------- | ---------------------------------------------------- |\n| `heap_1.c`       | 分配简单，时间确定                                 | 只分配、<span style=\"color:#FF0000;\">不回收</span>   |\n| `heap_2.c`       | 动态分配、最佳匹配                                 | <span style=\"color:#FF0000;\">碎片</span>、时间不定   |\n| `heap_3.c`       | 调用<span style=\"color:#FF3333;\">标准库</span>函数 | <span style=\"color:#FF0000;\">速度慢</span>、时间不定 |\n| `heap_4.c`(常用) | 相邻空闲内存可合并                                 | 可解决碎片问题、时间不定                             |\n| `heap_5.c`       | 在heap_4基础上支持分隔的内存块                     | 可解决碎片问题、时间不定                             |\n\n#### Heap相关的函数\n\n#####  分配、释放内存\n\n函数原型：\n\n```c\nvoid * pvPortMalloc( size_t xWantedSize );\nvoid vPortFree( void * pv );\n```\n\n作用：分配内存、释放内存。\n\n如果分配内存不成功，则返回值为NULL。\n\n##### 检测剩余多少空闲内存\n\n函数原型：\n\n```c\nsize_t xPortGetFreeHeapSize( void );\n```\n\n> 当前还有多少空闲内存，这函数可以用来优化内存的使用情况。比如当所有内核对象都分配好后，执行此函数返回2000，那么`configTOTAL_HEAP_SIZE`就可减小2000。\n\n注意：在heap_3中无法使用。\n\n#####  获取空闲内存容量的最小值\n\n函数原型：\n\n```c\nsize_t xPortGetMinimumEverFreeHeapSize( void );\n```\n\n返回：程序运行过程中，空闲内存容量的最小值。\n\n注意：只有heap_4、heap_5支持此函数。\n\n##### `malloc失败的钩子函数`\n\n在pvPortMalloc函数内部：\n\n```c\nvoid * pvPortMalloc( size_t xWantedSize )vPortDefineHeapRegions\n{\n    ......\n    #if ( configUSE_MALLOC_FAILED_HOOK == 1 )\n        {\n            if( pvReturn == NULL )\n            {\n                extern void vApplicationMallocFailedHook( void );\n                vApplicationMallocFailedHook();\n            }\n        }\n    #endif\n    \n    return pvReturn;        \n}\n```\n\n所以，如果想使用这个钩子函数：\n\n- 在`FreeRTOSConfig.h`中，把`configUSE_MALLOC_FAILED_HOOK`定义为1\n- 提供`vApplicationMallocFailedHook`函数\n- `pvPortMalloc`失败时，才会调用此函数\n\n### 任务管理\n\n#### 任务创建与删除\n\n##### 什么是任务\n\n在FreeRTOS中，任务就是一个函数，原型如下：\n\n```c\nvoid ATaskFunction( void *pvParameters );\n```\n\n要注意的是：\n\n- 这个函数不能返回\n- 同一个函数，可以用来创建多个任务；换句话说，多个任务可以运行同一个函数\n- 函数内部，尽量使用局部变量：\n  - 每个任务都有自己的栈\n  - 每个任务运行这个函数时\n    - 任务A的局部变量放在任务A的栈里、任务B的局部变量放在任务B的栈里\n    - 不同任务的局部变量，有自己的副本\n  - 函数使用全局变量、静态变量的话\n    - 只有一个副本：多个任务使用的是同一个副本\n    - 要防止冲突(后续会讲) 下面是一个示例：\n\n```c\nvoid ATaskFunction( void *pvParameters )\n{\n\t/* 对于不同的任务，局部变量放在任务的栈里，有各自的副本 */\n\tint32_t lVariableExample = 0;\n\t\n    /* 任务函数通常实现为一个无限循环 */\n\tfor( ;; )\n\t{\n\t\t/* 任务的代码 */\n\t}\n\n    /* 如果程序从循环中退出，一定要使用vTaskDelete删除自己\n     * NULL表示删除的是自己\n     */\n\tvTaskDelete( NULL );\n    \n    /* 程序不会执行到这里, 如果执行到这里就出错了 */\n}\n```\n\n##### 创建任务\n\n创建任务时使用的函数如下：\n\n```c\nBaseType_t xTaskCreate( TaskFunction_t pxTaskCode, // 函数指针, 任务函数\n                        const char * const pcName, // 任务的名字\n                        const configSTACK_DEPTH_TYPE usStackDepth, // 栈大小,单位为word,10表示40字节\n                        void * const pvParameters, // 调用任务函数时传入的参数\n                        UBaseType_t uxPriority,    // 优先级\n                        TaskHandle_t * const pxCreatedTask ); // 任务句柄, 以后使用它来操作这个任务\n```\n\n参数说明：\n\n| **参数**      | **描述**                                                     |\n| ------------- | ------------------------------------------------------------ |\n| pvTaskCode    | 函数指针，任务对应的 C 函数。任务应该永远不退出，或者在退出时调用 \"`vTaskDelete(NULL)`\"。 |\n| pcName        | 任务的名称，仅用于调试目的，FreeRTOS 内部不使用。pcName 的长度为 `configMAX_TASK_NAME_LEN`。 |\n| usStackDepth  | 每个任务都有自己的栈，usStackDepth 指定了栈的大小，单位为 word。例如，如果传入 100，表示栈的大小为 100 word，即 400 字节。最大值为 uint16_t 的最大值。确定栈的大小并不容易，通常是根据估计来设定。精确的办法是查看反汇编代码。 |\n| pvParameters  | 调用 pvTaskCode 函数指针时使用的参数：`pvTaskCode(pvParameters)`。 |\n| uxPriority    | 任务的优先级范围为 0~(`configMAX_PRIORITIES – 1`)。数值越小，优先级越低。如果传入的值过大，`xTaskCreate `会将其调整为 (`configMAX_PRIORITIES – 1`)。 |\n| pxCreatedTask | 用于保存 xTaskCreate 的输出结果，即任务的句柄（task handle）。如果以后需要对该任务进行操作，如修改优先级，则需要使用此句柄。如果不需要使用该句柄，可以传入 NULL。 |\n| 返回值        | 成功时返回 pdPASS，失败时返回 `errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY`（失败原因是内存不足）。请注意，文档中提到的失败返回值是 pdFAIL 是不正确的。pdFAIL 的值为 0，而 `errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY` 的值为 -1。 |\n\n使用静态分配内存的函数如下：\n\n```c\nTaskHandle_t xTaskCreateStatic ( \n    TaskFunction_t pxTaskCode,   // 函数指针, 任务函数\n    const char * const pcName,   // 任务的名字\n    const uint32_t ulStackDepth, // 栈大小,单位为word,10表示40字节\n    void * const pvParameters,   // 调用任务函数时传入的参数\n    UBaseType_t uxPriority,      // 优先级\n    StackType_t * const puxStackBuffer, // 静态分配的栈，就是一个buffer\n    StaticTask_t * const pxTaskBuffer // 静态分配的任务结构体的指针，用它来操作这个任务\n);\n```\n\n相比于使用动态分配内存创建任务的函数，最后2个参数不一样：\n\n| **参数**       | **描述**                                                     |\n| -------------- | ------------------------------------------------------------ |\n| pvTaskCode     | 函数指针，可以简单地认为任务就是一个C函数。 它稍微特殊一点：永远不退出，或者退出时要调用\"`vTaskDelete(NULL)`\" |\n| pcName         | 任务的名字，FreeRTOS内部不使用它，仅仅起调试作用。 长度为：`configMAX_TASK_NAME_LEN` |\n| usStackDepth   | 每个任务都有自己的栈，这里指定栈大小。 单位是word，比如传入100，表示栈大小为100 word，也就是400字节。 最大值为uint16_t的最大值。 怎么确定栈的大小，并不容易，很多时候是估计。 精确的办法是看反汇编码。 |\n| pvParameters   | 调用pvTaskCode函数指针时用到：pvTaskCode(pvParameters)       |\n| uxPriority     | 优先级范围：0~(`configMAX_PRIORITIES – 1`) 数值越小优先级越低， 如果传入过大的值，`xTaskCreate`会把它调整为(`configMAX_PRIORITIES – 1`) |\n| puxStackBuffer | 静态分配的栈内存，比如可以传入一个数组， 它的大小是`usStackDepth*4`。 |\n| pxTaskBuffer   | 静态分配的`StaticTask_t`结构体的指针                         |\n| 返回值         | 成功：返回任务句柄； 失败：NULL                              |\n\n#### 任务栈大小估算\n\n任务栈空间包含\n\n- 返回地址`LR`与其他寄存器：可以理解为<span style=\"color:#FF0000;\">函数调用深度</span>\n- 局部变量：如`char buff[1000]` 直接看类型 此处则可以算1个\n- 保留现场：可以理解为固定16个寄存器 即<span style=\"color:#FF3333;\">16 * 4 = 64b</span>\n\n> 公式如下：\n>\n> - （n层调用 * 36） + 局部变量 + 64b\n>\n> - 例如：\n>\n>   ![image-20250914221448446](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509142214793.png)\n\n#### 使用任务参数\n\n我们说过，多个任务可以使用同一个函数，怎么体现它们的差别？\n\n- 栈不同\n- 创建任务时可以传入不同的参数\n\n我们创建2个任务，使用同一个函数，但是在LCD上打印不一样的信息。\n\n```c\ntypedef struct{\n    int x;\n    int y;\n    const char *str;\n}DisplayInfo;\nvoid vTaskFunction( void *pvParameters )\n{\n\tDisplayInfo *info = pvParameters;\n\tuint32_t cnt = 0;\nuint32_t len;\n\t\n\t/* 任务函数的主体一般都是无限循环 */\n\tfor( ;; )\n\t{\n\t\t/* 打印任务的信息 */\n\t\tlen = LCD_PrintString(info->x, info->y, info->str);\n\t\tLCD_PrintSignedVal(len+1, info->y, cnt++);\n\n\t\tmdelay(500);\n\t}\n}\n```\n\n上述代码中的info来自参数pvParameters，pvParameters来自哪里？创建任务时传入的。\n\n代码如下：\n\n- 使用xTaskCreate创建任务时，第4个参数就是pvParameters\n- 不同的任务，pvParameters不一样\n\n```c\nDisplayInfo g_Task1Info ={0,0,\"task1\"};\nDisplayInfo g_Task2Info ={3,0,\"task2\"};\nDisplayInfo g_Task3Info ={6,0,\"task3\"};\n\n/* 使用同一个函数创建不同的任务 */\n  xTaskCreate(LcdPrintTask, \"task1\", 128, &g_Task1Info, osPriorityNormal, NULL);\n  xTaskCreate(LcdPrintTask, \"task2\", 128, &g_Task2Info, osPriorityNormal, NULL);\n  xTaskCreate(LcdPrintTask, \"task3\", 128, &g_Task3Info, osPriorityNormal, NULL);\n```\n\n#### 任务的删除\n\n删除任务时使用的函数如下：\n\n```c\nvoid vTaskDelete( TaskHandle_t xTaskToDelete );\n```\n\n参数说明：\n\n| **参数**   | **描述**                                                     |\n| ---------- | ------------------------------------------------------------ |\n| pvTaskCode | 任务句柄，使用xTaskCreate创建任务时可以得到一个句柄。 也可传入NULL，这表示删除自己。 |\n\n怎么删除任务？举个不好的例子：\n\n- 自杀：`vTaskDelete(NULL)`\n- 被杀：别的任务执行`vTaskDelete(pvTaskCode)`，`pvTaskCode`是自己的句柄\n- 杀人：执行`vTaskDelete(pvTaskCode)`，`pvTaskCode`是别的任务的句柄\n\n#### 任务管理与调度机制\n\n##### 调度机制\n\n> - 同等优先级的任务 轮流运行\n> - 最高优先级的任务先运行\n>   - 高优先级的任务未运行完，低优先级任务无法运行\n>   - 一旦高优先级任务就绪 马上运行\n>   - 最高优先级的任务有多个 他们轮流运行\n\n![img](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509151548547.png)\n\n##### 任务管理\n\n任务的切换通过链表操作进行切换 RTOS会创建3个链表 分别是就绪链表ReadyList、阻塞链表DelayTaskList、挂起链表\n\n- 先在优先级数组中按下标从大到小遍历，使用任务创建函数<span style=\"color:#33FFFF;\">本质其实是在对应优先级数组中创建TCB结构体，并且会有一个全局指针——当前执行TCB结构体pxCurrentTCB</span>，这就说明了为什么同等优先级下，最后创建的任务先运行（因为指针最终指向了最后一个任务链表，启动调度器后，开始运行）\n\n- 当调用`vTaskDelay`后会将当前任务链表丢到阻塞链表上，并根据`vTaskDelay`的参数等待`Tick中断`判断到达时间后，该任务链表才能再次回到原先链表上\n\n- 当任务调用`vTaskSuspend`后 当前任务会被丢到挂起链表，此任务只有调用`vTaskResume`才能回到原先链表，不能通过`Tick中断`回归\n\n> Tick中断是什么？他又做些什么？\n>\n> - Tick中断来源于\n>\n>   ![image-20250915160032344](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509151600535.png)\n>\n> - Tick中断做什么？\n>\n>   1. 有个计数器count，count一直执行++\n>   2. 判断DelayTaskList里任务是否可以恢复（可恢复则将其丢到ReadyList）\n>   3. 发起调度（遍历优先级数组，改变pxCurrentTCB指针指向）\n\n##### 空闲任务\n\n空闲任务是Freertos启动调度器时 会自动创建的一个最低优先级的任务`prvIdleTask`\n\n- 负责清理用户的自杀任务 如`vTaskDelete(NULL)`的内存释放\n- 由于优先级最低 所以当用户任务不释放CPU时，就会导致空闲任务不会运行，因而`vTaskDelete(NULL)`得不到释放\n- 因此尽量不要使用死延时，改用`vTaskDelay`释放CPU 或者不使用自杀函数`vTaskDelete(NULL)`\n\n> 此外 空闲任务中还有提供钩子函数 可以方便我们在里面打印调试信息\n>\n> 注意每个任务都要使用while(1)进行死循环\n>\n> - 如果有一个任务没有则会触发任务退出错误中断`prvTaskExitError`\n> - ![image-20250915163446773](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509151634028.png)\n\n### 同步与互斥\n\n#### 同步与互斥的概念\n\n一句话理解同步与互斥：我等你用完厕所，我再用厕所。\n\n- 什么叫同步？就是：哎哎哎，我正在用厕所，你等会。 \n- 什么叫互斥？就是：哎哎哎，我正在用厕所，你不能进来。\n\n同步与互斥经常放在一起讲，是因为它们之的关系很大，“互斥”操作可以使用“同步”来实现。我“等”你用完厕所，我再用厕所。这不就是用“同步”来实现“互斥”吗？\n\n再举一个例子。在团队活动里，同事A先写完报表，经理B才能拿去向领导汇报。经理B必须等同事A完成报表，AB之间有依赖，B必须放慢脚步，被称为同步。在团队活动中，同事A已经使用会议室了，经理B也想使用，即使经理B是领导，他也得等着，这就叫互斥。经理B跟同事A说：你用完会议室就提醒我。这就是使用\"同步\"来实现\"互斥\"。\n\n有时候看代码更容易理解，伪代码如下：\n\n```c\n void  抢厕所(void)\n {\n   if (有人在用) 我眯一会;\n   用厕所;\n   喂，醒醒，有人要用厕所吗;\n }\n```\n\n假设有A、B两人早起抢厕所，A先行一步占用了；B慢了一步，于是就眯一会；当A用完后叫醒B，B也就愉快地上厕所了。\n\n在这个过程中，A、B是互斥地访问“厕所”，“厕所”被称之为临界资源。我们使用了“休眠-唤醒”的同步机制实现了“临界资源”的“互斥访问”。\n\n同一时间只能有一个人使用的资源，被称为临界资源。比如任务A、B都要使用串口来打印，串口就是临界资源。如果A、B同时使用串口，那么打印出来的信息就是A、B混杂，无法分辨。所以使用串口时，应该是这样：A用完，B再用；B用完，A再用\n\n#### 各类方法的对比\n\n能实现同步、互斥的内核方法有：任务通知(task notification)、队列(queue)、事件组(event group)、信号量(semaphoe)、互斥量(mutex)。\n\n它们都有类似的操作方法：获取/释放、阻塞/唤醒、超时。比如：\n\n- 任务A获取资源，用完后任务A释放资源\n- 任务A获取不到资源则阻塞，任务B释放资源并把任务A唤醒\n- 任务A获取不到资源则阻塞，并定个闹钟；A要么超时返回，要么在这段时间内因为任务B释放资源而被唤醒。\n\n这些内核对象五花八门，记不住怎么办？我也记不住，通过对比的方法来区分它们。\n\n- 能否传信息？还是只能传递状态？\n- 为众生（所有任务都可以使用）？只为你（只能指定任务使用）？\n- 我生产，你们消费？\n- 我上锁，只能由我开锁\n\n| **内核对象** | **生产者** | **消费者** | **数据/状态**                                                | **说明**                                                     |\n| ------------ | ---------- | ---------- | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| 队列         | ALL        | ALL        | 数据：若干个数据 谁都可以往队列里扔数据， 谁都可以从队列里读数据 | 用来传递数据， 发送者、接收者无限制， 一个数据只能唤醒一个接收者 |\n| 事件组       | ALL        | ALL        | 多个位：或、与 谁都可以设置(生产)多个位， 谁都可以等待某个位、若干个位 | 用来传递事件， 可以是N个事件， 发送者、接受者无限制， 可以唤醒多个接收者：像广播 |\n| 信号量       | ALL        | ALL        | 数量：0~n 谁都可以增加一个数量， 谁都可消耗一个数量          | 用来维持资源的个数， 生产者、消费者无限制， 1个资源只能唤醒1个接收者 |\n| 任务通知     | ALL        | 只有我     | 数据、状态都可以传输， 使用任务通知时， 必须指定接受者       | N对1的关系： 发送者无限制， 接收者只能是这个任务             |\n| 互斥量       | 只能A开锁  | A上锁      | 位：0、1 我上锁：1变为0， 只能由我开锁：0变为1               | 就像一个空厕所， 谁使用谁上锁， 也只能由他开锁               |\n\n使用图形对比如下：\n\n- 队列：\n  - 里面可以放任意数据，可以放多个数据\n  - 任务、ISR都可以放入数据；任务、ISR都可以从中读出数据\n- 事件组：\n  - 一个事件用一bit表示，1表示事件发生了，0表示事件没发生\n  - 可以用来表示事件、事件的组合发生了，不能传递数据\n  - 有广播效果：事件或事件的组合发生了，等待它的多个任务都会被唤醒\n- 信号量：\n  - 核心是\"计数值\"\n  - 任务、ISR释放信号量时让计数值加1\n  - 任务、ISR获得信号量时，让计数值减1\n- 任务通知：\n  - 核心是任务的TCB里的数值\n  - 会被覆盖\n  - 发通知给谁？必须指定接收任务\n  - 只能由接收任务本身获取该通知\n- 互斥量：\n  - 数值只有0或1\n  - 谁获得互斥量，就必须由谁释放同一个互斥量\n\n![img](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509151740912.png)\n\n> 为何要引用这些机制呢？\n>\n> - 原本逻辑可以采用全局变量来进行传递信息，但在RTOS下，可能还未来得及改变全局变量的值就被切换到其他任务，这样就会发生全局变量未及时更新的问题\n> - 引入事件阻塞与唤醒大大提高了CPU的利用率\n>   - 当任务A计数1s，任务B负责打印任务A的最终计数值，就不会出现A运行，B也运行，而是等待A运行完后通知任务B，或大概估算任务A结束的时间，让B阻塞这么多的时间，这样就实现了整个时间轴都是任务A在运行\n\n### 队列\n\n#### 队列的本质\n\n队列中，数据的读写就是环形缓冲区，在这个基础上增加了互斥措施、阻塞-唤醒机制\n\n- 如果这个队列不传输数据，只调整“数据个数”，他就是信号量（semaphore）\n- 如果信号量中，限定“数据个数”最大值为1，他就是互斥量（mutex）\n\n#### 传输数据的两种方法\n\n使用队列传输数据时有两种方法：\n\n- 拷贝：把数据、把变量的值复制进队列里\n- 引用：把数据、把变量的地址复制进队列里\n\nFreeRTOS使用拷贝值的方法，这更简单：\n\n- 局部变量的值可以发送到队列中，后续即使函数退出、局部变量被回收，也不会影响队列中的数据\n- 无需分配buffer来保存数据，队列中有buffer\n- 局部变量可以马上再次使用\n- 发送任务、接收任务解耦：接收任务不需要知道这数据是谁的、也不需要发送任务来释放数据\n- 如果数据实在太大，你还是可以使用队列传输它的地址\n- 队列的空间有FreeRTOS内核分配，无需任务操心\n- 对于有内存保护功能的系统，如果队列使用引用方法，也就是使用地址，必须确保双方任务对这个地址都有访问权限。使用拷贝方法时，则无此限制：内核有足够的权限，把数据复制进队列、再把数据复制出队列。\n\n#### 队列的阻塞访问\n\n只要知道队列的句柄，谁都可以读、写该队列。任务、ISR都可读、写队列。可以多个任务读写队列。\n\n任务读写队列时，简单地说：如果读写不成功，则阻塞；可以指定超时时间。口语化地说，就是可以定个闹钟：如果能读写了就马上进入就绪态，否则就阻塞直到超时。\n\n某个任务读队列时，如果队列没有数据，则该任务可以进入阻塞状态：还可以指定阻塞的时间。如果队列有数据了，则该阻塞的任务会变为就绪态。如果一直都没有数据，则时间到之后它也会进入就绪态。\n\n既然读取队列的任务个数没有限制，那么当多个任务读取空队列时，这些任务都会进入阻塞状态：有多个任务在等待同一个队列的数据。当队列中有数据时，哪个任务会进入就绪态？\n\n- 优先级最高的任务\n- 如果大家的优先级相同，那等待时间最久的任务会进入就绪态\n\n跟读队列类似，一个任务要写队列时，如果队列满了，该任务也可以进入阻塞状态：还可以指定阻塞的时间。如果队列有空间了，则该阻塞的任务会变为就绪态。如果一直都没有空间，则时间到之后它也会进入就绪态。\n\n既然写队列的任务个数没有限制，那么当多个任务写\"满队列\"时，这些任务都会进入阻塞状态：有多个任务在等待同一个队列的空间。当队列中有空间时，哪个任务会进入就绪态？\n\n- 优先级最高的任务\n- 如果大家的优先级相同，那等待时间最久的任务会进入就绪态\n\n#### 队列函数\n\n##### 创建\n\n队列的创建有两种方法：动态分配内存、静态分配内存，\n\n- 动态分配内存：xQueueCreate，队列的内存在函数内部动态分配\n\n函数原型如下：\n\n```c\nQueueHandle_t xQueueCreate( UBaseType_t uxQueueLength, UBaseType_t uxItemSize );\n```\n\n| **参数**        | **说明**                                                     |\n| --------------- | ------------------------------------------------------------ |\n| `uxQueueLength` | 队列长度，最多能存放多少个数据(item)                         |\n| `uxItemSize`    | 每个数据(item)的大小：以字节为单位（可以定义一个结构体存放，然后sizeof(结构体)） |\n| 返回值          | 非0：成功，返回句柄，以后使用句柄来操作队列 NULL：失败，因为内存不足 |\n\n- 静态分配内存：`xQueueCreateStatic`，队列的内存要事先分配好\n\n函数原型如下：\n\n```c\nQueueHandle_t xQueueCreateStatic(*\n              \t\tUBaseType_t uxQueueLength,*\n              \t\tUBaseType_t uxItemSize,*\n              \t\tuint8_t *pucQueueStorageBuffer,*\n              \t\tStaticQueue_t *pxQueueBuffer*\n           \t\t );\n```\n\n| **参数**                | **说明**                                                     |\n| ----------------------- | ------------------------------------------------------------ |\n| `uxQueueLength`         | 队列长度，最多能存放多少个数据(item)                         |\n| `uxItemSize`            | 每个数据(item)的大小：以字节为单位                           |\n| `pucQueueStorageBuffer` | 如果uxItemSize非0，`pucQueueStorageBuffer`必须指向一个uint8_t数组， 此数组大小至少为\"uxQueueLength * uxItemSize\" |\n| `pxQueueBuffer`         | 必须执行一个`StaticQueue_t`结构体，用来保存队列的数据结构    |\n| 返回值                  | 非0：成功，返回句柄，以后使用句柄来操作队列 NULL：失败，因为`pxQueueBuffer`为NULL |\n\n##### 复位\n\n队列刚被创建时，里面没有数据；使用过程中可以调用 **xQueueReset()** 把队列恢复为初始状态，此函数原型为：\n\n```c\n/*  pxQueue : 复位哪个队列;\n * 返回值: pdPASS(必定成功)\n*/\nBaseType_t xQueueReset( QueueHandle_t pxQueue);\n```\n\n##### 删除\n\n删除队列的函数为 **vQueueDelete()** ，只能删除使用动态方法创建的队列，它会释放内存。原型如下：\n\n```c\nvoid vQueueDelete( QueueHandle_t xQueue );\n```\n\n##### 写队列\n\n可以把数据写到队列头部，也可以写到尾部，这些函数有两个版本：在任务中使用、在ISR中使用。函数原型如下：\n\n```c\n/* 等同于xQueueSendToBack\n * 往队列尾部写入数据，如果没有空间，阻塞时间为xTicksToWait\n */\nBaseType_t xQueueSend(\n                                QueueHandle_t    xQueue,\n                                const void       *pvItemToQueue,\n                                TickType_t       xTicksToWait\n                            );\n\n/* \n * 往队列尾部写入数据，如果没有空间，阻塞时间为xTicksToWait\n */\nBaseType_t xQueueSendToBack(\n                                QueueHandle_t    xQueue,\n                                const void       *pvItemToQueue,\n                                TickType_t       xTicksToWait\n                            );\n\n\n/* \n * 往队列尾部写入数据，此函数可以在中断函数中使用，不可阻塞\n */\nBaseType_t xQueueSendToBackFromISR(\n                                      QueueHandle_t xQueue,\n                                      const void *pvItemToQueue,\n                                      BaseType_t *pxHigherPriorityTaskWoken\n                                   );\n\n/* \n * 往队列头部写入数据，如果没有空间，阻塞时间为xTicksToWait\n */\nBaseType_t xQueueSendToFront(\n                                QueueHandle_t    xQueue,\n                                const void       *pvItemToQueue,\n                                TickType_t       xTicksToWait\n                            );\n\n/* \n * 往队列头部写入数据，此函数可以在中断函数中使用，不可阻塞\n */\nBaseType_t xQueueSendFromISR(\n                                      QueueHandle_t xQueue,\n                                      const void *pvItemToQueue,\n                                      BaseType_t *pxHigherPriorityTaskWoken\n                                   );\n```\n\n这些函数用到的参数是类似的，统一说明如下：\n\n| 参数            | 说明                                                         |\n| --------------- | ------------------------------------------------------------ |\n| `xQueue`        | 队列句柄，要写哪个队列                                       |\n| `pvItemToQueue` | 数据指针，这个数据的值会被复制进队列， 复制多大的数据？在创建队列时已经指定了数据大小 |\n| `xTicksToWait`  | 如果队列满则无法写入新数据，可以让任务进入阻塞状态， `xTicksToWait`表示阻塞的最大时间(Tick Count)。 如果被设为0，无法写入数据时函数会立刻返回； 如果被设为`portMAX_DELAY`，则会一直阻塞直到有空间可写 |\n| 返回值          | pdPASS：数据成功写入了队列 `errQUEUE_FULL`：写入失败，因为队列满了。 |\n\n##### 读队列\n\n使用 **xQueueReceive()** 函数读队列，读到一个数据后，队列中该数据会被移除。这个函数有两个版本：在任务中使用、在ISR中使用。函数原型如下：\n\n```c\nBaseType_t xQueueReceive( QueueHandle_t xQueue,\n                          void * const pvBuffer,\n                          TickType_t xTicksToWait );\n\nBaseType_t xQueueReceiveFromISR(\n                                    QueueHandle_t    xQueue,\n                                    void             *pvBuffer,\n                                    BaseType_t       *pxTaskWoken\n                                );\n```\n\n参数说明如下：\n\n| **参数**       | **说明**                                                     |\n| -------------- | ------------------------------------------------------------ |\n| `xQueue`       | 队列句柄，要读哪个队列                                       |\n| `pvBuffer`     | buffer指针，队列的数据会被复制到这个buffer 复制多大的数据？在创建队列时已经指定了数据大小 |\n| `xTicksToWait` | 果队列空则无法读出数据，可以让任务进入阻塞状态， xTicksToWait表示阻塞的最大时间(Tick Count)。 如果被设为0，无法读出数据时函数会立刻返回； 如果被设为portMAX_DELAY，则会一直阻塞直到有数据可写 |\n| 返回值         | pdPASS：从队列读出数据入 `errQUEUE_EMPTY`：读取失败，因为队列空了。 |\n\n##### 查询\n\n可以查询队列中有多少个数据、有多少空余空间。函数原型如下：\n\n```c\n/*\n * 返回队列中可用数据的个数\n */\nUBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue );\n\n/*\n * 返回队列中可用空间的个数\n */\nUBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue );\n```\n\n##### 覆盖/偷看\n\n当队列长度为1时，可以使用 **xQueueOverwrite()** 或 **xQueueOverwriteFromISR()** 来覆盖数据。\n\n注意，队列长度必须为1。当队列满时，这些函数会覆盖里面的数据，这也以为着这些函数不会被阻塞。\n\n函数原型如下：\n\n```c\n/* 覆盖队列\n * xQueue: 写哪个队列\n * pvItemToQueue: 数据地址\n * 返回值: pdTRUE表示成功, pdFALSE表示失败\n */\nBaseType_t xQueueOverwrite(\n                           QueueHandle_t xQueue,\n                           const void * pvItemToQueue\n                      );\n\nBaseType_t xQueueOverwriteFromISR(\n                           QueueHandle_t xQueue,\n                           const void * pvItemToQueue,\n                           BaseType_t *pxHigherPriorityTaskWoken\n                      );\n```\n\n如果想让队列中的数据供多方读取，也就是说读取时不要移除数据，要留给后来人。那么可以使用\"窥视\"，也就是**xQueuePeek()\\**或\\**xQueuePeekFromISR()**。这些函数会从队列中复制出数据，但是不移除数据。这也意味着，如果队列中没有数据，那么\"偷看\"时会导致阻塞；一旦队列中有数据，以后每次\"偷看\"都会成功。\n\n函数原型如下：\n\n```c\n/* 偷看队列\n * xQueue: 偷看哪个队列\n * pvItemToQueue: 数据地址, 用来保存复制出来的数据\n * xTicksToWait: 没有数据的话阻塞一会\n * 返回值: pdTRUE表示成功, pdFALSE表示失败\n */\nBaseType_t xQueuePeek(\n                          QueueHandle_t xQueue,\n                          void * const pvBuffer,\n                          TickType_t xTicksToWait\n                      );\n\nBaseType_t xQueuePeekFromISR(\n                                 QueueHandle_t xQueue,\n                                 void *pvBuffer,\n                             );\n```\n\n#### 使用队列时注意\n\n> 写队列与读队列 所传入的`buffer`一定要严格按照初始创建时的类型，否则就会出现死机\n>\n> - 情况一：创建时类型为指针（常用，可以接收多种类型）\n>\n> ```C\n> typedef struct\n> {\n>     uint8_t data[128];\n>     uint8_t index;\n> }Uart_RxTypeDef;\n> \n> Uart_RxTypeDef UartRx = {{0},0};\n> \n> void task(void *arg)\n> {\n>     Uart_RxTypeDef *data = &UartRx;\n>     debug_TX_QueueHandle = osMessageQueueNew(5, sizeof(void *), &debug_TX_Queue_attributes);\n>     xQueueSend(debug_TX_QueueHandle,&data,NULL);//此处一定要&data 因为创建队列的时候是指针 直接写data 相当于&UartRx 他并不是一个指针\n> }\n> \n> ```\n>\n> - 情况二：创建时类型为数据\n>\n> ```C\n> typedef struct\n> {\n>     uint8_t data[128];\n>     uint8_t index;\n> }Uart_RxTypeDef;\n> \n> Uart_RxTypeDef UartRx = {{0},0};\n> \n> void task(void *arg)\n> {\n>     Uart_RxTypeDef data = {{0},0};\n>     debug_TX_QueueHandle = osMessageQueueNew(5, sizeof(Uart_RxTypeDef), &debug_TX_Queue_attributes);\n>     xQueueSend(debug_TX_QueueHandle,&data,NULL);//此处的&data与情况一不一样 这个是参数要求要地址 所以需要将结构体的地址赋值过去\n> }\n> ```\n>\n> \n\n#### 队列集\n\n> 当多个队列需要上报到同一个处理任务时，队列集可以实现统合多个队列，再往上传递到同一个任务\n\n![image-20250915213146479](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509152131801.png)\n\n##### 创建队列集\n\n> 注意要使用队列集 需要先在`Core/inc/FreeRTOSConfig.h` 定义\n>\n> ```bash\n> #define configUSE_QUEUE_SETS 1\n> ```\n\n函数原型如下：\n\n```c\nQueueSetHandle_t xQueueCreateSet( const UBaseType_t uxEventQueueLength )\n```\n\n| **参数**      | **说明**                                                     |\n| ------------- | ------------------------------------------------------------ |\n| uxQueueLength | 队列集长度，最多能存放多少个数据(队列句柄)                   |\n| 返回值        | 非0：成功，返回句柄，以后使用句柄来操作队列NULL：失败，因为内存不足 |\n\n##### 把队列加入队列集\n\n函数原型如下：\n\n```c\nBaseType_t xQueueAddToSet( QueueSetMemberHandle_t xQueueOrSemaphore,\n\n                QueueSetHandle_t xQueueSet );\n\n \n```\n\n| **参数**          | **说明**                       |\n| ----------------- | ------------------------------ |\n| xQueueOrSemaphore | 队列句柄，这个队列要加入队列集 |\n| xQueueSet         | 队列集句柄                     |\n| 返回值            | pdTRUE：成功pdFALSE：失败      |\n\n##### 读取队列集\n\n函数原型如下：\n\n```c\nQueueSetMemberHandle_t xQueueSelectFromSet( QueueSetHandle_t xQueueSet,\n\n                        TickType_t const xTicksToWait );\n```\n\n| **参数**     | **说明**                                                     |\n| ------------ | ------------------------------------------------------------ |\n| xQueueSet    | 队列集句柄                                                   |\n| xTicksToWait | 如果队列集空则无法读出数据，可以让任务进入阻塞状态，xTicksToWait表示阻塞的最大时间(Tick Count)。如果被设为0，无法读出数据时函数会立刻返回；如果被设为portMAX_DELAY，则会一直阻塞直到有数据可写 |\n| 返回值       | NULL：失败，队列句柄：成功                                   |\n\n### 信号量\n\n前面介绍的队列(queue)可以用于传输数据：在任务之间、任务和中断之间。\n\n消息队列用于传输多个数据，但是有时候我们只需要传递状态，这个状态值需要用一个数值表示，比如：\n\n- 卖家：做好了1个包子！做好了2个包子！做好了3个包子！\n- 买家：买了1个包子，包子数量减1\n- 这个停车位我占了，停车位减1\n- 我开车走了，停车位加1\n\n在这种情况下我们只需要维护一个数值，使用信号量效率更高、更节省内存 本章涉及如下内容：\n\n- 怎么创建、删除信号量\n- 怎么发送、获得信号量\n- 什么是计数型信号量？什么是二进制信号量？\n\n####  信号量的特性\n\n##### 信号量的常规操作\n\n信号量这个名字很恰当：\n\n- 信号：起通知作用\n- 量：还可以用来表示资源的数量\n  - 当\"量\"没有限制时，它就是\"计数型信号量\"(Counting Semaphores)\n  - 当\"量\"只有0、1两个取值时，它就是\"二进制信号量\"(Binary Semaphores)\n- 支持的动作：\"give\"给出资源，计数值加1；\"take\"获得资源，计数值减1\n\n计数型信号量的典型场景是：\n\n- 计数：事件产生时\"give\"信号量，让计数值加1；处理事件时要先\"take\"信号量，就是获得信号量，让计数值减1。\n- 资源管理：要想访问资源需要先\"take\"信号量，让计数值减1；用完资源后\"give\"信号量，让计数值加1。 信号量的\"give\"、\"take\"双方并不需要相同，可以用于生产者-消费者场合：\n- 生产者为任务A、B，消费者为任务C、D\n- 一开始信号量的计数值为0，如果任务C、D想获得信号量，会有两种结果：\n  - 阻塞：买不到东西咱就等等吧，可以定个闹钟(超时时间)\n  - 即刻返回失败：不等\n- 任务A、B可以生产资源，就是让信号量的计数值增加1，并且把等待这个资源的顾客唤醒\n- 唤醒谁？谁优先级高就唤醒谁，如果大家优先级一样就唤醒等待时间最长的人\n\n二进制信号量跟计数型的唯一差别，就是计数值的最大值被限定为1。\n\n![img](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509161022312.png)\n\n##### 信号量跟队列的对比\n\n差异列表如下：\n\n| 队列                                                         | 信号量                                                       |\n| ------------------------------------------------------------ | ------------------------------------------------------------ |\n| 可以容纳多个数据， 创建队列时有2部分内存: 队列结构体、存储数据的空间 | 只有计数值，无法容纳其他数据。 创建信号量时，只需要分配信号量结构体 |\n| 生产者：没有空间存入数据时可以阻塞                           | 生产者：用于不阻塞，计数值已经达到最大时返回失败             |\n| 消费者：没有数据时可以阻塞                                   | 消费者：没有资源时可以阻塞                                   |\n\n##### 两种信号量的对比\n\n信号量的计数值都有限制：限定了最大值。如果最大值被限定为1，那么它就是二进制信号量；如果最大值不是1，它就是计数型信号量。\n\n差别列表如下：\n\n| 二进制信号量      | 计数型信号量           |\n| ----------------- | ---------------------- |\n| 被创建时初始值为0 | 被创建时初始值可以设定 |\n| 其他操作是一样的  | 其他操作是一样的       |\n\n#### 信号量函数\n\n使用信号量时，先创建、然后去添加资源、获得资源。使用句柄来表示一个信号量。\n\n##### 创建\n\n使用信号量之前，要先创建，得到一个句柄；使用信号量时，要使用句柄来表明使用哪个信号量。 对于二进制信号量、计数型信号量，它们的创建函数不一样：\n\n|          | 二进制信号量                                     | 计数型信号量                     |\n| -------- | ------------------------------------------------ | -------------------------------- |\n| 动态创建 | `xSemaphoreCreateBinary `计数值初始值为0         | `xSemaphoreCreateCounting`       |\n|          | `vSemaphoreCreateBinary`(过时了) 计数值初始值为1 |                                  |\n| 静态创建 | `xSemaphoreCreateBinaryStatic`                   | `xSemaphoreCreateCountingStatic` |\n\n创建二进制信号量的函数原型如下：\n\n```c\n/* 创建一个二进制信号量，返回它的句柄。\n * 此函数内部会分配信号量结构体 \n * 返回值: 返回句柄，非NULL表示成功\n */\nSemaphoreHandle_t xSemaphoreCreateBinary( void );\n\n/* 创建一个二进制信号量，返回它的句柄。\n * 此函数无需动态分配内存，所以需要先有一个StaticSemaphore_t结构体，并传入它的指针\n * 返回值: 返回句柄，非NULL表示成功\n */\nSemaphoreHandle_t xSemaphoreCreateBinaryStatic( StaticSemaphore_t *pxSemaphoreBuffer );\n```\n\n创建计数型信号量的函数原型如下：\n\n```c\n/* 创建一个计数型信号量，返回它的句柄。\n * 此函数内部会分配信号量结构体 \n * uxMaxCount: 最大计数值\n * uxInitialCount: 初始计数值\n * 返回值: 返回句柄，非NULL表示成功\n */\nSemaphoreHandle_t xSemaphoreCreateCounting(UBaseType_t uxMaxCount, UBaseType_t uxInitialCount);\n\n/* 创建一个计数型信号量，返回它的句柄。\n * 此函数无需动态分配内存，所以需要先有一个StaticSemaphore_t结构体，并传入它的指针\n * uxMaxCount: 最大计数值\n * uxInitialCount: 初始计数值\n * pxSemaphoreBuffer: StaticSemaphore_t结构体指针\n * 返回值: 返回句柄，非NULL表示成功\n */\nSemaphoreHandle_t xSemaphoreCreateCountingStatic( UBaseType_t uxMaxCount, \n                                                 UBaseType_t uxInitialCount, \n                                                 StaticSemaphore_t *pxSemaphoreBuffer );\n```\n\n##### 删除\n\n对于动态创建的信号量，不再需要它们时，可以删除它们以回收内存。\n\nvSemaphoreDelete可以用来删除二进制信号量、计数型信号量，函数原型如下：\n\n```c\n/*\n * xSemaphore: 信号量句柄，你要删除哪个信号量\n */\nvoid vSemaphoreDelete( SemaphoreHandle_t xSemaphore );\n```\n\n##### 释放/获取信号量\n\n二进制信号量、计数型信号量的give、take操作函数是一样的。这些函数也分为2个版本：给任务使用，给ISR使用。列表如下：\n\n|      | 在任务中使用     | 在ISR中使用             |\n| ---- | ---------------- | ----------------------- |\n| give | `xSemaphoreGive` | `xSemaphoreGiveFromISR` |\n| take | `xSemaphoreTake` | `xSemaphoreTakeFromISR` |\n\nxSemaphoreGive的函数原型如下：\n\n```c\nBaseType_t xSemaphoreGive( SemaphoreHandle_t xSemaphore );\n```\n\nxSemaphoreGive函数的参数与返回值列表如下：\n\n| 参数       | 说明                                                         |\n| ---------- | ------------------------------------------------------------ |\n| xSemaphore | 信号量句柄，释放哪个信号量                                   |\n| 返回值     | pdTRUE表示成功, 如果二进制信号量的计数值已经是1，再次调用此函数则返回失败； 如果计数型信号量的计数值已经是最大值，再次调用此函数则返回失败 |\n\npxHigherPriorityTaskWoken的函数原型如下：\n\n```c\nBaseType_t xSemaphoreGiveFromISR(\n                        SemaphoreHandle_t xSemaphore,\n                        BaseType_t *pxHigherPriorityTaskWoken\n                    );\n```\n\nxSemaphoreGiveFromISR函数的参数与返回值列表如下：\n\n| 参数                      | 说明                                                         |\n| ------------------------- | ------------------------------------------------------------ |\n| xSemaphore                | 信号量句柄，释放哪个信号量                                   |\n| pxHigherPriorityTaskWoken | 如果释放信号量导致更高优先级的任务变为了就绪态， 则*pxHigherPriorityTaskWoken = pdTRUE |\n| 返回值                    | pdTRUE表示成功, 如果二进制信号量的计数值已经是1，再次调用此函数则返回失败； 如果计数型信号量的计数值已经是最大值，再次调用此函数则返回失败 |\n\nxSemaphoreTake的函数原型如下：\n\n```c\nBaseType_t xSemaphoreTake(\n                   SemaphoreHandle_t xSemaphore,\n                   TickType_t xTicksToWait\n               );\n```\n\nxSemaphoreTake函数的参数与返回值列表如下：\n\n| 参数           | 说明                                                         |\n| -------------- | ------------------------------------------------------------ |\n| `xSemaphore`   | 信号量句柄，获取哪个信号量                                   |\n| `xTicksToWait` | 如果无法马上获得信号量，阻塞一会： 0：不阻塞，马上返回 `portMAX_DELAY`: 一直阻塞直到成功 其他值: 阻塞的Tick个数，可以使用*`pdMS_TO_TICKS`()*来指定阻塞时间为若干`ms` |\n| 返回值         | pdTRUE表示成功                                               |\n\nxSemaphoreTakeFromISR的函数原型如下：\n\n```c\nBaseType_t xSemaphoreTakeFromISR(\n                        SemaphoreHandle_t xSemaphore,\n                        BaseType_t *pxHigherPriorityTaskWoken\n                    );\n```\n\nxSemaphoreTakeFromISR函数的参数与返回值列表如下：\n\n| 参数                        | 说明                                                         |\n| --------------------------- | ------------------------------------------------------------ |\n| `xSemaphore`                | 信号量句柄，获取哪个信号量                                   |\n| `pxHigherPriorityTaskWoken` | 如果获取信号量导致更高优先级的任务变为了就绪态， 则`*pxHigherPriorityTaskWoken = pdTRUE` |\n| 返回值                      | pdTRUE表示成功                                               |\n\n#### 优先级反转\n\n信号量使用不当 就会出现优先级反转的问题——任务执行顺序：任务1、任务2、任务1、任务3\n\n即最高优先级的任务最后运行\n\n> 优先级反转：假设信号量值为1，同时创建了低、中等、高优先级任务\n>\n> - 低优先级任务获取信号量，中等优先级先阻塞一段时间，确保低优先级任务先成功获取到信号量\n> - 高优先级任务先阻塞一段时间，确保低优先级、中等优先级先完成任务，然后尝试获取信号量\n> - 此时由于低优先级获取了信号量，高优先级任务就会被阻塞\n> - 中等优先级不释放信号量，那么就会发生高优先级任务无法运行\n\n##### 示例\n\n```C\n#include \"uart.h\"\ntypedef struct __FILE FILE;\n\nstatic SemaphoreHandle_t task_mutex = NULL;\n\ntypedef struct\n{\n    uint8_t dev;\n    uint8_t *data;\n} uart_info_t;\n\nuart_info_t task1_data = {1, \"task1\"};\nuart_info_t task2_data = {2, \"task2\"};\nuart_info_t task3_data = {3, \"task3\"};\nint fputc(int ch, FILE *f)\n{\n    HAL_UART_Transmit(&huart1, (uint8_t *)&ch, 1, 0xFFFF);\n    return ch;\n}\n\nvoid task1(void *param)\n{\n    uint8_t cnt = 0;\n    xSemaphoreTake(task_mutex, portMAX_DELAY);\n    uart_info_t *data = param;\n    while (1)\n    {\n        printf(\"dev:%u,name:%s\\r\\n\", data->dev, data->data);\n        if (++cnt == 5)\n        {\n            xSemaphoreGive(task_mutex);\n        }\n        vTaskDelay(50);\n    }\n}\n\nvoid task2(void *param)\n{\n    uint8_t cnt = 0;\n    vTaskDelay(300);//先阻塞一段时间 确保任务1成功获取信号量且能够被切换为任务2\n    uart_info_t *data = param;\n    while (1)\n    {\n        printf(\"dev:%u,name:%s\\r\\n\", data->dev, data->data);\n        if (++cnt == 5)\n        {\n            vTaskDelete(NULL);\n        }\n        HAL_Delay(50);\n    }\n}\n\nvoid task3(void *param)\n{\n    uint8_t cnt = 0;\n    vTaskDelay(500);\t//先阻塞一段时间 确保任务1先成功获取信号量且能够被切换为任务2\n    xSemaphoreTake(task_mutex, portMAX_DELAY);\n    uart_info_t *data = param;\n    while (1)\n    {\n        printf(\"dev:%u,name:%s\\r\\n\", data->dev, data->data);\n        if (++cnt == 5)\n        {\n            vTaskDelete(NULL);\n        }\n    }\n}\n\nvoid uart_init(void)\n{\n    task_mutex = xSemaphoreCreateBinary();\n    xSemaphoreGive(task_mutex);\n    xTaskCreate(task1, \"task1\", 128, &task1_data, osPriorityNormal, NULL);\t//低优先级任务\n    xTaskCreate(task2, \"task2\", 128, &task2_data, osPriorityNormal1, NULL);\t//中等优先级任务\n    xTaskCreate(task3, \"task3\", 128, &task3_data, osPriorityNormal2, NULL);\t//高优先级任务\n}\n```\n\n![image-20250916160014655](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509161600972.png)\n\n#### 解决优先级反转\n\n> 使用互斥量 （实现优先级继承），当最高优先级任务等待互斥量时，可以将低优先级任务继承最高优先级，使得最高优先级任务也可以先运行\n>\n> 现象：任务1执行一小段时间被任务2抢占，当任务3时间到来，任务1继承任务3优先级，所以任务1运行释放后，任务1恢复原先优先级，任务3启动\n\n### 事件组\n\n> 上述任务同步与互斥的方法都是一对一通知，难以实现一对多通知（广播），因此引入了事件组\n\n#### 事件组的概念\n\n事件组可以简单地认为就是一个整数：\n\n- 的每一位表示一个事件\n- 每一位事件的含义由程序员决定，比如：Bit0表示用来串口是否就绪，Bit1表示按键是否被按下\n- 这些位，值为1表示事件发生了，值为0表示事件没发生\n- 一个或多个任务、ISR都可以去写这些位；一个或多个任务、ISR都可以去读这些位\n- 可以等待某一位、某些位中的任意一个，也可以等待多位\n\n![img](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509161809736.png)\n\n事件组用一个整数来表示，其中的高8位留给内核使用，只能用其他的位来表示事件。那么这个整数是多少位的？\n\n- 如果configUSE_16_BIT_TICKS是1，那么这个整数就是16位的，低8位用来表示事件\n- 如果configUSE_16_BIT_TICKS是0，那么这个整数就是32位的，低24位用来表示事件\n- configUSE_16_BIT_TICKS是用来表示Tick Count的，怎么会影响事件组？这只是基于效率来考虑\n  - 如果configUSE_16_BIT_TICKS是1，就表示该处理器使用16位更高效，所以事件组也使用16位\n  - 如果configUSE_16_BIT_TICKS是0，就表示该处理器使用32位更高效，所以事件组也使用32位\n\n#### 事件组的操作\n\n事件组和队列、信号量等不太一样，主要集中在2个地方：\n\n- 唤醒谁？\n  - 队列、信号量：事件发生时，只会唤醒一个任务\n  - 事件组：事件发生时，会唤醒所有符号条件的任务，简单地说它有\"广播\"的作用\n- 是否清除事件？\n  - 队列、信号量：是消耗型的资源，队列的数据被读走就没了；信号量被获取后就减少了\n  - 事件组：被唤醒的任务有两个选择，可以让事件保留不动，也可以清除事件\n\n以上图为列，事件组的常规操作如下：\n\n- 先创建事件组\n- 任务C、D等待事件：\n  - 等待什么事件？可以等待某一位、某些位中的任意一个，也可以等待多位。简单地说就是\"或\"、\"与\"的关系。\n  - 得到事件时，要不要清除？可选择清除、不清除。\n- 任务A、B产生事件：设置事件组里的某一位、某些位\n\n#### 事件组函数\n\n##### 创建\n\n使用事件组之前，要先创建，得到一个句柄；使用事件组时，要使用句柄来表明使用哪个事件组。\n\n有两种创建方法：动态分配内存、静态分配内存。函数原型如下：\n\n```c\n/* 创建一个事件组，返回它的句柄。\n * 此函数内部会分配事件组结构体 \n * 返回值: 返回句柄，非NULL表示成功\n */\nEventGroupHandle_t xEventGroupCreate( void );\n\n/* 创建一个事件组，返回它的句柄。\n * 此函数无需动态分配内存，所以需要先有一个StaticEventGroup_t结构体，并传入它的指针\n * 返回值: 返回句柄，非NULL表示成功\n */\nEventGroupHandle_t xEventGroupCreateStatic( StaticEventGroup_t * pxEventGroupBuffer );\n```\n\n##### 删除\n\n对于动态创建的事件组，不再需要它们时，可以删除它们以回收内存。\n\n**vEventGroupDelete**可以用来删除事件组，函数原型如下：\n\n```c\n/*\n * xEventGroup: 事件组句柄，你要删除哪个事件组\n */\nvoid vEventGroupDelete( EventGroupHandle_t xEventGroup )\n```\n\n##### 设置事件\n\n可以设置事件组的某个位、某些位，使用的函数有2个：\n\n- 在任务中使用**xEventGroupSetBits()**\n- 在ISR中使用**xEventGroupSetBitsFromISR()**\n\n有一个或多个任务在等待事件，如果这些事件符合这些任务的期望，那么任务还会被唤醒。\n\n函数原型如下：\n\n```c\n/* 设置事件组中的位\n * xEventGroup: 哪个事件组\n * uxBitsToSet: 设置哪些位? \n *              如果uxBitsToSet的bitX, bitY为1, 那么事件组中的bitX, bitY被设置为1\n *              可以用来设置多个位，比如 0x15 就表示设置bit4, bit2, bit0\n * 返回值: 返回原来的事件值(没什么意义, 因为很可能已经被其他任务修改了)\n */\nEventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup,\n                                    const EventBits_t uxBitsToSet );\n\n/* 设置事件组中的位\n * xEventGroup: 哪个事件组\n * uxBitsToSet: 设置哪些位? \n *              如果uxBitsToSet的bitX, bitY为1, 那么事件组中的bitX, bitY被设置为1\n *              可以用来设置多个位，比如 0x15 就表示设置bit4, bit2, bit0\n * pxHigherPriorityTaskWoken: 有没有导致更高优先级的任务进入就绪态? pdTRUE-有, pdFALSE-没有\n * 返回值: pdPASS-成功, pdFALSE-失败\n */\nBaseType_t xEventGroupSetBitsFromISR( EventGroupHandle_t xEventGroup,\n\t\t\t\t\t\t\t\t\t  const EventBits_t uxBitsToSet,\n\t\t\t\t\t\t\t\t\t  BaseType_t * pxHigherPriorityTaskWoken );\n```\n\n值得注意的是，ISR中的函数，比如队列函数**xQueueSendToBackFromISR**、信号量函数**xSemaphoreGiveFromISR**，它们会唤醒某个任务，最多只会唤醒1个任务。\n\n但是设置事件组时，有可能导致多个任务被唤醒，这会带来很大的不确定性。所以**xEventGroupSetBitsFromISR**函数不是直接去设置事件组，而是给一个FreeRTOS后台任务(daemon task)发送队列数据，由这个任务来设置事件组。\n\n如果后台任务的优先级比当前被中断的任务优先级高，**xEventGroupSetBitsFromISR**会设置**pxHigherPriorityTaskWoken**为pdTRUE。\n\n如果daemon task成功地把队列数据发送给了后台任务，那么**xEventGroupSetBitsFromISR**的返回值就是pdPASS。\n\n##### 等待事件\n\n使用**xEventGroupWaitBits**来等待事件，可以等待某一位、某些位中的任意一个，也可以等待多位；等到期望的事件后，还可以清除某些位。\n\n函数原型如下：\n\n```c\nEventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup,\n                                 const EventBits_t uxBitsToWaitFor,\n                                 const BaseType_t xClearOnExit,\n                                 const BaseType_t xWaitForAllBits,\n                                 TickType_t xTicksToWait );\n```\n\n先引入一个概念：unblock condition。一个任务在等待事件发生时，它处于阻塞状态；当期望的时间发生时，这个状态就叫\"unblock condition\"，非阻塞条件，或称为\"非阻塞条件成立\"；当\"非阻塞条件成立\"后，该任务就可以变为就绪态。\n\n函数参数说明列表如下：\n\n|    **参数**     | **说明**                                                     |\n| :-------------: | :----------------------------------------------------------- |\n|   xEventGroup   | 等待哪个事件组？                                             |\n| uxBitsToWaitFor | 等待哪些位？哪些位要被测试？                                 |\n| xWaitForAllBits | 怎么测试？是\"AND\"还是\"OR\"？ pdTRUE: 等待的位，全部为1; pdFALSE: 等待的位，某一个为1即可 |\n|  xClearOnExit   | 函数提出前是否要清除事件？ pdTRUE: 清除uxBitsToWaitFor指定的位 pdFALSE: 不清除 |\n|  xTicksToWait   | 如果期待的事件未发生，阻塞多久。 可以设置为0：判断后即刻返回； 可设置为portMAX_DELAY：一定等到成功才返回； 可以设置为期望的Tick Count，一般用*pdMS_TO_TICKS()*把ms转换为Tick Count |\n|     返回值      | 返回的是事件值， 如果期待的事件发生了，返回的是\"非阻塞条件成立\"时的事件值； 如果是超时退出，返回的是超时时刻的事件值。 |\n\n举例如下：\n\n| 事件组的值 | uxBitsToWaitFor | xWaitForAllBits | 说明                                                         |\n| :--------: | :-------------: | :-------------: | :----------------------------------------------------------- |\n|    0100    |      0101       |     pdTRUE      | 任务期望bit0,bit2都为1， 当前值只有bit2满足，任务进入阻塞态； 当事件组中bit0,bit2都为1时退出阻塞态 |\n|    0100    |      0110       |     pdFALSE     | 任务期望bit0,bit2某一个为1， 当前值满足，所以任务成功退出    |\n|    0100    |      0110       |     pdTRUE      | 任务期望bit1,bit2都为1， 当前值不满足，任务进入阻塞态； 当事件组中bit1,bit2都为1时退出阻塞态 |\n\n你可以使用*xEventGroupWaitBits()*等待期望的事件，它发生之后再使用*xEventGroupClearBits()*来清除。但是这两个函数之间，有可能被其他任务或中断抢占，它们可能会修改事件组。\n\n可以使用设置*xClearOnExit*为pdTRUE，使得对事件组的测试、清零都在*xEventGroupWaitBits()*函数内部完成，这是一个原子操作。\n\n##### 同步点\n\n有一个事情需要多个任务协同，比如：\n\n- 任务A：炒菜\n- 任务B：买酒\n- 任务C：摆台\n- A、B、C做好自己的事后，还要等别人做完；大家一起做完，才可开饭\n\n使用 **xEventGroupSync()** 函数可以同步多个任务：\n\n- 可以设置某位、某些位，表示自己做了什么事\n- 可以等待某位、某些位，表示要等等其他任务\n- 期望的时间发生后， **xEventGroupSync()** 才会成功返回。\n- **xEventGroupSync**成功返回后，会清除事件\n\n**xEventGroupSync** 函数原型如下：\n\n```text\nEventBits_t xEventGroupSync(    EventGroupHandle_t xEventGroup,\n                                const EventBits_t uxBitsToSet,\n                                const EventBits_t uxBitsToWaitFor,\n                                TickType_t xTicksToWait );\n```\n\n参数列表如下：\n\n|    **参数**     | **说明**                                                     |\n| :-------------: | ------------------------------------------------------------ |\n|   xEventGroup   | 哪个事件组？                                                 |\n|   uxBitsToSet   | 要设置哪些事件？我完成了哪些事件？ 比如0x05(二进制为0101)会导致事件组的bit0,bit2被设置为1 |\n| uxBitsToWaitFor | 等待那个位、哪些位？ 比如0x15(二级制10101)，表示要等待bit0,bit2,bit4都为1 |\n|  xTicksToWait   | 如果期待的事件未发生，阻塞多久。 可以设置为0：判断后即刻返回； 可设置为portMAX_DELAY：一定等到成功才返回； 可以设置为期望的Tick Count，一般用*pdMS_TO_TICKS()*把ms转换为Tick Count |\n|     返回值      | 返回的是事件值， 如果期待的事件发生了，返回的是\"非阻塞条件成立\"时的事件值； 如果是超时退出，返回的是超时时刻的事件值。 |\n\n参数列表如下：\n\n|    **参数**     | **说明**                                                     |\n| :-------------: | :----------------------------------------------------------- |\n|   xEventGroup   | 哪个事件组？                                                 |\n|   uxBitsToSet   | 要设置哪些事件？我完成了哪些事件？ 比如0x05(二进制为0101)会导致事件组的bit0,bit2被设置为1 |\n| uxBitsToWaitFor | 等待那个位、哪些位？ 比如0x15(二级制10101)，表示要等待bit0,bit2,bit4都为1 |\n|  xTicksToWait   | 如果期待的事件未发生，阻塞多久。 可以设置为0：判断后即刻返回； 可设置为portMAX_DELAY：一定等到成功才返回； 可以设置为期望的Tick Count，一般用*pdMS_TO_TICKS()*把ms转换为Tick Count |\n|     返回值      | 返回的是事件值， 如果期待的事件发生了，返回的是\"非阻塞条件成立\"时的事件值； 如果是超时退出，返回的是超时时刻的事件值。 |\n\n### 任务通知\n\n所谓\"任务通知\"，你可以反过来读\"通知任务\"。\n\n我们使用队列、信号量、事件组等等方法时，并不知道对方是谁。使用任务通知时，可以明确指定：通知哪个任务。\n\n使用队列、信号量、事件组时，我们都要事先创建对应的结构体，双方通过中间的结构体通信：\n\n![img](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509161952531.png)\n\n使用任务通知时，任务结构体TCB中就包含了内部对象，可以直接接收别人发过来的\"通知\"：\n\n![img](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509161952379.png)\n\n#### 任务通知的特性\n\n##### 优势及限制\n\n任务通知的优势：\n\n- 效率更高：使用任务通知来发送事件、数据给某个任务时，效率更高。比队列、信号量、事件组都有大的优势。\n- 更节省内存：使用其他方法时都要先创建对应的结构体，使用任务通知时无需额外创建结构体。\n\n任务通知的限制：\n\n- 不能发送数据给ISR：\n- ISR并没有任务结构体，所以无法使用任务通知的功能给ISR发送数据。但是ISR可以使用任务通知的功能，发数据给任务。\n- 数据只能给该任务独享\n- 使用队列、信号量、事件组时，数据保存在这些结构体中，其他任务、ISR都可以访问这些数据。使用任务通知时，数据存放入目标任务中，只有它可以访问这些数据。\n- 在日常工作中，这个限制影响不大。因为很多场合是从多个数据源把数据发给某个任务，而不是把一个数据源的数据发给多个任务。\n- 无法缓冲数据\n- 使用队列时，假设队列深度为N，那么它可以保持N个数据。\n- 使用任务通知时，任务结构体中只有一个任务通知值，只能保持一个数据。\n- <span style=\"color:#00FFFF;\">无法广播给多个任务</span>\n- 使用事件组可以同时给多个任务发送事件。\n- 使用任务通知，只能发个一个任务。\n- 如果发送受阻，发送方无法进入阻塞状态等待\n- 假设队列已经满了，使用 **xQueueSendToBack()** 给队列发送数据时，任务可以进入阻塞状态等待发送完成。\n- 使用任务通知时，即使对方无法接收数据，发送方也无法阻塞等待，只能即刻返回错误。\n\n#####  通知状态和通知值\n\n每个任务都有一个结构体：TCB(Task Control Block)，里面有2个成员：\n\n- 一个是uint8_t类型，用来表示通知状态\n- 一个是uint32_t类型，用来表示通知值\n\n```c\ntypedef struct tskTaskControlBlock\n{\n    ......\n    /* configTASK_NOTIFICATION_ARRAY_ENTRIES = 1 */\n    volatile uint32_t ulNotifiedValue[ configTASK_NOTIFICATION_ARRAY_ENTRIES ];\n    volatile uint8_t ucNotifyState[ configTASK_NOTIFICATION_ARRAY_ENTRIES ];\n    ......\n} tskTCB;\n```\n\n通知状态有3种取值：\n\n- taskNOT_WAITING_NOTIFICATION：任务没有在等待通知\n- taskWAITING_NOTIFICATION：任务在等待通知\n- taskNOTIFICATION_RECEIVED：任务接收到了通知，也被称为pending(有数据了，待处理)\n\n```c\n##define taskNOT_WAITING_NOTIFICATION              ( ( uint8_t ) 0 )  /* 也是初始状态 */\n##define taskWAITING_NOTIFICATION                  ( ( uint8_t ) 1 )\n##define taskNOTIFICATION_RECEIVED                 ( ( uint8_t ) 2 )\n```\n\n通知值可以有很多种类型：\n\n- 计数值\n- 位(类似事件组)\n- 任意数值\n\n#### 任务通知的使用\n\n使用任务通知，可以实现轻量级的队列(长度为1)、邮箱(覆盖的队列)、计数型信号量、二进制信号量、事件组。\n\n##### 两类函数\n\n任务通知有2套函数，简化版、专业版，列表如下：\n\n- 简化版函数的使用比较简单，它实际上也是使用专业版函数实现的\n- 专业版函数支持很多参数，可以实现很多功能\n\n|          | 简化版                                      | 专业版                              |\n| -------- | ------------------------------------------- | ----------------------------------- |\n| 发出通知 | `xTaskNotifyGive ` `vTaskNotifyGiveFromISR` | `xTaskNotify ` `xTaskNotifyFromISR` |\n| 取出通知 | `ulTaskNotifyTake`                          | `xTaskNotifyWait`                   |\n\n##### 简化版任务通知\n\n在任务中使用`xTaskNotifyGive`函数，在ISR中使用`vTaskNotifyGiveFromISR`函数，都是直接给其他任务发送通知：\n\n- 使得通知值加一\n- 并使得通知状态变为\"pending\"，也就是**taskNOTIFICATION_RECEIVED**，表示有数据了、待处理\n\n可以使用`ulTaskNotifyTake`函数来取出通知值：\n\n- 如果通知值等于0，则阻塞(可以指定超时时间)\n- 当通知值大于0时，任务从阻塞态进入就绪态\n- 在ulTaskNotifyTake返回之前，还可以做些清理工作：把通知值减一，或者把通知值清零\n\n使用ulTaskNotifyTake函数可以实现轻量级的、高效的二进制信号量、计数型信号量。\n\n这几个函数的原型如下：\n\n```c\nBaseType_t xTaskNotifyGive( TaskHandle_t xTaskToNotify );\n\nvoid vTaskNotifyGiveFromISR( TaskHandle_t xTaskHandle, BaseType_t *pxHigherPriorityTaskWoken );\n\nuint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait );\n```\n\n`xTaskNotifyGive`函数的参数说明如下：\n\n|    **参数**     | **说明**                                   |\n| :-------------: | ------------------------------------------ |\n| `xTaskToNotify` | 任务句柄(创建任务时得到)，给哪个任务发通知 |\n|     返回值      | 必定返回pdPASS                             |\n\n`vTaskNotifyGiveFromISR`函数的参数说明如下：\n\n|          **参数**           | **说明**                                                     |\n| :-------------------------: | ------------------------------------------------------------ |\n|        `xTaskHandle`        | 任务句柄(创建任务时得到)，给哪个任务发通知                   |\n| `pxHigherPriorityTaskWoken` | 被通知的任务，可能正处于阻塞状态。 此函数发出通知后，会把它从阻塞状态切换为就绪态。 如果被唤醒的任务的优先级，高于当前任务的优先级， 则\"*pxHigherPriorityTaskWoken\"被设置为pdTRUE， 这表示在中断返回之前要进行任务切换。 |\n\n`ulTaskNotifyTake`函数的参数说明如下：\n\n|      **参数**       | **说明**                                                     |\n| :-----------------: | ------------------------------------------------------------ |\n| `xClearCountOnExit` | 函数返回前是否清零： pdTRUE：把通知值清零 pdFALSE：如果通知值大于0，则把通知值减一 |\n|   `xTicksToWait`    | 任务进入阻塞态的超时时间，它在等待通知值大于0。 0：不等待，即刻返回； portMAX_DELAY：一直等待，直到通知值大于0； 其他值：Tick Count，可以用*pdMS_TO_TICKS()*把ms转换为Tick Count |\n|       返回值        | 函数返回之前，在清零或减一之前的通知值。 如果xTicksToWait非0，则返回值有2种情况： 1. 大于0：在超时前，通知值被增加了 2. 等于0：一直没有其他任务增加通知值，最后超时返回0 |\n\n##### 专业版任务通知\n\n**xTaskNotify** 函数功能更强大，可以使用不同参数实现各类功能，比如：\n\n- 让接收任务的通知值加一：这时 **xTaskNotify()** 等同于 **xTaskNotifyGive()**\n- 设置接收任务的通知值的某一位、某些位，这就是一个轻量级的、更高效的事件组\n- 把一个新值写入接收任务的通知值：上一次的通知值被读走后，写入才成功。这就是轻量级的、长度为1的队列\n- 用一个新值覆盖接收任务的通知值：无论上一次的通知值是否被读走，覆盖都成功。类似 **xQueueOverwrite()** 函数，这就是轻量级的邮箱。\n\n**xTaskNotify()** 比 **xTaskNotifyGive()** 更灵活、强大，使用上也就更复杂。**xTaskNotifyFromISR()** 是它对应的ISR版本。\n\n这两个函数用来发出任务通知，使用哪个函数来取出任务通知呢？\n\n使用 **xTaskNotifyWait()** 函数！它比 **ulTaskNotifyTake()** 更复杂：\n\n- 可以让任务等待(可以加上超时时间)，等到任务状态为\"pending\"(也就是有数据)\n- 还可以在函数进入、退出时，清除通知值的指定位\n\n这几个函数的原型如下：\n\n```c\nBaseType_t xTaskNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction );\n\nBaseType_t xTaskNotifyFromISR( TaskHandle_t xTaskToNotify,\n                               uint32_t ulValue, \n                               eNotifyAction eAction, \n                               BaseType_t *pxHigherPriorityTaskWoken );\n\nBaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, \n                            uint32_t ulBitsToClearOnExit, \n                            uint32_t *pulNotificationValue, \n                            TickType_t xTicksToWait );\n```\n\n`xTaskNotify`函数的参数说明如下：\n\n|    **参数**     | **说明**                                                     |\n| :-------------: | ------------------------------------------------------------ |\n| `xTaskToNotify` | 任务句柄(创建任务时得到)，给哪个任务发通知                   |\n|    `ulValue`    | 怎么使用ulValue，由eAction参数决定                           |\n|    `eAction`    | 见下表                                                       |\n|     返回值      | pdPASS：成功，大部分调用都会成功 pdFAIL：只有一种情况会失败，当eAction为eSetValueWithoutOverwrite， 并且通知状态为\"pending\"(表示有新数据未读)，这时就会失败。 |\n\n`eNotifyAction`参数说明：\n\n|   **eNotifyAction取值**   | **说明**                                                     |\n| :-----------------------: | ------------------------------------------------------------ |\n|        `eNoAction`        | 仅仅是更新通知状态为\"pending\"，未使用ulValue。 这个选项相当于轻量级的、更高效的二进制信号量。 |\n|        `eSetBits`         | 通知值 = 原来的通知值 \\| ulValue，按位或。 相当于轻量级的、更高效的事件组。 |\n|       `eIncrement`        | 通知值 = 原来的通知值 + 1，未使用ulValue。 相当于轻量级的、更高效的二进制信号量、计数型信号量。 相当于**xTaskNotifyGive()**函数。 |\n| eSetValueWithoutOverwrite | 不覆盖。 如果通知状态为\"pending\"(表示有数据未读)， 则此次调用xTaskNotify不做任何事，返回pdFAIL。 如果通知状态不是\"pending\"(表示没有新数据)， 则：通知值 = ulValue。 |\n|  eSetValueWithOverwrite   | 覆盖。 无论如何，不管通知状态是否为\"pendng\"， 通知值 = ulValue。 |\n\nxTaskNotifyFromISR函数跟xTaskNotify很类似，就多了最后一个参数**pxHigherPriorityTaskWoken**。在很多ISR函数中，这个参数的作用都是类似的，使用场景如下：\n\n- 被通知的任务，可能正处于阻塞状态\n- **xTaskNotifyFromISR**函数发出通知后，会把接收任务从阻塞状态切换为就绪态\n- 如果被唤醒的任务的优先级，高于当前任务的优先级，则\"*pxHigherPriorityTaskWoken\"被设置为pdTRUE，这表示在中断返回之前要进行任务切换。\n\nxTaskNotifyWait函数列表如下：\n\n|        **参数**        | **说明**                                                     |\n| :--------------------: | ------------------------------------------------------------ |\n| `ulBitsToClearOnEntry` | 在xTaskNotifyWait入口处，要清除通知值的哪些位？ 通知状态不是\"pending\"的情况下，才会清除。 它的本意是：我想等待某些事件发生，所以先把\"旧数据\"的某些位清零。 能清零的话：通知值 = 通知值 & ~(ulBitsToClearOnEntry)。 比如传入0x01，表示清除通知值的bit0； 传入0xffffffff即ULONG_MAX，表示清除所有位，即把值设置为0 |\n| `ulBitsToClearOnExit`  | 在xTaskNotifyWait出口处，如果不是因为超时推出，而是因为得到了数据而退出时： 通知值 = 通知值 & ~(ulBitsToClearOnExit)。 在清除某些位之前，通知值先被赋给\"*pulNotificationValue\"。 比如入0x03，表示清除通知值的bit0、bit1； 传入0xffffffff即ULONG_MAX，表示清除所有位，即把值设置为0 |\n| `pulNotificationValue` | 用来取出通知值。 在函数退出时，使用ulBitsToClearOnExit清除之前，把通知值赋给\"*pulNotificationValue\"。 如果不需要取出通知值，可以设为NULL。 |\n|     `xTicksToWait`     | 任务进入阻塞态的超时时间，它在等待通知状态变为\"pending\"。 0：不等待，即刻返回； portMAX_DELAY：一直等待，直到通知状态变为\"pending\"； 其他值：Tick Count，可以用*pdMS_TO_TICKS()*把ms转换为Tick Count |\n|         返回值         | 1. pdPASS：成功 这表示xTaskNotifyWait成功获得了通知： 可能是调用函数之前，通知状态就是\"pending\"； 也可能是在阻塞期间，通知状态变为了\"pending\"。 2. pdFAIL：没有得到通知。 |\n","source":"_posts/freertos.md","raw":"---\ntitle: freertos\ndate: 2025-09-05 15:48:39\nsticky: true\ncover: \"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071511987.png\"\ntags:\n  - 实时操作系统\n  - RTOS\n  - FreeRTOS\nlayout: page\ncategories: MCU\n---\n\n## FreeRTOS基础\n\n### 获取系统时间\n\n```C\nTickType_t currentTicks;\nwhile(1)\n{\n     currentTicks = xTaskGetTickCount();\n     printf(\"[%lu]dev:%u,name:%s\\r\\n\", currentTicks, data->dev, data->data);\n}\n```\n\n\n\n### 堆和栈\n\n堆：一块空闲的内存 可以使用`malloc`申请内存 使用完后用`free`释放内存\n\n> 堆也可以理解为就是定义了一个堆大小的数组 然后定义一个长度 每次动态改变长度来申请空间（链表）\n>\n> 在`FreeRTOSConfig.h`中就有定义堆大小的宏`configTOTAL_HEAP_SIZE` 他被引用到 `heap.c`中的 `static uint8_t ucHeap[configTOTAL_HEAP_SIZE];`\n\n栈：一块内存空间，CPU的SP寄存器指向它，它可以用于函数调用、局部变量、`多任务系统里保存现场`\n\n> 栈是`FreeRTOS`中非常重要的概念，每个任务都有自己的栈\n\n###  FreeRTOS源码概述\n\n#### 目录结构\n\n![img](https://photos.100ask.net/renesas-docs/DShanMCU_RA6M5/FreeRTOS/chapter-6/image1.png)\n\n> 主要涉及3个目录：\n>\n> - `ra\\aws\\FreeRTOS\\FreeRTOS\\Source`：存放的是FreeRTOS的核心文件\n> - `ra_gen`：从main.c可以看到创建任务的函数调用过程\n> - `src`：使用RASC创建任务时，在src目录下生成任务的入口函数\n\n#### 核心文件\n\n> FreeRTOS的最核心文件只有2个：\n>\n> - `FreeRTOS/Source/tasks.c`\n> - `FreeRTOS/Source/list.c`\n\n其他文件的作用也一起列表如下：\n\n| **`FreeRTOS/Source/`下的文件** | **作用**                                      |\n| ------------------------------ | --------------------------------------------- |\n| `tasks.c`                      | 必需，任务操作                                |\n| `list.c`                       | 必须，列表                                    |\n| `queue.c`                      | 基本必需，提供队列操作、信号量(semaphore)操作 |\n| `timer.c`                      | 可选，software timer                          |\n| `event_groups.c`               | 可选，提供event group功能                     |\n\n#### 头文件相关\n\n##### 头文件目录\n\n> FreeRTOS需要3个头文件目录：\n>\n> - FreeRTOS本身的头文件：`ra\\aws\\FreeRTOS\\FreeRTOS\\Source\\include`\n> - 移植时用到的头文件：`ra\\fsp\\src\\rm_freertos_port\\portmacro.h`\n> - 含有配置文件`FreeRTOSConfig.h`的目录：`ra_cfg\\aws`\n\n##### 头文件\n\n列表如下：\n\n| **头文件**         | **作用**                                                     |\n| ------------------ | ------------------------------------------------------------ |\n| `FreeRTOSConfig.h` | FreeRTOS的配置文件，比如选择调度算法：`configUSE_PREEMPTION` 每个工程都必定含有`FreeRTOSConfig.h` |\n| `FreeRTOS.h`       | 使用FreeRTOS API函数时，<span style=\"font-weight:bold;\">必须</span>包含此文件。 在`FreeRTOS.h`之后，再去包含其他头文件，比如： `task.h`、`queue.h`、`semphr.h`、`event_group.h` |\n\n#### 独属于FreeRTOS的数据类型和编程规范\n\n##### 数据类型\n\n每个移植的版本都含有自己的 **`portmacro.h`** 头文件，里面定义了2个数据类型：\n\n1. `TickType_t`：\n   - 时钟计数单位 （可以是uint16_t 也可以是uint32_t）\n     当`FreeRTOSConfig.h`中定义`configUSE_16_BIT_TICKS时 TickType_t`则为uint16_t\n\n> 对于32位架构，建议把TickType_t配置为uint32_t\n\n2. `BaseType_t`:这是该架构最高效的数据类型(取决于CPU是多少位的架构)\n   - `BaseType_t`通常用作简单的返回值的类型，还有逻辑值，比如 **pdTRUE/pdFALSE**\n\n#####  变量名\n\n变量名的前缀 对应其类型 如：`pcName` (代表着他是一个指向char类型的指针p)\n\n| **变量名前缀** | **含义**                                                     |\n| -------------- | ------------------------------------------------------------ |\n| c              | char                                                         |\n| s              | int16_t，short                                               |\n| l              | int32_t，long                                                |\n| x              | BaseType_t， 其他非标准的类型：结构体、task handle、queue handle等 |\n| u              | unsigned                                                     |\n| p              | 指针                                                         |\n| uc             | uint8_t，unsigned char                                       |\n| pc             | char指针                                                     |\n\n##### 函数名\n\n函数名的前缀有2部分：返回值类型、在哪个文件定义。\n\n| **函数名前缀**                                           | **含义**                                     |\n| -------------------------------------------------------- | -------------------------------------------- |\n| v<span style=\"font-weight:bold;\">Task</span>PrioritySet  | 返回值类型：void 在`task.c`中定义            |\n| x<span style=\"font-weight:bold;\">Queue</span>Receive     | 返回值类型：BaseType_t 在`queue.c`中定义     |\n| pv<span style=\"font-weight:bold;\">Timer</span>GetTimerID | 返回值类型：pointer to void 在`tmer.c`中定义 |\n\n##### 宏的名\n\n宏的名字是大小，可以添加小写的前缀。前缀是用来表示：宏在<span style=\"font-weight:bold;\">哪个文件</span>中定义。\n\n| **宏的前缀**                                                 | **含义：在哪个文件里定义**  |\n| ------------------------------------------------------------ | --------------------------- |\n| port (比如<span style=\"font-weight:bold;\">port</span>MAX_DELAY) | `portable.h`或`portmacro.h` |\n| task (比如<span style=\"font-weight:bold;\">task</span>ENTER_CRITICAL()) | `task.h`                    |\n| pd (比如<span style=\"font-weight:bold;\">pd</span>TRUE)       | `projdefs.h`                |\n| config (比如<span style=\"font-weight:bold;\">config</span>USE_PREEMPTION) | `FreeRTOSConfig.h`          |\n| err (比如<span style=\"font-weight:bold;\">err</span>QUEUE_FULL) | `projdefs.h`                |\n\n通用的宏定义如下：\n\n| **宏**    | **值** |\n| --------- | ------ |\n| `pdTRUE`  | 1      |\n| `pdFALSE` | 0      |\n| `pdPASS`  | 1      |\n| `pdFAIL`  | 0      |\n\n### 内存管理\n\n>  FreeRTOS中内存管理的接口函数为：`pvPortMalloc` 、`vPortFree`，对应于C库的`malloc`、`free`。 文件在`FreeRTOS/Source/portable/MemMang`下，它也是放在`portable目录`下，表示你可以提供自己的函数。\n>\n> 源码中默认提供了5个文件，对应内存管理的5种方法。\n\n| **文件**         | **优点**                                           | **缺点**                                             |\n| ---------------- | -------------------------------------------------- | ---------------------------------------------------- |\n| `heap_1.c`       | 分配简单，时间确定                                 | 只分配、<span style=\"color:#FF0000;\">不回收</span>   |\n| `heap_2.c`       | 动态分配、最佳匹配                                 | <span style=\"color:#FF0000;\">碎片</span>、时间不定   |\n| `heap_3.c`       | 调用<span style=\"color:#FF3333;\">标准库</span>函数 | <span style=\"color:#FF0000;\">速度慢</span>、时间不定 |\n| `heap_4.c`(常用) | 相邻空闲内存可合并                                 | 可解决碎片问题、时间不定                             |\n| `heap_5.c`       | 在heap_4基础上支持分隔的内存块                     | 可解决碎片问题、时间不定                             |\n\n#### Heap相关的函数\n\n#####  分配、释放内存\n\n函数原型：\n\n```c\nvoid * pvPortMalloc( size_t xWantedSize );\nvoid vPortFree( void * pv );\n```\n\n作用：分配内存、释放内存。\n\n如果分配内存不成功，则返回值为NULL。\n\n##### 检测剩余多少空闲内存\n\n函数原型：\n\n```c\nsize_t xPortGetFreeHeapSize( void );\n```\n\n> 当前还有多少空闲内存，这函数可以用来优化内存的使用情况。比如当所有内核对象都分配好后，执行此函数返回2000，那么`configTOTAL_HEAP_SIZE`就可减小2000。\n\n注意：在heap_3中无法使用。\n\n#####  获取空闲内存容量的最小值\n\n函数原型：\n\n```c\nsize_t xPortGetMinimumEverFreeHeapSize( void );\n```\n\n返回：程序运行过程中，空闲内存容量的最小值。\n\n注意：只有heap_4、heap_5支持此函数。\n\n##### `malloc失败的钩子函数`\n\n在pvPortMalloc函数内部：\n\n```c\nvoid * pvPortMalloc( size_t xWantedSize )vPortDefineHeapRegions\n{\n    ......\n    #if ( configUSE_MALLOC_FAILED_HOOK == 1 )\n        {\n            if( pvReturn == NULL )\n            {\n                extern void vApplicationMallocFailedHook( void );\n                vApplicationMallocFailedHook();\n            }\n        }\n    #endif\n    \n    return pvReturn;        \n}\n```\n\n所以，如果想使用这个钩子函数：\n\n- 在`FreeRTOSConfig.h`中，把`configUSE_MALLOC_FAILED_HOOK`定义为1\n- 提供`vApplicationMallocFailedHook`函数\n- `pvPortMalloc`失败时，才会调用此函数\n\n### 任务管理\n\n#### 任务创建与删除\n\n##### 什么是任务\n\n在FreeRTOS中，任务就是一个函数，原型如下：\n\n```c\nvoid ATaskFunction( void *pvParameters );\n```\n\n要注意的是：\n\n- 这个函数不能返回\n- 同一个函数，可以用来创建多个任务；换句话说，多个任务可以运行同一个函数\n- 函数内部，尽量使用局部变量：\n  - 每个任务都有自己的栈\n  - 每个任务运行这个函数时\n    - 任务A的局部变量放在任务A的栈里、任务B的局部变量放在任务B的栈里\n    - 不同任务的局部变量，有自己的副本\n  - 函数使用全局变量、静态变量的话\n    - 只有一个副本：多个任务使用的是同一个副本\n    - 要防止冲突(后续会讲) 下面是一个示例：\n\n```c\nvoid ATaskFunction( void *pvParameters )\n{\n\t/* 对于不同的任务，局部变量放在任务的栈里，有各自的副本 */\n\tint32_t lVariableExample = 0;\n\t\n    /* 任务函数通常实现为一个无限循环 */\n\tfor( ;; )\n\t{\n\t\t/* 任务的代码 */\n\t}\n\n    /* 如果程序从循环中退出，一定要使用vTaskDelete删除自己\n     * NULL表示删除的是自己\n     */\n\tvTaskDelete( NULL );\n    \n    /* 程序不会执行到这里, 如果执行到这里就出错了 */\n}\n```\n\n##### 创建任务\n\n创建任务时使用的函数如下：\n\n```c\nBaseType_t xTaskCreate( TaskFunction_t pxTaskCode, // 函数指针, 任务函数\n                        const char * const pcName, // 任务的名字\n                        const configSTACK_DEPTH_TYPE usStackDepth, // 栈大小,单位为word,10表示40字节\n                        void * const pvParameters, // 调用任务函数时传入的参数\n                        UBaseType_t uxPriority,    // 优先级\n                        TaskHandle_t * const pxCreatedTask ); // 任务句柄, 以后使用它来操作这个任务\n```\n\n参数说明：\n\n| **参数**      | **描述**                                                     |\n| ------------- | ------------------------------------------------------------ |\n| pvTaskCode    | 函数指针，任务对应的 C 函数。任务应该永远不退出，或者在退出时调用 \"`vTaskDelete(NULL)`\"。 |\n| pcName        | 任务的名称，仅用于调试目的，FreeRTOS 内部不使用。pcName 的长度为 `configMAX_TASK_NAME_LEN`。 |\n| usStackDepth  | 每个任务都有自己的栈，usStackDepth 指定了栈的大小，单位为 word。例如，如果传入 100，表示栈的大小为 100 word，即 400 字节。最大值为 uint16_t 的最大值。确定栈的大小并不容易，通常是根据估计来设定。精确的办法是查看反汇编代码。 |\n| pvParameters  | 调用 pvTaskCode 函数指针时使用的参数：`pvTaskCode(pvParameters)`。 |\n| uxPriority    | 任务的优先级范围为 0~(`configMAX_PRIORITIES – 1`)。数值越小，优先级越低。如果传入的值过大，`xTaskCreate `会将其调整为 (`configMAX_PRIORITIES – 1`)。 |\n| pxCreatedTask | 用于保存 xTaskCreate 的输出结果，即任务的句柄（task handle）。如果以后需要对该任务进行操作，如修改优先级，则需要使用此句柄。如果不需要使用该句柄，可以传入 NULL。 |\n| 返回值        | 成功时返回 pdPASS，失败时返回 `errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY`（失败原因是内存不足）。请注意，文档中提到的失败返回值是 pdFAIL 是不正确的。pdFAIL 的值为 0，而 `errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY` 的值为 -1。 |\n\n使用静态分配内存的函数如下：\n\n```c\nTaskHandle_t xTaskCreateStatic ( \n    TaskFunction_t pxTaskCode,   // 函数指针, 任务函数\n    const char * const pcName,   // 任务的名字\n    const uint32_t ulStackDepth, // 栈大小,单位为word,10表示40字节\n    void * const pvParameters,   // 调用任务函数时传入的参数\n    UBaseType_t uxPriority,      // 优先级\n    StackType_t * const puxStackBuffer, // 静态分配的栈，就是一个buffer\n    StaticTask_t * const pxTaskBuffer // 静态分配的任务结构体的指针，用它来操作这个任务\n);\n```\n\n相比于使用动态分配内存创建任务的函数，最后2个参数不一样：\n\n| **参数**       | **描述**                                                     |\n| -------------- | ------------------------------------------------------------ |\n| pvTaskCode     | 函数指针，可以简单地认为任务就是一个C函数。 它稍微特殊一点：永远不退出，或者退出时要调用\"`vTaskDelete(NULL)`\" |\n| pcName         | 任务的名字，FreeRTOS内部不使用它，仅仅起调试作用。 长度为：`configMAX_TASK_NAME_LEN` |\n| usStackDepth   | 每个任务都有自己的栈，这里指定栈大小。 单位是word，比如传入100，表示栈大小为100 word，也就是400字节。 最大值为uint16_t的最大值。 怎么确定栈的大小，并不容易，很多时候是估计。 精确的办法是看反汇编码。 |\n| pvParameters   | 调用pvTaskCode函数指针时用到：pvTaskCode(pvParameters)       |\n| uxPriority     | 优先级范围：0~(`configMAX_PRIORITIES – 1`) 数值越小优先级越低， 如果传入过大的值，`xTaskCreate`会把它调整为(`configMAX_PRIORITIES – 1`) |\n| puxStackBuffer | 静态分配的栈内存，比如可以传入一个数组， 它的大小是`usStackDepth*4`。 |\n| pxTaskBuffer   | 静态分配的`StaticTask_t`结构体的指针                         |\n| 返回值         | 成功：返回任务句柄； 失败：NULL                              |\n\n#### 任务栈大小估算\n\n任务栈空间包含\n\n- 返回地址`LR`与其他寄存器：可以理解为<span style=\"color:#FF0000;\">函数调用深度</span>\n- 局部变量：如`char buff[1000]` 直接看类型 此处则可以算1个\n- 保留现场：可以理解为固定16个寄存器 即<span style=\"color:#FF3333;\">16 * 4 = 64b</span>\n\n> 公式如下：\n>\n> - （n层调用 * 36） + 局部变量 + 64b\n>\n> - 例如：\n>\n>   ![image-20250914221448446](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509142214793.png)\n\n#### 使用任务参数\n\n我们说过，多个任务可以使用同一个函数，怎么体现它们的差别？\n\n- 栈不同\n- 创建任务时可以传入不同的参数\n\n我们创建2个任务，使用同一个函数，但是在LCD上打印不一样的信息。\n\n```c\ntypedef struct{\n    int x;\n    int y;\n    const char *str;\n}DisplayInfo;\nvoid vTaskFunction( void *pvParameters )\n{\n\tDisplayInfo *info = pvParameters;\n\tuint32_t cnt = 0;\nuint32_t len;\n\t\n\t/* 任务函数的主体一般都是无限循环 */\n\tfor( ;; )\n\t{\n\t\t/* 打印任务的信息 */\n\t\tlen = LCD_PrintString(info->x, info->y, info->str);\n\t\tLCD_PrintSignedVal(len+1, info->y, cnt++);\n\n\t\tmdelay(500);\n\t}\n}\n```\n\n上述代码中的info来自参数pvParameters，pvParameters来自哪里？创建任务时传入的。\n\n代码如下：\n\n- 使用xTaskCreate创建任务时，第4个参数就是pvParameters\n- 不同的任务，pvParameters不一样\n\n```c\nDisplayInfo g_Task1Info ={0,0,\"task1\"};\nDisplayInfo g_Task2Info ={3,0,\"task2\"};\nDisplayInfo g_Task3Info ={6,0,\"task3\"};\n\n/* 使用同一个函数创建不同的任务 */\n  xTaskCreate(LcdPrintTask, \"task1\", 128, &g_Task1Info, osPriorityNormal, NULL);\n  xTaskCreate(LcdPrintTask, \"task2\", 128, &g_Task2Info, osPriorityNormal, NULL);\n  xTaskCreate(LcdPrintTask, \"task3\", 128, &g_Task3Info, osPriorityNormal, NULL);\n```\n\n#### 任务的删除\n\n删除任务时使用的函数如下：\n\n```c\nvoid vTaskDelete( TaskHandle_t xTaskToDelete );\n```\n\n参数说明：\n\n| **参数**   | **描述**                                                     |\n| ---------- | ------------------------------------------------------------ |\n| pvTaskCode | 任务句柄，使用xTaskCreate创建任务时可以得到一个句柄。 也可传入NULL，这表示删除自己。 |\n\n怎么删除任务？举个不好的例子：\n\n- 自杀：`vTaskDelete(NULL)`\n- 被杀：别的任务执行`vTaskDelete(pvTaskCode)`，`pvTaskCode`是自己的句柄\n- 杀人：执行`vTaskDelete(pvTaskCode)`，`pvTaskCode`是别的任务的句柄\n\n#### 任务管理与调度机制\n\n##### 调度机制\n\n> - 同等优先级的任务 轮流运行\n> - 最高优先级的任务先运行\n>   - 高优先级的任务未运行完，低优先级任务无法运行\n>   - 一旦高优先级任务就绪 马上运行\n>   - 最高优先级的任务有多个 他们轮流运行\n\n![img](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509151548547.png)\n\n##### 任务管理\n\n任务的切换通过链表操作进行切换 RTOS会创建3个链表 分别是就绪链表ReadyList、阻塞链表DelayTaskList、挂起链表\n\n- 先在优先级数组中按下标从大到小遍历，使用任务创建函数<span style=\"color:#33FFFF;\">本质其实是在对应优先级数组中创建TCB结构体，并且会有一个全局指针——当前执行TCB结构体pxCurrentTCB</span>，这就说明了为什么同等优先级下，最后创建的任务先运行（因为指针最终指向了最后一个任务链表，启动调度器后，开始运行）\n\n- 当调用`vTaskDelay`后会将当前任务链表丢到阻塞链表上，并根据`vTaskDelay`的参数等待`Tick中断`判断到达时间后，该任务链表才能再次回到原先链表上\n\n- 当任务调用`vTaskSuspend`后 当前任务会被丢到挂起链表，此任务只有调用`vTaskResume`才能回到原先链表，不能通过`Tick中断`回归\n\n> Tick中断是什么？他又做些什么？\n>\n> - Tick中断来源于\n>\n>   ![image-20250915160032344](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509151600535.png)\n>\n> - Tick中断做什么？\n>\n>   1. 有个计数器count，count一直执行++\n>   2. 判断DelayTaskList里任务是否可以恢复（可恢复则将其丢到ReadyList）\n>   3. 发起调度（遍历优先级数组，改变pxCurrentTCB指针指向）\n\n##### 空闲任务\n\n空闲任务是Freertos启动调度器时 会自动创建的一个最低优先级的任务`prvIdleTask`\n\n- 负责清理用户的自杀任务 如`vTaskDelete(NULL)`的内存释放\n- 由于优先级最低 所以当用户任务不释放CPU时，就会导致空闲任务不会运行，因而`vTaskDelete(NULL)`得不到释放\n- 因此尽量不要使用死延时，改用`vTaskDelay`释放CPU 或者不使用自杀函数`vTaskDelete(NULL)`\n\n> 此外 空闲任务中还有提供钩子函数 可以方便我们在里面打印调试信息\n>\n> 注意每个任务都要使用while(1)进行死循环\n>\n> - 如果有一个任务没有则会触发任务退出错误中断`prvTaskExitError`\n> - ![image-20250915163446773](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509151634028.png)\n\n### 同步与互斥\n\n#### 同步与互斥的概念\n\n一句话理解同步与互斥：我等你用完厕所，我再用厕所。\n\n- 什么叫同步？就是：哎哎哎，我正在用厕所，你等会。 \n- 什么叫互斥？就是：哎哎哎，我正在用厕所，你不能进来。\n\n同步与互斥经常放在一起讲，是因为它们之的关系很大，“互斥”操作可以使用“同步”来实现。我“等”你用完厕所，我再用厕所。这不就是用“同步”来实现“互斥”吗？\n\n再举一个例子。在团队活动里，同事A先写完报表，经理B才能拿去向领导汇报。经理B必须等同事A完成报表，AB之间有依赖，B必须放慢脚步，被称为同步。在团队活动中，同事A已经使用会议室了，经理B也想使用，即使经理B是领导，他也得等着，这就叫互斥。经理B跟同事A说：你用完会议室就提醒我。这就是使用\"同步\"来实现\"互斥\"。\n\n有时候看代码更容易理解，伪代码如下：\n\n```c\n void  抢厕所(void)\n {\n   if (有人在用) 我眯一会;\n   用厕所;\n   喂，醒醒，有人要用厕所吗;\n }\n```\n\n假设有A、B两人早起抢厕所，A先行一步占用了；B慢了一步，于是就眯一会；当A用完后叫醒B，B也就愉快地上厕所了。\n\n在这个过程中，A、B是互斥地访问“厕所”，“厕所”被称之为临界资源。我们使用了“休眠-唤醒”的同步机制实现了“临界资源”的“互斥访问”。\n\n同一时间只能有一个人使用的资源，被称为临界资源。比如任务A、B都要使用串口来打印，串口就是临界资源。如果A、B同时使用串口，那么打印出来的信息就是A、B混杂，无法分辨。所以使用串口时，应该是这样：A用完，B再用；B用完，A再用\n\n#### 各类方法的对比\n\n能实现同步、互斥的内核方法有：任务通知(task notification)、队列(queue)、事件组(event group)、信号量(semaphoe)、互斥量(mutex)。\n\n它们都有类似的操作方法：获取/释放、阻塞/唤醒、超时。比如：\n\n- 任务A获取资源，用完后任务A释放资源\n- 任务A获取不到资源则阻塞，任务B释放资源并把任务A唤醒\n- 任务A获取不到资源则阻塞，并定个闹钟；A要么超时返回，要么在这段时间内因为任务B释放资源而被唤醒。\n\n这些内核对象五花八门，记不住怎么办？我也记不住，通过对比的方法来区分它们。\n\n- 能否传信息？还是只能传递状态？\n- 为众生（所有任务都可以使用）？只为你（只能指定任务使用）？\n- 我生产，你们消费？\n- 我上锁，只能由我开锁\n\n| **内核对象** | **生产者** | **消费者** | **数据/状态**                                                | **说明**                                                     |\n| ------------ | ---------- | ---------- | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| 队列         | ALL        | ALL        | 数据：若干个数据 谁都可以往队列里扔数据， 谁都可以从队列里读数据 | 用来传递数据， 发送者、接收者无限制， 一个数据只能唤醒一个接收者 |\n| 事件组       | ALL        | ALL        | 多个位：或、与 谁都可以设置(生产)多个位， 谁都可以等待某个位、若干个位 | 用来传递事件， 可以是N个事件， 发送者、接受者无限制， 可以唤醒多个接收者：像广播 |\n| 信号量       | ALL        | ALL        | 数量：0~n 谁都可以增加一个数量， 谁都可消耗一个数量          | 用来维持资源的个数， 生产者、消费者无限制， 1个资源只能唤醒1个接收者 |\n| 任务通知     | ALL        | 只有我     | 数据、状态都可以传输， 使用任务通知时， 必须指定接受者       | N对1的关系： 发送者无限制， 接收者只能是这个任务             |\n| 互斥量       | 只能A开锁  | A上锁      | 位：0、1 我上锁：1变为0， 只能由我开锁：0变为1               | 就像一个空厕所， 谁使用谁上锁， 也只能由他开锁               |\n\n使用图形对比如下：\n\n- 队列：\n  - 里面可以放任意数据，可以放多个数据\n  - 任务、ISR都可以放入数据；任务、ISR都可以从中读出数据\n- 事件组：\n  - 一个事件用一bit表示，1表示事件发生了，0表示事件没发生\n  - 可以用来表示事件、事件的组合发生了，不能传递数据\n  - 有广播效果：事件或事件的组合发生了，等待它的多个任务都会被唤醒\n- 信号量：\n  - 核心是\"计数值\"\n  - 任务、ISR释放信号量时让计数值加1\n  - 任务、ISR获得信号量时，让计数值减1\n- 任务通知：\n  - 核心是任务的TCB里的数值\n  - 会被覆盖\n  - 发通知给谁？必须指定接收任务\n  - 只能由接收任务本身获取该通知\n- 互斥量：\n  - 数值只有0或1\n  - 谁获得互斥量，就必须由谁释放同一个互斥量\n\n![img](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509151740912.png)\n\n> 为何要引用这些机制呢？\n>\n> - 原本逻辑可以采用全局变量来进行传递信息，但在RTOS下，可能还未来得及改变全局变量的值就被切换到其他任务，这样就会发生全局变量未及时更新的问题\n> - 引入事件阻塞与唤醒大大提高了CPU的利用率\n>   - 当任务A计数1s，任务B负责打印任务A的最终计数值，就不会出现A运行，B也运行，而是等待A运行完后通知任务B，或大概估算任务A结束的时间，让B阻塞这么多的时间，这样就实现了整个时间轴都是任务A在运行\n\n### 队列\n\n#### 队列的本质\n\n队列中，数据的读写就是环形缓冲区，在这个基础上增加了互斥措施、阻塞-唤醒机制\n\n- 如果这个队列不传输数据，只调整“数据个数”，他就是信号量（semaphore）\n- 如果信号量中，限定“数据个数”最大值为1，他就是互斥量（mutex）\n\n#### 传输数据的两种方法\n\n使用队列传输数据时有两种方法：\n\n- 拷贝：把数据、把变量的值复制进队列里\n- 引用：把数据、把变量的地址复制进队列里\n\nFreeRTOS使用拷贝值的方法，这更简单：\n\n- 局部变量的值可以发送到队列中，后续即使函数退出、局部变量被回收，也不会影响队列中的数据\n- 无需分配buffer来保存数据，队列中有buffer\n- 局部变量可以马上再次使用\n- 发送任务、接收任务解耦：接收任务不需要知道这数据是谁的、也不需要发送任务来释放数据\n- 如果数据实在太大，你还是可以使用队列传输它的地址\n- 队列的空间有FreeRTOS内核分配，无需任务操心\n- 对于有内存保护功能的系统，如果队列使用引用方法，也就是使用地址，必须确保双方任务对这个地址都有访问权限。使用拷贝方法时，则无此限制：内核有足够的权限，把数据复制进队列、再把数据复制出队列。\n\n#### 队列的阻塞访问\n\n只要知道队列的句柄，谁都可以读、写该队列。任务、ISR都可读、写队列。可以多个任务读写队列。\n\n任务读写队列时，简单地说：如果读写不成功，则阻塞；可以指定超时时间。口语化地说，就是可以定个闹钟：如果能读写了就马上进入就绪态，否则就阻塞直到超时。\n\n某个任务读队列时，如果队列没有数据，则该任务可以进入阻塞状态：还可以指定阻塞的时间。如果队列有数据了，则该阻塞的任务会变为就绪态。如果一直都没有数据，则时间到之后它也会进入就绪态。\n\n既然读取队列的任务个数没有限制，那么当多个任务读取空队列时，这些任务都会进入阻塞状态：有多个任务在等待同一个队列的数据。当队列中有数据时，哪个任务会进入就绪态？\n\n- 优先级最高的任务\n- 如果大家的优先级相同，那等待时间最久的任务会进入就绪态\n\n跟读队列类似，一个任务要写队列时，如果队列满了，该任务也可以进入阻塞状态：还可以指定阻塞的时间。如果队列有空间了，则该阻塞的任务会变为就绪态。如果一直都没有空间，则时间到之后它也会进入就绪态。\n\n既然写队列的任务个数没有限制，那么当多个任务写\"满队列\"时，这些任务都会进入阻塞状态：有多个任务在等待同一个队列的空间。当队列中有空间时，哪个任务会进入就绪态？\n\n- 优先级最高的任务\n- 如果大家的优先级相同，那等待时间最久的任务会进入就绪态\n\n#### 队列函数\n\n##### 创建\n\n队列的创建有两种方法：动态分配内存、静态分配内存，\n\n- 动态分配内存：xQueueCreate，队列的内存在函数内部动态分配\n\n函数原型如下：\n\n```c\nQueueHandle_t xQueueCreate( UBaseType_t uxQueueLength, UBaseType_t uxItemSize );\n```\n\n| **参数**        | **说明**                                                     |\n| --------------- | ------------------------------------------------------------ |\n| `uxQueueLength` | 队列长度，最多能存放多少个数据(item)                         |\n| `uxItemSize`    | 每个数据(item)的大小：以字节为单位（可以定义一个结构体存放，然后sizeof(结构体)） |\n| 返回值          | 非0：成功，返回句柄，以后使用句柄来操作队列 NULL：失败，因为内存不足 |\n\n- 静态分配内存：`xQueueCreateStatic`，队列的内存要事先分配好\n\n函数原型如下：\n\n```c\nQueueHandle_t xQueueCreateStatic(*\n              \t\tUBaseType_t uxQueueLength,*\n              \t\tUBaseType_t uxItemSize,*\n              \t\tuint8_t *pucQueueStorageBuffer,*\n              \t\tStaticQueue_t *pxQueueBuffer*\n           \t\t );\n```\n\n| **参数**                | **说明**                                                     |\n| ----------------------- | ------------------------------------------------------------ |\n| `uxQueueLength`         | 队列长度，最多能存放多少个数据(item)                         |\n| `uxItemSize`            | 每个数据(item)的大小：以字节为单位                           |\n| `pucQueueStorageBuffer` | 如果uxItemSize非0，`pucQueueStorageBuffer`必须指向一个uint8_t数组， 此数组大小至少为\"uxQueueLength * uxItemSize\" |\n| `pxQueueBuffer`         | 必须执行一个`StaticQueue_t`结构体，用来保存队列的数据结构    |\n| 返回值                  | 非0：成功，返回句柄，以后使用句柄来操作队列 NULL：失败，因为`pxQueueBuffer`为NULL |\n\n##### 复位\n\n队列刚被创建时，里面没有数据；使用过程中可以调用 **xQueueReset()** 把队列恢复为初始状态，此函数原型为：\n\n```c\n/*  pxQueue : 复位哪个队列;\n * 返回值: pdPASS(必定成功)\n*/\nBaseType_t xQueueReset( QueueHandle_t pxQueue);\n```\n\n##### 删除\n\n删除队列的函数为 **vQueueDelete()** ，只能删除使用动态方法创建的队列，它会释放内存。原型如下：\n\n```c\nvoid vQueueDelete( QueueHandle_t xQueue );\n```\n\n##### 写队列\n\n可以把数据写到队列头部，也可以写到尾部，这些函数有两个版本：在任务中使用、在ISR中使用。函数原型如下：\n\n```c\n/* 等同于xQueueSendToBack\n * 往队列尾部写入数据，如果没有空间，阻塞时间为xTicksToWait\n */\nBaseType_t xQueueSend(\n                                QueueHandle_t    xQueue,\n                                const void       *pvItemToQueue,\n                                TickType_t       xTicksToWait\n                            );\n\n/* \n * 往队列尾部写入数据，如果没有空间，阻塞时间为xTicksToWait\n */\nBaseType_t xQueueSendToBack(\n                                QueueHandle_t    xQueue,\n                                const void       *pvItemToQueue,\n                                TickType_t       xTicksToWait\n                            );\n\n\n/* \n * 往队列尾部写入数据，此函数可以在中断函数中使用，不可阻塞\n */\nBaseType_t xQueueSendToBackFromISR(\n                                      QueueHandle_t xQueue,\n                                      const void *pvItemToQueue,\n                                      BaseType_t *pxHigherPriorityTaskWoken\n                                   );\n\n/* \n * 往队列头部写入数据，如果没有空间，阻塞时间为xTicksToWait\n */\nBaseType_t xQueueSendToFront(\n                                QueueHandle_t    xQueue,\n                                const void       *pvItemToQueue,\n                                TickType_t       xTicksToWait\n                            );\n\n/* \n * 往队列头部写入数据，此函数可以在中断函数中使用，不可阻塞\n */\nBaseType_t xQueueSendFromISR(\n                                      QueueHandle_t xQueue,\n                                      const void *pvItemToQueue,\n                                      BaseType_t *pxHigherPriorityTaskWoken\n                                   );\n```\n\n这些函数用到的参数是类似的，统一说明如下：\n\n| 参数            | 说明                                                         |\n| --------------- | ------------------------------------------------------------ |\n| `xQueue`        | 队列句柄，要写哪个队列                                       |\n| `pvItemToQueue` | 数据指针，这个数据的值会被复制进队列， 复制多大的数据？在创建队列时已经指定了数据大小 |\n| `xTicksToWait`  | 如果队列满则无法写入新数据，可以让任务进入阻塞状态， `xTicksToWait`表示阻塞的最大时间(Tick Count)。 如果被设为0，无法写入数据时函数会立刻返回； 如果被设为`portMAX_DELAY`，则会一直阻塞直到有空间可写 |\n| 返回值          | pdPASS：数据成功写入了队列 `errQUEUE_FULL`：写入失败，因为队列满了。 |\n\n##### 读队列\n\n使用 **xQueueReceive()** 函数读队列，读到一个数据后，队列中该数据会被移除。这个函数有两个版本：在任务中使用、在ISR中使用。函数原型如下：\n\n```c\nBaseType_t xQueueReceive( QueueHandle_t xQueue,\n                          void * const pvBuffer,\n                          TickType_t xTicksToWait );\n\nBaseType_t xQueueReceiveFromISR(\n                                    QueueHandle_t    xQueue,\n                                    void             *pvBuffer,\n                                    BaseType_t       *pxTaskWoken\n                                );\n```\n\n参数说明如下：\n\n| **参数**       | **说明**                                                     |\n| -------------- | ------------------------------------------------------------ |\n| `xQueue`       | 队列句柄，要读哪个队列                                       |\n| `pvBuffer`     | buffer指针，队列的数据会被复制到这个buffer 复制多大的数据？在创建队列时已经指定了数据大小 |\n| `xTicksToWait` | 果队列空则无法读出数据，可以让任务进入阻塞状态， xTicksToWait表示阻塞的最大时间(Tick Count)。 如果被设为0，无法读出数据时函数会立刻返回； 如果被设为portMAX_DELAY，则会一直阻塞直到有数据可写 |\n| 返回值         | pdPASS：从队列读出数据入 `errQUEUE_EMPTY`：读取失败，因为队列空了。 |\n\n##### 查询\n\n可以查询队列中有多少个数据、有多少空余空间。函数原型如下：\n\n```c\n/*\n * 返回队列中可用数据的个数\n */\nUBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue );\n\n/*\n * 返回队列中可用空间的个数\n */\nUBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue );\n```\n\n##### 覆盖/偷看\n\n当队列长度为1时，可以使用 **xQueueOverwrite()** 或 **xQueueOverwriteFromISR()** 来覆盖数据。\n\n注意，队列长度必须为1。当队列满时，这些函数会覆盖里面的数据，这也以为着这些函数不会被阻塞。\n\n函数原型如下：\n\n```c\n/* 覆盖队列\n * xQueue: 写哪个队列\n * pvItemToQueue: 数据地址\n * 返回值: pdTRUE表示成功, pdFALSE表示失败\n */\nBaseType_t xQueueOverwrite(\n                           QueueHandle_t xQueue,\n                           const void * pvItemToQueue\n                      );\n\nBaseType_t xQueueOverwriteFromISR(\n                           QueueHandle_t xQueue,\n                           const void * pvItemToQueue,\n                           BaseType_t *pxHigherPriorityTaskWoken\n                      );\n```\n\n如果想让队列中的数据供多方读取，也就是说读取时不要移除数据，要留给后来人。那么可以使用\"窥视\"，也就是**xQueuePeek()\\**或\\**xQueuePeekFromISR()**。这些函数会从队列中复制出数据，但是不移除数据。这也意味着，如果队列中没有数据，那么\"偷看\"时会导致阻塞；一旦队列中有数据，以后每次\"偷看\"都会成功。\n\n函数原型如下：\n\n```c\n/* 偷看队列\n * xQueue: 偷看哪个队列\n * pvItemToQueue: 数据地址, 用来保存复制出来的数据\n * xTicksToWait: 没有数据的话阻塞一会\n * 返回值: pdTRUE表示成功, pdFALSE表示失败\n */\nBaseType_t xQueuePeek(\n                          QueueHandle_t xQueue,\n                          void * const pvBuffer,\n                          TickType_t xTicksToWait\n                      );\n\nBaseType_t xQueuePeekFromISR(\n                                 QueueHandle_t xQueue,\n                                 void *pvBuffer,\n                             );\n```\n\n#### 使用队列时注意\n\n> 写队列与读队列 所传入的`buffer`一定要严格按照初始创建时的类型，否则就会出现死机\n>\n> - 情况一：创建时类型为指针（常用，可以接收多种类型）\n>\n> ```C\n> typedef struct\n> {\n>     uint8_t data[128];\n>     uint8_t index;\n> }Uart_RxTypeDef;\n> \n> Uart_RxTypeDef UartRx = {{0},0};\n> \n> void task(void *arg)\n> {\n>     Uart_RxTypeDef *data = &UartRx;\n>     debug_TX_QueueHandle = osMessageQueueNew(5, sizeof(void *), &debug_TX_Queue_attributes);\n>     xQueueSend(debug_TX_QueueHandle,&data,NULL);//此处一定要&data 因为创建队列的时候是指针 直接写data 相当于&UartRx 他并不是一个指针\n> }\n> \n> ```\n>\n> - 情况二：创建时类型为数据\n>\n> ```C\n> typedef struct\n> {\n>     uint8_t data[128];\n>     uint8_t index;\n> }Uart_RxTypeDef;\n> \n> Uart_RxTypeDef UartRx = {{0},0};\n> \n> void task(void *arg)\n> {\n>     Uart_RxTypeDef data = {{0},0};\n>     debug_TX_QueueHandle = osMessageQueueNew(5, sizeof(Uart_RxTypeDef), &debug_TX_Queue_attributes);\n>     xQueueSend(debug_TX_QueueHandle,&data,NULL);//此处的&data与情况一不一样 这个是参数要求要地址 所以需要将结构体的地址赋值过去\n> }\n> ```\n>\n> \n\n#### 队列集\n\n> 当多个队列需要上报到同一个处理任务时，队列集可以实现统合多个队列，再往上传递到同一个任务\n\n![image-20250915213146479](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509152131801.png)\n\n##### 创建队列集\n\n> 注意要使用队列集 需要先在`Core/inc/FreeRTOSConfig.h` 定义\n>\n> ```bash\n> #define configUSE_QUEUE_SETS 1\n> ```\n\n函数原型如下：\n\n```c\nQueueSetHandle_t xQueueCreateSet( const UBaseType_t uxEventQueueLength )\n```\n\n| **参数**      | **说明**                                                     |\n| ------------- | ------------------------------------------------------------ |\n| uxQueueLength | 队列集长度，最多能存放多少个数据(队列句柄)                   |\n| 返回值        | 非0：成功，返回句柄，以后使用句柄来操作队列NULL：失败，因为内存不足 |\n\n##### 把队列加入队列集\n\n函数原型如下：\n\n```c\nBaseType_t xQueueAddToSet( QueueSetMemberHandle_t xQueueOrSemaphore,\n\n                QueueSetHandle_t xQueueSet );\n\n \n```\n\n| **参数**          | **说明**                       |\n| ----------------- | ------------------------------ |\n| xQueueOrSemaphore | 队列句柄，这个队列要加入队列集 |\n| xQueueSet         | 队列集句柄                     |\n| 返回值            | pdTRUE：成功pdFALSE：失败      |\n\n##### 读取队列集\n\n函数原型如下：\n\n```c\nQueueSetMemberHandle_t xQueueSelectFromSet( QueueSetHandle_t xQueueSet,\n\n                        TickType_t const xTicksToWait );\n```\n\n| **参数**     | **说明**                                                     |\n| ------------ | ------------------------------------------------------------ |\n| xQueueSet    | 队列集句柄                                                   |\n| xTicksToWait | 如果队列集空则无法读出数据，可以让任务进入阻塞状态，xTicksToWait表示阻塞的最大时间(Tick Count)。如果被设为0，无法读出数据时函数会立刻返回；如果被设为portMAX_DELAY，则会一直阻塞直到有数据可写 |\n| 返回值       | NULL：失败，队列句柄：成功                                   |\n\n### 信号量\n\n前面介绍的队列(queue)可以用于传输数据：在任务之间、任务和中断之间。\n\n消息队列用于传输多个数据，但是有时候我们只需要传递状态，这个状态值需要用一个数值表示，比如：\n\n- 卖家：做好了1个包子！做好了2个包子！做好了3个包子！\n- 买家：买了1个包子，包子数量减1\n- 这个停车位我占了，停车位减1\n- 我开车走了，停车位加1\n\n在这种情况下我们只需要维护一个数值，使用信号量效率更高、更节省内存 本章涉及如下内容：\n\n- 怎么创建、删除信号量\n- 怎么发送、获得信号量\n- 什么是计数型信号量？什么是二进制信号量？\n\n####  信号量的特性\n\n##### 信号量的常规操作\n\n信号量这个名字很恰当：\n\n- 信号：起通知作用\n- 量：还可以用来表示资源的数量\n  - 当\"量\"没有限制时，它就是\"计数型信号量\"(Counting Semaphores)\n  - 当\"量\"只有0、1两个取值时，它就是\"二进制信号量\"(Binary Semaphores)\n- 支持的动作：\"give\"给出资源，计数值加1；\"take\"获得资源，计数值减1\n\n计数型信号量的典型场景是：\n\n- 计数：事件产生时\"give\"信号量，让计数值加1；处理事件时要先\"take\"信号量，就是获得信号量，让计数值减1。\n- 资源管理：要想访问资源需要先\"take\"信号量，让计数值减1；用完资源后\"give\"信号量，让计数值加1。 信号量的\"give\"、\"take\"双方并不需要相同，可以用于生产者-消费者场合：\n- 生产者为任务A、B，消费者为任务C、D\n- 一开始信号量的计数值为0，如果任务C、D想获得信号量，会有两种结果：\n  - 阻塞：买不到东西咱就等等吧，可以定个闹钟(超时时间)\n  - 即刻返回失败：不等\n- 任务A、B可以生产资源，就是让信号量的计数值增加1，并且把等待这个资源的顾客唤醒\n- 唤醒谁？谁优先级高就唤醒谁，如果大家优先级一样就唤醒等待时间最长的人\n\n二进制信号量跟计数型的唯一差别，就是计数值的最大值被限定为1。\n\n![img](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509161022312.png)\n\n##### 信号量跟队列的对比\n\n差异列表如下：\n\n| 队列                                                         | 信号量                                                       |\n| ------------------------------------------------------------ | ------------------------------------------------------------ |\n| 可以容纳多个数据， 创建队列时有2部分内存: 队列结构体、存储数据的空间 | 只有计数值，无法容纳其他数据。 创建信号量时，只需要分配信号量结构体 |\n| 生产者：没有空间存入数据时可以阻塞                           | 生产者：用于不阻塞，计数值已经达到最大时返回失败             |\n| 消费者：没有数据时可以阻塞                                   | 消费者：没有资源时可以阻塞                                   |\n\n##### 两种信号量的对比\n\n信号量的计数值都有限制：限定了最大值。如果最大值被限定为1，那么它就是二进制信号量；如果最大值不是1，它就是计数型信号量。\n\n差别列表如下：\n\n| 二进制信号量      | 计数型信号量           |\n| ----------------- | ---------------------- |\n| 被创建时初始值为0 | 被创建时初始值可以设定 |\n| 其他操作是一样的  | 其他操作是一样的       |\n\n#### 信号量函数\n\n使用信号量时，先创建、然后去添加资源、获得资源。使用句柄来表示一个信号量。\n\n##### 创建\n\n使用信号量之前，要先创建，得到一个句柄；使用信号量时，要使用句柄来表明使用哪个信号量。 对于二进制信号量、计数型信号量，它们的创建函数不一样：\n\n|          | 二进制信号量                                     | 计数型信号量                     |\n| -------- | ------------------------------------------------ | -------------------------------- |\n| 动态创建 | `xSemaphoreCreateBinary `计数值初始值为0         | `xSemaphoreCreateCounting`       |\n|          | `vSemaphoreCreateBinary`(过时了) 计数值初始值为1 |                                  |\n| 静态创建 | `xSemaphoreCreateBinaryStatic`                   | `xSemaphoreCreateCountingStatic` |\n\n创建二进制信号量的函数原型如下：\n\n```c\n/* 创建一个二进制信号量，返回它的句柄。\n * 此函数内部会分配信号量结构体 \n * 返回值: 返回句柄，非NULL表示成功\n */\nSemaphoreHandle_t xSemaphoreCreateBinary( void );\n\n/* 创建一个二进制信号量，返回它的句柄。\n * 此函数无需动态分配内存，所以需要先有一个StaticSemaphore_t结构体，并传入它的指针\n * 返回值: 返回句柄，非NULL表示成功\n */\nSemaphoreHandle_t xSemaphoreCreateBinaryStatic( StaticSemaphore_t *pxSemaphoreBuffer );\n```\n\n创建计数型信号量的函数原型如下：\n\n```c\n/* 创建一个计数型信号量，返回它的句柄。\n * 此函数内部会分配信号量结构体 \n * uxMaxCount: 最大计数值\n * uxInitialCount: 初始计数值\n * 返回值: 返回句柄，非NULL表示成功\n */\nSemaphoreHandle_t xSemaphoreCreateCounting(UBaseType_t uxMaxCount, UBaseType_t uxInitialCount);\n\n/* 创建一个计数型信号量，返回它的句柄。\n * 此函数无需动态分配内存，所以需要先有一个StaticSemaphore_t结构体，并传入它的指针\n * uxMaxCount: 最大计数值\n * uxInitialCount: 初始计数值\n * pxSemaphoreBuffer: StaticSemaphore_t结构体指针\n * 返回值: 返回句柄，非NULL表示成功\n */\nSemaphoreHandle_t xSemaphoreCreateCountingStatic( UBaseType_t uxMaxCount, \n                                                 UBaseType_t uxInitialCount, \n                                                 StaticSemaphore_t *pxSemaphoreBuffer );\n```\n\n##### 删除\n\n对于动态创建的信号量，不再需要它们时，可以删除它们以回收内存。\n\nvSemaphoreDelete可以用来删除二进制信号量、计数型信号量，函数原型如下：\n\n```c\n/*\n * xSemaphore: 信号量句柄，你要删除哪个信号量\n */\nvoid vSemaphoreDelete( SemaphoreHandle_t xSemaphore );\n```\n\n##### 释放/获取信号量\n\n二进制信号量、计数型信号量的give、take操作函数是一样的。这些函数也分为2个版本：给任务使用，给ISR使用。列表如下：\n\n|      | 在任务中使用     | 在ISR中使用             |\n| ---- | ---------------- | ----------------------- |\n| give | `xSemaphoreGive` | `xSemaphoreGiveFromISR` |\n| take | `xSemaphoreTake` | `xSemaphoreTakeFromISR` |\n\nxSemaphoreGive的函数原型如下：\n\n```c\nBaseType_t xSemaphoreGive( SemaphoreHandle_t xSemaphore );\n```\n\nxSemaphoreGive函数的参数与返回值列表如下：\n\n| 参数       | 说明                                                         |\n| ---------- | ------------------------------------------------------------ |\n| xSemaphore | 信号量句柄，释放哪个信号量                                   |\n| 返回值     | pdTRUE表示成功, 如果二进制信号量的计数值已经是1，再次调用此函数则返回失败； 如果计数型信号量的计数值已经是最大值，再次调用此函数则返回失败 |\n\npxHigherPriorityTaskWoken的函数原型如下：\n\n```c\nBaseType_t xSemaphoreGiveFromISR(\n                        SemaphoreHandle_t xSemaphore,\n                        BaseType_t *pxHigherPriorityTaskWoken\n                    );\n```\n\nxSemaphoreGiveFromISR函数的参数与返回值列表如下：\n\n| 参数                      | 说明                                                         |\n| ------------------------- | ------------------------------------------------------------ |\n| xSemaphore                | 信号量句柄，释放哪个信号量                                   |\n| pxHigherPriorityTaskWoken | 如果释放信号量导致更高优先级的任务变为了就绪态， 则*pxHigherPriorityTaskWoken = pdTRUE |\n| 返回值                    | pdTRUE表示成功, 如果二进制信号量的计数值已经是1，再次调用此函数则返回失败； 如果计数型信号量的计数值已经是最大值，再次调用此函数则返回失败 |\n\nxSemaphoreTake的函数原型如下：\n\n```c\nBaseType_t xSemaphoreTake(\n                   SemaphoreHandle_t xSemaphore,\n                   TickType_t xTicksToWait\n               );\n```\n\nxSemaphoreTake函数的参数与返回值列表如下：\n\n| 参数           | 说明                                                         |\n| -------------- | ------------------------------------------------------------ |\n| `xSemaphore`   | 信号量句柄，获取哪个信号量                                   |\n| `xTicksToWait` | 如果无法马上获得信号量，阻塞一会： 0：不阻塞，马上返回 `portMAX_DELAY`: 一直阻塞直到成功 其他值: 阻塞的Tick个数，可以使用*`pdMS_TO_TICKS`()*来指定阻塞时间为若干`ms` |\n| 返回值         | pdTRUE表示成功                                               |\n\nxSemaphoreTakeFromISR的函数原型如下：\n\n```c\nBaseType_t xSemaphoreTakeFromISR(\n                        SemaphoreHandle_t xSemaphore,\n                        BaseType_t *pxHigherPriorityTaskWoken\n                    );\n```\n\nxSemaphoreTakeFromISR函数的参数与返回值列表如下：\n\n| 参数                        | 说明                                                         |\n| --------------------------- | ------------------------------------------------------------ |\n| `xSemaphore`                | 信号量句柄，获取哪个信号量                                   |\n| `pxHigherPriorityTaskWoken` | 如果获取信号量导致更高优先级的任务变为了就绪态， 则`*pxHigherPriorityTaskWoken = pdTRUE` |\n| 返回值                      | pdTRUE表示成功                                               |\n\n#### 优先级反转\n\n信号量使用不当 就会出现优先级反转的问题——任务执行顺序：任务1、任务2、任务1、任务3\n\n即最高优先级的任务最后运行\n\n> 优先级反转：假设信号量值为1，同时创建了低、中等、高优先级任务\n>\n> - 低优先级任务获取信号量，中等优先级先阻塞一段时间，确保低优先级任务先成功获取到信号量\n> - 高优先级任务先阻塞一段时间，确保低优先级、中等优先级先完成任务，然后尝试获取信号量\n> - 此时由于低优先级获取了信号量，高优先级任务就会被阻塞\n> - 中等优先级不释放信号量，那么就会发生高优先级任务无法运行\n\n##### 示例\n\n```C\n#include \"uart.h\"\ntypedef struct __FILE FILE;\n\nstatic SemaphoreHandle_t task_mutex = NULL;\n\ntypedef struct\n{\n    uint8_t dev;\n    uint8_t *data;\n} uart_info_t;\n\nuart_info_t task1_data = {1, \"task1\"};\nuart_info_t task2_data = {2, \"task2\"};\nuart_info_t task3_data = {3, \"task3\"};\nint fputc(int ch, FILE *f)\n{\n    HAL_UART_Transmit(&huart1, (uint8_t *)&ch, 1, 0xFFFF);\n    return ch;\n}\n\nvoid task1(void *param)\n{\n    uint8_t cnt = 0;\n    xSemaphoreTake(task_mutex, portMAX_DELAY);\n    uart_info_t *data = param;\n    while (1)\n    {\n        printf(\"dev:%u,name:%s\\r\\n\", data->dev, data->data);\n        if (++cnt == 5)\n        {\n            xSemaphoreGive(task_mutex);\n        }\n        vTaskDelay(50);\n    }\n}\n\nvoid task2(void *param)\n{\n    uint8_t cnt = 0;\n    vTaskDelay(300);//先阻塞一段时间 确保任务1成功获取信号量且能够被切换为任务2\n    uart_info_t *data = param;\n    while (1)\n    {\n        printf(\"dev:%u,name:%s\\r\\n\", data->dev, data->data);\n        if (++cnt == 5)\n        {\n            vTaskDelete(NULL);\n        }\n        HAL_Delay(50);\n    }\n}\n\nvoid task3(void *param)\n{\n    uint8_t cnt = 0;\n    vTaskDelay(500);\t//先阻塞一段时间 确保任务1先成功获取信号量且能够被切换为任务2\n    xSemaphoreTake(task_mutex, portMAX_DELAY);\n    uart_info_t *data = param;\n    while (1)\n    {\n        printf(\"dev:%u,name:%s\\r\\n\", data->dev, data->data);\n        if (++cnt == 5)\n        {\n            vTaskDelete(NULL);\n        }\n    }\n}\n\nvoid uart_init(void)\n{\n    task_mutex = xSemaphoreCreateBinary();\n    xSemaphoreGive(task_mutex);\n    xTaskCreate(task1, \"task1\", 128, &task1_data, osPriorityNormal, NULL);\t//低优先级任务\n    xTaskCreate(task2, \"task2\", 128, &task2_data, osPriorityNormal1, NULL);\t//中等优先级任务\n    xTaskCreate(task3, \"task3\", 128, &task3_data, osPriorityNormal2, NULL);\t//高优先级任务\n}\n```\n\n![image-20250916160014655](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509161600972.png)\n\n#### 解决优先级反转\n\n> 使用互斥量 （实现优先级继承），当最高优先级任务等待互斥量时，可以将低优先级任务继承最高优先级，使得最高优先级任务也可以先运行\n>\n> 现象：任务1执行一小段时间被任务2抢占，当任务3时间到来，任务1继承任务3优先级，所以任务1运行释放后，任务1恢复原先优先级，任务3启动\n\n### 事件组\n\n> 上述任务同步与互斥的方法都是一对一通知，难以实现一对多通知（广播），因此引入了事件组\n\n#### 事件组的概念\n\n事件组可以简单地认为就是一个整数：\n\n- 的每一位表示一个事件\n- 每一位事件的含义由程序员决定，比如：Bit0表示用来串口是否就绪，Bit1表示按键是否被按下\n- 这些位，值为1表示事件发生了，值为0表示事件没发生\n- 一个或多个任务、ISR都可以去写这些位；一个或多个任务、ISR都可以去读这些位\n- 可以等待某一位、某些位中的任意一个，也可以等待多位\n\n![img](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509161809736.png)\n\n事件组用一个整数来表示，其中的高8位留给内核使用，只能用其他的位来表示事件。那么这个整数是多少位的？\n\n- 如果configUSE_16_BIT_TICKS是1，那么这个整数就是16位的，低8位用来表示事件\n- 如果configUSE_16_BIT_TICKS是0，那么这个整数就是32位的，低24位用来表示事件\n- configUSE_16_BIT_TICKS是用来表示Tick Count的，怎么会影响事件组？这只是基于效率来考虑\n  - 如果configUSE_16_BIT_TICKS是1，就表示该处理器使用16位更高效，所以事件组也使用16位\n  - 如果configUSE_16_BIT_TICKS是0，就表示该处理器使用32位更高效，所以事件组也使用32位\n\n#### 事件组的操作\n\n事件组和队列、信号量等不太一样，主要集中在2个地方：\n\n- 唤醒谁？\n  - 队列、信号量：事件发生时，只会唤醒一个任务\n  - 事件组：事件发生时，会唤醒所有符号条件的任务，简单地说它有\"广播\"的作用\n- 是否清除事件？\n  - 队列、信号量：是消耗型的资源，队列的数据被读走就没了；信号量被获取后就减少了\n  - 事件组：被唤醒的任务有两个选择，可以让事件保留不动，也可以清除事件\n\n以上图为列，事件组的常规操作如下：\n\n- 先创建事件组\n- 任务C、D等待事件：\n  - 等待什么事件？可以等待某一位、某些位中的任意一个，也可以等待多位。简单地说就是\"或\"、\"与\"的关系。\n  - 得到事件时，要不要清除？可选择清除、不清除。\n- 任务A、B产生事件：设置事件组里的某一位、某些位\n\n#### 事件组函数\n\n##### 创建\n\n使用事件组之前，要先创建，得到一个句柄；使用事件组时，要使用句柄来表明使用哪个事件组。\n\n有两种创建方法：动态分配内存、静态分配内存。函数原型如下：\n\n```c\n/* 创建一个事件组，返回它的句柄。\n * 此函数内部会分配事件组结构体 \n * 返回值: 返回句柄，非NULL表示成功\n */\nEventGroupHandle_t xEventGroupCreate( void );\n\n/* 创建一个事件组，返回它的句柄。\n * 此函数无需动态分配内存，所以需要先有一个StaticEventGroup_t结构体，并传入它的指针\n * 返回值: 返回句柄，非NULL表示成功\n */\nEventGroupHandle_t xEventGroupCreateStatic( StaticEventGroup_t * pxEventGroupBuffer );\n```\n\n##### 删除\n\n对于动态创建的事件组，不再需要它们时，可以删除它们以回收内存。\n\n**vEventGroupDelete**可以用来删除事件组，函数原型如下：\n\n```c\n/*\n * xEventGroup: 事件组句柄，你要删除哪个事件组\n */\nvoid vEventGroupDelete( EventGroupHandle_t xEventGroup )\n```\n\n##### 设置事件\n\n可以设置事件组的某个位、某些位，使用的函数有2个：\n\n- 在任务中使用**xEventGroupSetBits()**\n- 在ISR中使用**xEventGroupSetBitsFromISR()**\n\n有一个或多个任务在等待事件，如果这些事件符合这些任务的期望，那么任务还会被唤醒。\n\n函数原型如下：\n\n```c\n/* 设置事件组中的位\n * xEventGroup: 哪个事件组\n * uxBitsToSet: 设置哪些位? \n *              如果uxBitsToSet的bitX, bitY为1, 那么事件组中的bitX, bitY被设置为1\n *              可以用来设置多个位，比如 0x15 就表示设置bit4, bit2, bit0\n * 返回值: 返回原来的事件值(没什么意义, 因为很可能已经被其他任务修改了)\n */\nEventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup,\n                                    const EventBits_t uxBitsToSet );\n\n/* 设置事件组中的位\n * xEventGroup: 哪个事件组\n * uxBitsToSet: 设置哪些位? \n *              如果uxBitsToSet的bitX, bitY为1, 那么事件组中的bitX, bitY被设置为1\n *              可以用来设置多个位，比如 0x15 就表示设置bit4, bit2, bit0\n * pxHigherPriorityTaskWoken: 有没有导致更高优先级的任务进入就绪态? pdTRUE-有, pdFALSE-没有\n * 返回值: pdPASS-成功, pdFALSE-失败\n */\nBaseType_t xEventGroupSetBitsFromISR( EventGroupHandle_t xEventGroup,\n\t\t\t\t\t\t\t\t\t  const EventBits_t uxBitsToSet,\n\t\t\t\t\t\t\t\t\t  BaseType_t * pxHigherPriorityTaskWoken );\n```\n\n值得注意的是，ISR中的函数，比如队列函数**xQueueSendToBackFromISR**、信号量函数**xSemaphoreGiveFromISR**，它们会唤醒某个任务，最多只会唤醒1个任务。\n\n但是设置事件组时，有可能导致多个任务被唤醒，这会带来很大的不确定性。所以**xEventGroupSetBitsFromISR**函数不是直接去设置事件组，而是给一个FreeRTOS后台任务(daemon task)发送队列数据，由这个任务来设置事件组。\n\n如果后台任务的优先级比当前被中断的任务优先级高，**xEventGroupSetBitsFromISR**会设置**pxHigherPriorityTaskWoken**为pdTRUE。\n\n如果daemon task成功地把队列数据发送给了后台任务，那么**xEventGroupSetBitsFromISR**的返回值就是pdPASS。\n\n##### 等待事件\n\n使用**xEventGroupWaitBits**来等待事件，可以等待某一位、某些位中的任意一个，也可以等待多位；等到期望的事件后，还可以清除某些位。\n\n函数原型如下：\n\n```c\nEventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup,\n                                 const EventBits_t uxBitsToWaitFor,\n                                 const BaseType_t xClearOnExit,\n                                 const BaseType_t xWaitForAllBits,\n                                 TickType_t xTicksToWait );\n```\n\n先引入一个概念：unblock condition。一个任务在等待事件发生时，它处于阻塞状态；当期望的时间发生时，这个状态就叫\"unblock condition\"，非阻塞条件，或称为\"非阻塞条件成立\"；当\"非阻塞条件成立\"后，该任务就可以变为就绪态。\n\n函数参数说明列表如下：\n\n|    **参数**     | **说明**                                                     |\n| :-------------: | :----------------------------------------------------------- |\n|   xEventGroup   | 等待哪个事件组？                                             |\n| uxBitsToWaitFor | 等待哪些位？哪些位要被测试？                                 |\n| xWaitForAllBits | 怎么测试？是\"AND\"还是\"OR\"？ pdTRUE: 等待的位，全部为1; pdFALSE: 等待的位，某一个为1即可 |\n|  xClearOnExit   | 函数提出前是否要清除事件？ pdTRUE: 清除uxBitsToWaitFor指定的位 pdFALSE: 不清除 |\n|  xTicksToWait   | 如果期待的事件未发生，阻塞多久。 可以设置为0：判断后即刻返回； 可设置为portMAX_DELAY：一定等到成功才返回； 可以设置为期望的Tick Count，一般用*pdMS_TO_TICKS()*把ms转换为Tick Count |\n|     返回值      | 返回的是事件值， 如果期待的事件发生了，返回的是\"非阻塞条件成立\"时的事件值； 如果是超时退出，返回的是超时时刻的事件值。 |\n\n举例如下：\n\n| 事件组的值 | uxBitsToWaitFor | xWaitForAllBits | 说明                                                         |\n| :--------: | :-------------: | :-------------: | :----------------------------------------------------------- |\n|    0100    |      0101       |     pdTRUE      | 任务期望bit0,bit2都为1， 当前值只有bit2满足，任务进入阻塞态； 当事件组中bit0,bit2都为1时退出阻塞态 |\n|    0100    |      0110       |     pdFALSE     | 任务期望bit0,bit2某一个为1， 当前值满足，所以任务成功退出    |\n|    0100    |      0110       |     pdTRUE      | 任务期望bit1,bit2都为1， 当前值不满足，任务进入阻塞态； 当事件组中bit1,bit2都为1时退出阻塞态 |\n\n你可以使用*xEventGroupWaitBits()*等待期望的事件，它发生之后再使用*xEventGroupClearBits()*来清除。但是这两个函数之间，有可能被其他任务或中断抢占，它们可能会修改事件组。\n\n可以使用设置*xClearOnExit*为pdTRUE，使得对事件组的测试、清零都在*xEventGroupWaitBits()*函数内部完成，这是一个原子操作。\n\n##### 同步点\n\n有一个事情需要多个任务协同，比如：\n\n- 任务A：炒菜\n- 任务B：买酒\n- 任务C：摆台\n- A、B、C做好自己的事后，还要等别人做完；大家一起做完，才可开饭\n\n使用 **xEventGroupSync()** 函数可以同步多个任务：\n\n- 可以设置某位、某些位，表示自己做了什么事\n- 可以等待某位、某些位，表示要等等其他任务\n- 期望的时间发生后， **xEventGroupSync()** 才会成功返回。\n- **xEventGroupSync**成功返回后，会清除事件\n\n**xEventGroupSync** 函数原型如下：\n\n```text\nEventBits_t xEventGroupSync(    EventGroupHandle_t xEventGroup,\n                                const EventBits_t uxBitsToSet,\n                                const EventBits_t uxBitsToWaitFor,\n                                TickType_t xTicksToWait );\n```\n\n参数列表如下：\n\n|    **参数**     | **说明**                                                     |\n| :-------------: | ------------------------------------------------------------ |\n|   xEventGroup   | 哪个事件组？                                                 |\n|   uxBitsToSet   | 要设置哪些事件？我完成了哪些事件？ 比如0x05(二进制为0101)会导致事件组的bit0,bit2被设置为1 |\n| uxBitsToWaitFor | 等待那个位、哪些位？ 比如0x15(二级制10101)，表示要等待bit0,bit2,bit4都为1 |\n|  xTicksToWait   | 如果期待的事件未发生，阻塞多久。 可以设置为0：判断后即刻返回； 可设置为portMAX_DELAY：一定等到成功才返回； 可以设置为期望的Tick Count，一般用*pdMS_TO_TICKS()*把ms转换为Tick Count |\n|     返回值      | 返回的是事件值， 如果期待的事件发生了，返回的是\"非阻塞条件成立\"时的事件值； 如果是超时退出，返回的是超时时刻的事件值。 |\n\n参数列表如下：\n\n|    **参数**     | **说明**                                                     |\n| :-------------: | :----------------------------------------------------------- |\n|   xEventGroup   | 哪个事件组？                                                 |\n|   uxBitsToSet   | 要设置哪些事件？我完成了哪些事件？ 比如0x05(二进制为0101)会导致事件组的bit0,bit2被设置为1 |\n| uxBitsToWaitFor | 等待那个位、哪些位？ 比如0x15(二级制10101)，表示要等待bit0,bit2,bit4都为1 |\n|  xTicksToWait   | 如果期待的事件未发生，阻塞多久。 可以设置为0：判断后即刻返回； 可设置为portMAX_DELAY：一定等到成功才返回； 可以设置为期望的Tick Count，一般用*pdMS_TO_TICKS()*把ms转换为Tick Count |\n|     返回值      | 返回的是事件值， 如果期待的事件发生了，返回的是\"非阻塞条件成立\"时的事件值； 如果是超时退出，返回的是超时时刻的事件值。 |\n\n### 任务通知\n\n所谓\"任务通知\"，你可以反过来读\"通知任务\"。\n\n我们使用队列、信号量、事件组等等方法时，并不知道对方是谁。使用任务通知时，可以明确指定：通知哪个任务。\n\n使用队列、信号量、事件组时，我们都要事先创建对应的结构体，双方通过中间的结构体通信：\n\n![img](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509161952531.png)\n\n使用任务通知时，任务结构体TCB中就包含了内部对象，可以直接接收别人发过来的\"通知\"：\n\n![img](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509161952379.png)\n\n#### 任务通知的特性\n\n##### 优势及限制\n\n任务通知的优势：\n\n- 效率更高：使用任务通知来发送事件、数据给某个任务时，效率更高。比队列、信号量、事件组都有大的优势。\n- 更节省内存：使用其他方法时都要先创建对应的结构体，使用任务通知时无需额外创建结构体。\n\n任务通知的限制：\n\n- 不能发送数据给ISR：\n- ISR并没有任务结构体，所以无法使用任务通知的功能给ISR发送数据。但是ISR可以使用任务通知的功能，发数据给任务。\n- 数据只能给该任务独享\n- 使用队列、信号量、事件组时，数据保存在这些结构体中，其他任务、ISR都可以访问这些数据。使用任务通知时，数据存放入目标任务中，只有它可以访问这些数据。\n- 在日常工作中，这个限制影响不大。因为很多场合是从多个数据源把数据发给某个任务，而不是把一个数据源的数据发给多个任务。\n- 无法缓冲数据\n- 使用队列时，假设队列深度为N，那么它可以保持N个数据。\n- 使用任务通知时，任务结构体中只有一个任务通知值，只能保持一个数据。\n- <span style=\"color:#00FFFF;\">无法广播给多个任务</span>\n- 使用事件组可以同时给多个任务发送事件。\n- 使用任务通知，只能发个一个任务。\n- 如果发送受阻，发送方无法进入阻塞状态等待\n- 假设队列已经满了，使用 **xQueueSendToBack()** 给队列发送数据时，任务可以进入阻塞状态等待发送完成。\n- 使用任务通知时，即使对方无法接收数据，发送方也无法阻塞等待，只能即刻返回错误。\n\n#####  通知状态和通知值\n\n每个任务都有一个结构体：TCB(Task Control Block)，里面有2个成员：\n\n- 一个是uint8_t类型，用来表示通知状态\n- 一个是uint32_t类型，用来表示通知值\n\n```c\ntypedef struct tskTaskControlBlock\n{\n    ......\n    /* configTASK_NOTIFICATION_ARRAY_ENTRIES = 1 */\n    volatile uint32_t ulNotifiedValue[ configTASK_NOTIFICATION_ARRAY_ENTRIES ];\n    volatile uint8_t ucNotifyState[ configTASK_NOTIFICATION_ARRAY_ENTRIES ];\n    ......\n} tskTCB;\n```\n\n通知状态有3种取值：\n\n- taskNOT_WAITING_NOTIFICATION：任务没有在等待通知\n- taskWAITING_NOTIFICATION：任务在等待通知\n- taskNOTIFICATION_RECEIVED：任务接收到了通知，也被称为pending(有数据了，待处理)\n\n```c\n##define taskNOT_WAITING_NOTIFICATION              ( ( uint8_t ) 0 )  /* 也是初始状态 */\n##define taskWAITING_NOTIFICATION                  ( ( uint8_t ) 1 )\n##define taskNOTIFICATION_RECEIVED                 ( ( uint8_t ) 2 )\n```\n\n通知值可以有很多种类型：\n\n- 计数值\n- 位(类似事件组)\n- 任意数值\n\n#### 任务通知的使用\n\n使用任务通知，可以实现轻量级的队列(长度为1)、邮箱(覆盖的队列)、计数型信号量、二进制信号量、事件组。\n\n##### 两类函数\n\n任务通知有2套函数，简化版、专业版，列表如下：\n\n- 简化版函数的使用比较简单，它实际上也是使用专业版函数实现的\n- 专业版函数支持很多参数，可以实现很多功能\n\n|          | 简化版                                      | 专业版                              |\n| -------- | ------------------------------------------- | ----------------------------------- |\n| 发出通知 | `xTaskNotifyGive ` `vTaskNotifyGiveFromISR` | `xTaskNotify ` `xTaskNotifyFromISR` |\n| 取出通知 | `ulTaskNotifyTake`                          | `xTaskNotifyWait`                   |\n\n##### 简化版任务通知\n\n在任务中使用`xTaskNotifyGive`函数，在ISR中使用`vTaskNotifyGiveFromISR`函数，都是直接给其他任务发送通知：\n\n- 使得通知值加一\n- 并使得通知状态变为\"pending\"，也就是**taskNOTIFICATION_RECEIVED**，表示有数据了、待处理\n\n可以使用`ulTaskNotifyTake`函数来取出通知值：\n\n- 如果通知值等于0，则阻塞(可以指定超时时间)\n- 当通知值大于0时，任务从阻塞态进入就绪态\n- 在ulTaskNotifyTake返回之前，还可以做些清理工作：把通知值减一，或者把通知值清零\n\n使用ulTaskNotifyTake函数可以实现轻量级的、高效的二进制信号量、计数型信号量。\n\n这几个函数的原型如下：\n\n```c\nBaseType_t xTaskNotifyGive( TaskHandle_t xTaskToNotify );\n\nvoid vTaskNotifyGiveFromISR( TaskHandle_t xTaskHandle, BaseType_t *pxHigherPriorityTaskWoken );\n\nuint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait );\n```\n\n`xTaskNotifyGive`函数的参数说明如下：\n\n|    **参数**     | **说明**                                   |\n| :-------------: | ------------------------------------------ |\n| `xTaskToNotify` | 任务句柄(创建任务时得到)，给哪个任务发通知 |\n|     返回值      | 必定返回pdPASS                             |\n\n`vTaskNotifyGiveFromISR`函数的参数说明如下：\n\n|          **参数**           | **说明**                                                     |\n| :-------------------------: | ------------------------------------------------------------ |\n|        `xTaskHandle`        | 任务句柄(创建任务时得到)，给哪个任务发通知                   |\n| `pxHigherPriorityTaskWoken` | 被通知的任务，可能正处于阻塞状态。 此函数发出通知后，会把它从阻塞状态切换为就绪态。 如果被唤醒的任务的优先级，高于当前任务的优先级， 则\"*pxHigherPriorityTaskWoken\"被设置为pdTRUE， 这表示在中断返回之前要进行任务切换。 |\n\n`ulTaskNotifyTake`函数的参数说明如下：\n\n|      **参数**       | **说明**                                                     |\n| :-----------------: | ------------------------------------------------------------ |\n| `xClearCountOnExit` | 函数返回前是否清零： pdTRUE：把通知值清零 pdFALSE：如果通知值大于0，则把通知值减一 |\n|   `xTicksToWait`    | 任务进入阻塞态的超时时间，它在等待通知值大于0。 0：不等待，即刻返回； portMAX_DELAY：一直等待，直到通知值大于0； 其他值：Tick Count，可以用*pdMS_TO_TICKS()*把ms转换为Tick Count |\n|       返回值        | 函数返回之前，在清零或减一之前的通知值。 如果xTicksToWait非0，则返回值有2种情况： 1. 大于0：在超时前，通知值被增加了 2. 等于0：一直没有其他任务增加通知值，最后超时返回0 |\n\n##### 专业版任务通知\n\n**xTaskNotify** 函数功能更强大，可以使用不同参数实现各类功能，比如：\n\n- 让接收任务的通知值加一：这时 **xTaskNotify()** 等同于 **xTaskNotifyGive()**\n- 设置接收任务的通知值的某一位、某些位，这就是一个轻量级的、更高效的事件组\n- 把一个新值写入接收任务的通知值：上一次的通知值被读走后，写入才成功。这就是轻量级的、长度为1的队列\n- 用一个新值覆盖接收任务的通知值：无论上一次的通知值是否被读走，覆盖都成功。类似 **xQueueOverwrite()** 函数，这就是轻量级的邮箱。\n\n**xTaskNotify()** 比 **xTaskNotifyGive()** 更灵活、强大，使用上也就更复杂。**xTaskNotifyFromISR()** 是它对应的ISR版本。\n\n这两个函数用来发出任务通知，使用哪个函数来取出任务通知呢？\n\n使用 **xTaskNotifyWait()** 函数！它比 **ulTaskNotifyTake()** 更复杂：\n\n- 可以让任务等待(可以加上超时时间)，等到任务状态为\"pending\"(也就是有数据)\n- 还可以在函数进入、退出时，清除通知值的指定位\n\n这几个函数的原型如下：\n\n```c\nBaseType_t xTaskNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction );\n\nBaseType_t xTaskNotifyFromISR( TaskHandle_t xTaskToNotify,\n                               uint32_t ulValue, \n                               eNotifyAction eAction, \n                               BaseType_t *pxHigherPriorityTaskWoken );\n\nBaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, \n                            uint32_t ulBitsToClearOnExit, \n                            uint32_t *pulNotificationValue, \n                            TickType_t xTicksToWait );\n```\n\n`xTaskNotify`函数的参数说明如下：\n\n|    **参数**     | **说明**                                                     |\n| :-------------: | ------------------------------------------------------------ |\n| `xTaskToNotify` | 任务句柄(创建任务时得到)，给哪个任务发通知                   |\n|    `ulValue`    | 怎么使用ulValue，由eAction参数决定                           |\n|    `eAction`    | 见下表                                                       |\n|     返回值      | pdPASS：成功，大部分调用都会成功 pdFAIL：只有一种情况会失败，当eAction为eSetValueWithoutOverwrite， 并且通知状态为\"pending\"(表示有新数据未读)，这时就会失败。 |\n\n`eNotifyAction`参数说明：\n\n|   **eNotifyAction取值**   | **说明**                                                     |\n| :-----------------------: | ------------------------------------------------------------ |\n|        `eNoAction`        | 仅仅是更新通知状态为\"pending\"，未使用ulValue。 这个选项相当于轻量级的、更高效的二进制信号量。 |\n|        `eSetBits`         | 通知值 = 原来的通知值 \\| ulValue，按位或。 相当于轻量级的、更高效的事件组。 |\n|       `eIncrement`        | 通知值 = 原来的通知值 + 1，未使用ulValue。 相当于轻量级的、更高效的二进制信号量、计数型信号量。 相当于**xTaskNotifyGive()**函数。 |\n| eSetValueWithoutOverwrite | 不覆盖。 如果通知状态为\"pending\"(表示有数据未读)， 则此次调用xTaskNotify不做任何事，返回pdFAIL。 如果通知状态不是\"pending\"(表示没有新数据)， 则：通知值 = ulValue。 |\n|  eSetValueWithOverwrite   | 覆盖。 无论如何，不管通知状态是否为\"pendng\"， 通知值 = ulValue。 |\n\nxTaskNotifyFromISR函数跟xTaskNotify很类似，就多了最后一个参数**pxHigherPriorityTaskWoken**。在很多ISR函数中，这个参数的作用都是类似的，使用场景如下：\n\n- 被通知的任务，可能正处于阻塞状态\n- **xTaskNotifyFromISR**函数发出通知后，会把接收任务从阻塞状态切换为就绪态\n- 如果被唤醒的任务的优先级，高于当前任务的优先级，则\"*pxHigherPriorityTaskWoken\"被设置为pdTRUE，这表示在中断返回之前要进行任务切换。\n\nxTaskNotifyWait函数列表如下：\n\n|        **参数**        | **说明**                                                     |\n| :--------------------: | ------------------------------------------------------------ |\n| `ulBitsToClearOnEntry` | 在xTaskNotifyWait入口处，要清除通知值的哪些位？ 通知状态不是\"pending\"的情况下，才会清除。 它的本意是：我想等待某些事件发生，所以先把\"旧数据\"的某些位清零。 能清零的话：通知值 = 通知值 & ~(ulBitsToClearOnEntry)。 比如传入0x01，表示清除通知值的bit0； 传入0xffffffff即ULONG_MAX，表示清除所有位，即把值设置为0 |\n| `ulBitsToClearOnExit`  | 在xTaskNotifyWait出口处，如果不是因为超时推出，而是因为得到了数据而退出时： 通知值 = 通知值 & ~(ulBitsToClearOnExit)。 在清除某些位之前，通知值先被赋给\"*pulNotificationValue\"。 比如入0x03，表示清除通知值的bit0、bit1； 传入0xffffffff即ULONG_MAX，表示清除所有位，即把值设置为0 |\n| `pulNotificationValue` | 用来取出通知值。 在函数退出时，使用ulBitsToClearOnExit清除之前，把通知值赋给\"*pulNotificationValue\"。 如果不需要取出通知值，可以设为NULL。 |\n|     `xTicksToWait`     | 任务进入阻塞态的超时时间，它在等待通知状态变为\"pending\"。 0：不等待，即刻返回； portMAX_DELAY：一直等待，直到通知状态变为\"pending\"； 其他值：Tick Count，可以用*pdMS_TO_TICKS()*把ms转换为Tick Count |\n|         返回值         | 1. pdPASS：成功 这表示xTaskNotifyWait成功获得了通知： 可能是调用函数之前，通知状态就是\"pending\"； 也可能是在阻塞期间，通知状态变为了\"pending\"。 2. pdFAIL：没有得到通知。 |\n","slug":"freertos","published":1,"updated":"2025-09-19T03:20:58.000Z","comments":1,"photos":[],"_id":"cmk8pg6xn00106sk91exxffbm","content":"<h2 id=\"FreeRTOS基础\"><a href=\"#FreeRTOS基础\" class=\"headerlink\" title=\"FreeRTOS基础\"></a>FreeRTOS基础</h2><h3 id=\"获取系统时间\"><a href=\"#获取系统时间\" class=\"headerlink\" title=\"获取系统时间\"></a>获取系统时间</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TickType_t currentTicks;</span><br><span class=\"line\"><span class=\"keyword\">while</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">     currentTicks = xTaskGetTickCount();</span><br><span class=\"line\">     <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;[%lu]dev:%u,name:%s\\r\\n&quot;</span>, currentTicks, data-&gt;dev, data-&gt;data);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"堆和栈\"><a href=\"#堆和栈\" class=\"headerlink\" title=\"堆和栈\"></a>堆和栈</h3><p>堆：一块空闲的内存 可以使用<code>malloc</code>申请内存 使用完后用<code>free</code>释放内存</p>\n<blockquote>\n<p>堆也可以理解为就是定义了一个堆大小的数组 然后定义一个长度 每次动态改变长度来申请空间（链表）</p>\n<p>在<code>FreeRTOSConfig.h</code>中就有定义堆大小的宏<code>configTOTAL_HEAP_SIZE</code> 他被引用到 <code>heap.c</code>中的 <code>static uint8_t ucHeap[configTOTAL_HEAP_SIZE];</code></p>\n</blockquote>\n<p>栈：一块内存空间，CPU的SP寄存器指向它，它可以用于函数调用、局部变量、<code>多任务系统里保存现场</code></p>\n<blockquote>\n<p>栈是<code>FreeRTOS</code>中非常重要的概念，每个任务都有自己的栈</p>\n</blockquote>\n<h3 id=\"FreeRTOS源码概述\"><a href=\"#FreeRTOS源码概述\" class=\"headerlink\" title=\"FreeRTOS源码概述\"></a>FreeRTOS源码概述</h3><h4 id=\"目录结构\"><a href=\"#目录结构\" class=\"headerlink\" title=\"目录结构\"></a>目录结构</h4><p><img src=\"https://photos.100ask.net/renesas-docs/DShanMCU_RA6M5/FreeRTOS/chapter-6/image1.png\" alt=\"img\"></p>\n<blockquote>\n<p>主要涉及3个目录：</p>\n<ul>\n<li><code>ra\\aws\\FreeRTOS\\FreeRTOS\\Source</code>：存放的是FreeRTOS的核心文件</li>\n<li><code>ra_gen</code>：从main.c可以看到创建任务的函数调用过程</li>\n<li><code>src</code>：使用RASC创建任务时，在src目录下生成任务的入口函数</li>\n</ul>\n</blockquote>\n<h4 id=\"核心文件\"><a href=\"#核心文件\" class=\"headerlink\" title=\"核心文件\"></a>核心文件</h4><blockquote>\n<p>FreeRTOS的最核心文件只有2个：</p>\n<ul>\n<li><code>FreeRTOS/Source/tasks.c</code></li>\n<li><code>FreeRTOS/Source/list.c</code></li>\n</ul>\n</blockquote>\n<p>其他文件的作用也一起列表如下：</p>\n<table>\n<thead>\n<tr>\n<th><strong><code>FreeRTOS/Source/</code>下的文件</strong></th>\n<th><strong>作用</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>tasks.c</code></td>\n<td>必需，任务操作</td>\n</tr>\n<tr>\n<td><code>list.c</code></td>\n<td>必须，列表</td>\n</tr>\n<tr>\n<td><code>queue.c</code></td>\n<td>基本必需，提供队列操作、信号量(semaphore)操作</td>\n</tr>\n<tr>\n<td><code>timer.c</code></td>\n<td>可选，software timer</td>\n</tr>\n<tr>\n<td><code>event_groups.c</code></td>\n<td>可选，提供event group功能</td>\n</tr>\n</tbody></table>\n<h4 id=\"头文件相关\"><a href=\"#头文件相关\" class=\"headerlink\" title=\"头文件相关\"></a>头文件相关</h4><h5 id=\"头文件目录\"><a href=\"#头文件目录\" class=\"headerlink\" title=\"头文件目录\"></a>头文件目录</h5><blockquote>\n<p>FreeRTOS需要3个头文件目录：</p>\n<ul>\n<li>FreeRTOS本身的头文件：<code>ra\\aws\\FreeRTOS\\FreeRTOS\\Source\\include</code></li>\n<li>移植时用到的头文件：<code>ra\\fsp\\src\\rm_freertos_port\\portmacro.h</code></li>\n<li>含有配置文件<code>FreeRTOSConfig.h</code>的目录：<code>ra_cfg\\aws</code></li>\n</ul>\n</blockquote>\n<h5 id=\"头文件\"><a href=\"#头文件\" class=\"headerlink\" title=\"头文件\"></a>头文件</h5><p>列表如下：</p>\n<table>\n<thead>\n<tr>\n<th><strong>头文件</strong></th>\n<th><strong>作用</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>FreeRTOSConfig.h</code></td>\n<td>FreeRTOS的配置文件，比如选择调度算法：<code>configUSE_PREEMPTION</code> 每个工程都必定含有<code>FreeRTOSConfig.h</code></td>\n</tr>\n<tr>\n<td><code>FreeRTOS.h</code></td>\n<td>使用FreeRTOS API函数时，<span style=\"font-weight:bold;\">必须</span>包含此文件。 在<code>FreeRTOS.h</code>之后，再去包含其他头文件，比如： <code>task.h</code>、<code>queue.h</code>、<code>semphr.h</code>、<code>event_group.h</code></td>\n</tr>\n</tbody></table>\n<h4 id=\"独属于FreeRTOS的数据类型和编程规范\"><a href=\"#独属于FreeRTOS的数据类型和编程规范\" class=\"headerlink\" title=\"独属于FreeRTOS的数据类型和编程规范\"></a>独属于FreeRTOS的数据类型和编程规范</h4><h5 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h5><p>每个移植的版本都含有自己的 <strong><code>portmacro.h</code></strong> 头文件，里面定义了2个数据类型：</p>\n<ol>\n<li><code>TickType_t</code>：<ul>\n<li>时钟计数单位 （可以是uint16_t 也可以是uint32_t）<br>当<code>FreeRTOSConfig.h</code>中定义<code>configUSE_16_BIT_TICKS时 TickType_t</code>则为uint16_t</li>\n</ul>\n</li>\n</ol>\n<blockquote>\n<p>对于32位架构，建议把TickType_t配置为uint32_t</p>\n</blockquote>\n<ol start=\"2\">\n<li><code>BaseType_t</code>:这是该架构最高效的数据类型(取决于CPU是多少位的架构)<ul>\n<li><code>BaseType_t</code>通常用作简单的返回值的类型，还有逻辑值，比如 <strong>pdTRUE&#x2F;pdFALSE</strong></li>\n</ul>\n</li>\n</ol>\n<h5 id=\"变量名\"><a href=\"#变量名\" class=\"headerlink\" title=\"变量名\"></a>变量名</h5><p>变量名的前缀 对应其类型 如：<code>pcName</code> (代表着他是一个指向char类型的指针p)</p>\n<table>\n<thead>\n<tr>\n<th><strong>变量名前缀</strong></th>\n<th><strong>含义</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>c</td>\n<td>char</td>\n</tr>\n<tr>\n<td>s</td>\n<td>int16_t，short</td>\n</tr>\n<tr>\n<td>l</td>\n<td>int32_t，long</td>\n</tr>\n<tr>\n<td>x</td>\n<td>BaseType_t， 其他非标准的类型：结构体、task handle、queue handle等</td>\n</tr>\n<tr>\n<td>u</td>\n<td>unsigned</td>\n</tr>\n<tr>\n<td>p</td>\n<td>指针</td>\n</tr>\n<tr>\n<td>uc</td>\n<td>uint8_t，unsigned char</td>\n</tr>\n<tr>\n<td>pc</td>\n<td>char指针</td>\n</tr>\n</tbody></table>\n<h5 id=\"函数名\"><a href=\"#函数名\" class=\"headerlink\" title=\"函数名\"></a>函数名</h5><p>函数名的前缀有2部分：返回值类型、在哪个文件定义。</p>\n<table>\n<thead>\n<tr>\n<th><strong>函数名前缀</strong></th>\n<th><strong>含义</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>v<span style=\"font-weight:bold;\">Task</span>PrioritySet</td>\n<td>返回值类型：void 在<code>task.c</code>中定义</td>\n</tr>\n<tr>\n<td>x<span style=\"font-weight:bold;\">Queue</span>Receive</td>\n<td>返回值类型：BaseType_t 在<code>queue.c</code>中定义</td>\n</tr>\n<tr>\n<td>pv<span style=\"font-weight:bold;\">Timer</span>GetTimerID</td>\n<td>返回值类型：pointer to void 在<code>tmer.c</code>中定义</td>\n</tr>\n</tbody></table>\n<h5 id=\"宏的名\"><a href=\"#宏的名\" class=\"headerlink\" title=\"宏的名\"></a>宏的名</h5><p>宏的名字是大小，可以添加小写的前缀。前缀是用来表示：宏在<span style=\"font-weight:bold;\">哪个文件</span>中定义。</p>\n<table>\n<thead>\n<tr>\n<th><strong>宏的前缀</strong></th>\n<th><strong>含义：在哪个文件里定义</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>port (比如<span style=\"font-weight:bold;\">port</span>MAX_DELAY)</td>\n<td><code>portable.h</code>或<code>portmacro.h</code></td>\n</tr>\n<tr>\n<td>task (比如<span style=\"font-weight:bold;\">task</span>ENTER_CRITICAL())</td>\n<td><code>task.h</code></td>\n</tr>\n<tr>\n<td>pd (比如<span style=\"font-weight:bold;\">pd</span>TRUE)</td>\n<td><code>projdefs.h</code></td>\n</tr>\n<tr>\n<td>config (比如<span style=\"font-weight:bold;\">config</span>USE_PREEMPTION)</td>\n<td><code>FreeRTOSConfig.h</code></td>\n</tr>\n<tr>\n<td>err (比如<span style=\"font-weight:bold;\">err</span>QUEUE_FULL)</td>\n<td><code>projdefs.h</code></td>\n</tr>\n</tbody></table>\n<p>通用的宏定义如下：</p>\n<table>\n<thead>\n<tr>\n<th><strong>宏</strong></th>\n<th><strong>值</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>pdTRUE</code></td>\n<td>1</td>\n</tr>\n<tr>\n<td><code>pdFALSE</code></td>\n<td>0</td>\n</tr>\n<tr>\n<td><code>pdPASS</code></td>\n<td>1</td>\n</tr>\n<tr>\n<td><code>pdFAIL</code></td>\n<td>0</td>\n</tr>\n</tbody></table>\n<h3 id=\"内存管理\"><a href=\"#内存管理\" class=\"headerlink\" title=\"内存管理\"></a>内存管理</h3><blockquote>\n<p> FreeRTOS中内存管理的接口函数为：<code>pvPortMalloc</code> 、<code>vPortFree</code>，对应于C库的<code>malloc</code>、<code>free</code>。 文件在<code>FreeRTOS/Source/portable/MemMang</code>下，它也是放在<code>portable目录</code>下，表示你可以提供自己的函数。</p>\n<p>源码中默认提供了5个文件，对应内存管理的5种方法。</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th><strong>文件</strong></th>\n<th><strong>优点</strong></th>\n<th><strong>缺点</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>heap_1.c</code></td>\n<td>分配简单，时间确定</td>\n<td>只分配、<span style=\"color:#FF0000;\">不回收</span></td>\n</tr>\n<tr>\n<td><code>heap_2.c</code></td>\n<td>动态分配、最佳匹配</td>\n<td><span style=\"color:#FF0000;\">碎片</span>、时间不定</td>\n</tr>\n<tr>\n<td><code>heap_3.c</code></td>\n<td>调用<span style=\"color:#FF3333;\">标准库</span>函数</td>\n<td><span style=\"color:#FF0000;\">速度慢</span>、时间不定</td>\n</tr>\n<tr>\n<td><code>heap_4.c</code>(常用)</td>\n<td>相邻空闲内存可合并</td>\n<td>可解决碎片问题、时间不定</td>\n</tr>\n<tr>\n<td><code>heap_5.c</code></td>\n<td>在heap_4基础上支持分隔的内存块</td>\n<td>可解决碎片问题、时间不定</td>\n</tr>\n</tbody></table>\n<h4 id=\"Heap相关的函数\"><a href=\"#Heap相关的函数\" class=\"headerlink\" title=\"Heap相关的函数\"></a>Heap相关的函数</h4><h5 id=\"分配、释放内存\"><a href=\"#分配、释放内存\" class=\"headerlink\" title=\"分配、释放内存\"></a>分配、释放内存</h5><p>函数原型：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> * <span class=\"title function_\">pvPortMalloc</span><span class=\"params\">( <span class=\"type\">size_t</span> xWantedSize )</span>;</span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">vPortFree</span><span class=\"params\">( <span class=\"type\">void</span> * pv )</span>;</span><br></pre></td></tr></table></figure>\n\n<p>作用：分配内存、释放内存。</p>\n<p>如果分配内存不成功，则返回值为NULL。</p>\n<h5 id=\"检测剩余多少空闲内存\"><a href=\"#检测剩余多少空闲内存\" class=\"headerlink\" title=\"检测剩余多少空闲内存\"></a>检测剩余多少空闲内存</h5><p>函数原型：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">size_t</span> <span class=\"title function_\">xPortGetFreeHeapSize</span><span class=\"params\">( <span class=\"type\">void</span> )</span>;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>当前还有多少空闲内存，这函数可以用来优化内存的使用情况。比如当所有内核对象都分配好后，执行此函数返回2000，那么<code>configTOTAL_HEAP_SIZE</code>就可减小2000。</p>\n</blockquote>\n<p>注意：在heap_3中无法使用。</p>\n<h5 id=\"获取空闲内存容量的最小值\"><a href=\"#获取空闲内存容量的最小值\" class=\"headerlink\" title=\"获取空闲内存容量的最小值\"></a>获取空闲内存容量的最小值</h5><p>函数原型：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">size_t</span> <span class=\"title function_\">xPortGetMinimumEverFreeHeapSize</span><span class=\"params\">( <span class=\"type\">void</span> )</span>;</span><br></pre></td></tr></table></figure>\n\n<p>返回：程序运行过程中，空闲内存容量的最小值。</p>\n<p>注意：只有heap_4、heap_5支持此函数。</p>\n<h5 id=\"malloc失败的钩子函数\"><a href=\"#malloc失败的钩子函数\" class=\"headerlink\" title=\"malloc失败的钩子函数\"></a><code>malloc失败的钩子函数</code></h5><p>在pvPortMalloc函数内部：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> * <span class=\"title function_\">pvPortMalloc</span><span class=\"params\">( <span class=\"type\">size_t</span> xWantedSize )</span>vPortDefineHeapRegions</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ......</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"keyword\">if</span> ( configUSE_MALLOC_FAILED_HOOK == 1 )</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>( pvReturn == <span class=\"literal\">NULL</span> )</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">extern</span> <span class=\"type\">void</span> <span class=\"title function_\">vApplicationMallocFailedHook</span><span class=\"params\">( <span class=\"type\">void</span> )</span>;</span><br><span class=\"line\">                vApplicationMallocFailedHook();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> pvReturn;        </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>所以，如果想使用这个钩子函数：</p>\n<ul>\n<li>在<code>FreeRTOSConfig.h</code>中，把<code>configUSE_MALLOC_FAILED_HOOK</code>定义为1</li>\n<li>提供<code>vApplicationMallocFailedHook</code>函数</li>\n<li><code>pvPortMalloc</code>失败时，才会调用此函数</li>\n</ul>\n<h3 id=\"任务管理\"><a href=\"#任务管理\" class=\"headerlink\" title=\"任务管理\"></a>任务管理</h3><h4 id=\"任务创建与删除\"><a href=\"#任务创建与删除\" class=\"headerlink\" title=\"任务创建与删除\"></a>任务创建与删除</h4><h5 id=\"什么是任务\"><a href=\"#什么是任务\" class=\"headerlink\" title=\"什么是任务\"></a>什么是任务</h5><p>在FreeRTOS中，任务就是一个函数，原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">ATaskFunction</span><span class=\"params\">( <span class=\"type\">void</span> *pvParameters )</span>;</span><br></pre></td></tr></table></figure>\n\n<p>要注意的是：</p>\n<ul>\n<li>这个函数不能返回</li>\n<li>同一个函数，可以用来创建多个任务；换句话说，多个任务可以运行同一个函数</li>\n<li>函数内部，尽量使用局部变量：<ul>\n<li>每个任务都有自己的栈</li>\n<li>每个任务运行这个函数时<ul>\n<li>任务A的局部变量放在任务A的栈里、任务B的局部变量放在任务B的栈里</li>\n<li>不同任务的局部变量，有自己的副本</li>\n</ul>\n</li>\n<li>函数使用全局变量、静态变量的话<ul>\n<li>只有一个副本：多个任务使用的是同一个副本</li>\n<li>要防止冲突(后续会讲) 下面是一个示例：</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">ATaskFunction</span><span class=\"params\">( <span class=\"type\">void</span> *pvParameters )</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"comment\">/* 对于不同的任务，局部变量放在任务的栈里，有各自的副本 */</span></span><br><span class=\"line\">\t<span class=\"type\">int32_t</span> lVariableExample = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t</span><br><span class=\"line\">    <span class=\"comment\">/* 任务函数通常实现为一个无限循环 */</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>( ;; )</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">/* 任务的代码 */</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* 如果程序从循环中退出，一定要使用vTaskDelete删除自己</span></span><br><span class=\"line\"><span class=\"comment\">     * NULL表示删除的是自己</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">\tvTaskDelete( <span class=\"literal\">NULL</span> );</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/* 程序不会执行到这里, 如果执行到这里就出错了 */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"创建任务\"><a href=\"#创建任务\" class=\"headerlink\" title=\"创建任务\"></a>创建任务</h5><p>创建任务时使用的函数如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BaseType_t <span class=\"title function_\">xTaskCreate</span><span class=\"params\">( TaskFunction_t pxTaskCode, <span class=\"comment\">// 函数指针, 任务函数</span></span></span><br><span class=\"line\"><span class=\"params\">                        <span class=\"type\">const</span> <span class=\"type\">char</span> * <span class=\"type\">const</span> pcName, <span class=\"comment\">// 任务的名字</span></span></span><br><span class=\"line\"><span class=\"params\">                        <span class=\"type\">const</span> configSTACK_DEPTH_TYPE usStackDepth, <span class=\"comment\">// 栈大小,单位为word,10表示40字节</span></span></span><br><span class=\"line\"><span class=\"params\">                        <span class=\"type\">void</span> * <span class=\"type\">const</span> pvParameters, <span class=\"comment\">// 调用任务函数时传入的参数</span></span></span><br><span class=\"line\"><span class=\"params\">                        UBaseType_t uxPriority,    <span class=\"comment\">// 优先级</span></span></span><br><span class=\"line\"><span class=\"params\">                        TaskHandle_t * <span class=\"type\">const</span> pxCreatedTask )</span>; <span class=\"comment\">// 任务句柄, 以后使用它来操作这个任务</span></span><br></pre></td></tr></table></figure>\n\n<p>参数说明：</p>\n<table>\n<thead>\n<tr>\n<th><strong>参数</strong></th>\n<th><strong>描述</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>pvTaskCode</td>\n<td>函数指针，任务对应的 C 函数。任务应该永远不退出，或者在退出时调用 “<code>vTaskDelete(NULL)</code>“。</td>\n</tr>\n<tr>\n<td>pcName</td>\n<td>任务的名称，仅用于调试目的，FreeRTOS 内部不使用。pcName 的长度为 <code>configMAX_TASK_NAME_LEN</code>。</td>\n</tr>\n<tr>\n<td>usStackDepth</td>\n<td>每个任务都有自己的栈，usStackDepth 指定了栈的大小，单位为 word。例如，如果传入 100，表示栈的大小为 100 word，即 400 字节。最大值为 uint16_t 的最大值。确定栈的大小并不容易，通常是根据估计来设定。精确的办法是查看反汇编代码。</td>\n</tr>\n<tr>\n<td>pvParameters</td>\n<td>调用 pvTaskCode 函数指针时使用的参数：<code>pvTaskCode(pvParameters)</code>。</td>\n</tr>\n<tr>\n<td>uxPriority</td>\n<td>任务的优先级范围为 0~(<code>configMAX_PRIORITIES – 1</code>)。数值越小，优先级越低。如果传入的值过大，<code>xTaskCreate </code>会将其调整为 (<code>configMAX_PRIORITIES – 1</code>)。</td>\n</tr>\n<tr>\n<td>pxCreatedTask</td>\n<td>用于保存 xTaskCreate 的输出结果，即任务的句柄（task handle）。如果以后需要对该任务进行操作，如修改优先级，则需要使用此句柄。如果不需要使用该句柄，可以传入 NULL。</td>\n</tr>\n<tr>\n<td>返回值</td>\n<td>成功时返回 pdPASS，失败时返回 <code>errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY</code>（失败原因是内存不足）。请注意，文档中提到的失败返回值是 pdFAIL 是不正确的。pdFAIL 的值为 0，而 <code>errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY</code> 的值为 -1。</td>\n</tr>\n</tbody></table>\n<p>使用静态分配内存的函数如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TaskHandle_t <span class=\"title function_\">xTaskCreateStatic</span> <span class=\"params\">( </span></span><br><span class=\"line\"><span class=\"params\">    TaskFunction_t pxTaskCode,   <span class=\"comment\">// 函数指针, 任务函数</span></span></span><br><span class=\"line\"><span class=\"params\">    <span class=\"type\">const</span> <span class=\"type\">char</span> * <span class=\"type\">const</span> pcName,   <span class=\"comment\">// 任务的名字</span></span></span><br><span class=\"line\"><span class=\"params\">    <span class=\"type\">const</span> <span class=\"type\">uint32_t</span> ulStackDepth, <span class=\"comment\">// 栈大小,单位为word,10表示40字节</span></span></span><br><span class=\"line\"><span class=\"params\">    <span class=\"type\">void</span> * <span class=\"type\">const</span> pvParameters,   <span class=\"comment\">// 调用任务函数时传入的参数</span></span></span><br><span class=\"line\"><span class=\"params\">    UBaseType_t uxPriority,      <span class=\"comment\">// 优先级</span></span></span><br><span class=\"line\"><span class=\"params\">    StackType_t * <span class=\"type\">const</span> puxStackBuffer, <span class=\"comment\">// 静态分配的栈，就是一个buffer</span></span></span><br><span class=\"line\"><span class=\"params\">    StaticTask_t * <span class=\"type\">const</span> pxTaskBuffer <span class=\"comment\">// 静态分配的任务结构体的指针，用它来操作这个任务</span></span></span><br><span class=\"line\"><span class=\"params\">)</span>;</span><br></pre></td></tr></table></figure>\n\n<p>相比于使用动态分配内存创建任务的函数，最后2个参数不一样：</p>\n<table>\n<thead>\n<tr>\n<th><strong>参数</strong></th>\n<th><strong>描述</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>pvTaskCode</td>\n<td>函数指针，可以简单地认为任务就是一个C函数。 它稍微特殊一点：永远不退出，或者退出时要调用”<code>vTaskDelete(NULL)</code>“</td>\n</tr>\n<tr>\n<td>pcName</td>\n<td>任务的名字，FreeRTOS内部不使用它，仅仅起调试作用。 长度为：<code>configMAX_TASK_NAME_LEN</code></td>\n</tr>\n<tr>\n<td>usStackDepth</td>\n<td>每个任务都有自己的栈，这里指定栈大小。 单位是word，比如传入100，表示栈大小为100 word，也就是400字节。 最大值为uint16_t的最大值。 怎么确定栈的大小，并不容易，很多时候是估计。 精确的办法是看反汇编码。</td>\n</tr>\n<tr>\n<td>pvParameters</td>\n<td>调用pvTaskCode函数指针时用到：pvTaskCode(pvParameters)</td>\n</tr>\n<tr>\n<td>uxPriority</td>\n<td>优先级范围：0~(<code>configMAX_PRIORITIES – 1</code>) 数值越小优先级越低， 如果传入过大的值，<code>xTaskCreate</code>会把它调整为(<code>configMAX_PRIORITIES – 1</code>)</td>\n</tr>\n<tr>\n<td>puxStackBuffer</td>\n<td>静态分配的栈内存，比如可以传入一个数组， 它的大小是<code>usStackDepth*4</code>。</td>\n</tr>\n<tr>\n<td>pxTaskBuffer</td>\n<td>静态分配的<code>StaticTask_t</code>结构体的指针</td>\n</tr>\n<tr>\n<td>返回值</td>\n<td>成功：返回任务句柄； 失败：NULL</td>\n</tr>\n</tbody></table>\n<h4 id=\"任务栈大小估算\"><a href=\"#任务栈大小估算\" class=\"headerlink\" title=\"任务栈大小估算\"></a>任务栈大小估算</h4><p>任务栈空间包含</p>\n<ul>\n<li>返回地址<code>LR</code>与其他寄存器：可以理解为<span style=\"color:#FF0000;\">函数调用深度</span></li>\n<li>局部变量：如<code>char buff[1000]</code> 直接看类型 此处则可以算1个</li>\n<li>保留现场：可以理解为固定16个寄存器 即<span style=\"color:#FF3333;\">16 * 4 &#x3D; 64b</span></li>\n</ul>\n<blockquote>\n<p>公式如下：</p>\n<ul>\n<li><p>（n层调用 * 36） + 局部变量 + 64b</p>\n</li>\n<li><p>例如：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509142214793.png\" alt=\"image-20250914221448446\"></p>\n</li>\n</ul>\n</blockquote>\n<h4 id=\"使用任务参数\"><a href=\"#使用任务参数\" class=\"headerlink\" title=\"使用任务参数\"></a>使用任务参数</h4><p>我们说过，多个任务可以使用同一个函数，怎么体现它们的差别？</p>\n<ul>\n<li>栈不同</li>\n<li>创建任务时可以传入不同的参数</li>\n</ul>\n<p>我们创建2个任务，使用同一个函数，但是在LCD上打印不一样的信息。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span>&#123;</span></span><br><span class=\"line\">    <span class=\"type\">int</span> x;</span><br><span class=\"line\">    <span class=\"type\">int</span> y;</span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">char</span> *str;</span><br><span class=\"line\">&#125;DisplayInfo;</span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">vTaskFunction</span><span class=\"params\">( <span class=\"type\">void</span> *pvParameters )</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tDisplayInfo *info = pvParameters;</span><br><span class=\"line\">\t<span class=\"type\">uint32_t</span> cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"type\">uint32_t</span> len;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">/* 任务函数的主体一般都是无限循环 */</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>( ;; )</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">/* 打印任务的信息 */</span></span><br><span class=\"line\">\t\tlen = LCD_PrintString(info-&gt;x, info-&gt;y, info-&gt;str);</span><br><span class=\"line\">\t\tLCD_PrintSignedVal(len+<span class=\"number\">1</span>, info-&gt;y, cnt++);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tmdelay(<span class=\"number\">500</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上述代码中的info来自参数pvParameters，pvParameters来自哪里？创建任务时传入的。</p>\n<p>代码如下：</p>\n<ul>\n<li>使用xTaskCreate创建任务时，第4个参数就是pvParameters</li>\n<li>不同的任务，pvParameters不一样</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DisplayInfo g_Task1Info =&#123;<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"string\">&quot;task1&quot;</span>&#125;;</span><br><span class=\"line\">DisplayInfo g_Task2Info =&#123;<span class=\"number\">3</span>,<span class=\"number\">0</span>,<span class=\"string\">&quot;task2&quot;</span>&#125;;</span><br><span class=\"line\">DisplayInfo g_Task3Info =&#123;<span class=\"number\">6</span>,<span class=\"number\">0</span>,<span class=\"string\">&quot;task3&quot;</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 使用同一个函数创建不同的任务 */</span></span><br><span class=\"line\">  xTaskCreate(LcdPrintTask, <span class=\"string\">&quot;task1&quot;</span>, <span class=\"number\">128</span>, &amp;g_Task1Info, osPriorityNormal, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">  xTaskCreate(LcdPrintTask, <span class=\"string\">&quot;task2&quot;</span>, <span class=\"number\">128</span>, &amp;g_Task2Info, osPriorityNormal, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">  xTaskCreate(LcdPrintTask, <span class=\"string\">&quot;task3&quot;</span>, <span class=\"number\">128</span>, &amp;g_Task3Info, osPriorityNormal, <span class=\"literal\">NULL</span>);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"任务的删除\"><a href=\"#任务的删除\" class=\"headerlink\" title=\"任务的删除\"></a>任务的删除</h4><p>删除任务时使用的函数如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">vTaskDelete</span><span class=\"params\">( TaskHandle_t xTaskToDelete )</span>;</span><br></pre></td></tr></table></figure>\n\n<p>参数说明：</p>\n<table>\n<thead>\n<tr>\n<th><strong>参数</strong></th>\n<th><strong>描述</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>pvTaskCode</td>\n<td>任务句柄，使用xTaskCreate创建任务时可以得到一个句柄。 也可传入NULL，这表示删除自己。</td>\n</tr>\n</tbody></table>\n<p>怎么删除任务？举个不好的例子：</p>\n<ul>\n<li>自杀：<code>vTaskDelete(NULL)</code></li>\n<li>被杀：别的任务执行<code>vTaskDelete(pvTaskCode)</code>，<code>pvTaskCode</code>是自己的句柄</li>\n<li>杀人：执行<code>vTaskDelete(pvTaskCode)</code>，<code>pvTaskCode</code>是别的任务的句柄</li>\n</ul>\n<h4 id=\"任务管理与调度机制\"><a href=\"#任务管理与调度机制\" class=\"headerlink\" title=\"任务管理与调度机制\"></a>任务管理与调度机制</h4><h5 id=\"调度机制\"><a href=\"#调度机制\" class=\"headerlink\" title=\"调度机制\"></a>调度机制</h5><blockquote>\n<ul>\n<li>同等优先级的任务 轮流运行</li>\n<li>最高优先级的任务先运行<ul>\n<li>高优先级的任务未运行完，低优先级任务无法运行</li>\n<li>一旦高优先级任务就绪 马上运行</li>\n<li>最高优先级的任务有多个 他们轮流运行</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509151548547.png\" alt=\"img\"></p>\n<h5 id=\"任务管理-1\"><a href=\"#任务管理-1\" class=\"headerlink\" title=\"任务管理\"></a>任务管理</h5><p>任务的切换通过链表操作进行切换 RTOS会创建3个链表 分别是就绪链表ReadyList、阻塞链表DelayTaskList、挂起链表</p>\n<ul>\n<li><p>先在优先级数组中按下标从大到小遍历，使用任务创建函数<span style=\"color:#33FFFF;\">本质其实是在对应优先级数组中创建TCB结构体，并且会有一个全局指针——当前执行TCB结构体pxCurrentTCB</span>，这就说明了为什么同等优先级下，最后创建的任务先运行（因为指针最终指向了最后一个任务链表，启动调度器后，开始运行）</p>\n</li>\n<li><p>当调用<code>vTaskDelay</code>后会将当前任务链表丢到阻塞链表上，并根据<code>vTaskDelay</code>的参数等待<code>Tick中断</code>判断到达时间后，该任务链表才能再次回到原先链表上</p>\n</li>\n<li><p>当任务调用<code>vTaskSuspend</code>后 当前任务会被丢到挂起链表，此任务只有调用<code>vTaskResume</code>才能回到原先链表，不能通过<code>Tick中断</code>回归</p>\n</li>\n</ul>\n<blockquote>\n<p>Tick中断是什么？他又做些什么？</p>\n<ul>\n<li><p>Tick中断来源于</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509151600535.png\" alt=\"image-20250915160032344\"></p>\n</li>\n<li><p>Tick中断做什么？</p>\n<ol>\n<li>有个计数器count，count一直执行++</li>\n<li>判断DelayTaskList里任务是否可以恢复（可恢复则将其丢到ReadyList）</li>\n<li>发起调度（遍历优先级数组，改变pxCurrentTCB指针指向）</li>\n</ol>\n</li>\n</ul>\n</blockquote>\n<h5 id=\"空闲任务\"><a href=\"#空闲任务\" class=\"headerlink\" title=\"空闲任务\"></a>空闲任务</h5><p>空闲任务是Freertos启动调度器时 会自动创建的一个最低优先级的任务<code>prvIdleTask</code></p>\n<ul>\n<li>负责清理用户的自杀任务 如<code>vTaskDelete(NULL)</code>的内存释放</li>\n<li>由于优先级最低 所以当用户任务不释放CPU时，就会导致空闲任务不会运行，因而<code>vTaskDelete(NULL)</code>得不到释放</li>\n<li>因此尽量不要使用死延时，改用<code>vTaskDelay</code>释放CPU 或者不使用自杀函数<code>vTaskDelete(NULL)</code></li>\n</ul>\n<blockquote>\n<p>此外 空闲任务中还有提供钩子函数 可以方便我们在里面打印调试信息</p>\n<p>注意每个任务都要使用while(1)进行死循环</p>\n<ul>\n<li>如果有一个任务没有则会触发任务退出错误中断<code>prvTaskExitError</code></li>\n<li><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509151634028.png\" alt=\"image-20250915163446773\"></li>\n</ul>\n</blockquote>\n<h3 id=\"同步与互斥\"><a href=\"#同步与互斥\" class=\"headerlink\" title=\"同步与互斥\"></a>同步与互斥</h3><h4 id=\"同步与互斥的概念\"><a href=\"#同步与互斥的概念\" class=\"headerlink\" title=\"同步与互斥的概念\"></a>同步与互斥的概念</h4><p>一句话理解同步与互斥：我等你用完厕所，我再用厕所。</p>\n<ul>\n<li>什么叫同步？就是：哎哎哎，我正在用厕所，你等会。 </li>\n<li>什么叫互斥？就是：哎哎哎，我正在用厕所，你不能进来。</li>\n</ul>\n<p>同步与互斥经常放在一起讲，是因为它们之的关系很大，“互斥”操作可以使用“同步”来实现。我“等”你用完厕所，我再用厕所。这不就是用“同步”来实现“互斥”吗？</p>\n<p>再举一个例子。在团队活动里，同事A先写完报表，经理B才能拿去向领导汇报。经理B必须等同事A完成报表，AB之间有依赖，B必须放慢脚步，被称为同步。在团队活动中，同事A已经使用会议室了，经理B也想使用，即使经理B是领导，他也得等着，这就叫互斥。经理B跟同事A说：你用完会议室就提醒我。这就是使用”同步”来实现”互斥”。</p>\n<p>有时候看代码更容易理解，伪代码如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span>  抢厕所(<span class=\"type\">void</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (有人在用) 我眯一会;</span><br><span class=\"line\">  用厕所;</span><br><span class=\"line\">  喂，醒醒，有人要用厕所吗;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>假设有A、B两人早起抢厕所，A先行一步占用了；B慢了一步，于是就眯一会；当A用完后叫醒B，B也就愉快地上厕所了。</p>\n<p>在这个过程中，A、B是互斥地访问“厕所”，“厕所”被称之为临界资源。我们使用了“休眠-唤醒”的同步机制实现了“临界资源”的“互斥访问”。</p>\n<p>同一时间只能有一个人使用的资源，被称为临界资源。比如任务A、B都要使用串口来打印，串口就是临界资源。如果A、B同时使用串口，那么打印出来的信息就是A、B混杂，无法分辨。所以使用串口时，应该是这样：A用完，B再用；B用完，A再用</p>\n<h4 id=\"各类方法的对比\"><a href=\"#各类方法的对比\" class=\"headerlink\" title=\"各类方法的对比\"></a>各类方法的对比</h4><p>能实现同步、互斥的内核方法有：任务通知(task notification)、队列(queue)、事件组(event group)、信号量(semaphoe)、互斥量(mutex)。</p>\n<p>它们都有类似的操作方法：获取&#x2F;释放、阻塞&#x2F;唤醒、超时。比如：</p>\n<ul>\n<li>任务A获取资源，用完后任务A释放资源</li>\n<li>任务A获取不到资源则阻塞，任务B释放资源并把任务A唤醒</li>\n<li>任务A获取不到资源则阻塞，并定个闹钟；A要么超时返回，要么在这段时间内因为任务B释放资源而被唤醒。</li>\n</ul>\n<p>这些内核对象五花八门，记不住怎么办？我也记不住，通过对比的方法来区分它们。</p>\n<ul>\n<li>能否传信息？还是只能传递状态？</li>\n<li>为众生（所有任务都可以使用）？只为你（只能指定任务使用）？</li>\n<li>我生产，你们消费？</li>\n<li>我上锁，只能由我开锁</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th><strong>内核对象</strong></th>\n<th><strong>生产者</strong></th>\n<th><strong>消费者</strong></th>\n<th><strong>数据&#x2F;状态</strong></th>\n<th><strong>说明</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>队列</td>\n<td>ALL</td>\n<td>ALL</td>\n<td>数据：若干个数据 谁都可以往队列里扔数据， 谁都可以从队列里读数据</td>\n<td>用来传递数据， 发送者、接收者无限制， 一个数据只能唤醒一个接收者</td>\n</tr>\n<tr>\n<td>事件组</td>\n<td>ALL</td>\n<td>ALL</td>\n<td>多个位：或、与 谁都可以设置(生产)多个位， 谁都可以等待某个位、若干个位</td>\n<td>用来传递事件， 可以是N个事件， 发送者、接受者无限制， 可以唤醒多个接收者：像广播</td>\n</tr>\n<tr>\n<td>信号量</td>\n<td>ALL</td>\n<td>ALL</td>\n<td>数量：0~n 谁都可以增加一个数量， 谁都可消耗一个数量</td>\n<td>用来维持资源的个数， 生产者、消费者无限制， 1个资源只能唤醒1个接收者</td>\n</tr>\n<tr>\n<td>任务通知</td>\n<td>ALL</td>\n<td>只有我</td>\n<td>数据、状态都可以传输， 使用任务通知时， 必须指定接受者</td>\n<td>N对1的关系： 发送者无限制， 接收者只能是这个任务</td>\n</tr>\n<tr>\n<td>互斥量</td>\n<td>只能A开锁</td>\n<td>A上锁</td>\n<td>位：0、1 我上锁：1变为0， 只能由我开锁：0变为1</td>\n<td>就像一个空厕所， 谁使用谁上锁， 也只能由他开锁</td>\n</tr>\n</tbody></table>\n<p>使用图形对比如下：</p>\n<ul>\n<li>队列：<ul>\n<li>里面可以放任意数据，可以放多个数据</li>\n<li>任务、ISR都可以放入数据；任务、ISR都可以从中读出数据</li>\n</ul>\n</li>\n<li>事件组：<ul>\n<li>一个事件用一bit表示，1表示事件发生了，0表示事件没发生</li>\n<li>可以用来表示事件、事件的组合发生了，不能传递数据</li>\n<li>有广播效果：事件或事件的组合发生了，等待它的多个任务都会被唤醒</li>\n</ul>\n</li>\n<li>信号量：<ul>\n<li>核心是”计数值”</li>\n<li>任务、ISR释放信号量时让计数值加1</li>\n<li>任务、ISR获得信号量时，让计数值减1</li>\n</ul>\n</li>\n<li>任务通知：<ul>\n<li>核心是任务的TCB里的数值</li>\n<li>会被覆盖</li>\n<li>发通知给谁？必须指定接收任务</li>\n<li>只能由接收任务本身获取该通知</li>\n</ul>\n</li>\n<li>互斥量：<ul>\n<li>数值只有0或1</li>\n<li>谁获得互斥量，就必须由谁释放同一个互斥量</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509151740912.png\" alt=\"img\"></p>\n<blockquote>\n<p>为何要引用这些机制呢？</p>\n<ul>\n<li>原本逻辑可以采用全局变量来进行传递信息，但在RTOS下，可能还未来得及改变全局变量的值就被切换到其他任务，这样就会发生全局变量未及时更新的问题</li>\n<li>引入事件阻塞与唤醒大大提高了CPU的利用率<ul>\n<li>当任务A计数1s，任务B负责打印任务A的最终计数值，就不会出现A运行，B也运行，而是等待A运行完后通知任务B，或大概估算任务A结束的时间，让B阻塞这么多的时间，这样就实现了整个时间轴都是任务A在运行</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<h3 id=\"队列\"><a href=\"#队列\" class=\"headerlink\" title=\"队列\"></a>队列</h3><h4 id=\"队列的本质\"><a href=\"#队列的本质\" class=\"headerlink\" title=\"队列的本质\"></a>队列的本质</h4><p>队列中，数据的读写就是环形缓冲区，在这个基础上增加了互斥措施、阻塞-唤醒机制</p>\n<ul>\n<li>如果这个队列不传输数据，只调整“数据个数”，他就是信号量（semaphore）</li>\n<li>如果信号量中，限定“数据个数”最大值为1，他就是互斥量（mutex）</li>\n</ul>\n<h4 id=\"传输数据的两种方法\"><a href=\"#传输数据的两种方法\" class=\"headerlink\" title=\"传输数据的两种方法\"></a>传输数据的两种方法</h4><p>使用队列传输数据时有两种方法：</p>\n<ul>\n<li>拷贝：把数据、把变量的值复制进队列里</li>\n<li>引用：把数据、把变量的地址复制进队列里</li>\n</ul>\n<p>FreeRTOS使用拷贝值的方法，这更简单：</p>\n<ul>\n<li>局部变量的值可以发送到队列中，后续即使函数退出、局部变量被回收，也不会影响队列中的数据</li>\n<li>无需分配buffer来保存数据，队列中有buffer</li>\n<li>局部变量可以马上再次使用</li>\n<li>发送任务、接收任务解耦：接收任务不需要知道这数据是谁的、也不需要发送任务来释放数据</li>\n<li>如果数据实在太大，你还是可以使用队列传输它的地址</li>\n<li>队列的空间有FreeRTOS内核分配，无需任务操心</li>\n<li>对于有内存保护功能的系统，如果队列使用引用方法，也就是使用地址，必须确保双方任务对这个地址都有访问权限。使用拷贝方法时，则无此限制：内核有足够的权限，把数据复制进队列、再把数据复制出队列。</li>\n</ul>\n<h4 id=\"队列的阻塞访问\"><a href=\"#队列的阻塞访问\" class=\"headerlink\" title=\"队列的阻塞访问\"></a>队列的阻塞访问</h4><p>只要知道队列的句柄，谁都可以读、写该队列。任务、ISR都可读、写队列。可以多个任务读写队列。</p>\n<p>任务读写队列时，简单地说：如果读写不成功，则阻塞；可以指定超时时间。口语化地说，就是可以定个闹钟：如果能读写了就马上进入就绪态，否则就阻塞直到超时。</p>\n<p>某个任务读队列时，如果队列没有数据，则该任务可以进入阻塞状态：还可以指定阻塞的时间。如果队列有数据了，则该阻塞的任务会变为就绪态。如果一直都没有数据，则时间到之后它也会进入就绪态。</p>\n<p>既然读取队列的任务个数没有限制，那么当多个任务读取空队列时，这些任务都会进入阻塞状态：有多个任务在等待同一个队列的数据。当队列中有数据时，哪个任务会进入就绪态？</p>\n<ul>\n<li>优先级最高的任务</li>\n<li>如果大家的优先级相同，那等待时间最久的任务会进入就绪态</li>\n</ul>\n<p>跟读队列类似，一个任务要写队列时，如果队列满了，该任务也可以进入阻塞状态：还可以指定阻塞的时间。如果队列有空间了，则该阻塞的任务会变为就绪态。如果一直都没有空间，则时间到之后它也会进入就绪态。</p>\n<p>既然写队列的任务个数没有限制，那么当多个任务写”满队列”时，这些任务都会进入阻塞状态：有多个任务在等待同一个队列的空间。当队列中有空间时，哪个任务会进入就绪态？</p>\n<ul>\n<li>优先级最高的任务</li>\n<li>如果大家的优先级相同，那等待时间最久的任务会进入就绪态</li>\n</ul>\n<h4 id=\"队列函数\"><a href=\"#队列函数\" class=\"headerlink\" title=\"队列函数\"></a>队列函数</h4><h5 id=\"创建\"><a href=\"#创建\" class=\"headerlink\" title=\"创建\"></a>创建</h5><p>队列的创建有两种方法：动态分配内存、静态分配内存，</p>\n<ul>\n<li>动态分配内存：xQueueCreate，队列的内存在函数内部动态分配</li>\n</ul>\n<p>函数原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">QueueHandle_t <span class=\"title function_\">xQueueCreate</span><span class=\"params\">( UBaseType_t uxQueueLength, UBaseType_t uxItemSize )</span>;</span><br></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th><strong>参数</strong></th>\n<th><strong>说明</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>uxQueueLength</code></td>\n<td>队列长度，最多能存放多少个数据(item)</td>\n</tr>\n<tr>\n<td><code>uxItemSize</code></td>\n<td>每个数据(item)的大小：以字节为单位（可以定义一个结构体存放，然后sizeof(结构体)）</td>\n</tr>\n<tr>\n<td>返回值</td>\n<td>非0：成功，返回句柄，以后使用句柄来操作队列 NULL：失败，因为内存不足</td>\n</tr>\n</tbody></table>\n<ul>\n<li>静态分配内存：<code>xQueueCreateStatic</code>，队列的内存要事先分配好</li>\n</ul>\n<p>函数原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">QueueHandle_t <span class=\"title function_\">xQueueCreateStatic</span><span class=\"params\">(*</span></span><br><span class=\"line\"><span class=\"params\">              \t\tUBaseType_t uxQueueLength,*</span></span><br><span class=\"line\"><span class=\"params\">              \t\tUBaseType_t uxItemSize,*</span></span><br><span class=\"line\"><span class=\"params\">              \t\t<span class=\"type\">uint8_t</span> *pucQueueStorageBuffer,*</span></span><br><span class=\"line\"><span class=\"params\">              \t\tStaticQueue_t *pxQueueBuffer*</span></span><br><span class=\"line\"><span class=\"params\">           \t\t )</span>;</span><br></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th><strong>参数</strong></th>\n<th><strong>说明</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>uxQueueLength</code></td>\n<td>队列长度，最多能存放多少个数据(item)</td>\n</tr>\n<tr>\n<td><code>uxItemSize</code></td>\n<td>每个数据(item)的大小：以字节为单位</td>\n</tr>\n<tr>\n<td><code>pucQueueStorageBuffer</code></td>\n<td>如果uxItemSize非0，<code>pucQueueStorageBuffer</code>必须指向一个uint8_t数组， 此数组大小至少为”uxQueueLength * uxItemSize”</td>\n</tr>\n<tr>\n<td><code>pxQueueBuffer</code></td>\n<td>必须执行一个<code>StaticQueue_t</code>结构体，用来保存队列的数据结构</td>\n</tr>\n<tr>\n<td>返回值</td>\n<td>非0：成功，返回句柄，以后使用句柄来操作队列 NULL：失败，因为<code>pxQueueBuffer</code>为NULL</td>\n</tr>\n</tbody></table>\n<h5 id=\"复位\"><a href=\"#复位\" class=\"headerlink\" title=\"复位\"></a>复位</h5><p>队列刚被创建时，里面没有数据；使用过程中可以调用 <strong>xQueueReset()</strong> 把队列恢复为初始状态，此函数原型为：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*  pxQueue : 复位哪个队列;</span></span><br><span class=\"line\"><span class=\"comment\"> * 返回值: pdPASS(必定成功)</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\">BaseType_t <span class=\"title function_\">xQueueReset</span><span class=\"params\">( QueueHandle_t pxQueue)</span>;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"删除\"><a href=\"#删除\" class=\"headerlink\" title=\"删除\"></a>删除</h5><p>删除队列的函数为 <strong>vQueueDelete()</strong> ，只能删除使用动态方法创建的队列，它会释放内存。原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">vQueueDelete</span><span class=\"params\">( QueueHandle_t xQueue )</span>;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"写队列\"><a href=\"#写队列\" class=\"headerlink\" title=\"写队列\"></a>写队列</h5><p>可以把数据写到队列头部，也可以写到尾部，这些函数有两个版本：在任务中使用、在ISR中使用。函数原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 等同于xQueueSendToBack</span></span><br><span class=\"line\"><span class=\"comment\"> * 往队列尾部写入数据，如果没有空间，阻塞时间为xTicksToWait</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">BaseType_t <span class=\"title function_\">xQueueSend</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">                                QueueHandle_t    xQueue,</span></span><br><span class=\"line\"><span class=\"params\">                                <span class=\"type\">const</span> <span class=\"type\">void</span>       *pvItemToQueue,</span></span><br><span class=\"line\"><span class=\"params\">                                TickType_t       xTicksToWait</span></span><br><span class=\"line\"><span class=\"params\">                            )</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\"> * 往队列尾部写入数据，如果没有空间，阻塞时间为xTicksToWait</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">BaseType_t <span class=\"title function_\">xQueueSendToBack</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">                                QueueHandle_t    xQueue,</span></span><br><span class=\"line\"><span class=\"params\">                                <span class=\"type\">const</span> <span class=\"type\">void</span>       *pvItemToQueue,</span></span><br><span class=\"line\"><span class=\"params\">                                TickType_t       xTicksToWait</span></span><br><span class=\"line\"><span class=\"params\">                            )</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\"> * 往队列尾部写入数据，此函数可以在中断函数中使用，不可阻塞</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">BaseType_t <span class=\"title function_\">xQueueSendToBackFromISR</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">                                      QueueHandle_t xQueue,</span></span><br><span class=\"line\"><span class=\"params\">                                      <span class=\"type\">const</span> <span class=\"type\">void</span> *pvItemToQueue,</span></span><br><span class=\"line\"><span class=\"params\">                                      BaseType_t *pxHigherPriorityTaskWoken</span></span><br><span class=\"line\"><span class=\"params\">                                   )</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\"> * 往队列头部写入数据，如果没有空间，阻塞时间为xTicksToWait</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">BaseType_t <span class=\"title function_\">xQueueSendToFront</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">                                QueueHandle_t    xQueue,</span></span><br><span class=\"line\"><span class=\"params\">                                <span class=\"type\">const</span> <span class=\"type\">void</span>       *pvItemToQueue,</span></span><br><span class=\"line\"><span class=\"params\">                                TickType_t       xTicksToWait</span></span><br><span class=\"line\"><span class=\"params\">                            )</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\"> * 往队列头部写入数据，此函数可以在中断函数中使用，不可阻塞</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">BaseType_t <span class=\"title function_\">xQueueSendFromISR</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">                                      QueueHandle_t xQueue,</span></span><br><span class=\"line\"><span class=\"params\">                                      <span class=\"type\">const</span> <span class=\"type\">void</span> *pvItemToQueue,</span></span><br><span class=\"line\"><span class=\"params\">                                      BaseType_t *pxHigherPriorityTaskWoken</span></span><br><span class=\"line\"><span class=\"params\">                                   )</span>;</span><br></pre></td></tr></table></figure>\n\n<p>这些函数用到的参数是类似的，统一说明如下：</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>xQueue</code></td>\n<td>队列句柄，要写哪个队列</td>\n</tr>\n<tr>\n<td><code>pvItemToQueue</code></td>\n<td>数据指针，这个数据的值会被复制进队列， 复制多大的数据？在创建队列时已经指定了数据大小</td>\n</tr>\n<tr>\n<td><code>xTicksToWait</code></td>\n<td>如果队列满则无法写入新数据，可以让任务进入阻塞状态， <code>xTicksToWait</code>表示阻塞的最大时间(Tick Count)。 如果被设为0，无法写入数据时函数会立刻返回； 如果被设为<code>portMAX_DELAY</code>，则会一直阻塞直到有空间可写</td>\n</tr>\n<tr>\n<td>返回值</td>\n<td>pdPASS：数据成功写入了队列 <code>errQUEUE_FULL</code>：写入失败，因为队列满了。</td>\n</tr>\n</tbody></table>\n<h5 id=\"读队列\"><a href=\"#读队列\" class=\"headerlink\" title=\"读队列\"></a>读队列</h5><p>使用 <strong>xQueueReceive()</strong> 函数读队列，读到一个数据后，队列中该数据会被移除。这个函数有两个版本：在任务中使用、在ISR中使用。函数原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BaseType_t <span class=\"title function_\">xQueueReceive</span><span class=\"params\">( QueueHandle_t xQueue,</span></span><br><span class=\"line\"><span class=\"params\">                          <span class=\"type\">void</span> * <span class=\"type\">const</span> pvBuffer,</span></span><br><span class=\"line\"><span class=\"params\">                          TickType_t xTicksToWait )</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">BaseType_t <span class=\"title function_\">xQueueReceiveFromISR</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">                                    QueueHandle_t    xQueue,</span></span><br><span class=\"line\"><span class=\"params\">                                    <span class=\"type\">void</span>             *pvBuffer,</span></span><br><span class=\"line\"><span class=\"params\">                                    BaseType_t       *pxTaskWoken</span></span><br><span class=\"line\"><span class=\"params\">                                )</span>;</span><br></pre></td></tr></table></figure>\n\n<p>参数说明如下：</p>\n<table>\n<thead>\n<tr>\n<th><strong>参数</strong></th>\n<th><strong>说明</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>xQueue</code></td>\n<td>队列句柄，要读哪个队列</td>\n</tr>\n<tr>\n<td><code>pvBuffer</code></td>\n<td>buffer指针，队列的数据会被复制到这个buffer 复制多大的数据？在创建队列时已经指定了数据大小</td>\n</tr>\n<tr>\n<td><code>xTicksToWait</code></td>\n<td>果队列空则无法读出数据，可以让任务进入阻塞状态， xTicksToWait表示阻塞的最大时间(Tick Count)。 如果被设为0，无法读出数据时函数会立刻返回； 如果被设为portMAX_DELAY，则会一直阻塞直到有数据可写</td>\n</tr>\n<tr>\n<td>返回值</td>\n<td>pdPASS：从队列读出数据入 <code>errQUEUE_EMPTY</code>：读取失败，因为队列空了。</td>\n</tr>\n</tbody></table>\n<h5 id=\"查询\"><a href=\"#查询\" class=\"headerlink\" title=\"查询\"></a>查询</h5><p>可以查询队列中有多少个数据、有多少空余空间。函数原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 返回队列中可用数据的个数</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">UBaseType_t <span class=\"title function_\">uxQueueMessagesWaiting</span><span class=\"params\">( <span class=\"type\">const</span> QueueHandle_t xQueue )</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 返回队列中可用空间的个数</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">UBaseType_t <span class=\"title function_\">uxQueueSpacesAvailable</span><span class=\"params\">( <span class=\"type\">const</span> QueueHandle_t xQueue )</span>;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"覆盖-偷看\"><a href=\"#覆盖-偷看\" class=\"headerlink\" title=\"覆盖&#x2F;偷看\"></a>覆盖&#x2F;偷看</h5><p>当队列长度为1时，可以使用 <strong>xQueueOverwrite()</strong> 或 <strong>xQueueOverwriteFromISR()</strong> 来覆盖数据。</p>\n<p>注意，队列长度必须为1。当队列满时，这些函数会覆盖里面的数据，这也以为着这些函数不会被阻塞。</p>\n<p>函数原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 覆盖队列</span></span><br><span class=\"line\"><span class=\"comment\"> * xQueue: 写哪个队列</span></span><br><span class=\"line\"><span class=\"comment\"> * pvItemToQueue: 数据地址</span></span><br><span class=\"line\"><span class=\"comment\"> * 返回值: pdTRUE表示成功, pdFALSE表示失败</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">BaseType_t <span class=\"title function_\">xQueueOverwrite</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">                           QueueHandle_t xQueue,</span></span><br><span class=\"line\"><span class=\"params\">                           <span class=\"type\">const</span> <span class=\"type\">void</span> * pvItemToQueue</span></span><br><span class=\"line\"><span class=\"params\">                      )</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">BaseType_t <span class=\"title function_\">xQueueOverwriteFromISR</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">                           QueueHandle_t xQueue,</span></span><br><span class=\"line\"><span class=\"params\">                           <span class=\"type\">const</span> <span class=\"type\">void</span> * pvItemToQueue,</span></span><br><span class=\"line\"><span class=\"params\">                           BaseType_t *pxHigherPriorityTaskWoken</span></span><br><span class=\"line\"><span class=\"params\">                      )</span>;</span><br></pre></td></tr></table></figure>\n\n<p>如果想让队列中的数据供多方读取，也就是说读取时不要移除数据，要留给后来人。那么可以使用”窥视”，也就是**xQueuePeek()**或**xQueuePeekFromISR()**。这些函数会从队列中复制出数据，但是不移除数据。这也意味着，如果队列中没有数据，那么”偷看”时会导致阻塞；一旦队列中有数据，以后每次”偷看”都会成功。</p>\n<p>函数原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 偷看队列</span></span><br><span class=\"line\"><span class=\"comment\"> * xQueue: 偷看哪个队列</span></span><br><span class=\"line\"><span class=\"comment\"> * pvItemToQueue: 数据地址, 用来保存复制出来的数据</span></span><br><span class=\"line\"><span class=\"comment\"> * xTicksToWait: 没有数据的话阻塞一会</span></span><br><span class=\"line\"><span class=\"comment\"> * 返回值: pdTRUE表示成功, pdFALSE表示失败</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">BaseType_t <span class=\"title function_\">xQueuePeek</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">                          QueueHandle_t xQueue,</span></span><br><span class=\"line\"><span class=\"params\">                          <span class=\"type\">void</span> * <span class=\"type\">const</span> pvBuffer,</span></span><br><span class=\"line\"><span class=\"params\">                          TickType_t xTicksToWait</span></span><br><span class=\"line\"><span class=\"params\">                      )</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">BaseType_t <span class=\"title function_\">xQueuePeekFromISR</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">                                 QueueHandle_t xQueue,</span></span><br><span class=\"line\"><span class=\"params\">                                 <span class=\"type\">void</span> *pvBuffer,</span></span><br><span class=\"line\"><span class=\"params\">                             )</span>;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"使用队列时注意\"><a href=\"#使用队列时注意\" class=\"headerlink\" title=\"使用队列时注意\"></a>使用队列时注意</h4><blockquote>\n<p>写队列与读队列 所传入的<code>buffer</code>一定要严格按照初始创建时的类型，否则就会出现死机</p>\n<ul>\n<li>情况一：创建时类型为指针（常用，可以接收多种类型）</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"type\">uint8_t</span> data[<span class=\"number\">128</span>];</span><br><span class=\"line\">    <span class=\"type\">uint8_t</span> index;</span><br><span class=\"line\">&#125;Uart_RxTypeDef;</span><br><span class=\"line\"></span><br><span class=\"line\">Uart_RxTypeDef UartRx = &#123;&#123;<span class=\"number\">0</span>&#125;,<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">task</span><span class=\"params\">(<span class=\"type\">void</span> *arg)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Uart_RxTypeDef *data = &amp;UartRx;</span><br><span class=\"line\">    debug_TX_QueueHandle = osMessageQueueNew(<span class=\"number\">5</span>, <span class=\"keyword\">sizeof</span>(<span class=\"type\">void</span> *), &amp;debug_TX_Queue_attributes);</span><br><span class=\"line\">    xQueueSend(debug_TX_QueueHandle,&amp;data,<span class=\"literal\">NULL</span>);<span class=\"comment\">//此处一定要&amp;data 因为创建队列的时候是指针 直接写data 相当于&amp;UartRx 他并不是一个指针</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>情况二：创建时类型为数据</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"type\">uint8_t</span> data[<span class=\"number\">128</span>];</span><br><span class=\"line\">    <span class=\"type\">uint8_t</span> index;</span><br><span class=\"line\">&#125;Uart_RxTypeDef;</span><br><span class=\"line\"></span><br><span class=\"line\">Uart_RxTypeDef UartRx = &#123;&#123;<span class=\"number\">0</span>&#125;,<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">task</span><span class=\"params\">(<span class=\"type\">void</span> *arg)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Uart_RxTypeDef data = &#123;&#123;<span class=\"number\">0</span>&#125;,<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">    debug_TX_QueueHandle = osMessageQueueNew(<span class=\"number\">5</span>, <span class=\"keyword\">sizeof</span>(Uart_RxTypeDef), &amp;debug_TX_Queue_attributes);</span><br><span class=\"line\">    xQueueSend(debug_TX_QueueHandle,&amp;data,<span class=\"literal\">NULL</span>);<span class=\"comment\">//此处的&amp;data与情况一不一样 这个是参数要求要地址 所以需要将结构体的地址赋值过去</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n</blockquote>\n<h4 id=\"队列集\"><a href=\"#队列集\" class=\"headerlink\" title=\"队列集\"></a>队列集</h4><blockquote>\n<p>当多个队列需要上报到同一个处理任务时，队列集可以实现统合多个队列，再往上传递到同一个任务</p>\n</blockquote>\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509152131801.png\" alt=\"image-20250915213146479\"></p>\n<h5 id=\"创建队列集\"><a href=\"#创建队列集\" class=\"headerlink\" title=\"创建队列集\"></a>创建队列集</h5><blockquote>\n<p>注意要使用队列集 需要先在<code>Core/inc/FreeRTOSConfig.h</code> 定义</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#define configUSE_QUEUE_SETS 1</span></span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>函数原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">QueueSetHandle_t <span class=\"title function_\">xQueueCreateSet</span><span class=\"params\">( <span class=\"type\">const</span> UBaseType_t uxEventQueueLength )</span></span><br></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th><strong>参数</strong></th>\n<th><strong>说明</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>uxQueueLength</td>\n<td>队列集长度，最多能存放多少个数据(队列句柄)</td>\n</tr>\n<tr>\n<td>返回值</td>\n<td>非0：成功，返回句柄，以后使用句柄来操作队列NULL：失败，因为内存不足</td>\n</tr>\n</tbody></table>\n<h5 id=\"把队列加入队列集\"><a href=\"#把队列加入队列集\" class=\"headerlink\" title=\"把队列加入队列集\"></a>把队列加入队列集</h5><p>函数原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BaseType_t <span class=\"title function_\">xQueueAddToSet</span><span class=\"params\">( QueueSetMemberHandle_t xQueueOrSemaphore,</span></span><br><span class=\"line\"><span class=\"params\"></span></span><br><span class=\"line\"><span class=\"params\">                QueueSetHandle_t xQueueSet )</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"> </span><br></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th><strong>参数</strong></th>\n<th><strong>说明</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>xQueueOrSemaphore</td>\n<td>队列句柄，这个队列要加入队列集</td>\n</tr>\n<tr>\n<td>xQueueSet</td>\n<td>队列集句柄</td>\n</tr>\n<tr>\n<td>返回值</td>\n<td>pdTRUE：成功pdFALSE：失败</td>\n</tr>\n</tbody></table>\n<h5 id=\"读取队列集\"><a href=\"#读取队列集\" class=\"headerlink\" title=\"读取队列集\"></a>读取队列集</h5><p>函数原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">QueueSetMemberHandle_t <span class=\"title function_\">xQueueSelectFromSet</span><span class=\"params\">( QueueSetHandle_t xQueueSet,</span></span><br><span class=\"line\"><span class=\"params\"></span></span><br><span class=\"line\"><span class=\"params\">                        TickType_t <span class=\"type\">const</span> xTicksToWait )</span>;</span><br></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th><strong>参数</strong></th>\n<th><strong>说明</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>xQueueSet</td>\n<td>队列集句柄</td>\n</tr>\n<tr>\n<td>xTicksToWait</td>\n<td>如果队列集空则无法读出数据，可以让任务进入阻塞状态，xTicksToWait表示阻塞的最大时间(Tick Count)。如果被设为0，无法读出数据时函数会立刻返回；如果被设为portMAX_DELAY，则会一直阻塞直到有数据可写</td>\n</tr>\n<tr>\n<td>返回值</td>\n<td>NULL：失败，队列句柄：成功</td>\n</tr>\n</tbody></table>\n<h3 id=\"信号量\"><a href=\"#信号量\" class=\"headerlink\" title=\"信号量\"></a>信号量</h3><p>前面介绍的队列(queue)可以用于传输数据：在任务之间、任务和中断之间。</p>\n<p>消息队列用于传输多个数据，但是有时候我们只需要传递状态，这个状态值需要用一个数值表示，比如：</p>\n<ul>\n<li>卖家：做好了1个包子！做好了2个包子！做好了3个包子！</li>\n<li>买家：买了1个包子，包子数量减1</li>\n<li>这个停车位我占了，停车位减1</li>\n<li>我开车走了，停车位加1</li>\n</ul>\n<p>在这种情况下我们只需要维护一个数值，使用信号量效率更高、更节省内存 本章涉及如下内容：</p>\n<ul>\n<li>怎么创建、删除信号量</li>\n<li>怎么发送、获得信号量</li>\n<li>什么是计数型信号量？什么是二进制信号量？</li>\n</ul>\n<h4 id=\"信号量的特性\"><a href=\"#信号量的特性\" class=\"headerlink\" title=\"信号量的特性\"></a>信号量的特性</h4><h5 id=\"信号量的常规操作\"><a href=\"#信号量的常规操作\" class=\"headerlink\" title=\"信号量的常规操作\"></a>信号量的常规操作</h5><p>信号量这个名字很恰当：</p>\n<ul>\n<li>信号：起通知作用</li>\n<li>量：还可以用来表示资源的数量<ul>\n<li>当”量”没有限制时，它就是”计数型信号量”(Counting Semaphores)</li>\n<li>当”量”只有0、1两个取值时，它就是”二进制信号量”(Binary Semaphores)</li>\n</ul>\n</li>\n<li>支持的动作：”give”给出资源，计数值加1；”take”获得资源，计数值减1</li>\n</ul>\n<p>计数型信号量的典型场景是：</p>\n<ul>\n<li>计数：事件产生时”give”信号量，让计数值加1；处理事件时要先”take”信号量，就是获得信号量，让计数值减1。</li>\n<li>资源管理：要想访问资源需要先”take”信号量，让计数值减1；用完资源后”give”信号量，让计数值加1。 信号量的”give”、”take”双方并不需要相同，可以用于生产者-消费者场合：</li>\n<li>生产者为任务A、B，消费者为任务C、D</li>\n<li>一开始信号量的计数值为0，如果任务C、D想获得信号量，会有两种结果：<ul>\n<li>阻塞：买不到东西咱就等等吧，可以定个闹钟(超时时间)</li>\n<li>即刻返回失败：不等</li>\n</ul>\n</li>\n<li>任务A、B可以生产资源，就是让信号量的计数值增加1，并且把等待这个资源的顾客唤醒</li>\n<li>唤醒谁？谁优先级高就唤醒谁，如果大家优先级一样就唤醒等待时间最长的人</li>\n</ul>\n<p>二进制信号量跟计数型的唯一差别，就是计数值的最大值被限定为1。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509161022312.png\" alt=\"img\"></p>\n<h5 id=\"信号量跟队列的对比\"><a href=\"#信号量跟队列的对比\" class=\"headerlink\" title=\"信号量跟队列的对比\"></a>信号量跟队列的对比</h5><p>差异列表如下：</p>\n<table>\n<thead>\n<tr>\n<th>队列</th>\n<th>信号量</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>可以容纳多个数据， 创建队列时有2部分内存: 队列结构体、存储数据的空间</td>\n<td>只有计数值，无法容纳其他数据。 创建信号量时，只需要分配信号量结构体</td>\n</tr>\n<tr>\n<td>生产者：没有空间存入数据时可以阻塞</td>\n<td>生产者：用于不阻塞，计数值已经达到最大时返回失败</td>\n</tr>\n<tr>\n<td>消费者：没有数据时可以阻塞</td>\n<td>消费者：没有资源时可以阻塞</td>\n</tr>\n</tbody></table>\n<h5 id=\"两种信号量的对比\"><a href=\"#两种信号量的对比\" class=\"headerlink\" title=\"两种信号量的对比\"></a>两种信号量的对比</h5><p>信号量的计数值都有限制：限定了最大值。如果最大值被限定为1，那么它就是二进制信号量；如果最大值不是1，它就是计数型信号量。</p>\n<p>差别列表如下：</p>\n<table>\n<thead>\n<tr>\n<th>二进制信号量</th>\n<th>计数型信号量</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>被创建时初始值为0</td>\n<td>被创建时初始值可以设定</td>\n</tr>\n<tr>\n<td>其他操作是一样的</td>\n<td>其他操作是一样的</td>\n</tr>\n</tbody></table>\n<h4 id=\"信号量函数\"><a href=\"#信号量函数\" class=\"headerlink\" title=\"信号量函数\"></a>信号量函数</h4><p>使用信号量时，先创建、然后去添加资源、获得资源。使用句柄来表示一个信号量。</p>\n<h5 id=\"创建-1\"><a href=\"#创建-1\" class=\"headerlink\" title=\"创建\"></a>创建</h5><p>使用信号量之前，要先创建，得到一个句柄；使用信号量时，要使用句柄来表明使用哪个信号量。 对于二进制信号量、计数型信号量，它们的创建函数不一样：</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>二进制信号量</th>\n<th>计数型信号量</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>动态创建</td>\n<td><code>xSemaphoreCreateBinary </code>计数值初始值为0</td>\n<td><code>xSemaphoreCreateCounting</code></td>\n</tr>\n<tr>\n<td></td>\n<td><code>vSemaphoreCreateBinary</code>(过时了) 计数值初始值为1</td>\n<td></td>\n</tr>\n<tr>\n<td>静态创建</td>\n<td><code>xSemaphoreCreateBinaryStatic</code></td>\n<td><code>xSemaphoreCreateCountingStatic</code></td>\n</tr>\n</tbody></table>\n<p>创建二进制信号量的函数原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 创建一个二进制信号量，返回它的句柄。</span></span><br><span class=\"line\"><span class=\"comment\"> * 此函数内部会分配信号量结构体 </span></span><br><span class=\"line\"><span class=\"comment\"> * 返回值: 返回句柄，非NULL表示成功</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">SemaphoreHandle_t <span class=\"title function_\">xSemaphoreCreateBinary</span><span class=\"params\">( <span class=\"type\">void</span> )</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 创建一个二进制信号量，返回它的句柄。</span></span><br><span class=\"line\"><span class=\"comment\"> * 此函数无需动态分配内存，所以需要先有一个StaticSemaphore_t结构体，并传入它的指针</span></span><br><span class=\"line\"><span class=\"comment\"> * 返回值: 返回句柄，非NULL表示成功</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">SemaphoreHandle_t <span class=\"title function_\">xSemaphoreCreateBinaryStatic</span><span class=\"params\">( StaticSemaphore_t *pxSemaphoreBuffer )</span>;</span><br></pre></td></tr></table></figure>\n\n<p>创建计数型信号量的函数原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 创建一个计数型信号量，返回它的句柄。</span></span><br><span class=\"line\"><span class=\"comment\"> * 此函数内部会分配信号量结构体 </span></span><br><span class=\"line\"><span class=\"comment\"> * uxMaxCount: 最大计数值</span></span><br><span class=\"line\"><span class=\"comment\"> * uxInitialCount: 初始计数值</span></span><br><span class=\"line\"><span class=\"comment\"> * 返回值: 返回句柄，非NULL表示成功</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">SemaphoreHandle_t <span class=\"title function_\">xSemaphoreCreateCounting</span><span class=\"params\">(UBaseType_t uxMaxCount, UBaseType_t uxInitialCount)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 创建一个计数型信号量，返回它的句柄。</span></span><br><span class=\"line\"><span class=\"comment\"> * 此函数无需动态分配内存，所以需要先有一个StaticSemaphore_t结构体，并传入它的指针</span></span><br><span class=\"line\"><span class=\"comment\"> * uxMaxCount: 最大计数值</span></span><br><span class=\"line\"><span class=\"comment\"> * uxInitialCount: 初始计数值</span></span><br><span class=\"line\"><span class=\"comment\"> * pxSemaphoreBuffer: StaticSemaphore_t结构体指针</span></span><br><span class=\"line\"><span class=\"comment\"> * 返回值: 返回句柄，非NULL表示成功</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">SemaphoreHandle_t <span class=\"title function_\">xSemaphoreCreateCountingStatic</span><span class=\"params\">( UBaseType_t uxMaxCount, </span></span><br><span class=\"line\"><span class=\"params\">                                                 UBaseType_t uxInitialCount, </span></span><br><span class=\"line\"><span class=\"params\">                                                 StaticSemaphore_t *pxSemaphoreBuffer )</span>;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"删除-1\"><a href=\"#删除-1\" class=\"headerlink\" title=\"删除\"></a>删除</h5><p>对于动态创建的信号量，不再需要它们时，可以删除它们以回收内存。</p>\n<p>vSemaphoreDelete可以用来删除二进制信号量、计数型信号量，函数原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * xSemaphore: 信号量句柄，你要删除哪个信号量</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">vSemaphoreDelete</span><span class=\"params\">( SemaphoreHandle_t xSemaphore )</span>;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"释放-获取信号量\"><a href=\"#释放-获取信号量\" class=\"headerlink\" title=\"释放&#x2F;获取信号量\"></a>释放&#x2F;获取信号量</h5><p>二进制信号量、计数型信号量的give、take操作函数是一样的。这些函数也分为2个版本：给任务使用，给ISR使用。列表如下：</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>在任务中使用</th>\n<th>在ISR中使用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>give</td>\n<td><code>xSemaphoreGive</code></td>\n<td><code>xSemaphoreGiveFromISR</code></td>\n</tr>\n<tr>\n<td>take</td>\n<td><code>xSemaphoreTake</code></td>\n<td><code>xSemaphoreTakeFromISR</code></td>\n</tr>\n</tbody></table>\n<p>xSemaphoreGive的函数原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BaseType_t <span class=\"title function_\">xSemaphoreGive</span><span class=\"params\">( SemaphoreHandle_t xSemaphore )</span>;</span><br></pre></td></tr></table></figure>\n\n<p>xSemaphoreGive函数的参数与返回值列表如下：</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>xSemaphore</td>\n<td>信号量句柄，释放哪个信号量</td>\n</tr>\n<tr>\n<td>返回值</td>\n<td>pdTRUE表示成功, 如果二进制信号量的计数值已经是1，再次调用此函数则返回失败； 如果计数型信号量的计数值已经是最大值，再次调用此函数则返回失败</td>\n</tr>\n</tbody></table>\n<p>pxHigherPriorityTaskWoken的函数原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BaseType_t <span class=\"title function_\">xSemaphoreGiveFromISR</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">                        SemaphoreHandle_t xSemaphore,</span></span><br><span class=\"line\"><span class=\"params\">                        BaseType_t *pxHigherPriorityTaskWoken</span></span><br><span class=\"line\"><span class=\"params\">                    )</span>;</span><br></pre></td></tr></table></figure>\n\n<p>xSemaphoreGiveFromISR函数的参数与返回值列表如下：</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>xSemaphore</td>\n<td>信号量句柄，释放哪个信号量</td>\n</tr>\n<tr>\n<td>pxHigherPriorityTaskWoken</td>\n<td>如果释放信号量导致更高优先级的任务变为了就绪态， 则*pxHigherPriorityTaskWoken &#x3D; pdTRUE</td>\n</tr>\n<tr>\n<td>返回值</td>\n<td>pdTRUE表示成功, 如果二进制信号量的计数值已经是1，再次调用此函数则返回失败； 如果计数型信号量的计数值已经是最大值，再次调用此函数则返回失败</td>\n</tr>\n</tbody></table>\n<p>xSemaphoreTake的函数原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BaseType_t <span class=\"title function_\">xSemaphoreTake</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">                   SemaphoreHandle_t xSemaphore,</span></span><br><span class=\"line\"><span class=\"params\">                   TickType_t xTicksToWait</span></span><br><span class=\"line\"><span class=\"params\">               )</span>;</span><br></pre></td></tr></table></figure>\n\n<p>xSemaphoreTake函数的参数与返回值列表如下：</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>xSemaphore</code></td>\n<td>信号量句柄，获取哪个信号量</td>\n</tr>\n<tr>\n<td><code>xTicksToWait</code></td>\n<td>如果无法马上获得信号量，阻塞一会： 0：不阻塞，马上返回 <code>portMAX_DELAY</code>: 一直阻塞直到成功 其他值: 阻塞的Tick个数，可以使用*<code>pdMS_TO_TICKS</code>()*来指定阻塞时间为若干<code>ms</code></td>\n</tr>\n<tr>\n<td>返回值</td>\n<td>pdTRUE表示成功</td>\n</tr>\n</tbody></table>\n<p>xSemaphoreTakeFromISR的函数原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BaseType_t <span class=\"title function_\">xSemaphoreTakeFromISR</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">                        SemaphoreHandle_t xSemaphore,</span></span><br><span class=\"line\"><span class=\"params\">                        BaseType_t *pxHigherPriorityTaskWoken</span></span><br><span class=\"line\"><span class=\"params\">                    )</span>;</span><br></pre></td></tr></table></figure>\n\n<p>xSemaphoreTakeFromISR函数的参数与返回值列表如下：</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>xSemaphore</code></td>\n<td>信号量句柄，获取哪个信号量</td>\n</tr>\n<tr>\n<td><code>pxHigherPriorityTaskWoken</code></td>\n<td>如果获取信号量导致更高优先级的任务变为了就绪态， 则<code>*pxHigherPriorityTaskWoken = pdTRUE</code></td>\n</tr>\n<tr>\n<td>返回值</td>\n<td>pdTRUE表示成功</td>\n</tr>\n</tbody></table>\n<h4 id=\"优先级反转\"><a href=\"#优先级反转\" class=\"headerlink\" title=\"优先级反转\"></a>优先级反转</h4><p>信号量使用不当 就会出现优先级反转的问题——任务执行顺序：任务1、任务2、任务1、任务3</p>\n<p>即最高优先级的任务最后运行</p>\n<blockquote>\n<p>优先级反转：假设信号量值为1，同时创建了低、中等、高优先级任务</p>\n<ul>\n<li>低优先级任务获取信号量，中等优先级先阻塞一段时间，确保低优先级任务先成功获取到信号量</li>\n<li>高优先级任务先阻塞一段时间，确保低优先级、中等优先级先完成任务，然后尝试获取信号量</li>\n<li>此时由于低优先级获取了信号量，高优先级任务就会被阻塞</li>\n<li>中等优先级不释放信号量，那么就会发生高优先级任务无法运行</li>\n</ul>\n</blockquote>\n<h5 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;uart.h&quot;</span></span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> __<span class=\"title\">FILE</span> <span class=\"title\">FILE</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> SemaphoreHandle_t task_mutex = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"type\">uint8_t</span> dev;</span><br><span class=\"line\">    <span class=\"type\">uint8_t</span> *data;</span><br><span class=\"line\">&#125; <span class=\"type\">uart_info_t</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">uart_info_t</span> task1_data = &#123;<span class=\"number\">1</span>, <span class=\"string\">&quot;task1&quot;</span>&#125;;</span><br><span class=\"line\"><span class=\"type\">uart_info_t</span> task2_data = &#123;<span class=\"number\">2</span>, <span class=\"string\">&quot;task2&quot;</span>&#125;;</span><br><span class=\"line\"><span class=\"type\">uart_info_t</span> task3_data = &#123;<span class=\"number\">3</span>, <span class=\"string\">&quot;task3&quot;</span>&#125;;</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">fputc</span><span class=\"params\">(<span class=\"type\">int</span> ch, FILE *f)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    HAL_UART_Transmit(&amp;huart1, (<span class=\"type\">uint8_t</span> *)&amp;ch, <span class=\"number\">1</span>, <span class=\"number\">0xFFFF</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ch;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">task1</span><span class=\"params\">(<span class=\"type\">void</span> *param)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">uint8_t</span> cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">    xSemaphoreTake(task_mutex, portMAX_DELAY);</span><br><span class=\"line\">    <span class=\"type\">uart_info_t</span> *data = param;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;dev:%u,name:%s\\r\\n&quot;</span>, data-&gt;dev, data-&gt;data);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (++cnt == <span class=\"number\">5</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            xSemaphoreGive(task_mutex);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        vTaskDelay(<span class=\"number\">50</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">task2</span><span class=\"params\">(<span class=\"type\">void</span> *param)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">uint8_t</span> cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">    vTaskDelay(<span class=\"number\">300</span>);<span class=\"comment\">//先阻塞一段时间 确保任务1成功获取信号量且能够被切换为任务2</span></span><br><span class=\"line\">    <span class=\"type\">uart_info_t</span> *data = param;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;dev:%u,name:%s\\r\\n&quot;</span>, data-&gt;dev, data-&gt;data);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (++cnt == <span class=\"number\">5</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            vTaskDelete(<span class=\"literal\">NULL</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        HAL_Delay(<span class=\"number\">50</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">task3</span><span class=\"params\">(<span class=\"type\">void</span> *param)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">uint8_t</span> cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">    vTaskDelay(<span class=\"number\">500</span>);\t<span class=\"comment\">//先阻塞一段时间 确保任务1先成功获取信号量且能够被切换为任务2</span></span><br><span class=\"line\">    xSemaphoreTake(task_mutex, portMAX_DELAY);</span><br><span class=\"line\">    <span class=\"type\">uart_info_t</span> *data = param;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;dev:%u,name:%s\\r\\n&quot;</span>, data-&gt;dev, data-&gt;data);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (++cnt == <span class=\"number\">5</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            vTaskDelete(<span class=\"literal\">NULL</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">uart_init</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    task_mutex = xSemaphoreCreateBinary();</span><br><span class=\"line\">    xSemaphoreGive(task_mutex);</span><br><span class=\"line\">    xTaskCreate(task1, <span class=\"string\">&quot;task1&quot;</span>, <span class=\"number\">128</span>, &amp;task1_data, osPriorityNormal, <span class=\"literal\">NULL</span>);\t<span class=\"comment\">//低优先级任务</span></span><br><span class=\"line\">    xTaskCreate(task2, <span class=\"string\">&quot;task2&quot;</span>, <span class=\"number\">128</span>, &amp;task2_data, osPriorityNormal1, <span class=\"literal\">NULL</span>);\t<span class=\"comment\">//中等优先级任务</span></span><br><span class=\"line\">    xTaskCreate(task3, <span class=\"string\">&quot;task3&quot;</span>, <span class=\"number\">128</span>, &amp;task3_data, osPriorityNormal2, <span class=\"literal\">NULL</span>);\t<span class=\"comment\">//高优先级任务</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509161600972.png\" alt=\"image-20250916160014655\"></p>\n<h4 id=\"解决优先级反转\"><a href=\"#解决优先级反转\" class=\"headerlink\" title=\"解决优先级反转\"></a>解决优先级反转</h4><blockquote>\n<p>使用互斥量 （实现优先级继承），当最高优先级任务等待互斥量时，可以将低优先级任务继承最高优先级，使得最高优先级任务也可以先运行</p>\n<p>现象：任务1执行一小段时间被任务2抢占，当任务3时间到来，任务1继承任务3优先级，所以任务1运行释放后，任务1恢复原先优先级，任务3启动</p>\n</blockquote>\n<h3 id=\"事件组\"><a href=\"#事件组\" class=\"headerlink\" title=\"事件组\"></a>事件组</h3><blockquote>\n<p>上述任务同步与互斥的方法都是一对一通知，难以实现一对多通知（广播），因此引入了事件组</p>\n</blockquote>\n<h4 id=\"事件组的概念\"><a href=\"#事件组的概念\" class=\"headerlink\" title=\"事件组的概念\"></a>事件组的概念</h4><p>事件组可以简单地认为就是一个整数：</p>\n<ul>\n<li>的每一位表示一个事件</li>\n<li>每一位事件的含义由程序员决定，比如：Bit0表示用来串口是否就绪，Bit1表示按键是否被按下</li>\n<li>这些位，值为1表示事件发生了，值为0表示事件没发生</li>\n<li>一个或多个任务、ISR都可以去写这些位；一个或多个任务、ISR都可以去读这些位</li>\n<li>可以等待某一位、某些位中的任意一个，也可以等待多位</li>\n</ul>\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509161809736.png\" alt=\"img\"></p>\n<p>事件组用一个整数来表示，其中的高8位留给内核使用，只能用其他的位来表示事件。那么这个整数是多少位的？</p>\n<ul>\n<li>如果configUSE_16_BIT_TICKS是1，那么这个整数就是16位的，低8位用来表示事件</li>\n<li>如果configUSE_16_BIT_TICKS是0，那么这个整数就是32位的，低24位用来表示事件</li>\n<li>configUSE_16_BIT_TICKS是用来表示Tick Count的，怎么会影响事件组？这只是基于效率来考虑<ul>\n<li>如果configUSE_16_BIT_TICKS是1，就表示该处理器使用16位更高效，所以事件组也使用16位</li>\n<li>如果configUSE_16_BIT_TICKS是0，就表示该处理器使用32位更高效，所以事件组也使用32位</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"事件组的操作\"><a href=\"#事件组的操作\" class=\"headerlink\" title=\"事件组的操作\"></a>事件组的操作</h4><p>事件组和队列、信号量等不太一样，主要集中在2个地方：</p>\n<ul>\n<li>唤醒谁？<ul>\n<li>队列、信号量：事件发生时，只会唤醒一个任务</li>\n<li>事件组：事件发生时，会唤醒所有符号条件的任务，简单地说它有”广播”的作用</li>\n</ul>\n</li>\n<li>是否清除事件？<ul>\n<li>队列、信号量：是消耗型的资源，队列的数据被读走就没了；信号量被获取后就减少了</li>\n<li>事件组：被唤醒的任务有两个选择，可以让事件保留不动，也可以清除事件</li>\n</ul>\n</li>\n</ul>\n<p>以上图为列，事件组的常规操作如下：</p>\n<ul>\n<li>先创建事件组</li>\n<li>任务C、D等待事件：<ul>\n<li>等待什么事件？可以等待某一位、某些位中的任意一个，也可以等待多位。简单地说就是”或”、”与”的关系。</li>\n<li>得到事件时，要不要清除？可选择清除、不清除。</li>\n</ul>\n</li>\n<li>任务A、B产生事件：设置事件组里的某一位、某些位</li>\n</ul>\n<h4 id=\"事件组函数\"><a href=\"#事件组函数\" class=\"headerlink\" title=\"事件组函数\"></a>事件组函数</h4><h5 id=\"创建-2\"><a href=\"#创建-2\" class=\"headerlink\" title=\"创建\"></a>创建</h5><p>使用事件组之前，要先创建，得到一个句柄；使用事件组时，要使用句柄来表明使用哪个事件组。</p>\n<p>有两种创建方法：动态分配内存、静态分配内存。函数原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 创建一个事件组，返回它的句柄。</span></span><br><span class=\"line\"><span class=\"comment\"> * 此函数内部会分配事件组结构体 </span></span><br><span class=\"line\"><span class=\"comment\"> * 返回值: 返回句柄，非NULL表示成功</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">EventGroupHandle_t <span class=\"title function_\">xEventGroupCreate</span><span class=\"params\">( <span class=\"type\">void</span> )</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 创建一个事件组，返回它的句柄。</span></span><br><span class=\"line\"><span class=\"comment\"> * 此函数无需动态分配内存，所以需要先有一个StaticEventGroup_t结构体，并传入它的指针</span></span><br><span class=\"line\"><span class=\"comment\"> * 返回值: 返回句柄，非NULL表示成功</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">EventGroupHandle_t <span class=\"title function_\">xEventGroupCreateStatic</span><span class=\"params\">( StaticEventGroup_t * pxEventGroupBuffer )</span>;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"删除-2\"><a href=\"#删除-2\" class=\"headerlink\" title=\"删除\"></a>删除</h5><p>对于动态创建的事件组，不再需要它们时，可以删除它们以回收内存。</p>\n<p><strong>vEventGroupDelete</strong>可以用来删除事件组，函数原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * xEventGroup: 事件组句柄，你要删除哪个事件组</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">vEventGroupDelete</span><span class=\"params\">( EventGroupHandle_t xEventGroup )</span></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"设置事件\"><a href=\"#设置事件\" class=\"headerlink\" title=\"设置事件\"></a>设置事件</h5><p>可以设置事件组的某个位、某些位，使用的函数有2个：</p>\n<ul>\n<li>在任务中使用<strong>xEventGroupSetBits()</strong></li>\n<li>在ISR中使用<strong>xEventGroupSetBitsFromISR()</strong></li>\n</ul>\n<p>有一个或多个任务在等待事件，如果这些事件符合这些任务的期望，那么任务还会被唤醒。</p>\n<p>函数原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 设置事件组中的位</span></span><br><span class=\"line\"><span class=\"comment\"> * xEventGroup: 哪个事件组</span></span><br><span class=\"line\"><span class=\"comment\"> * uxBitsToSet: 设置哪些位? </span></span><br><span class=\"line\"><span class=\"comment\"> *              如果uxBitsToSet的bitX, bitY为1, 那么事件组中的bitX, bitY被设置为1</span></span><br><span class=\"line\"><span class=\"comment\"> *              可以用来设置多个位，比如 0x15 就表示设置bit4, bit2, bit0</span></span><br><span class=\"line\"><span class=\"comment\"> * 返回值: 返回原来的事件值(没什么意义, 因为很可能已经被其他任务修改了)</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">EventBits_t <span class=\"title function_\">xEventGroupSetBits</span><span class=\"params\">( EventGroupHandle_t xEventGroup,</span></span><br><span class=\"line\"><span class=\"params\">                                    <span class=\"type\">const</span> EventBits_t uxBitsToSet )</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 设置事件组中的位</span></span><br><span class=\"line\"><span class=\"comment\"> * xEventGroup: 哪个事件组</span></span><br><span class=\"line\"><span class=\"comment\"> * uxBitsToSet: 设置哪些位? </span></span><br><span class=\"line\"><span class=\"comment\"> *              如果uxBitsToSet的bitX, bitY为1, 那么事件组中的bitX, bitY被设置为1</span></span><br><span class=\"line\"><span class=\"comment\"> *              可以用来设置多个位，比如 0x15 就表示设置bit4, bit2, bit0</span></span><br><span class=\"line\"><span class=\"comment\"> * pxHigherPriorityTaskWoken: 有没有导致更高优先级的任务进入就绪态? pdTRUE-有, pdFALSE-没有</span></span><br><span class=\"line\"><span class=\"comment\"> * 返回值: pdPASS-成功, pdFALSE-失败</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">BaseType_t <span class=\"title function_\">xEventGroupSetBitsFromISR</span><span class=\"params\">( EventGroupHandle_t xEventGroup,</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t\t\t\t\t\t\t  <span class=\"type\">const</span> EventBits_t uxBitsToSet,</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t\t\t\t\t\t\t  BaseType_t * pxHigherPriorityTaskWoken )</span>;</span><br></pre></td></tr></table></figure>\n\n<p>值得注意的是，ISR中的函数，比如队列函数<strong>xQueueSendToBackFromISR</strong>、信号量函数<strong>xSemaphoreGiveFromISR</strong>，它们会唤醒某个任务，最多只会唤醒1个任务。</p>\n<p>但是设置事件组时，有可能导致多个任务被唤醒，这会带来很大的不确定性。所以<strong>xEventGroupSetBitsFromISR</strong>函数不是直接去设置事件组，而是给一个FreeRTOS后台任务(daemon task)发送队列数据，由这个任务来设置事件组。</p>\n<p>如果后台任务的优先级比当前被中断的任务优先级高，<strong>xEventGroupSetBitsFromISR</strong>会设置<strong>pxHigherPriorityTaskWoken</strong>为pdTRUE。</p>\n<p>如果daemon task成功地把队列数据发送给了后台任务，那么<strong>xEventGroupSetBitsFromISR</strong>的返回值就是pdPASS。</p>\n<h5 id=\"等待事件\"><a href=\"#等待事件\" class=\"headerlink\" title=\"等待事件\"></a>等待事件</h5><p>使用<strong>xEventGroupWaitBits</strong>来等待事件，可以等待某一位、某些位中的任意一个，也可以等待多位；等到期望的事件后，还可以清除某些位。</p>\n<p>函数原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EventBits_t <span class=\"title function_\">xEventGroupWaitBits</span><span class=\"params\">( EventGroupHandle_t xEventGroup,</span></span><br><span class=\"line\"><span class=\"params\">                                 <span class=\"type\">const</span> EventBits_t uxBitsToWaitFor,</span></span><br><span class=\"line\"><span class=\"params\">                                 <span class=\"type\">const</span> BaseType_t xClearOnExit,</span></span><br><span class=\"line\"><span class=\"params\">                                 <span class=\"type\">const</span> BaseType_t xWaitForAllBits,</span></span><br><span class=\"line\"><span class=\"params\">                                 TickType_t xTicksToWait )</span>;</span><br></pre></td></tr></table></figure>\n\n<p>先引入一个概念：unblock condition。一个任务在等待事件发生时，它处于阻塞状态；当期望的时间发生时，这个状态就叫”unblock condition”，非阻塞条件，或称为”非阻塞条件成立”；当”非阻塞条件成立”后，该任务就可以变为就绪态。</p>\n<p>函数参数说明列表如下：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\"><strong>参数</strong></th>\n<th align=\"left\"><strong>说明</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">xEventGroup</td>\n<td align=\"left\">等待哪个事件组？</td>\n</tr>\n<tr>\n<td align=\"center\">uxBitsToWaitFor</td>\n<td align=\"left\">等待哪些位？哪些位要被测试？</td>\n</tr>\n<tr>\n<td align=\"center\">xWaitForAllBits</td>\n<td align=\"left\">怎么测试？是”AND”还是”OR”？ pdTRUE: 等待的位，全部为1; pdFALSE: 等待的位，某一个为1即可</td>\n</tr>\n<tr>\n<td align=\"center\">xClearOnExit</td>\n<td align=\"left\">函数提出前是否要清除事件？ pdTRUE: 清除uxBitsToWaitFor指定的位 pdFALSE: 不清除</td>\n</tr>\n<tr>\n<td align=\"center\">xTicksToWait</td>\n<td align=\"left\">如果期待的事件未发生，阻塞多久。 可以设置为0：判断后即刻返回； 可设置为portMAX_DELAY：一定等到成功才返回； 可以设置为期望的Tick Count，一般用*pdMS_TO_TICKS()*把ms转换为Tick Count</td>\n</tr>\n<tr>\n<td align=\"center\">返回值</td>\n<td align=\"left\">返回的是事件值， 如果期待的事件发生了，返回的是”非阻塞条件成立”时的事件值； 如果是超时退出，返回的是超时时刻的事件值。</td>\n</tr>\n</tbody></table>\n<p>举例如下：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">事件组的值</th>\n<th align=\"center\">uxBitsToWaitFor</th>\n<th align=\"center\">xWaitForAllBits</th>\n<th align=\"left\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">0100</td>\n<td align=\"center\">0101</td>\n<td align=\"center\">pdTRUE</td>\n<td align=\"left\">任务期望bit0,bit2都为1， 当前值只有bit2满足，任务进入阻塞态； 当事件组中bit0,bit2都为1时退出阻塞态</td>\n</tr>\n<tr>\n<td align=\"center\">0100</td>\n<td align=\"center\">0110</td>\n<td align=\"center\">pdFALSE</td>\n<td align=\"left\">任务期望bit0,bit2某一个为1， 当前值满足，所以任务成功退出</td>\n</tr>\n<tr>\n<td align=\"center\">0100</td>\n<td align=\"center\">0110</td>\n<td align=\"center\">pdTRUE</td>\n<td align=\"left\">任务期望bit1,bit2都为1， 当前值不满足，任务进入阻塞态； 当事件组中bit1,bit2都为1时退出阻塞态</td>\n</tr>\n</tbody></table>\n<p>你可以使用*xEventGroupWaitBits()<em>等待期望的事件，它发生之后再使用</em>xEventGroupClearBits()*来清除。但是这两个函数之间，有可能被其他任务或中断抢占，它们可能会修改事件组。</p>\n<p>可以使用设置<em>xClearOnExit</em>为pdTRUE，使得对事件组的测试、清零都在*xEventGroupWaitBits()*函数内部完成，这是一个原子操作。</p>\n<h5 id=\"同步点\"><a href=\"#同步点\" class=\"headerlink\" title=\"同步点\"></a>同步点</h5><p>有一个事情需要多个任务协同，比如：</p>\n<ul>\n<li>任务A：炒菜</li>\n<li>任务B：买酒</li>\n<li>任务C：摆台</li>\n<li>A、B、C做好自己的事后，还要等别人做完；大家一起做完，才可开饭</li>\n</ul>\n<p>使用 <strong>xEventGroupSync()</strong> 函数可以同步多个任务：</p>\n<ul>\n<li>可以设置某位、某些位，表示自己做了什么事</li>\n<li>可以等待某位、某些位，表示要等等其他任务</li>\n<li>期望的时间发生后， <strong>xEventGroupSync()</strong> 才会成功返回。</li>\n<li><strong>xEventGroupSync</strong>成功返回后，会清除事件</li>\n</ul>\n<p><strong>xEventGroupSync</strong> 函数原型如下：</p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EventBits_t xEventGroupSync(    EventGroupHandle_t xEventGroup,</span><br><span class=\"line\">                                const EventBits_t uxBitsToSet,</span><br><span class=\"line\">                                const EventBits_t uxBitsToWaitFor,</span><br><span class=\"line\">                                TickType_t xTicksToWait );</span><br></pre></td></tr></table></figure>\n\n<p>参数列表如下：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\"><strong>参数</strong></th>\n<th><strong>说明</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">xEventGroup</td>\n<td>哪个事件组？</td>\n</tr>\n<tr>\n<td align=\"center\">uxBitsToSet</td>\n<td>要设置哪些事件？我完成了哪些事件？ 比如0x05(二进制为0101)会导致事件组的bit0,bit2被设置为1</td>\n</tr>\n<tr>\n<td align=\"center\">uxBitsToWaitFor</td>\n<td>等待那个位、哪些位？ 比如0x15(二级制10101)，表示要等待bit0,bit2,bit4都为1</td>\n</tr>\n<tr>\n<td align=\"center\">xTicksToWait</td>\n<td>如果期待的事件未发生，阻塞多久。 可以设置为0：判断后即刻返回； 可设置为portMAX_DELAY：一定等到成功才返回； 可以设置为期望的Tick Count，一般用*pdMS_TO_TICKS()*把ms转换为Tick Count</td>\n</tr>\n<tr>\n<td align=\"center\">返回值</td>\n<td>返回的是事件值， 如果期待的事件发生了，返回的是”非阻塞条件成立”时的事件值； 如果是超时退出，返回的是超时时刻的事件值。</td>\n</tr>\n</tbody></table>\n<p>参数列表如下：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\"><strong>参数</strong></th>\n<th align=\"left\"><strong>说明</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">xEventGroup</td>\n<td align=\"left\">哪个事件组？</td>\n</tr>\n<tr>\n<td align=\"center\">uxBitsToSet</td>\n<td align=\"left\">要设置哪些事件？我完成了哪些事件？ 比如0x05(二进制为0101)会导致事件组的bit0,bit2被设置为1</td>\n</tr>\n<tr>\n<td align=\"center\">uxBitsToWaitFor</td>\n<td align=\"left\">等待那个位、哪些位？ 比如0x15(二级制10101)，表示要等待bit0,bit2,bit4都为1</td>\n</tr>\n<tr>\n<td align=\"center\">xTicksToWait</td>\n<td align=\"left\">如果期待的事件未发生，阻塞多久。 可以设置为0：判断后即刻返回； 可设置为portMAX_DELAY：一定等到成功才返回； 可以设置为期望的Tick Count，一般用*pdMS_TO_TICKS()*把ms转换为Tick Count</td>\n</tr>\n<tr>\n<td align=\"center\">返回值</td>\n<td align=\"left\">返回的是事件值， 如果期待的事件发生了，返回的是”非阻塞条件成立”时的事件值； 如果是超时退出，返回的是超时时刻的事件值。</td>\n</tr>\n</tbody></table>\n<h3 id=\"任务通知\"><a href=\"#任务通知\" class=\"headerlink\" title=\"任务通知\"></a>任务通知</h3><p>所谓”任务通知”，你可以反过来读”通知任务”。</p>\n<p>我们使用队列、信号量、事件组等等方法时，并不知道对方是谁。使用任务通知时，可以明确指定：通知哪个任务。</p>\n<p>使用队列、信号量、事件组时，我们都要事先创建对应的结构体，双方通过中间的结构体通信：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509161952531.png\" alt=\"img\"></p>\n<p>使用任务通知时，任务结构体TCB中就包含了内部对象，可以直接接收别人发过来的”通知”：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509161952379.png\" alt=\"img\"></p>\n<h4 id=\"任务通知的特性\"><a href=\"#任务通知的特性\" class=\"headerlink\" title=\"任务通知的特性\"></a>任务通知的特性</h4><h5 id=\"优势及限制\"><a href=\"#优势及限制\" class=\"headerlink\" title=\"优势及限制\"></a>优势及限制</h5><p>任务通知的优势：</p>\n<ul>\n<li>效率更高：使用任务通知来发送事件、数据给某个任务时，效率更高。比队列、信号量、事件组都有大的优势。</li>\n<li>更节省内存：使用其他方法时都要先创建对应的结构体，使用任务通知时无需额外创建结构体。</li>\n</ul>\n<p>任务通知的限制：</p>\n<ul>\n<li>不能发送数据给ISR：</li>\n<li>ISR并没有任务结构体，所以无法使用任务通知的功能给ISR发送数据。但是ISR可以使用任务通知的功能，发数据给任务。</li>\n<li>数据只能给该任务独享</li>\n<li>使用队列、信号量、事件组时，数据保存在这些结构体中，其他任务、ISR都可以访问这些数据。使用任务通知时，数据存放入目标任务中，只有它可以访问这些数据。</li>\n<li>在日常工作中，这个限制影响不大。因为很多场合是从多个数据源把数据发给某个任务，而不是把一个数据源的数据发给多个任务。</li>\n<li>无法缓冲数据</li>\n<li>使用队列时，假设队列深度为N，那么它可以保持N个数据。</li>\n<li>使用任务通知时，任务结构体中只有一个任务通知值，只能保持一个数据。</li>\n<li><span style=\"color:#00FFFF;\">无法广播给多个任务</span></li>\n<li>使用事件组可以同时给多个任务发送事件。</li>\n<li>使用任务通知，只能发个一个任务。</li>\n<li>如果发送受阻，发送方无法进入阻塞状态等待</li>\n<li>假设队列已经满了，使用 <strong>xQueueSendToBack()</strong> 给队列发送数据时，任务可以进入阻塞状态等待发送完成。</li>\n<li>使用任务通知时，即使对方无法接收数据，发送方也无法阻塞等待，只能即刻返回错误。</li>\n</ul>\n<h5 id=\"通知状态和通知值\"><a href=\"#通知状态和通知值\" class=\"headerlink\" title=\"通知状态和通知值\"></a>通知状态和通知值</h5><p>每个任务都有一个结构体：TCB(Task Control Block)，里面有2个成员：</p>\n<ul>\n<li>一个是uint8_t类型，用来表示通知状态</li>\n<li>一个是uint32_t类型，用来表示通知值</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tskTaskControlBlock</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    ......</span><br><span class=\"line\">    <span class=\"comment\">/* configTASK_NOTIFICATION_ARRAY_ENTRIES = 1 */</span></span><br><span class=\"line\">    <span class=\"keyword\">volatile</span> <span class=\"type\">uint32_t</span> ulNotifiedValue[ configTASK_NOTIFICATION_ARRAY_ENTRIES ];</span><br><span class=\"line\">    <span class=\"keyword\">volatile</span> <span class=\"type\">uint8_t</span> ucNotifyState[ configTASK_NOTIFICATION_ARRAY_ENTRIES ];</span><br><span class=\"line\">    ......</span><br><span class=\"line\">&#125; tskTCB;</span><br></pre></td></tr></table></figure>\n\n<p>通知状态有3种取值：</p>\n<ul>\n<li>taskNOT_WAITING_NOTIFICATION：任务没有在等待通知</li>\n<li>taskWAITING_NOTIFICATION：任务在等待通知</li>\n<li>taskNOTIFICATION_RECEIVED：任务接收到了通知，也被称为pending(有数据了，待处理)</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#<span class=\"meta\">#<span class=\"keyword\">define</span> taskNOT_WAITING_NOTIFICATION              ( ( uint8_t ) 0 )  <span class=\"comment\">/* 也是初始状态 */</span></span></span><br><span class=\"line\">#<span class=\"meta\">#<span class=\"keyword\">define</span> taskWAITING_NOTIFICATION                  ( ( uint8_t ) 1 )</span></span><br><span class=\"line\">#<span class=\"meta\">#<span class=\"keyword\">define</span> taskNOTIFICATION_RECEIVED                 ( ( uint8_t ) 2 )</span></span><br></pre></td></tr></table></figure>\n\n<p>通知值可以有很多种类型：</p>\n<ul>\n<li>计数值</li>\n<li>位(类似事件组)</li>\n<li>任意数值</li>\n</ul>\n<h4 id=\"任务通知的使用\"><a href=\"#任务通知的使用\" class=\"headerlink\" title=\"任务通知的使用\"></a>任务通知的使用</h4><p>使用任务通知，可以实现轻量级的队列(长度为1)、邮箱(覆盖的队列)、计数型信号量、二进制信号量、事件组。</p>\n<h5 id=\"两类函数\"><a href=\"#两类函数\" class=\"headerlink\" title=\"两类函数\"></a>两类函数</h5><p>任务通知有2套函数，简化版、专业版，列表如下：</p>\n<ul>\n<li>简化版函数的使用比较简单，它实际上也是使用专业版函数实现的</li>\n<li>专业版函数支持很多参数，可以实现很多功能</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>简化版</th>\n<th>专业版</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>发出通知</td>\n<td><code>xTaskNotifyGive </code> <code>vTaskNotifyGiveFromISR</code></td>\n<td><code>xTaskNotify </code> <code>xTaskNotifyFromISR</code></td>\n</tr>\n<tr>\n<td>取出通知</td>\n<td><code>ulTaskNotifyTake</code></td>\n<td><code>xTaskNotifyWait</code></td>\n</tr>\n</tbody></table>\n<h5 id=\"简化版任务通知\"><a href=\"#简化版任务通知\" class=\"headerlink\" title=\"简化版任务通知\"></a>简化版任务通知</h5><p>在任务中使用<code>xTaskNotifyGive</code>函数，在ISR中使用<code>vTaskNotifyGiveFromISR</code>函数，都是直接给其他任务发送通知：</p>\n<ul>\n<li>使得通知值加一</li>\n<li>并使得通知状态变为”pending”，也就是<strong>taskNOTIFICATION_RECEIVED</strong>，表示有数据了、待处理</li>\n</ul>\n<p>可以使用<code>ulTaskNotifyTake</code>函数来取出通知值：</p>\n<ul>\n<li>如果通知值等于0，则阻塞(可以指定超时时间)</li>\n<li>当通知值大于0时，任务从阻塞态进入就绪态</li>\n<li>在ulTaskNotifyTake返回之前，还可以做些清理工作：把通知值减一，或者把通知值清零</li>\n</ul>\n<p>使用ulTaskNotifyTake函数可以实现轻量级的、高效的二进制信号量、计数型信号量。</p>\n<p>这几个函数的原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BaseType_t <span class=\"title function_\">xTaskNotifyGive</span><span class=\"params\">( TaskHandle_t xTaskToNotify )</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">vTaskNotifyGiveFromISR</span><span class=\"params\">( TaskHandle_t xTaskHandle, BaseType_t *pxHigherPriorityTaskWoken )</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">uint32_t</span> <span class=\"title function_\">ulTaskNotifyTake</span><span class=\"params\">( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )</span>;</span><br></pre></td></tr></table></figure>\n\n<p><code>xTaskNotifyGive</code>函数的参数说明如下：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\"><strong>参数</strong></th>\n<th><strong>说明</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><code>xTaskToNotify</code></td>\n<td>任务句柄(创建任务时得到)，给哪个任务发通知</td>\n</tr>\n<tr>\n<td align=\"center\">返回值</td>\n<td>必定返回pdPASS</td>\n</tr>\n</tbody></table>\n<p><code>vTaskNotifyGiveFromISR</code>函数的参数说明如下：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\"><strong>参数</strong></th>\n<th><strong>说明</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><code>xTaskHandle</code></td>\n<td>任务句柄(创建任务时得到)，给哪个任务发通知</td>\n</tr>\n<tr>\n<td align=\"center\"><code>pxHigherPriorityTaskWoken</code></td>\n<td>被通知的任务，可能正处于阻塞状态。 此函数发出通知后，会把它从阻塞状态切换为就绪态。 如果被唤醒的任务的优先级，高于当前任务的优先级， 则”*pxHigherPriorityTaskWoken”被设置为pdTRUE， 这表示在中断返回之前要进行任务切换。</td>\n</tr>\n</tbody></table>\n<p><code>ulTaskNotifyTake</code>函数的参数说明如下：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\"><strong>参数</strong></th>\n<th><strong>说明</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><code>xClearCountOnExit</code></td>\n<td>函数返回前是否清零： pdTRUE：把通知值清零 pdFALSE：如果通知值大于0，则把通知值减一</td>\n</tr>\n<tr>\n<td align=\"center\"><code>xTicksToWait</code></td>\n<td>任务进入阻塞态的超时时间，它在等待通知值大于0。 0：不等待，即刻返回； portMAX_DELAY：一直等待，直到通知值大于0； 其他值：Tick Count，可以用*pdMS_TO_TICKS()*把ms转换为Tick Count</td>\n</tr>\n<tr>\n<td align=\"center\">返回值</td>\n<td>函数返回之前，在清零或减一之前的通知值。 如果xTicksToWait非0，则返回值有2种情况： 1. 大于0：在超时前，通知值被增加了 2. 等于0：一直没有其他任务增加通知值，最后超时返回0</td>\n</tr>\n</tbody></table>\n<h5 id=\"专业版任务通知\"><a href=\"#专业版任务通知\" class=\"headerlink\" title=\"专业版任务通知\"></a>专业版任务通知</h5><p><strong>xTaskNotify</strong> 函数功能更强大，可以使用不同参数实现各类功能，比如：</p>\n<ul>\n<li>让接收任务的通知值加一：这时 <strong>xTaskNotify()</strong> 等同于 <strong>xTaskNotifyGive()</strong></li>\n<li>设置接收任务的通知值的某一位、某些位，这就是一个轻量级的、更高效的事件组</li>\n<li>把一个新值写入接收任务的通知值：上一次的通知值被读走后，写入才成功。这就是轻量级的、长度为1的队列</li>\n<li>用一个新值覆盖接收任务的通知值：无论上一次的通知值是否被读走，覆盖都成功。类似 <strong>xQueueOverwrite()</strong> 函数，这就是轻量级的邮箱。</li>\n</ul>\n<p><strong>xTaskNotify()</strong> 比 <strong>xTaskNotifyGive()</strong> 更灵活、强大，使用上也就更复杂。<strong>xTaskNotifyFromISR()</strong> 是它对应的ISR版本。</p>\n<p>这两个函数用来发出任务通知，使用哪个函数来取出任务通知呢？</p>\n<p>使用 <strong>xTaskNotifyWait()</strong> 函数！它比 <strong>ulTaskNotifyTake()</strong> 更复杂：</p>\n<ul>\n<li>可以让任务等待(可以加上超时时间)，等到任务状态为”pending”(也就是有数据)</li>\n<li>还可以在函数进入、退出时，清除通知值的指定位</li>\n</ul>\n<p>这几个函数的原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BaseType_t <span class=\"title function_\">xTaskNotify</span><span class=\"params\">( TaskHandle_t xTaskToNotify, <span class=\"type\">uint32_t</span> ulValue, eNotifyAction eAction )</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">BaseType_t <span class=\"title function_\">xTaskNotifyFromISR</span><span class=\"params\">( TaskHandle_t xTaskToNotify,</span></span><br><span class=\"line\"><span class=\"params\">                               <span class=\"type\">uint32_t</span> ulValue, </span></span><br><span class=\"line\"><span class=\"params\">                               eNotifyAction eAction, </span></span><br><span class=\"line\"><span class=\"params\">                               BaseType_t *pxHigherPriorityTaskWoken )</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">BaseType_t <span class=\"title function_\">xTaskNotifyWait</span><span class=\"params\">( <span class=\"type\">uint32_t</span> ulBitsToClearOnEntry, </span></span><br><span class=\"line\"><span class=\"params\">                            <span class=\"type\">uint32_t</span> ulBitsToClearOnExit, </span></span><br><span class=\"line\"><span class=\"params\">                            <span class=\"type\">uint32_t</span> *pulNotificationValue, </span></span><br><span class=\"line\"><span class=\"params\">                            TickType_t xTicksToWait )</span>;</span><br></pre></td></tr></table></figure>\n\n<p><code>xTaskNotify</code>函数的参数说明如下：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\"><strong>参数</strong></th>\n<th><strong>说明</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><code>xTaskToNotify</code></td>\n<td>任务句柄(创建任务时得到)，给哪个任务发通知</td>\n</tr>\n<tr>\n<td align=\"center\"><code>ulValue</code></td>\n<td>怎么使用ulValue，由eAction参数决定</td>\n</tr>\n<tr>\n<td align=\"center\"><code>eAction</code></td>\n<td>见下表</td>\n</tr>\n<tr>\n<td align=\"center\">返回值</td>\n<td>pdPASS：成功，大部分调用都会成功 pdFAIL：只有一种情况会失败，当eAction为eSetValueWithoutOverwrite， 并且通知状态为”pending”(表示有新数据未读)，这时就会失败。</td>\n</tr>\n</tbody></table>\n<p><code>eNotifyAction</code>参数说明：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\"><strong>eNotifyAction取值</strong></th>\n<th><strong>说明</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><code>eNoAction</code></td>\n<td>仅仅是更新通知状态为”pending”，未使用ulValue。 这个选项相当于轻量级的、更高效的二进制信号量。</td>\n</tr>\n<tr>\n<td align=\"center\"><code>eSetBits</code></td>\n<td>通知值 &#x3D; 原来的通知值 | ulValue，按位或。 相当于轻量级的、更高效的事件组。</td>\n</tr>\n<tr>\n<td align=\"center\"><code>eIncrement</code></td>\n<td>通知值 &#x3D; 原来的通知值 + 1，未使用ulValue。 相当于轻量级的、更高效的二进制信号量、计数型信号量。 相当于**xTaskNotifyGive()**函数。</td>\n</tr>\n<tr>\n<td align=\"center\">eSetValueWithoutOverwrite</td>\n<td>不覆盖。 如果通知状态为”pending”(表示有数据未读)， 则此次调用xTaskNotify不做任何事，返回pdFAIL。 如果通知状态不是”pending”(表示没有新数据)， 则：通知值 &#x3D; ulValue。</td>\n</tr>\n<tr>\n<td align=\"center\">eSetValueWithOverwrite</td>\n<td>覆盖。 无论如何，不管通知状态是否为”pendng”， 通知值 &#x3D; ulValue。</td>\n</tr>\n</tbody></table>\n<p>xTaskNotifyFromISR函数跟xTaskNotify很类似，就多了最后一个参数<strong>pxHigherPriorityTaskWoken</strong>。在很多ISR函数中，这个参数的作用都是类似的，使用场景如下：</p>\n<ul>\n<li>被通知的任务，可能正处于阻塞状态</li>\n<li><strong>xTaskNotifyFromISR</strong>函数发出通知后，会把接收任务从阻塞状态切换为就绪态</li>\n<li>如果被唤醒的任务的优先级，高于当前任务的优先级，则”*pxHigherPriorityTaskWoken”被设置为pdTRUE，这表示在中断返回之前要进行任务切换。</li>\n</ul>\n<p>xTaskNotifyWait函数列表如下：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\"><strong>参数</strong></th>\n<th><strong>说明</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><code>ulBitsToClearOnEntry</code></td>\n<td>在xTaskNotifyWait入口处，要清除通知值的哪些位？ 通知状态不是”pending”的情况下，才会清除。 它的本意是：我想等待某些事件发生，所以先把”旧数据”的某些位清零。 能清零的话：通知值 &#x3D; 通知值 &amp; ~(ulBitsToClearOnEntry)。 比如传入0x01，表示清除通知值的bit0； 传入0xffffffff即ULONG_MAX，表示清除所有位，即把值设置为0</td>\n</tr>\n<tr>\n<td align=\"center\"><code>ulBitsToClearOnExit</code></td>\n<td>在xTaskNotifyWait出口处，如果不是因为超时推出，而是因为得到了数据而退出时： 通知值 &#x3D; 通知值 &amp; ~(ulBitsToClearOnExit)。 在清除某些位之前，通知值先被赋给”*pulNotificationValue”。 比如入0x03，表示清除通知值的bit0、bit1； 传入0xffffffff即ULONG_MAX，表示清除所有位，即把值设置为0</td>\n</tr>\n<tr>\n<td align=\"center\"><code>pulNotificationValue</code></td>\n<td>用来取出通知值。 在函数退出时，使用ulBitsToClearOnExit清除之前，把通知值赋给”*pulNotificationValue”。 如果不需要取出通知值，可以设为NULL。</td>\n</tr>\n<tr>\n<td align=\"center\"><code>xTicksToWait</code></td>\n<td>任务进入阻塞态的超时时间，它在等待通知状态变为”pending”。 0：不等待，即刻返回； portMAX_DELAY：一直等待，直到通知状态变为”pending”； 其他值：Tick Count，可以用*pdMS_TO_TICKS()*把ms转换为Tick Count</td>\n</tr>\n<tr>\n<td align=\"center\">返回值</td>\n<td>1. pdPASS：成功 这表示xTaskNotifyWait成功获得了通知： 可能是调用函数之前，通知状态就是”pending”； 也可能是在阻塞期间，通知状态变为了”pending”。 2. pdFAIL：没有得到通知。</td>\n</tr>\n</tbody></table>\n","excerpt":"","more":"<h2 id=\"FreeRTOS基础\"><a href=\"#FreeRTOS基础\" class=\"headerlink\" title=\"FreeRTOS基础\"></a>FreeRTOS基础</h2><h3 id=\"获取系统时间\"><a href=\"#获取系统时间\" class=\"headerlink\" title=\"获取系统时间\"></a>获取系统时间</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TickType_t currentTicks;</span><br><span class=\"line\"><span class=\"keyword\">while</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">     currentTicks = xTaskGetTickCount();</span><br><span class=\"line\">     <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;[%lu]dev:%u,name:%s\\r\\n&quot;</span>, currentTicks, data-&gt;dev, data-&gt;data);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"堆和栈\"><a href=\"#堆和栈\" class=\"headerlink\" title=\"堆和栈\"></a>堆和栈</h3><p>堆：一块空闲的内存 可以使用<code>malloc</code>申请内存 使用完后用<code>free</code>释放内存</p>\n<blockquote>\n<p>堆也可以理解为就是定义了一个堆大小的数组 然后定义一个长度 每次动态改变长度来申请空间（链表）</p>\n<p>在<code>FreeRTOSConfig.h</code>中就有定义堆大小的宏<code>configTOTAL_HEAP_SIZE</code> 他被引用到 <code>heap.c</code>中的 <code>static uint8_t ucHeap[configTOTAL_HEAP_SIZE];</code></p>\n</blockquote>\n<p>栈：一块内存空间，CPU的SP寄存器指向它，它可以用于函数调用、局部变量、<code>多任务系统里保存现场</code></p>\n<blockquote>\n<p>栈是<code>FreeRTOS</code>中非常重要的概念，每个任务都有自己的栈</p>\n</blockquote>\n<h3 id=\"FreeRTOS源码概述\"><a href=\"#FreeRTOS源码概述\" class=\"headerlink\" title=\"FreeRTOS源码概述\"></a>FreeRTOS源码概述</h3><h4 id=\"目录结构\"><a href=\"#目录结构\" class=\"headerlink\" title=\"目录结构\"></a>目录结构</h4><p><img src=\"https://photos.100ask.net/renesas-docs/DShanMCU_RA6M5/FreeRTOS/chapter-6/image1.png\" alt=\"img\"></p>\n<blockquote>\n<p>主要涉及3个目录：</p>\n<ul>\n<li><code>ra\\aws\\FreeRTOS\\FreeRTOS\\Source</code>：存放的是FreeRTOS的核心文件</li>\n<li><code>ra_gen</code>：从main.c可以看到创建任务的函数调用过程</li>\n<li><code>src</code>：使用RASC创建任务时，在src目录下生成任务的入口函数</li>\n</ul>\n</blockquote>\n<h4 id=\"核心文件\"><a href=\"#核心文件\" class=\"headerlink\" title=\"核心文件\"></a>核心文件</h4><blockquote>\n<p>FreeRTOS的最核心文件只有2个：</p>\n<ul>\n<li><code>FreeRTOS/Source/tasks.c</code></li>\n<li><code>FreeRTOS/Source/list.c</code></li>\n</ul>\n</blockquote>\n<p>其他文件的作用也一起列表如下：</p>\n<table>\n<thead>\n<tr>\n<th><strong><code>FreeRTOS/Source/</code>下的文件</strong></th>\n<th><strong>作用</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>tasks.c</code></td>\n<td>必需，任务操作</td>\n</tr>\n<tr>\n<td><code>list.c</code></td>\n<td>必须，列表</td>\n</tr>\n<tr>\n<td><code>queue.c</code></td>\n<td>基本必需，提供队列操作、信号量(semaphore)操作</td>\n</tr>\n<tr>\n<td><code>timer.c</code></td>\n<td>可选，software timer</td>\n</tr>\n<tr>\n<td><code>event_groups.c</code></td>\n<td>可选，提供event group功能</td>\n</tr>\n</tbody></table>\n<h4 id=\"头文件相关\"><a href=\"#头文件相关\" class=\"headerlink\" title=\"头文件相关\"></a>头文件相关</h4><h5 id=\"头文件目录\"><a href=\"#头文件目录\" class=\"headerlink\" title=\"头文件目录\"></a>头文件目录</h5><blockquote>\n<p>FreeRTOS需要3个头文件目录：</p>\n<ul>\n<li>FreeRTOS本身的头文件：<code>ra\\aws\\FreeRTOS\\FreeRTOS\\Source\\include</code></li>\n<li>移植时用到的头文件：<code>ra\\fsp\\src\\rm_freertos_port\\portmacro.h</code></li>\n<li>含有配置文件<code>FreeRTOSConfig.h</code>的目录：<code>ra_cfg\\aws</code></li>\n</ul>\n</blockquote>\n<h5 id=\"头文件\"><a href=\"#头文件\" class=\"headerlink\" title=\"头文件\"></a>头文件</h5><p>列表如下：</p>\n<table>\n<thead>\n<tr>\n<th><strong>头文件</strong></th>\n<th><strong>作用</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>FreeRTOSConfig.h</code></td>\n<td>FreeRTOS的配置文件，比如选择调度算法：<code>configUSE_PREEMPTION</code> 每个工程都必定含有<code>FreeRTOSConfig.h</code></td>\n</tr>\n<tr>\n<td><code>FreeRTOS.h</code></td>\n<td>使用FreeRTOS API函数时，<span style=\"font-weight:bold;\">必须</span>包含此文件。 在<code>FreeRTOS.h</code>之后，再去包含其他头文件，比如： <code>task.h</code>、<code>queue.h</code>、<code>semphr.h</code>、<code>event_group.h</code></td>\n</tr>\n</tbody></table>\n<h4 id=\"独属于FreeRTOS的数据类型和编程规范\"><a href=\"#独属于FreeRTOS的数据类型和编程规范\" class=\"headerlink\" title=\"独属于FreeRTOS的数据类型和编程规范\"></a>独属于FreeRTOS的数据类型和编程规范</h4><h5 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h5><p>每个移植的版本都含有自己的 <strong><code>portmacro.h</code></strong> 头文件，里面定义了2个数据类型：</p>\n<ol>\n<li><code>TickType_t</code>：<ul>\n<li>时钟计数单位 （可以是uint16_t 也可以是uint32_t）<br>当<code>FreeRTOSConfig.h</code>中定义<code>configUSE_16_BIT_TICKS时 TickType_t</code>则为uint16_t</li>\n</ul>\n</li>\n</ol>\n<blockquote>\n<p>对于32位架构，建议把TickType_t配置为uint32_t</p>\n</blockquote>\n<ol start=\"2\">\n<li><code>BaseType_t</code>:这是该架构最高效的数据类型(取决于CPU是多少位的架构)<ul>\n<li><code>BaseType_t</code>通常用作简单的返回值的类型，还有逻辑值，比如 <strong>pdTRUE&#x2F;pdFALSE</strong></li>\n</ul>\n</li>\n</ol>\n<h5 id=\"变量名\"><a href=\"#变量名\" class=\"headerlink\" title=\"变量名\"></a>变量名</h5><p>变量名的前缀 对应其类型 如：<code>pcName</code> (代表着他是一个指向char类型的指针p)</p>\n<table>\n<thead>\n<tr>\n<th><strong>变量名前缀</strong></th>\n<th><strong>含义</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>c</td>\n<td>char</td>\n</tr>\n<tr>\n<td>s</td>\n<td>int16_t，short</td>\n</tr>\n<tr>\n<td>l</td>\n<td>int32_t，long</td>\n</tr>\n<tr>\n<td>x</td>\n<td>BaseType_t， 其他非标准的类型：结构体、task handle、queue handle等</td>\n</tr>\n<tr>\n<td>u</td>\n<td>unsigned</td>\n</tr>\n<tr>\n<td>p</td>\n<td>指针</td>\n</tr>\n<tr>\n<td>uc</td>\n<td>uint8_t，unsigned char</td>\n</tr>\n<tr>\n<td>pc</td>\n<td>char指针</td>\n</tr>\n</tbody></table>\n<h5 id=\"函数名\"><a href=\"#函数名\" class=\"headerlink\" title=\"函数名\"></a>函数名</h5><p>函数名的前缀有2部分：返回值类型、在哪个文件定义。</p>\n<table>\n<thead>\n<tr>\n<th><strong>函数名前缀</strong></th>\n<th><strong>含义</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>v<span style=\"font-weight:bold;\">Task</span>PrioritySet</td>\n<td>返回值类型：void 在<code>task.c</code>中定义</td>\n</tr>\n<tr>\n<td>x<span style=\"font-weight:bold;\">Queue</span>Receive</td>\n<td>返回值类型：BaseType_t 在<code>queue.c</code>中定义</td>\n</tr>\n<tr>\n<td>pv<span style=\"font-weight:bold;\">Timer</span>GetTimerID</td>\n<td>返回值类型：pointer to void 在<code>tmer.c</code>中定义</td>\n</tr>\n</tbody></table>\n<h5 id=\"宏的名\"><a href=\"#宏的名\" class=\"headerlink\" title=\"宏的名\"></a>宏的名</h5><p>宏的名字是大小，可以添加小写的前缀。前缀是用来表示：宏在<span style=\"font-weight:bold;\">哪个文件</span>中定义。</p>\n<table>\n<thead>\n<tr>\n<th><strong>宏的前缀</strong></th>\n<th><strong>含义：在哪个文件里定义</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>port (比如<span style=\"font-weight:bold;\">port</span>MAX_DELAY)</td>\n<td><code>portable.h</code>或<code>portmacro.h</code></td>\n</tr>\n<tr>\n<td>task (比如<span style=\"font-weight:bold;\">task</span>ENTER_CRITICAL())</td>\n<td><code>task.h</code></td>\n</tr>\n<tr>\n<td>pd (比如<span style=\"font-weight:bold;\">pd</span>TRUE)</td>\n<td><code>projdefs.h</code></td>\n</tr>\n<tr>\n<td>config (比如<span style=\"font-weight:bold;\">config</span>USE_PREEMPTION)</td>\n<td><code>FreeRTOSConfig.h</code></td>\n</tr>\n<tr>\n<td>err (比如<span style=\"font-weight:bold;\">err</span>QUEUE_FULL)</td>\n<td><code>projdefs.h</code></td>\n</tr>\n</tbody></table>\n<p>通用的宏定义如下：</p>\n<table>\n<thead>\n<tr>\n<th><strong>宏</strong></th>\n<th><strong>值</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>pdTRUE</code></td>\n<td>1</td>\n</tr>\n<tr>\n<td><code>pdFALSE</code></td>\n<td>0</td>\n</tr>\n<tr>\n<td><code>pdPASS</code></td>\n<td>1</td>\n</tr>\n<tr>\n<td><code>pdFAIL</code></td>\n<td>0</td>\n</tr>\n</tbody></table>\n<h3 id=\"内存管理\"><a href=\"#内存管理\" class=\"headerlink\" title=\"内存管理\"></a>内存管理</h3><blockquote>\n<p> FreeRTOS中内存管理的接口函数为：<code>pvPortMalloc</code> 、<code>vPortFree</code>，对应于C库的<code>malloc</code>、<code>free</code>。 文件在<code>FreeRTOS/Source/portable/MemMang</code>下，它也是放在<code>portable目录</code>下，表示你可以提供自己的函数。</p>\n<p>源码中默认提供了5个文件，对应内存管理的5种方法。</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th><strong>文件</strong></th>\n<th><strong>优点</strong></th>\n<th><strong>缺点</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>heap_1.c</code></td>\n<td>分配简单，时间确定</td>\n<td>只分配、<span style=\"color:#FF0000;\">不回收</span></td>\n</tr>\n<tr>\n<td><code>heap_2.c</code></td>\n<td>动态分配、最佳匹配</td>\n<td><span style=\"color:#FF0000;\">碎片</span>、时间不定</td>\n</tr>\n<tr>\n<td><code>heap_3.c</code></td>\n<td>调用<span style=\"color:#FF3333;\">标准库</span>函数</td>\n<td><span style=\"color:#FF0000;\">速度慢</span>、时间不定</td>\n</tr>\n<tr>\n<td><code>heap_4.c</code>(常用)</td>\n<td>相邻空闲内存可合并</td>\n<td>可解决碎片问题、时间不定</td>\n</tr>\n<tr>\n<td><code>heap_5.c</code></td>\n<td>在heap_4基础上支持分隔的内存块</td>\n<td>可解决碎片问题、时间不定</td>\n</tr>\n</tbody></table>\n<h4 id=\"Heap相关的函数\"><a href=\"#Heap相关的函数\" class=\"headerlink\" title=\"Heap相关的函数\"></a>Heap相关的函数</h4><h5 id=\"分配、释放内存\"><a href=\"#分配、释放内存\" class=\"headerlink\" title=\"分配、释放内存\"></a>分配、释放内存</h5><p>函数原型：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> * <span class=\"title function_\">pvPortMalloc</span><span class=\"params\">( <span class=\"type\">size_t</span> xWantedSize )</span>;</span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">vPortFree</span><span class=\"params\">( <span class=\"type\">void</span> * pv )</span>;</span><br></pre></td></tr></table></figure>\n\n<p>作用：分配内存、释放内存。</p>\n<p>如果分配内存不成功，则返回值为NULL。</p>\n<h5 id=\"检测剩余多少空闲内存\"><a href=\"#检测剩余多少空闲内存\" class=\"headerlink\" title=\"检测剩余多少空闲内存\"></a>检测剩余多少空闲内存</h5><p>函数原型：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">size_t</span> <span class=\"title function_\">xPortGetFreeHeapSize</span><span class=\"params\">( <span class=\"type\">void</span> )</span>;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>当前还有多少空闲内存，这函数可以用来优化内存的使用情况。比如当所有内核对象都分配好后，执行此函数返回2000，那么<code>configTOTAL_HEAP_SIZE</code>就可减小2000。</p>\n</blockquote>\n<p>注意：在heap_3中无法使用。</p>\n<h5 id=\"获取空闲内存容量的最小值\"><a href=\"#获取空闲内存容量的最小值\" class=\"headerlink\" title=\"获取空闲内存容量的最小值\"></a>获取空闲内存容量的最小值</h5><p>函数原型：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">size_t</span> <span class=\"title function_\">xPortGetMinimumEverFreeHeapSize</span><span class=\"params\">( <span class=\"type\">void</span> )</span>;</span><br></pre></td></tr></table></figure>\n\n<p>返回：程序运行过程中，空闲内存容量的最小值。</p>\n<p>注意：只有heap_4、heap_5支持此函数。</p>\n<h5 id=\"malloc失败的钩子函数\"><a href=\"#malloc失败的钩子函数\" class=\"headerlink\" title=\"malloc失败的钩子函数\"></a><code>malloc失败的钩子函数</code></h5><p>在pvPortMalloc函数内部：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> * <span class=\"title function_\">pvPortMalloc</span><span class=\"params\">( <span class=\"type\">size_t</span> xWantedSize )</span>vPortDefineHeapRegions</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ......</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"keyword\">if</span> ( configUSE_MALLOC_FAILED_HOOK == 1 )</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>( pvReturn == <span class=\"literal\">NULL</span> )</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">extern</span> <span class=\"type\">void</span> <span class=\"title function_\">vApplicationMallocFailedHook</span><span class=\"params\">( <span class=\"type\">void</span> )</span>;</span><br><span class=\"line\">                vApplicationMallocFailedHook();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> pvReturn;        </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>所以，如果想使用这个钩子函数：</p>\n<ul>\n<li>在<code>FreeRTOSConfig.h</code>中，把<code>configUSE_MALLOC_FAILED_HOOK</code>定义为1</li>\n<li>提供<code>vApplicationMallocFailedHook</code>函数</li>\n<li><code>pvPortMalloc</code>失败时，才会调用此函数</li>\n</ul>\n<h3 id=\"任务管理\"><a href=\"#任务管理\" class=\"headerlink\" title=\"任务管理\"></a>任务管理</h3><h4 id=\"任务创建与删除\"><a href=\"#任务创建与删除\" class=\"headerlink\" title=\"任务创建与删除\"></a>任务创建与删除</h4><h5 id=\"什么是任务\"><a href=\"#什么是任务\" class=\"headerlink\" title=\"什么是任务\"></a>什么是任务</h5><p>在FreeRTOS中，任务就是一个函数，原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">ATaskFunction</span><span class=\"params\">( <span class=\"type\">void</span> *pvParameters )</span>;</span><br></pre></td></tr></table></figure>\n\n<p>要注意的是：</p>\n<ul>\n<li>这个函数不能返回</li>\n<li>同一个函数，可以用来创建多个任务；换句话说，多个任务可以运行同一个函数</li>\n<li>函数内部，尽量使用局部变量：<ul>\n<li>每个任务都有自己的栈</li>\n<li>每个任务运行这个函数时<ul>\n<li>任务A的局部变量放在任务A的栈里、任务B的局部变量放在任务B的栈里</li>\n<li>不同任务的局部变量，有自己的副本</li>\n</ul>\n</li>\n<li>函数使用全局变量、静态变量的话<ul>\n<li>只有一个副本：多个任务使用的是同一个副本</li>\n<li>要防止冲突(后续会讲) 下面是一个示例：</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">ATaskFunction</span><span class=\"params\">( <span class=\"type\">void</span> *pvParameters )</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"comment\">/* 对于不同的任务，局部变量放在任务的栈里，有各自的副本 */</span></span><br><span class=\"line\">\t<span class=\"type\">int32_t</span> lVariableExample = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t</span><br><span class=\"line\">    <span class=\"comment\">/* 任务函数通常实现为一个无限循环 */</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>( ;; )</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">/* 任务的代码 */</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* 如果程序从循环中退出，一定要使用vTaskDelete删除自己</span></span><br><span class=\"line\"><span class=\"comment\">     * NULL表示删除的是自己</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">\tvTaskDelete( <span class=\"literal\">NULL</span> );</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/* 程序不会执行到这里, 如果执行到这里就出错了 */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"创建任务\"><a href=\"#创建任务\" class=\"headerlink\" title=\"创建任务\"></a>创建任务</h5><p>创建任务时使用的函数如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BaseType_t <span class=\"title function_\">xTaskCreate</span><span class=\"params\">( TaskFunction_t pxTaskCode, <span class=\"comment\">// 函数指针, 任务函数</span></span></span><br><span class=\"line\"><span class=\"params\">                        <span class=\"type\">const</span> <span class=\"type\">char</span> * <span class=\"type\">const</span> pcName, <span class=\"comment\">// 任务的名字</span></span></span><br><span class=\"line\"><span class=\"params\">                        <span class=\"type\">const</span> configSTACK_DEPTH_TYPE usStackDepth, <span class=\"comment\">// 栈大小,单位为word,10表示40字节</span></span></span><br><span class=\"line\"><span class=\"params\">                        <span class=\"type\">void</span> * <span class=\"type\">const</span> pvParameters, <span class=\"comment\">// 调用任务函数时传入的参数</span></span></span><br><span class=\"line\"><span class=\"params\">                        UBaseType_t uxPriority,    <span class=\"comment\">// 优先级</span></span></span><br><span class=\"line\"><span class=\"params\">                        TaskHandle_t * <span class=\"type\">const</span> pxCreatedTask )</span>; <span class=\"comment\">// 任务句柄, 以后使用它来操作这个任务</span></span><br></pre></td></tr></table></figure>\n\n<p>参数说明：</p>\n<table>\n<thead>\n<tr>\n<th><strong>参数</strong></th>\n<th><strong>描述</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>pvTaskCode</td>\n<td>函数指针，任务对应的 C 函数。任务应该永远不退出，或者在退出时调用 “<code>vTaskDelete(NULL)</code>“。</td>\n</tr>\n<tr>\n<td>pcName</td>\n<td>任务的名称，仅用于调试目的，FreeRTOS 内部不使用。pcName 的长度为 <code>configMAX_TASK_NAME_LEN</code>。</td>\n</tr>\n<tr>\n<td>usStackDepth</td>\n<td>每个任务都有自己的栈，usStackDepth 指定了栈的大小，单位为 word。例如，如果传入 100，表示栈的大小为 100 word，即 400 字节。最大值为 uint16_t 的最大值。确定栈的大小并不容易，通常是根据估计来设定。精确的办法是查看反汇编代码。</td>\n</tr>\n<tr>\n<td>pvParameters</td>\n<td>调用 pvTaskCode 函数指针时使用的参数：<code>pvTaskCode(pvParameters)</code>。</td>\n</tr>\n<tr>\n<td>uxPriority</td>\n<td>任务的优先级范围为 0~(<code>configMAX_PRIORITIES – 1</code>)。数值越小，优先级越低。如果传入的值过大，<code>xTaskCreate </code>会将其调整为 (<code>configMAX_PRIORITIES – 1</code>)。</td>\n</tr>\n<tr>\n<td>pxCreatedTask</td>\n<td>用于保存 xTaskCreate 的输出结果，即任务的句柄（task handle）。如果以后需要对该任务进行操作，如修改优先级，则需要使用此句柄。如果不需要使用该句柄，可以传入 NULL。</td>\n</tr>\n<tr>\n<td>返回值</td>\n<td>成功时返回 pdPASS，失败时返回 <code>errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY</code>（失败原因是内存不足）。请注意，文档中提到的失败返回值是 pdFAIL 是不正确的。pdFAIL 的值为 0，而 <code>errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY</code> 的值为 -1。</td>\n</tr>\n</tbody></table>\n<p>使用静态分配内存的函数如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TaskHandle_t <span class=\"title function_\">xTaskCreateStatic</span> <span class=\"params\">( </span></span><br><span class=\"line\"><span class=\"params\">    TaskFunction_t pxTaskCode,   <span class=\"comment\">// 函数指针, 任务函数</span></span></span><br><span class=\"line\"><span class=\"params\">    <span class=\"type\">const</span> <span class=\"type\">char</span> * <span class=\"type\">const</span> pcName,   <span class=\"comment\">// 任务的名字</span></span></span><br><span class=\"line\"><span class=\"params\">    <span class=\"type\">const</span> <span class=\"type\">uint32_t</span> ulStackDepth, <span class=\"comment\">// 栈大小,单位为word,10表示40字节</span></span></span><br><span class=\"line\"><span class=\"params\">    <span class=\"type\">void</span> * <span class=\"type\">const</span> pvParameters,   <span class=\"comment\">// 调用任务函数时传入的参数</span></span></span><br><span class=\"line\"><span class=\"params\">    UBaseType_t uxPriority,      <span class=\"comment\">// 优先级</span></span></span><br><span class=\"line\"><span class=\"params\">    StackType_t * <span class=\"type\">const</span> puxStackBuffer, <span class=\"comment\">// 静态分配的栈，就是一个buffer</span></span></span><br><span class=\"line\"><span class=\"params\">    StaticTask_t * <span class=\"type\">const</span> pxTaskBuffer <span class=\"comment\">// 静态分配的任务结构体的指针，用它来操作这个任务</span></span></span><br><span class=\"line\"><span class=\"params\">)</span>;</span><br></pre></td></tr></table></figure>\n\n<p>相比于使用动态分配内存创建任务的函数，最后2个参数不一样：</p>\n<table>\n<thead>\n<tr>\n<th><strong>参数</strong></th>\n<th><strong>描述</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>pvTaskCode</td>\n<td>函数指针，可以简单地认为任务就是一个C函数。 它稍微特殊一点：永远不退出，或者退出时要调用”<code>vTaskDelete(NULL)</code>“</td>\n</tr>\n<tr>\n<td>pcName</td>\n<td>任务的名字，FreeRTOS内部不使用它，仅仅起调试作用。 长度为：<code>configMAX_TASK_NAME_LEN</code></td>\n</tr>\n<tr>\n<td>usStackDepth</td>\n<td>每个任务都有自己的栈，这里指定栈大小。 单位是word，比如传入100，表示栈大小为100 word，也就是400字节。 最大值为uint16_t的最大值。 怎么确定栈的大小，并不容易，很多时候是估计。 精确的办法是看反汇编码。</td>\n</tr>\n<tr>\n<td>pvParameters</td>\n<td>调用pvTaskCode函数指针时用到：pvTaskCode(pvParameters)</td>\n</tr>\n<tr>\n<td>uxPriority</td>\n<td>优先级范围：0~(<code>configMAX_PRIORITIES – 1</code>) 数值越小优先级越低， 如果传入过大的值，<code>xTaskCreate</code>会把它调整为(<code>configMAX_PRIORITIES – 1</code>)</td>\n</tr>\n<tr>\n<td>puxStackBuffer</td>\n<td>静态分配的栈内存，比如可以传入一个数组， 它的大小是<code>usStackDepth*4</code>。</td>\n</tr>\n<tr>\n<td>pxTaskBuffer</td>\n<td>静态分配的<code>StaticTask_t</code>结构体的指针</td>\n</tr>\n<tr>\n<td>返回值</td>\n<td>成功：返回任务句柄； 失败：NULL</td>\n</tr>\n</tbody></table>\n<h4 id=\"任务栈大小估算\"><a href=\"#任务栈大小估算\" class=\"headerlink\" title=\"任务栈大小估算\"></a>任务栈大小估算</h4><p>任务栈空间包含</p>\n<ul>\n<li>返回地址<code>LR</code>与其他寄存器：可以理解为<span style=\"color:#FF0000;\">函数调用深度</span></li>\n<li>局部变量：如<code>char buff[1000]</code> 直接看类型 此处则可以算1个</li>\n<li>保留现场：可以理解为固定16个寄存器 即<span style=\"color:#FF3333;\">16 * 4 &#x3D; 64b</span></li>\n</ul>\n<blockquote>\n<p>公式如下：</p>\n<ul>\n<li><p>（n层调用 * 36） + 局部变量 + 64b</p>\n</li>\n<li><p>例如：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509142214793.png\" alt=\"image-20250914221448446\"></p>\n</li>\n</ul>\n</blockquote>\n<h4 id=\"使用任务参数\"><a href=\"#使用任务参数\" class=\"headerlink\" title=\"使用任务参数\"></a>使用任务参数</h4><p>我们说过，多个任务可以使用同一个函数，怎么体现它们的差别？</p>\n<ul>\n<li>栈不同</li>\n<li>创建任务时可以传入不同的参数</li>\n</ul>\n<p>我们创建2个任务，使用同一个函数，但是在LCD上打印不一样的信息。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span>&#123;</span></span><br><span class=\"line\">    <span class=\"type\">int</span> x;</span><br><span class=\"line\">    <span class=\"type\">int</span> y;</span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">char</span> *str;</span><br><span class=\"line\">&#125;DisplayInfo;</span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">vTaskFunction</span><span class=\"params\">( <span class=\"type\">void</span> *pvParameters )</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tDisplayInfo *info = pvParameters;</span><br><span class=\"line\">\t<span class=\"type\">uint32_t</span> cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"type\">uint32_t</span> len;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">/* 任务函数的主体一般都是无限循环 */</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>( ;; )</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">/* 打印任务的信息 */</span></span><br><span class=\"line\">\t\tlen = LCD_PrintString(info-&gt;x, info-&gt;y, info-&gt;str);</span><br><span class=\"line\">\t\tLCD_PrintSignedVal(len+<span class=\"number\">1</span>, info-&gt;y, cnt++);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tmdelay(<span class=\"number\">500</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上述代码中的info来自参数pvParameters，pvParameters来自哪里？创建任务时传入的。</p>\n<p>代码如下：</p>\n<ul>\n<li>使用xTaskCreate创建任务时，第4个参数就是pvParameters</li>\n<li>不同的任务，pvParameters不一样</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DisplayInfo g_Task1Info =&#123;<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"string\">&quot;task1&quot;</span>&#125;;</span><br><span class=\"line\">DisplayInfo g_Task2Info =&#123;<span class=\"number\">3</span>,<span class=\"number\">0</span>,<span class=\"string\">&quot;task2&quot;</span>&#125;;</span><br><span class=\"line\">DisplayInfo g_Task3Info =&#123;<span class=\"number\">6</span>,<span class=\"number\">0</span>,<span class=\"string\">&quot;task3&quot;</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 使用同一个函数创建不同的任务 */</span></span><br><span class=\"line\">  xTaskCreate(LcdPrintTask, <span class=\"string\">&quot;task1&quot;</span>, <span class=\"number\">128</span>, &amp;g_Task1Info, osPriorityNormal, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">  xTaskCreate(LcdPrintTask, <span class=\"string\">&quot;task2&quot;</span>, <span class=\"number\">128</span>, &amp;g_Task2Info, osPriorityNormal, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">  xTaskCreate(LcdPrintTask, <span class=\"string\">&quot;task3&quot;</span>, <span class=\"number\">128</span>, &amp;g_Task3Info, osPriorityNormal, <span class=\"literal\">NULL</span>);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"任务的删除\"><a href=\"#任务的删除\" class=\"headerlink\" title=\"任务的删除\"></a>任务的删除</h4><p>删除任务时使用的函数如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">vTaskDelete</span><span class=\"params\">( TaskHandle_t xTaskToDelete )</span>;</span><br></pre></td></tr></table></figure>\n\n<p>参数说明：</p>\n<table>\n<thead>\n<tr>\n<th><strong>参数</strong></th>\n<th><strong>描述</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>pvTaskCode</td>\n<td>任务句柄，使用xTaskCreate创建任务时可以得到一个句柄。 也可传入NULL，这表示删除自己。</td>\n</tr>\n</tbody></table>\n<p>怎么删除任务？举个不好的例子：</p>\n<ul>\n<li>自杀：<code>vTaskDelete(NULL)</code></li>\n<li>被杀：别的任务执行<code>vTaskDelete(pvTaskCode)</code>，<code>pvTaskCode</code>是自己的句柄</li>\n<li>杀人：执行<code>vTaskDelete(pvTaskCode)</code>，<code>pvTaskCode</code>是别的任务的句柄</li>\n</ul>\n<h4 id=\"任务管理与调度机制\"><a href=\"#任务管理与调度机制\" class=\"headerlink\" title=\"任务管理与调度机制\"></a>任务管理与调度机制</h4><h5 id=\"调度机制\"><a href=\"#调度机制\" class=\"headerlink\" title=\"调度机制\"></a>调度机制</h5><blockquote>\n<ul>\n<li>同等优先级的任务 轮流运行</li>\n<li>最高优先级的任务先运行<ul>\n<li>高优先级的任务未运行完，低优先级任务无法运行</li>\n<li>一旦高优先级任务就绪 马上运行</li>\n<li>最高优先级的任务有多个 他们轮流运行</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509151548547.png\" alt=\"img\"></p>\n<h5 id=\"任务管理-1\"><a href=\"#任务管理-1\" class=\"headerlink\" title=\"任务管理\"></a>任务管理</h5><p>任务的切换通过链表操作进行切换 RTOS会创建3个链表 分别是就绪链表ReadyList、阻塞链表DelayTaskList、挂起链表</p>\n<ul>\n<li><p>先在优先级数组中按下标从大到小遍历，使用任务创建函数<span style=\"color:#33FFFF;\">本质其实是在对应优先级数组中创建TCB结构体，并且会有一个全局指针——当前执行TCB结构体pxCurrentTCB</span>，这就说明了为什么同等优先级下，最后创建的任务先运行（因为指针最终指向了最后一个任务链表，启动调度器后，开始运行）</p>\n</li>\n<li><p>当调用<code>vTaskDelay</code>后会将当前任务链表丢到阻塞链表上，并根据<code>vTaskDelay</code>的参数等待<code>Tick中断</code>判断到达时间后，该任务链表才能再次回到原先链表上</p>\n</li>\n<li><p>当任务调用<code>vTaskSuspend</code>后 当前任务会被丢到挂起链表，此任务只有调用<code>vTaskResume</code>才能回到原先链表，不能通过<code>Tick中断</code>回归</p>\n</li>\n</ul>\n<blockquote>\n<p>Tick中断是什么？他又做些什么？</p>\n<ul>\n<li><p>Tick中断来源于</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509151600535.png\" alt=\"image-20250915160032344\"></p>\n</li>\n<li><p>Tick中断做什么？</p>\n<ol>\n<li>有个计数器count，count一直执行++</li>\n<li>判断DelayTaskList里任务是否可以恢复（可恢复则将其丢到ReadyList）</li>\n<li>发起调度（遍历优先级数组，改变pxCurrentTCB指针指向）</li>\n</ol>\n</li>\n</ul>\n</blockquote>\n<h5 id=\"空闲任务\"><a href=\"#空闲任务\" class=\"headerlink\" title=\"空闲任务\"></a>空闲任务</h5><p>空闲任务是Freertos启动调度器时 会自动创建的一个最低优先级的任务<code>prvIdleTask</code></p>\n<ul>\n<li>负责清理用户的自杀任务 如<code>vTaskDelete(NULL)</code>的内存释放</li>\n<li>由于优先级最低 所以当用户任务不释放CPU时，就会导致空闲任务不会运行，因而<code>vTaskDelete(NULL)</code>得不到释放</li>\n<li>因此尽量不要使用死延时，改用<code>vTaskDelay</code>释放CPU 或者不使用自杀函数<code>vTaskDelete(NULL)</code></li>\n</ul>\n<blockquote>\n<p>此外 空闲任务中还有提供钩子函数 可以方便我们在里面打印调试信息</p>\n<p>注意每个任务都要使用while(1)进行死循环</p>\n<ul>\n<li>如果有一个任务没有则会触发任务退出错误中断<code>prvTaskExitError</code></li>\n<li><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509151634028.png\" alt=\"image-20250915163446773\"></li>\n</ul>\n</blockquote>\n<h3 id=\"同步与互斥\"><a href=\"#同步与互斥\" class=\"headerlink\" title=\"同步与互斥\"></a>同步与互斥</h3><h4 id=\"同步与互斥的概念\"><a href=\"#同步与互斥的概念\" class=\"headerlink\" title=\"同步与互斥的概念\"></a>同步与互斥的概念</h4><p>一句话理解同步与互斥：我等你用完厕所，我再用厕所。</p>\n<ul>\n<li>什么叫同步？就是：哎哎哎，我正在用厕所，你等会。 </li>\n<li>什么叫互斥？就是：哎哎哎，我正在用厕所，你不能进来。</li>\n</ul>\n<p>同步与互斥经常放在一起讲，是因为它们之的关系很大，“互斥”操作可以使用“同步”来实现。我“等”你用完厕所，我再用厕所。这不就是用“同步”来实现“互斥”吗？</p>\n<p>再举一个例子。在团队活动里，同事A先写完报表，经理B才能拿去向领导汇报。经理B必须等同事A完成报表，AB之间有依赖，B必须放慢脚步，被称为同步。在团队活动中，同事A已经使用会议室了，经理B也想使用，即使经理B是领导，他也得等着，这就叫互斥。经理B跟同事A说：你用完会议室就提醒我。这就是使用”同步”来实现”互斥”。</p>\n<p>有时候看代码更容易理解，伪代码如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span>  抢厕所(<span class=\"type\">void</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (有人在用) 我眯一会;</span><br><span class=\"line\">  用厕所;</span><br><span class=\"line\">  喂，醒醒，有人要用厕所吗;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>假设有A、B两人早起抢厕所，A先行一步占用了；B慢了一步，于是就眯一会；当A用完后叫醒B，B也就愉快地上厕所了。</p>\n<p>在这个过程中，A、B是互斥地访问“厕所”，“厕所”被称之为临界资源。我们使用了“休眠-唤醒”的同步机制实现了“临界资源”的“互斥访问”。</p>\n<p>同一时间只能有一个人使用的资源，被称为临界资源。比如任务A、B都要使用串口来打印，串口就是临界资源。如果A、B同时使用串口，那么打印出来的信息就是A、B混杂，无法分辨。所以使用串口时，应该是这样：A用完，B再用；B用完，A再用</p>\n<h4 id=\"各类方法的对比\"><a href=\"#各类方法的对比\" class=\"headerlink\" title=\"各类方法的对比\"></a>各类方法的对比</h4><p>能实现同步、互斥的内核方法有：任务通知(task notification)、队列(queue)、事件组(event group)、信号量(semaphoe)、互斥量(mutex)。</p>\n<p>它们都有类似的操作方法：获取&#x2F;释放、阻塞&#x2F;唤醒、超时。比如：</p>\n<ul>\n<li>任务A获取资源，用完后任务A释放资源</li>\n<li>任务A获取不到资源则阻塞，任务B释放资源并把任务A唤醒</li>\n<li>任务A获取不到资源则阻塞，并定个闹钟；A要么超时返回，要么在这段时间内因为任务B释放资源而被唤醒。</li>\n</ul>\n<p>这些内核对象五花八门，记不住怎么办？我也记不住，通过对比的方法来区分它们。</p>\n<ul>\n<li>能否传信息？还是只能传递状态？</li>\n<li>为众生（所有任务都可以使用）？只为你（只能指定任务使用）？</li>\n<li>我生产，你们消费？</li>\n<li>我上锁，只能由我开锁</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th><strong>内核对象</strong></th>\n<th><strong>生产者</strong></th>\n<th><strong>消费者</strong></th>\n<th><strong>数据&#x2F;状态</strong></th>\n<th><strong>说明</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>队列</td>\n<td>ALL</td>\n<td>ALL</td>\n<td>数据：若干个数据 谁都可以往队列里扔数据， 谁都可以从队列里读数据</td>\n<td>用来传递数据， 发送者、接收者无限制， 一个数据只能唤醒一个接收者</td>\n</tr>\n<tr>\n<td>事件组</td>\n<td>ALL</td>\n<td>ALL</td>\n<td>多个位：或、与 谁都可以设置(生产)多个位， 谁都可以等待某个位、若干个位</td>\n<td>用来传递事件， 可以是N个事件， 发送者、接受者无限制， 可以唤醒多个接收者：像广播</td>\n</tr>\n<tr>\n<td>信号量</td>\n<td>ALL</td>\n<td>ALL</td>\n<td>数量：0~n 谁都可以增加一个数量， 谁都可消耗一个数量</td>\n<td>用来维持资源的个数， 生产者、消费者无限制， 1个资源只能唤醒1个接收者</td>\n</tr>\n<tr>\n<td>任务通知</td>\n<td>ALL</td>\n<td>只有我</td>\n<td>数据、状态都可以传输， 使用任务通知时， 必须指定接受者</td>\n<td>N对1的关系： 发送者无限制， 接收者只能是这个任务</td>\n</tr>\n<tr>\n<td>互斥量</td>\n<td>只能A开锁</td>\n<td>A上锁</td>\n<td>位：0、1 我上锁：1变为0， 只能由我开锁：0变为1</td>\n<td>就像一个空厕所， 谁使用谁上锁， 也只能由他开锁</td>\n</tr>\n</tbody></table>\n<p>使用图形对比如下：</p>\n<ul>\n<li>队列：<ul>\n<li>里面可以放任意数据，可以放多个数据</li>\n<li>任务、ISR都可以放入数据；任务、ISR都可以从中读出数据</li>\n</ul>\n</li>\n<li>事件组：<ul>\n<li>一个事件用一bit表示，1表示事件发生了，0表示事件没发生</li>\n<li>可以用来表示事件、事件的组合发生了，不能传递数据</li>\n<li>有广播效果：事件或事件的组合发生了，等待它的多个任务都会被唤醒</li>\n</ul>\n</li>\n<li>信号量：<ul>\n<li>核心是”计数值”</li>\n<li>任务、ISR释放信号量时让计数值加1</li>\n<li>任务、ISR获得信号量时，让计数值减1</li>\n</ul>\n</li>\n<li>任务通知：<ul>\n<li>核心是任务的TCB里的数值</li>\n<li>会被覆盖</li>\n<li>发通知给谁？必须指定接收任务</li>\n<li>只能由接收任务本身获取该通知</li>\n</ul>\n</li>\n<li>互斥量：<ul>\n<li>数值只有0或1</li>\n<li>谁获得互斥量，就必须由谁释放同一个互斥量</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509151740912.png\" alt=\"img\"></p>\n<blockquote>\n<p>为何要引用这些机制呢？</p>\n<ul>\n<li>原本逻辑可以采用全局变量来进行传递信息，但在RTOS下，可能还未来得及改变全局变量的值就被切换到其他任务，这样就会发生全局变量未及时更新的问题</li>\n<li>引入事件阻塞与唤醒大大提高了CPU的利用率<ul>\n<li>当任务A计数1s，任务B负责打印任务A的最终计数值，就不会出现A运行，B也运行，而是等待A运行完后通知任务B，或大概估算任务A结束的时间，让B阻塞这么多的时间，这样就实现了整个时间轴都是任务A在运行</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<h3 id=\"队列\"><a href=\"#队列\" class=\"headerlink\" title=\"队列\"></a>队列</h3><h4 id=\"队列的本质\"><a href=\"#队列的本质\" class=\"headerlink\" title=\"队列的本质\"></a>队列的本质</h4><p>队列中，数据的读写就是环形缓冲区，在这个基础上增加了互斥措施、阻塞-唤醒机制</p>\n<ul>\n<li>如果这个队列不传输数据，只调整“数据个数”，他就是信号量（semaphore）</li>\n<li>如果信号量中，限定“数据个数”最大值为1，他就是互斥量（mutex）</li>\n</ul>\n<h4 id=\"传输数据的两种方法\"><a href=\"#传输数据的两种方法\" class=\"headerlink\" title=\"传输数据的两种方法\"></a>传输数据的两种方法</h4><p>使用队列传输数据时有两种方法：</p>\n<ul>\n<li>拷贝：把数据、把变量的值复制进队列里</li>\n<li>引用：把数据、把变量的地址复制进队列里</li>\n</ul>\n<p>FreeRTOS使用拷贝值的方法，这更简单：</p>\n<ul>\n<li>局部变量的值可以发送到队列中，后续即使函数退出、局部变量被回收，也不会影响队列中的数据</li>\n<li>无需分配buffer来保存数据，队列中有buffer</li>\n<li>局部变量可以马上再次使用</li>\n<li>发送任务、接收任务解耦：接收任务不需要知道这数据是谁的、也不需要发送任务来释放数据</li>\n<li>如果数据实在太大，你还是可以使用队列传输它的地址</li>\n<li>队列的空间有FreeRTOS内核分配，无需任务操心</li>\n<li>对于有内存保护功能的系统，如果队列使用引用方法，也就是使用地址，必须确保双方任务对这个地址都有访问权限。使用拷贝方法时，则无此限制：内核有足够的权限，把数据复制进队列、再把数据复制出队列。</li>\n</ul>\n<h4 id=\"队列的阻塞访问\"><a href=\"#队列的阻塞访问\" class=\"headerlink\" title=\"队列的阻塞访问\"></a>队列的阻塞访问</h4><p>只要知道队列的句柄，谁都可以读、写该队列。任务、ISR都可读、写队列。可以多个任务读写队列。</p>\n<p>任务读写队列时，简单地说：如果读写不成功，则阻塞；可以指定超时时间。口语化地说，就是可以定个闹钟：如果能读写了就马上进入就绪态，否则就阻塞直到超时。</p>\n<p>某个任务读队列时，如果队列没有数据，则该任务可以进入阻塞状态：还可以指定阻塞的时间。如果队列有数据了，则该阻塞的任务会变为就绪态。如果一直都没有数据，则时间到之后它也会进入就绪态。</p>\n<p>既然读取队列的任务个数没有限制，那么当多个任务读取空队列时，这些任务都会进入阻塞状态：有多个任务在等待同一个队列的数据。当队列中有数据时，哪个任务会进入就绪态？</p>\n<ul>\n<li>优先级最高的任务</li>\n<li>如果大家的优先级相同，那等待时间最久的任务会进入就绪态</li>\n</ul>\n<p>跟读队列类似，一个任务要写队列时，如果队列满了，该任务也可以进入阻塞状态：还可以指定阻塞的时间。如果队列有空间了，则该阻塞的任务会变为就绪态。如果一直都没有空间，则时间到之后它也会进入就绪态。</p>\n<p>既然写队列的任务个数没有限制，那么当多个任务写”满队列”时，这些任务都会进入阻塞状态：有多个任务在等待同一个队列的空间。当队列中有空间时，哪个任务会进入就绪态？</p>\n<ul>\n<li>优先级最高的任务</li>\n<li>如果大家的优先级相同，那等待时间最久的任务会进入就绪态</li>\n</ul>\n<h4 id=\"队列函数\"><a href=\"#队列函数\" class=\"headerlink\" title=\"队列函数\"></a>队列函数</h4><h5 id=\"创建\"><a href=\"#创建\" class=\"headerlink\" title=\"创建\"></a>创建</h5><p>队列的创建有两种方法：动态分配内存、静态分配内存，</p>\n<ul>\n<li>动态分配内存：xQueueCreate，队列的内存在函数内部动态分配</li>\n</ul>\n<p>函数原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">QueueHandle_t <span class=\"title function_\">xQueueCreate</span><span class=\"params\">( UBaseType_t uxQueueLength, UBaseType_t uxItemSize )</span>;</span><br></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th><strong>参数</strong></th>\n<th><strong>说明</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>uxQueueLength</code></td>\n<td>队列长度，最多能存放多少个数据(item)</td>\n</tr>\n<tr>\n<td><code>uxItemSize</code></td>\n<td>每个数据(item)的大小：以字节为单位（可以定义一个结构体存放，然后sizeof(结构体)）</td>\n</tr>\n<tr>\n<td>返回值</td>\n<td>非0：成功，返回句柄，以后使用句柄来操作队列 NULL：失败，因为内存不足</td>\n</tr>\n</tbody></table>\n<ul>\n<li>静态分配内存：<code>xQueueCreateStatic</code>，队列的内存要事先分配好</li>\n</ul>\n<p>函数原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">QueueHandle_t <span class=\"title function_\">xQueueCreateStatic</span><span class=\"params\">(*</span></span><br><span class=\"line\"><span class=\"params\">              \t\tUBaseType_t uxQueueLength,*</span></span><br><span class=\"line\"><span class=\"params\">              \t\tUBaseType_t uxItemSize,*</span></span><br><span class=\"line\"><span class=\"params\">              \t\t<span class=\"type\">uint8_t</span> *pucQueueStorageBuffer,*</span></span><br><span class=\"line\"><span class=\"params\">              \t\tStaticQueue_t *pxQueueBuffer*</span></span><br><span class=\"line\"><span class=\"params\">           \t\t )</span>;</span><br></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th><strong>参数</strong></th>\n<th><strong>说明</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>uxQueueLength</code></td>\n<td>队列长度，最多能存放多少个数据(item)</td>\n</tr>\n<tr>\n<td><code>uxItemSize</code></td>\n<td>每个数据(item)的大小：以字节为单位</td>\n</tr>\n<tr>\n<td><code>pucQueueStorageBuffer</code></td>\n<td>如果uxItemSize非0，<code>pucQueueStorageBuffer</code>必须指向一个uint8_t数组， 此数组大小至少为”uxQueueLength * uxItemSize”</td>\n</tr>\n<tr>\n<td><code>pxQueueBuffer</code></td>\n<td>必须执行一个<code>StaticQueue_t</code>结构体，用来保存队列的数据结构</td>\n</tr>\n<tr>\n<td>返回值</td>\n<td>非0：成功，返回句柄，以后使用句柄来操作队列 NULL：失败，因为<code>pxQueueBuffer</code>为NULL</td>\n</tr>\n</tbody></table>\n<h5 id=\"复位\"><a href=\"#复位\" class=\"headerlink\" title=\"复位\"></a>复位</h5><p>队列刚被创建时，里面没有数据；使用过程中可以调用 <strong>xQueueReset()</strong> 把队列恢复为初始状态，此函数原型为：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*  pxQueue : 复位哪个队列;</span></span><br><span class=\"line\"><span class=\"comment\"> * 返回值: pdPASS(必定成功)</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\">BaseType_t <span class=\"title function_\">xQueueReset</span><span class=\"params\">( QueueHandle_t pxQueue)</span>;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"删除\"><a href=\"#删除\" class=\"headerlink\" title=\"删除\"></a>删除</h5><p>删除队列的函数为 <strong>vQueueDelete()</strong> ，只能删除使用动态方法创建的队列，它会释放内存。原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">vQueueDelete</span><span class=\"params\">( QueueHandle_t xQueue )</span>;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"写队列\"><a href=\"#写队列\" class=\"headerlink\" title=\"写队列\"></a>写队列</h5><p>可以把数据写到队列头部，也可以写到尾部，这些函数有两个版本：在任务中使用、在ISR中使用。函数原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 等同于xQueueSendToBack</span></span><br><span class=\"line\"><span class=\"comment\"> * 往队列尾部写入数据，如果没有空间，阻塞时间为xTicksToWait</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">BaseType_t <span class=\"title function_\">xQueueSend</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">                                QueueHandle_t    xQueue,</span></span><br><span class=\"line\"><span class=\"params\">                                <span class=\"type\">const</span> <span class=\"type\">void</span>       *pvItemToQueue,</span></span><br><span class=\"line\"><span class=\"params\">                                TickType_t       xTicksToWait</span></span><br><span class=\"line\"><span class=\"params\">                            )</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\"> * 往队列尾部写入数据，如果没有空间，阻塞时间为xTicksToWait</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">BaseType_t <span class=\"title function_\">xQueueSendToBack</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">                                QueueHandle_t    xQueue,</span></span><br><span class=\"line\"><span class=\"params\">                                <span class=\"type\">const</span> <span class=\"type\">void</span>       *pvItemToQueue,</span></span><br><span class=\"line\"><span class=\"params\">                                TickType_t       xTicksToWait</span></span><br><span class=\"line\"><span class=\"params\">                            )</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\"> * 往队列尾部写入数据，此函数可以在中断函数中使用，不可阻塞</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">BaseType_t <span class=\"title function_\">xQueueSendToBackFromISR</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">                                      QueueHandle_t xQueue,</span></span><br><span class=\"line\"><span class=\"params\">                                      <span class=\"type\">const</span> <span class=\"type\">void</span> *pvItemToQueue,</span></span><br><span class=\"line\"><span class=\"params\">                                      BaseType_t *pxHigherPriorityTaskWoken</span></span><br><span class=\"line\"><span class=\"params\">                                   )</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\"> * 往队列头部写入数据，如果没有空间，阻塞时间为xTicksToWait</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">BaseType_t <span class=\"title function_\">xQueueSendToFront</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">                                QueueHandle_t    xQueue,</span></span><br><span class=\"line\"><span class=\"params\">                                <span class=\"type\">const</span> <span class=\"type\">void</span>       *pvItemToQueue,</span></span><br><span class=\"line\"><span class=\"params\">                                TickType_t       xTicksToWait</span></span><br><span class=\"line\"><span class=\"params\">                            )</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\"> * 往队列头部写入数据，此函数可以在中断函数中使用，不可阻塞</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">BaseType_t <span class=\"title function_\">xQueueSendFromISR</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">                                      QueueHandle_t xQueue,</span></span><br><span class=\"line\"><span class=\"params\">                                      <span class=\"type\">const</span> <span class=\"type\">void</span> *pvItemToQueue,</span></span><br><span class=\"line\"><span class=\"params\">                                      BaseType_t *pxHigherPriorityTaskWoken</span></span><br><span class=\"line\"><span class=\"params\">                                   )</span>;</span><br></pre></td></tr></table></figure>\n\n<p>这些函数用到的参数是类似的，统一说明如下：</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>xQueue</code></td>\n<td>队列句柄，要写哪个队列</td>\n</tr>\n<tr>\n<td><code>pvItemToQueue</code></td>\n<td>数据指针，这个数据的值会被复制进队列， 复制多大的数据？在创建队列时已经指定了数据大小</td>\n</tr>\n<tr>\n<td><code>xTicksToWait</code></td>\n<td>如果队列满则无法写入新数据，可以让任务进入阻塞状态， <code>xTicksToWait</code>表示阻塞的最大时间(Tick Count)。 如果被设为0，无法写入数据时函数会立刻返回； 如果被设为<code>portMAX_DELAY</code>，则会一直阻塞直到有空间可写</td>\n</tr>\n<tr>\n<td>返回值</td>\n<td>pdPASS：数据成功写入了队列 <code>errQUEUE_FULL</code>：写入失败，因为队列满了。</td>\n</tr>\n</tbody></table>\n<h5 id=\"读队列\"><a href=\"#读队列\" class=\"headerlink\" title=\"读队列\"></a>读队列</h5><p>使用 <strong>xQueueReceive()</strong> 函数读队列，读到一个数据后，队列中该数据会被移除。这个函数有两个版本：在任务中使用、在ISR中使用。函数原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BaseType_t <span class=\"title function_\">xQueueReceive</span><span class=\"params\">( QueueHandle_t xQueue,</span></span><br><span class=\"line\"><span class=\"params\">                          <span class=\"type\">void</span> * <span class=\"type\">const</span> pvBuffer,</span></span><br><span class=\"line\"><span class=\"params\">                          TickType_t xTicksToWait )</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">BaseType_t <span class=\"title function_\">xQueueReceiveFromISR</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">                                    QueueHandle_t    xQueue,</span></span><br><span class=\"line\"><span class=\"params\">                                    <span class=\"type\">void</span>             *pvBuffer,</span></span><br><span class=\"line\"><span class=\"params\">                                    BaseType_t       *pxTaskWoken</span></span><br><span class=\"line\"><span class=\"params\">                                )</span>;</span><br></pre></td></tr></table></figure>\n\n<p>参数说明如下：</p>\n<table>\n<thead>\n<tr>\n<th><strong>参数</strong></th>\n<th><strong>说明</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>xQueue</code></td>\n<td>队列句柄，要读哪个队列</td>\n</tr>\n<tr>\n<td><code>pvBuffer</code></td>\n<td>buffer指针，队列的数据会被复制到这个buffer 复制多大的数据？在创建队列时已经指定了数据大小</td>\n</tr>\n<tr>\n<td><code>xTicksToWait</code></td>\n<td>果队列空则无法读出数据，可以让任务进入阻塞状态， xTicksToWait表示阻塞的最大时间(Tick Count)。 如果被设为0，无法读出数据时函数会立刻返回； 如果被设为portMAX_DELAY，则会一直阻塞直到有数据可写</td>\n</tr>\n<tr>\n<td>返回值</td>\n<td>pdPASS：从队列读出数据入 <code>errQUEUE_EMPTY</code>：读取失败，因为队列空了。</td>\n</tr>\n</tbody></table>\n<h5 id=\"查询\"><a href=\"#查询\" class=\"headerlink\" title=\"查询\"></a>查询</h5><p>可以查询队列中有多少个数据、有多少空余空间。函数原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 返回队列中可用数据的个数</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">UBaseType_t <span class=\"title function_\">uxQueueMessagesWaiting</span><span class=\"params\">( <span class=\"type\">const</span> QueueHandle_t xQueue )</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 返回队列中可用空间的个数</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">UBaseType_t <span class=\"title function_\">uxQueueSpacesAvailable</span><span class=\"params\">( <span class=\"type\">const</span> QueueHandle_t xQueue )</span>;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"覆盖-偷看\"><a href=\"#覆盖-偷看\" class=\"headerlink\" title=\"覆盖&#x2F;偷看\"></a>覆盖&#x2F;偷看</h5><p>当队列长度为1时，可以使用 <strong>xQueueOverwrite()</strong> 或 <strong>xQueueOverwriteFromISR()</strong> 来覆盖数据。</p>\n<p>注意，队列长度必须为1。当队列满时，这些函数会覆盖里面的数据，这也以为着这些函数不会被阻塞。</p>\n<p>函数原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 覆盖队列</span></span><br><span class=\"line\"><span class=\"comment\"> * xQueue: 写哪个队列</span></span><br><span class=\"line\"><span class=\"comment\"> * pvItemToQueue: 数据地址</span></span><br><span class=\"line\"><span class=\"comment\"> * 返回值: pdTRUE表示成功, pdFALSE表示失败</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">BaseType_t <span class=\"title function_\">xQueueOverwrite</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">                           QueueHandle_t xQueue,</span></span><br><span class=\"line\"><span class=\"params\">                           <span class=\"type\">const</span> <span class=\"type\">void</span> * pvItemToQueue</span></span><br><span class=\"line\"><span class=\"params\">                      )</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">BaseType_t <span class=\"title function_\">xQueueOverwriteFromISR</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">                           QueueHandle_t xQueue,</span></span><br><span class=\"line\"><span class=\"params\">                           <span class=\"type\">const</span> <span class=\"type\">void</span> * pvItemToQueue,</span></span><br><span class=\"line\"><span class=\"params\">                           BaseType_t *pxHigherPriorityTaskWoken</span></span><br><span class=\"line\"><span class=\"params\">                      )</span>;</span><br></pre></td></tr></table></figure>\n\n<p>如果想让队列中的数据供多方读取，也就是说读取时不要移除数据，要留给后来人。那么可以使用”窥视”，也就是**xQueuePeek()**或**xQueuePeekFromISR()**。这些函数会从队列中复制出数据，但是不移除数据。这也意味着，如果队列中没有数据，那么”偷看”时会导致阻塞；一旦队列中有数据，以后每次”偷看”都会成功。</p>\n<p>函数原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 偷看队列</span></span><br><span class=\"line\"><span class=\"comment\"> * xQueue: 偷看哪个队列</span></span><br><span class=\"line\"><span class=\"comment\"> * pvItemToQueue: 数据地址, 用来保存复制出来的数据</span></span><br><span class=\"line\"><span class=\"comment\"> * xTicksToWait: 没有数据的话阻塞一会</span></span><br><span class=\"line\"><span class=\"comment\"> * 返回值: pdTRUE表示成功, pdFALSE表示失败</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">BaseType_t <span class=\"title function_\">xQueuePeek</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">                          QueueHandle_t xQueue,</span></span><br><span class=\"line\"><span class=\"params\">                          <span class=\"type\">void</span> * <span class=\"type\">const</span> pvBuffer,</span></span><br><span class=\"line\"><span class=\"params\">                          TickType_t xTicksToWait</span></span><br><span class=\"line\"><span class=\"params\">                      )</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">BaseType_t <span class=\"title function_\">xQueuePeekFromISR</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">                                 QueueHandle_t xQueue,</span></span><br><span class=\"line\"><span class=\"params\">                                 <span class=\"type\">void</span> *pvBuffer,</span></span><br><span class=\"line\"><span class=\"params\">                             )</span>;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"使用队列时注意\"><a href=\"#使用队列时注意\" class=\"headerlink\" title=\"使用队列时注意\"></a>使用队列时注意</h4><blockquote>\n<p>写队列与读队列 所传入的<code>buffer</code>一定要严格按照初始创建时的类型，否则就会出现死机</p>\n<ul>\n<li>情况一：创建时类型为指针（常用，可以接收多种类型）</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"type\">uint8_t</span> data[<span class=\"number\">128</span>];</span><br><span class=\"line\">    <span class=\"type\">uint8_t</span> index;</span><br><span class=\"line\">&#125;Uart_RxTypeDef;</span><br><span class=\"line\"></span><br><span class=\"line\">Uart_RxTypeDef UartRx = &#123;&#123;<span class=\"number\">0</span>&#125;,<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">task</span><span class=\"params\">(<span class=\"type\">void</span> *arg)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Uart_RxTypeDef *data = &amp;UartRx;</span><br><span class=\"line\">    debug_TX_QueueHandle = osMessageQueueNew(<span class=\"number\">5</span>, <span class=\"keyword\">sizeof</span>(<span class=\"type\">void</span> *), &amp;debug_TX_Queue_attributes);</span><br><span class=\"line\">    xQueueSend(debug_TX_QueueHandle,&amp;data,<span class=\"literal\">NULL</span>);<span class=\"comment\">//此处一定要&amp;data 因为创建队列的时候是指针 直接写data 相当于&amp;UartRx 他并不是一个指针</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>情况二：创建时类型为数据</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"type\">uint8_t</span> data[<span class=\"number\">128</span>];</span><br><span class=\"line\">    <span class=\"type\">uint8_t</span> index;</span><br><span class=\"line\">&#125;Uart_RxTypeDef;</span><br><span class=\"line\"></span><br><span class=\"line\">Uart_RxTypeDef UartRx = &#123;&#123;<span class=\"number\">0</span>&#125;,<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">task</span><span class=\"params\">(<span class=\"type\">void</span> *arg)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Uart_RxTypeDef data = &#123;&#123;<span class=\"number\">0</span>&#125;,<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">    debug_TX_QueueHandle = osMessageQueueNew(<span class=\"number\">5</span>, <span class=\"keyword\">sizeof</span>(Uart_RxTypeDef), &amp;debug_TX_Queue_attributes);</span><br><span class=\"line\">    xQueueSend(debug_TX_QueueHandle,&amp;data,<span class=\"literal\">NULL</span>);<span class=\"comment\">//此处的&amp;data与情况一不一样 这个是参数要求要地址 所以需要将结构体的地址赋值过去</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n</blockquote>\n<h4 id=\"队列集\"><a href=\"#队列集\" class=\"headerlink\" title=\"队列集\"></a>队列集</h4><blockquote>\n<p>当多个队列需要上报到同一个处理任务时，队列集可以实现统合多个队列，再往上传递到同一个任务</p>\n</blockquote>\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509152131801.png\" alt=\"image-20250915213146479\"></p>\n<h5 id=\"创建队列集\"><a href=\"#创建队列集\" class=\"headerlink\" title=\"创建队列集\"></a>创建队列集</h5><blockquote>\n<p>注意要使用队列集 需要先在<code>Core/inc/FreeRTOSConfig.h</code> 定义</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#define configUSE_QUEUE_SETS 1</span></span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>函数原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">QueueSetHandle_t <span class=\"title function_\">xQueueCreateSet</span><span class=\"params\">( <span class=\"type\">const</span> UBaseType_t uxEventQueueLength )</span></span><br></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th><strong>参数</strong></th>\n<th><strong>说明</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>uxQueueLength</td>\n<td>队列集长度，最多能存放多少个数据(队列句柄)</td>\n</tr>\n<tr>\n<td>返回值</td>\n<td>非0：成功，返回句柄，以后使用句柄来操作队列NULL：失败，因为内存不足</td>\n</tr>\n</tbody></table>\n<h5 id=\"把队列加入队列集\"><a href=\"#把队列加入队列集\" class=\"headerlink\" title=\"把队列加入队列集\"></a>把队列加入队列集</h5><p>函数原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BaseType_t <span class=\"title function_\">xQueueAddToSet</span><span class=\"params\">( QueueSetMemberHandle_t xQueueOrSemaphore,</span></span><br><span class=\"line\"><span class=\"params\"></span></span><br><span class=\"line\"><span class=\"params\">                QueueSetHandle_t xQueueSet )</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"> </span><br></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th><strong>参数</strong></th>\n<th><strong>说明</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>xQueueOrSemaphore</td>\n<td>队列句柄，这个队列要加入队列集</td>\n</tr>\n<tr>\n<td>xQueueSet</td>\n<td>队列集句柄</td>\n</tr>\n<tr>\n<td>返回值</td>\n<td>pdTRUE：成功pdFALSE：失败</td>\n</tr>\n</tbody></table>\n<h5 id=\"读取队列集\"><a href=\"#读取队列集\" class=\"headerlink\" title=\"读取队列集\"></a>读取队列集</h5><p>函数原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">QueueSetMemberHandle_t <span class=\"title function_\">xQueueSelectFromSet</span><span class=\"params\">( QueueSetHandle_t xQueueSet,</span></span><br><span class=\"line\"><span class=\"params\"></span></span><br><span class=\"line\"><span class=\"params\">                        TickType_t <span class=\"type\">const</span> xTicksToWait )</span>;</span><br></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th><strong>参数</strong></th>\n<th><strong>说明</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>xQueueSet</td>\n<td>队列集句柄</td>\n</tr>\n<tr>\n<td>xTicksToWait</td>\n<td>如果队列集空则无法读出数据，可以让任务进入阻塞状态，xTicksToWait表示阻塞的最大时间(Tick Count)。如果被设为0，无法读出数据时函数会立刻返回；如果被设为portMAX_DELAY，则会一直阻塞直到有数据可写</td>\n</tr>\n<tr>\n<td>返回值</td>\n<td>NULL：失败，队列句柄：成功</td>\n</tr>\n</tbody></table>\n<h3 id=\"信号量\"><a href=\"#信号量\" class=\"headerlink\" title=\"信号量\"></a>信号量</h3><p>前面介绍的队列(queue)可以用于传输数据：在任务之间、任务和中断之间。</p>\n<p>消息队列用于传输多个数据，但是有时候我们只需要传递状态，这个状态值需要用一个数值表示，比如：</p>\n<ul>\n<li>卖家：做好了1个包子！做好了2个包子！做好了3个包子！</li>\n<li>买家：买了1个包子，包子数量减1</li>\n<li>这个停车位我占了，停车位减1</li>\n<li>我开车走了，停车位加1</li>\n</ul>\n<p>在这种情况下我们只需要维护一个数值，使用信号量效率更高、更节省内存 本章涉及如下内容：</p>\n<ul>\n<li>怎么创建、删除信号量</li>\n<li>怎么发送、获得信号量</li>\n<li>什么是计数型信号量？什么是二进制信号量？</li>\n</ul>\n<h4 id=\"信号量的特性\"><a href=\"#信号量的特性\" class=\"headerlink\" title=\"信号量的特性\"></a>信号量的特性</h4><h5 id=\"信号量的常规操作\"><a href=\"#信号量的常规操作\" class=\"headerlink\" title=\"信号量的常规操作\"></a>信号量的常规操作</h5><p>信号量这个名字很恰当：</p>\n<ul>\n<li>信号：起通知作用</li>\n<li>量：还可以用来表示资源的数量<ul>\n<li>当”量”没有限制时，它就是”计数型信号量”(Counting Semaphores)</li>\n<li>当”量”只有0、1两个取值时，它就是”二进制信号量”(Binary Semaphores)</li>\n</ul>\n</li>\n<li>支持的动作：”give”给出资源，计数值加1；”take”获得资源，计数值减1</li>\n</ul>\n<p>计数型信号量的典型场景是：</p>\n<ul>\n<li>计数：事件产生时”give”信号量，让计数值加1；处理事件时要先”take”信号量，就是获得信号量，让计数值减1。</li>\n<li>资源管理：要想访问资源需要先”take”信号量，让计数值减1；用完资源后”give”信号量，让计数值加1。 信号量的”give”、”take”双方并不需要相同，可以用于生产者-消费者场合：</li>\n<li>生产者为任务A、B，消费者为任务C、D</li>\n<li>一开始信号量的计数值为0，如果任务C、D想获得信号量，会有两种结果：<ul>\n<li>阻塞：买不到东西咱就等等吧，可以定个闹钟(超时时间)</li>\n<li>即刻返回失败：不等</li>\n</ul>\n</li>\n<li>任务A、B可以生产资源，就是让信号量的计数值增加1，并且把等待这个资源的顾客唤醒</li>\n<li>唤醒谁？谁优先级高就唤醒谁，如果大家优先级一样就唤醒等待时间最长的人</li>\n</ul>\n<p>二进制信号量跟计数型的唯一差别，就是计数值的最大值被限定为1。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509161022312.png\" alt=\"img\"></p>\n<h5 id=\"信号量跟队列的对比\"><a href=\"#信号量跟队列的对比\" class=\"headerlink\" title=\"信号量跟队列的对比\"></a>信号量跟队列的对比</h5><p>差异列表如下：</p>\n<table>\n<thead>\n<tr>\n<th>队列</th>\n<th>信号量</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>可以容纳多个数据， 创建队列时有2部分内存: 队列结构体、存储数据的空间</td>\n<td>只有计数值，无法容纳其他数据。 创建信号量时，只需要分配信号量结构体</td>\n</tr>\n<tr>\n<td>生产者：没有空间存入数据时可以阻塞</td>\n<td>生产者：用于不阻塞，计数值已经达到最大时返回失败</td>\n</tr>\n<tr>\n<td>消费者：没有数据时可以阻塞</td>\n<td>消费者：没有资源时可以阻塞</td>\n</tr>\n</tbody></table>\n<h5 id=\"两种信号量的对比\"><a href=\"#两种信号量的对比\" class=\"headerlink\" title=\"两种信号量的对比\"></a>两种信号量的对比</h5><p>信号量的计数值都有限制：限定了最大值。如果最大值被限定为1，那么它就是二进制信号量；如果最大值不是1，它就是计数型信号量。</p>\n<p>差别列表如下：</p>\n<table>\n<thead>\n<tr>\n<th>二进制信号量</th>\n<th>计数型信号量</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>被创建时初始值为0</td>\n<td>被创建时初始值可以设定</td>\n</tr>\n<tr>\n<td>其他操作是一样的</td>\n<td>其他操作是一样的</td>\n</tr>\n</tbody></table>\n<h4 id=\"信号量函数\"><a href=\"#信号量函数\" class=\"headerlink\" title=\"信号量函数\"></a>信号量函数</h4><p>使用信号量时，先创建、然后去添加资源、获得资源。使用句柄来表示一个信号量。</p>\n<h5 id=\"创建-1\"><a href=\"#创建-1\" class=\"headerlink\" title=\"创建\"></a>创建</h5><p>使用信号量之前，要先创建，得到一个句柄；使用信号量时，要使用句柄来表明使用哪个信号量。 对于二进制信号量、计数型信号量，它们的创建函数不一样：</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>二进制信号量</th>\n<th>计数型信号量</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>动态创建</td>\n<td><code>xSemaphoreCreateBinary </code>计数值初始值为0</td>\n<td><code>xSemaphoreCreateCounting</code></td>\n</tr>\n<tr>\n<td></td>\n<td><code>vSemaphoreCreateBinary</code>(过时了) 计数值初始值为1</td>\n<td></td>\n</tr>\n<tr>\n<td>静态创建</td>\n<td><code>xSemaphoreCreateBinaryStatic</code></td>\n<td><code>xSemaphoreCreateCountingStatic</code></td>\n</tr>\n</tbody></table>\n<p>创建二进制信号量的函数原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 创建一个二进制信号量，返回它的句柄。</span></span><br><span class=\"line\"><span class=\"comment\"> * 此函数内部会分配信号量结构体 </span></span><br><span class=\"line\"><span class=\"comment\"> * 返回值: 返回句柄，非NULL表示成功</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">SemaphoreHandle_t <span class=\"title function_\">xSemaphoreCreateBinary</span><span class=\"params\">( <span class=\"type\">void</span> )</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 创建一个二进制信号量，返回它的句柄。</span></span><br><span class=\"line\"><span class=\"comment\"> * 此函数无需动态分配内存，所以需要先有一个StaticSemaphore_t结构体，并传入它的指针</span></span><br><span class=\"line\"><span class=\"comment\"> * 返回值: 返回句柄，非NULL表示成功</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">SemaphoreHandle_t <span class=\"title function_\">xSemaphoreCreateBinaryStatic</span><span class=\"params\">( StaticSemaphore_t *pxSemaphoreBuffer )</span>;</span><br></pre></td></tr></table></figure>\n\n<p>创建计数型信号量的函数原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 创建一个计数型信号量，返回它的句柄。</span></span><br><span class=\"line\"><span class=\"comment\"> * 此函数内部会分配信号量结构体 </span></span><br><span class=\"line\"><span class=\"comment\"> * uxMaxCount: 最大计数值</span></span><br><span class=\"line\"><span class=\"comment\"> * uxInitialCount: 初始计数值</span></span><br><span class=\"line\"><span class=\"comment\"> * 返回值: 返回句柄，非NULL表示成功</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">SemaphoreHandle_t <span class=\"title function_\">xSemaphoreCreateCounting</span><span class=\"params\">(UBaseType_t uxMaxCount, UBaseType_t uxInitialCount)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 创建一个计数型信号量，返回它的句柄。</span></span><br><span class=\"line\"><span class=\"comment\"> * 此函数无需动态分配内存，所以需要先有一个StaticSemaphore_t结构体，并传入它的指针</span></span><br><span class=\"line\"><span class=\"comment\"> * uxMaxCount: 最大计数值</span></span><br><span class=\"line\"><span class=\"comment\"> * uxInitialCount: 初始计数值</span></span><br><span class=\"line\"><span class=\"comment\"> * pxSemaphoreBuffer: StaticSemaphore_t结构体指针</span></span><br><span class=\"line\"><span class=\"comment\"> * 返回值: 返回句柄，非NULL表示成功</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">SemaphoreHandle_t <span class=\"title function_\">xSemaphoreCreateCountingStatic</span><span class=\"params\">( UBaseType_t uxMaxCount, </span></span><br><span class=\"line\"><span class=\"params\">                                                 UBaseType_t uxInitialCount, </span></span><br><span class=\"line\"><span class=\"params\">                                                 StaticSemaphore_t *pxSemaphoreBuffer )</span>;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"删除-1\"><a href=\"#删除-1\" class=\"headerlink\" title=\"删除\"></a>删除</h5><p>对于动态创建的信号量，不再需要它们时，可以删除它们以回收内存。</p>\n<p>vSemaphoreDelete可以用来删除二进制信号量、计数型信号量，函数原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * xSemaphore: 信号量句柄，你要删除哪个信号量</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">vSemaphoreDelete</span><span class=\"params\">( SemaphoreHandle_t xSemaphore )</span>;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"释放-获取信号量\"><a href=\"#释放-获取信号量\" class=\"headerlink\" title=\"释放&#x2F;获取信号量\"></a>释放&#x2F;获取信号量</h5><p>二进制信号量、计数型信号量的give、take操作函数是一样的。这些函数也分为2个版本：给任务使用，给ISR使用。列表如下：</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>在任务中使用</th>\n<th>在ISR中使用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>give</td>\n<td><code>xSemaphoreGive</code></td>\n<td><code>xSemaphoreGiveFromISR</code></td>\n</tr>\n<tr>\n<td>take</td>\n<td><code>xSemaphoreTake</code></td>\n<td><code>xSemaphoreTakeFromISR</code></td>\n</tr>\n</tbody></table>\n<p>xSemaphoreGive的函数原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BaseType_t <span class=\"title function_\">xSemaphoreGive</span><span class=\"params\">( SemaphoreHandle_t xSemaphore )</span>;</span><br></pre></td></tr></table></figure>\n\n<p>xSemaphoreGive函数的参数与返回值列表如下：</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>xSemaphore</td>\n<td>信号量句柄，释放哪个信号量</td>\n</tr>\n<tr>\n<td>返回值</td>\n<td>pdTRUE表示成功, 如果二进制信号量的计数值已经是1，再次调用此函数则返回失败； 如果计数型信号量的计数值已经是最大值，再次调用此函数则返回失败</td>\n</tr>\n</tbody></table>\n<p>pxHigherPriorityTaskWoken的函数原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BaseType_t <span class=\"title function_\">xSemaphoreGiveFromISR</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">                        SemaphoreHandle_t xSemaphore,</span></span><br><span class=\"line\"><span class=\"params\">                        BaseType_t *pxHigherPriorityTaskWoken</span></span><br><span class=\"line\"><span class=\"params\">                    )</span>;</span><br></pre></td></tr></table></figure>\n\n<p>xSemaphoreGiveFromISR函数的参数与返回值列表如下：</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>xSemaphore</td>\n<td>信号量句柄，释放哪个信号量</td>\n</tr>\n<tr>\n<td>pxHigherPriorityTaskWoken</td>\n<td>如果释放信号量导致更高优先级的任务变为了就绪态， 则*pxHigherPriorityTaskWoken &#x3D; pdTRUE</td>\n</tr>\n<tr>\n<td>返回值</td>\n<td>pdTRUE表示成功, 如果二进制信号量的计数值已经是1，再次调用此函数则返回失败； 如果计数型信号量的计数值已经是最大值，再次调用此函数则返回失败</td>\n</tr>\n</tbody></table>\n<p>xSemaphoreTake的函数原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BaseType_t <span class=\"title function_\">xSemaphoreTake</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">                   SemaphoreHandle_t xSemaphore,</span></span><br><span class=\"line\"><span class=\"params\">                   TickType_t xTicksToWait</span></span><br><span class=\"line\"><span class=\"params\">               )</span>;</span><br></pre></td></tr></table></figure>\n\n<p>xSemaphoreTake函数的参数与返回值列表如下：</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>xSemaphore</code></td>\n<td>信号量句柄，获取哪个信号量</td>\n</tr>\n<tr>\n<td><code>xTicksToWait</code></td>\n<td>如果无法马上获得信号量，阻塞一会： 0：不阻塞，马上返回 <code>portMAX_DELAY</code>: 一直阻塞直到成功 其他值: 阻塞的Tick个数，可以使用*<code>pdMS_TO_TICKS</code>()*来指定阻塞时间为若干<code>ms</code></td>\n</tr>\n<tr>\n<td>返回值</td>\n<td>pdTRUE表示成功</td>\n</tr>\n</tbody></table>\n<p>xSemaphoreTakeFromISR的函数原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BaseType_t <span class=\"title function_\">xSemaphoreTakeFromISR</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">                        SemaphoreHandle_t xSemaphore,</span></span><br><span class=\"line\"><span class=\"params\">                        BaseType_t *pxHigherPriorityTaskWoken</span></span><br><span class=\"line\"><span class=\"params\">                    )</span>;</span><br></pre></td></tr></table></figure>\n\n<p>xSemaphoreTakeFromISR函数的参数与返回值列表如下：</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>xSemaphore</code></td>\n<td>信号量句柄，获取哪个信号量</td>\n</tr>\n<tr>\n<td><code>pxHigherPriorityTaskWoken</code></td>\n<td>如果获取信号量导致更高优先级的任务变为了就绪态， 则<code>*pxHigherPriorityTaskWoken = pdTRUE</code></td>\n</tr>\n<tr>\n<td>返回值</td>\n<td>pdTRUE表示成功</td>\n</tr>\n</tbody></table>\n<h4 id=\"优先级反转\"><a href=\"#优先级反转\" class=\"headerlink\" title=\"优先级反转\"></a>优先级反转</h4><p>信号量使用不当 就会出现优先级反转的问题——任务执行顺序：任务1、任务2、任务1、任务3</p>\n<p>即最高优先级的任务最后运行</p>\n<blockquote>\n<p>优先级反转：假设信号量值为1，同时创建了低、中等、高优先级任务</p>\n<ul>\n<li>低优先级任务获取信号量，中等优先级先阻塞一段时间，确保低优先级任务先成功获取到信号量</li>\n<li>高优先级任务先阻塞一段时间，确保低优先级、中等优先级先完成任务，然后尝试获取信号量</li>\n<li>此时由于低优先级获取了信号量，高优先级任务就会被阻塞</li>\n<li>中等优先级不释放信号量，那么就会发生高优先级任务无法运行</li>\n</ul>\n</blockquote>\n<h5 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h5><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;uart.h&quot;</span></span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> __<span class=\"title\">FILE</span> <span class=\"title\">FILE</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> SemaphoreHandle_t task_mutex = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"type\">uint8_t</span> dev;</span><br><span class=\"line\">    <span class=\"type\">uint8_t</span> *data;</span><br><span class=\"line\">&#125; <span class=\"type\">uart_info_t</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">uart_info_t</span> task1_data = &#123;<span class=\"number\">1</span>, <span class=\"string\">&quot;task1&quot;</span>&#125;;</span><br><span class=\"line\"><span class=\"type\">uart_info_t</span> task2_data = &#123;<span class=\"number\">2</span>, <span class=\"string\">&quot;task2&quot;</span>&#125;;</span><br><span class=\"line\"><span class=\"type\">uart_info_t</span> task3_data = &#123;<span class=\"number\">3</span>, <span class=\"string\">&quot;task3&quot;</span>&#125;;</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">fputc</span><span class=\"params\">(<span class=\"type\">int</span> ch, FILE *f)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    HAL_UART_Transmit(&amp;huart1, (<span class=\"type\">uint8_t</span> *)&amp;ch, <span class=\"number\">1</span>, <span class=\"number\">0xFFFF</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ch;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">task1</span><span class=\"params\">(<span class=\"type\">void</span> *param)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">uint8_t</span> cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">    xSemaphoreTake(task_mutex, portMAX_DELAY);</span><br><span class=\"line\">    <span class=\"type\">uart_info_t</span> *data = param;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;dev:%u,name:%s\\r\\n&quot;</span>, data-&gt;dev, data-&gt;data);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (++cnt == <span class=\"number\">5</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            xSemaphoreGive(task_mutex);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        vTaskDelay(<span class=\"number\">50</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">task2</span><span class=\"params\">(<span class=\"type\">void</span> *param)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">uint8_t</span> cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">    vTaskDelay(<span class=\"number\">300</span>);<span class=\"comment\">//先阻塞一段时间 确保任务1成功获取信号量且能够被切换为任务2</span></span><br><span class=\"line\">    <span class=\"type\">uart_info_t</span> *data = param;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;dev:%u,name:%s\\r\\n&quot;</span>, data-&gt;dev, data-&gt;data);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (++cnt == <span class=\"number\">5</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            vTaskDelete(<span class=\"literal\">NULL</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        HAL_Delay(<span class=\"number\">50</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">task3</span><span class=\"params\">(<span class=\"type\">void</span> *param)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">uint8_t</span> cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">    vTaskDelay(<span class=\"number\">500</span>);\t<span class=\"comment\">//先阻塞一段时间 确保任务1先成功获取信号量且能够被切换为任务2</span></span><br><span class=\"line\">    xSemaphoreTake(task_mutex, portMAX_DELAY);</span><br><span class=\"line\">    <span class=\"type\">uart_info_t</span> *data = param;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;dev:%u,name:%s\\r\\n&quot;</span>, data-&gt;dev, data-&gt;data);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (++cnt == <span class=\"number\">5</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            vTaskDelete(<span class=\"literal\">NULL</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">uart_init</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    task_mutex = xSemaphoreCreateBinary();</span><br><span class=\"line\">    xSemaphoreGive(task_mutex);</span><br><span class=\"line\">    xTaskCreate(task1, <span class=\"string\">&quot;task1&quot;</span>, <span class=\"number\">128</span>, &amp;task1_data, osPriorityNormal, <span class=\"literal\">NULL</span>);\t<span class=\"comment\">//低优先级任务</span></span><br><span class=\"line\">    xTaskCreate(task2, <span class=\"string\">&quot;task2&quot;</span>, <span class=\"number\">128</span>, &amp;task2_data, osPriorityNormal1, <span class=\"literal\">NULL</span>);\t<span class=\"comment\">//中等优先级任务</span></span><br><span class=\"line\">    xTaskCreate(task3, <span class=\"string\">&quot;task3&quot;</span>, <span class=\"number\">128</span>, &amp;task3_data, osPriorityNormal2, <span class=\"literal\">NULL</span>);\t<span class=\"comment\">//高优先级任务</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509161600972.png\" alt=\"image-20250916160014655\"></p>\n<h4 id=\"解决优先级反转\"><a href=\"#解决优先级反转\" class=\"headerlink\" title=\"解决优先级反转\"></a>解决优先级反转</h4><blockquote>\n<p>使用互斥量 （实现优先级继承），当最高优先级任务等待互斥量时，可以将低优先级任务继承最高优先级，使得最高优先级任务也可以先运行</p>\n<p>现象：任务1执行一小段时间被任务2抢占，当任务3时间到来，任务1继承任务3优先级，所以任务1运行释放后，任务1恢复原先优先级，任务3启动</p>\n</blockquote>\n<h3 id=\"事件组\"><a href=\"#事件组\" class=\"headerlink\" title=\"事件组\"></a>事件组</h3><blockquote>\n<p>上述任务同步与互斥的方法都是一对一通知，难以实现一对多通知（广播），因此引入了事件组</p>\n</blockquote>\n<h4 id=\"事件组的概念\"><a href=\"#事件组的概念\" class=\"headerlink\" title=\"事件组的概念\"></a>事件组的概念</h4><p>事件组可以简单地认为就是一个整数：</p>\n<ul>\n<li>的每一位表示一个事件</li>\n<li>每一位事件的含义由程序员决定，比如：Bit0表示用来串口是否就绪，Bit1表示按键是否被按下</li>\n<li>这些位，值为1表示事件发生了，值为0表示事件没发生</li>\n<li>一个或多个任务、ISR都可以去写这些位；一个或多个任务、ISR都可以去读这些位</li>\n<li>可以等待某一位、某些位中的任意一个，也可以等待多位</li>\n</ul>\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509161809736.png\" alt=\"img\"></p>\n<p>事件组用一个整数来表示，其中的高8位留给内核使用，只能用其他的位来表示事件。那么这个整数是多少位的？</p>\n<ul>\n<li>如果configUSE_16_BIT_TICKS是1，那么这个整数就是16位的，低8位用来表示事件</li>\n<li>如果configUSE_16_BIT_TICKS是0，那么这个整数就是32位的，低24位用来表示事件</li>\n<li>configUSE_16_BIT_TICKS是用来表示Tick Count的，怎么会影响事件组？这只是基于效率来考虑<ul>\n<li>如果configUSE_16_BIT_TICKS是1，就表示该处理器使用16位更高效，所以事件组也使用16位</li>\n<li>如果configUSE_16_BIT_TICKS是0，就表示该处理器使用32位更高效，所以事件组也使用32位</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"事件组的操作\"><a href=\"#事件组的操作\" class=\"headerlink\" title=\"事件组的操作\"></a>事件组的操作</h4><p>事件组和队列、信号量等不太一样，主要集中在2个地方：</p>\n<ul>\n<li>唤醒谁？<ul>\n<li>队列、信号量：事件发生时，只会唤醒一个任务</li>\n<li>事件组：事件发生时，会唤醒所有符号条件的任务，简单地说它有”广播”的作用</li>\n</ul>\n</li>\n<li>是否清除事件？<ul>\n<li>队列、信号量：是消耗型的资源，队列的数据被读走就没了；信号量被获取后就减少了</li>\n<li>事件组：被唤醒的任务有两个选择，可以让事件保留不动，也可以清除事件</li>\n</ul>\n</li>\n</ul>\n<p>以上图为列，事件组的常规操作如下：</p>\n<ul>\n<li>先创建事件组</li>\n<li>任务C、D等待事件：<ul>\n<li>等待什么事件？可以等待某一位、某些位中的任意一个，也可以等待多位。简单地说就是”或”、”与”的关系。</li>\n<li>得到事件时，要不要清除？可选择清除、不清除。</li>\n</ul>\n</li>\n<li>任务A、B产生事件：设置事件组里的某一位、某些位</li>\n</ul>\n<h4 id=\"事件组函数\"><a href=\"#事件组函数\" class=\"headerlink\" title=\"事件组函数\"></a>事件组函数</h4><h5 id=\"创建-2\"><a href=\"#创建-2\" class=\"headerlink\" title=\"创建\"></a>创建</h5><p>使用事件组之前，要先创建，得到一个句柄；使用事件组时，要使用句柄来表明使用哪个事件组。</p>\n<p>有两种创建方法：动态分配内存、静态分配内存。函数原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 创建一个事件组，返回它的句柄。</span></span><br><span class=\"line\"><span class=\"comment\"> * 此函数内部会分配事件组结构体 </span></span><br><span class=\"line\"><span class=\"comment\"> * 返回值: 返回句柄，非NULL表示成功</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">EventGroupHandle_t <span class=\"title function_\">xEventGroupCreate</span><span class=\"params\">( <span class=\"type\">void</span> )</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 创建一个事件组，返回它的句柄。</span></span><br><span class=\"line\"><span class=\"comment\"> * 此函数无需动态分配内存，所以需要先有一个StaticEventGroup_t结构体，并传入它的指针</span></span><br><span class=\"line\"><span class=\"comment\"> * 返回值: 返回句柄，非NULL表示成功</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">EventGroupHandle_t <span class=\"title function_\">xEventGroupCreateStatic</span><span class=\"params\">( StaticEventGroup_t * pxEventGroupBuffer )</span>;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"删除-2\"><a href=\"#删除-2\" class=\"headerlink\" title=\"删除\"></a>删除</h5><p>对于动态创建的事件组，不再需要它们时，可以删除它们以回收内存。</p>\n<p><strong>vEventGroupDelete</strong>可以用来删除事件组，函数原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * xEventGroup: 事件组句柄，你要删除哪个事件组</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">vEventGroupDelete</span><span class=\"params\">( EventGroupHandle_t xEventGroup )</span></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"设置事件\"><a href=\"#设置事件\" class=\"headerlink\" title=\"设置事件\"></a>设置事件</h5><p>可以设置事件组的某个位、某些位，使用的函数有2个：</p>\n<ul>\n<li>在任务中使用<strong>xEventGroupSetBits()</strong></li>\n<li>在ISR中使用<strong>xEventGroupSetBitsFromISR()</strong></li>\n</ul>\n<p>有一个或多个任务在等待事件，如果这些事件符合这些任务的期望，那么任务还会被唤醒。</p>\n<p>函数原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 设置事件组中的位</span></span><br><span class=\"line\"><span class=\"comment\"> * xEventGroup: 哪个事件组</span></span><br><span class=\"line\"><span class=\"comment\"> * uxBitsToSet: 设置哪些位? </span></span><br><span class=\"line\"><span class=\"comment\"> *              如果uxBitsToSet的bitX, bitY为1, 那么事件组中的bitX, bitY被设置为1</span></span><br><span class=\"line\"><span class=\"comment\"> *              可以用来设置多个位，比如 0x15 就表示设置bit4, bit2, bit0</span></span><br><span class=\"line\"><span class=\"comment\"> * 返回值: 返回原来的事件值(没什么意义, 因为很可能已经被其他任务修改了)</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">EventBits_t <span class=\"title function_\">xEventGroupSetBits</span><span class=\"params\">( EventGroupHandle_t xEventGroup,</span></span><br><span class=\"line\"><span class=\"params\">                                    <span class=\"type\">const</span> EventBits_t uxBitsToSet )</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 设置事件组中的位</span></span><br><span class=\"line\"><span class=\"comment\"> * xEventGroup: 哪个事件组</span></span><br><span class=\"line\"><span class=\"comment\"> * uxBitsToSet: 设置哪些位? </span></span><br><span class=\"line\"><span class=\"comment\"> *              如果uxBitsToSet的bitX, bitY为1, 那么事件组中的bitX, bitY被设置为1</span></span><br><span class=\"line\"><span class=\"comment\"> *              可以用来设置多个位，比如 0x15 就表示设置bit4, bit2, bit0</span></span><br><span class=\"line\"><span class=\"comment\"> * pxHigherPriorityTaskWoken: 有没有导致更高优先级的任务进入就绪态? pdTRUE-有, pdFALSE-没有</span></span><br><span class=\"line\"><span class=\"comment\"> * 返回值: pdPASS-成功, pdFALSE-失败</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">BaseType_t <span class=\"title function_\">xEventGroupSetBitsFromISR</span><span class=\"params\">( EventGroupHandle_t xEventGroup,</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t\t\t\t\t\t\t  <span class=\"type\">const</span> EventBits_t uxBitsToSet,</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t\t\t\t\t\t\t  BaseType_t * pxHigherPriorityTaskWoken )</span>;</span><br></pre></td></tr></table></figure>\n\n<p>值得注意的是，ISR中的函数，比如队列函数<strong>xQueueSendToBackFromISR</strong>、信号量函数<strong>xSemaphoreGiveFromISR</strong>，它们会唤醒某个任务，最多只会唤醒1个任务。</p>\n<p>但是设置事件组时，有可能导致多个任务被唤醒，这会带来很大的不确定性。所以<strong>xEventGroupSetBitsFromISR</strong>函数不是直接去设置事件组，而是给一个FreeRTOS后台任务(daemon task)发送队列数据，由这个任务来设置事件组。</p>\n<p>如果后台任务的优先级比当前被中断的任务优先级高，<strong>xEventGroupSetBitsFromISR</strong>会设置<strong>pxHigherPriorityTaskWoken</strong>为pdTRUE。</p>\n<p>如果daemon task成功地把队列数据发送给了后台任务，那么<strong>xEventGroupSetBitsFromISR</strong>的返回值就是pdPASS。</p>\n<h5 id=\"等待事件\"><a href=\"#等待事件\" class=\"headerlink\" title=\"等待事件\"></a>等待事件</h5><p>使用<strong>xEventGroupWaitBits</strong>来等待事件，可以等待某一位、某些位中的任意一个，也可以等待多位；等到期望的事件后，还可以清除某些位。</p>\n<p>函数原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EventBits_t <span class=\"title function_\">xEventGroupWaitBits</span><span class=\"params\">( EventGroupHandle_t xEventGroup,</span></span><br><span class=\"line\"><span class=\"params\">                                 <span class=\"type\">const</span> EventBits_t uxBitsToWaitFor,</span></span><br><span class=\"line\"><span class=\"params\">                                 <span class=\"type\">const</span> BaseType_t xClearOnExit,</span></span><br><span class=\"line\"><span class=\"params\">                                 <span class=\"type\">const</span> BaseType_t xWaitForAllBits,</span></span><br><span class=\"line\"><span class=\"params\">                                 TickType_t xTicksToWait )</span>;</span><br></pre></td></tr></table></figure>\n\n<p>先引入一个概念：unblock condition。一个任务在等待事件发生时，它处于阻塞状态；当期望的时间发生时，这个状态就叫”unblock condition”，非阻塞条件，或称为”非阻塞条件成立”；当”非阻塞条件成立”后，该任务就可以变为就绪态。</p>\n<p>函数参数说明列表如下：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\"><strong>参数</strong></th>\n<th align=\"left\"><strong>说明</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">xEventGroup</td>\n<td align=\"left\">等待哪个事件组？</td>\n</tr>\n<tr>\n<td align=\"center\">uxBitsToWaitFor</td>\n<td align=\"left\">等待哪些位？哪些位要被测试？</td>\n</tr>\n<tr>\n<td align=\"center\">xWaitForAllBits</td>\n<td align=\"left\">怎么测试？是”AND”还是”OR”？ pdTRUE: 等待的位，全部为1; pdFALSE: 等待的位，某一个为1即可</td>\n</tr>\n<tr>\n<td align=\"center\">xClearOnExit</td>\n<td align=\"left\">函数提出前是否要清除事件？ pdTRUE: 清除uxBitsToWaitFor指定的位 pdFALSE: 不清除</td>\n</tr>\n<tr>\n<td align=\"center\">xTicksToWait</td>\n<td align=\"left\">如果期待的事件未发生，阻塞多久。 可以设置为0：判断后即刻返回； 可设置为portMAX_DELAY：一定等到成功才返回； 可以设置为期望的Tick Count，一般用*pdMS_TO_TICKS()*把ms转换为Tick Count</td>\n</tr>\n<tr>\n<td align=\"center\">返回值</td>\n<td align=\"left\">返回的是事件值， 如果期待的事件发生了，返回的是”非阻塞条件成立”时的事件值； 如果是超时退出，返回的是超时时刻的事件值。</td>\n</tr>\n</tbody></table>\n<p>举例如下：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">事件组的值</th>\n<th align=\"center\">uxBitsToWaitFor</th>\n<th align=\"center\">xWaitForAllBits</th>\n<th align=\"left\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">0100</td>\n<td align=\"center\">0101</td>\n<td align=\"center\">pdTRUE</td>\n<td align=\"left\">任务期望bit0,bit2都为1， 当前值只有bit2满足，任务进入阻塞态； 当事件组中bit0,bit2都为1时退出阻塞态</td>\n</tr>\n<tr>\n<td align=\"center\">0100</td>\n<td align=\"center\">0110</td>\n<td align=\"center\">pdFALSE</td>\n<td align=\"left\">任务期望bit0,bit2某一个为1， 当前值满足，所以任务成功退出</td>\n</tr>\n<tr>\n<td align=\"center\">0100</td>\n<td align=\"center\">0110</td>\n<td align=\"center\">pdTRUE</td>\n<td align=\"left\">任务期望bit1,bit2都为1， 当前值不满足，任务进入阻塞态； 当事件组中bit1,bit2都为1时退出阻塞态</td>\n</tr>\n</tbody></table>\n<p>你可以使用*xEventGroupWaitBits()<em>等待期望的事件，它发生之后再使用</em>xEventGroupClearBits()*来清除。但是这两个函数之间，有可能被其他任务或中断抢占，它们可能会修改事件组。</p>\n<p>可以使用设置<em>xClearOnExit</em>为pdTRUE，使得对事件组的测试、清零都在*xEventGroupWaitBits()*函数内部完成，这是一个原子操作。</p>\n<h5 id=\"同步点\"><a href=\"#同步点\" class=\"headerlink\" title=\"同步点\"></a>同步点</h5><p>有一个事情需要多个任务协同，比如：</p>\n<ul>\n<li>任务A：炒菜</li>\n<li>任务B：买酒</li>\n<li>任务C：摆台</li>\n<li>A、B、C做好自己的事后，还要等别人做完；大家一起做完，才可开饭</li>\n</ul>\n<p>使用 <strong>xEventGroupSync()</strong> 函数可以同步多个任务：</p>\n<ul>\n<li>可以设置某位、某些位，表示自己做了什么事</li>\n<li>可以等待某位、某些位，表示要等等其他任务</li>\n<li>期望的时间发生后， <strong>xEventGroupSync()</strong> 才会成功返回。</li>\n<li><strong>xEventGroupSync</strong>成功返回后，会清除事件</li>\n</ul>\n<p><strong>xEventGroupSync</strong> 函数原型如下：</p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EventBits_t xEventGroupSync(    EventGroupHandle_t xEventGroup,</span><br><span class=\"line\">                                const EventBits_t uxBitsToSet,</span><br><span class=\"line\">                                const EventBits_t uxBitsToWaitFor,</span><br><span class=\"line\">                                TickType_t xTicksToWait );</span><br></pre></td></tr></table></figure>\n\n<p>参数列表如下：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\"><strong>参数</strong></th>\n<th><strong>说明</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">xEventGroup</td>\n<td>哪个事件组？</td>\n</tr>\n<tr>\n<td align=\"center\">uxBitsToSet</td>\n<td>要设置哪些事件？我完成了哪些事件？ 比如0x05(二进制为0101)会导致事件组的bit0,bit2被设置为1</td>\n</tr>\n<tr>\n<td align=\"center\">uxBitsToWaitFor</td>\n<td>等待那个位、哪些位？ 比如0x15(二级制10101)，表示要等待bit0,bit2,bit4都为1</td>\n</tr>\n<tr>\n<td align=\"center\">xTicksToWait</td>\n<td>如果期待的事件未发生，阻塞多久。 可以设置为0：判断后即刻返回； 可设置为portMAX_DELAY：一定等到成功才返回； 可以设置为期望的Tick Count，一般用*pdMS_TO_TICKS()*把ms转换为Tick Count</td>\n</tr>\n<tr>\n<td align=\"center\">返回值</td>\n<td>返回的是事件值， 如果期待的事件发生了，返回的是”非阻塞条件成立”时的事件值； 如果是超时退出，返回的是超时时刻的事件值。</td>\n</tr>\n</tbody></table>\n<p>参数列表如下：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\"><strong>参数</strong></th>\n<th align=\"left\"><strong>说明</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">xEventGroup</td>\n<td align=\"left\">哪个事件组？</td>\n</tr>\n<tr>\n<td align=\"center\">uxBitsToSet</td>\n<td align=\"left\">要设置哪些事件？我完成了哪些事件？ 比如0x05(二进制为0101)会导致事件组的bit0,bit2被设置为1</td>\n</tr>\n<tr>\n<td align=\"center\">uxBitsToWaitFor</td>\n<td align=\"left\">等待那个位、哪些位？ 比如0x15(二级制10101)，表示要等待bit0,bit2,bit4都为1</td>\n</tr>\n<tr>\n<td align=\"center\">xTicksToWait</td>\n<td align=\"left\">如果期待的事件未发生，阻塞多久。 可以设置为0：判断后即刻返回； 可设置为portMAX_DELAY：一定等到成功才返回； 可以设置为期望的Tick Count，一般用*pdMS_TO_TICKS()*把ms转换为Tick Count</td>\n</tr>\n<tr>\n<td align=\"center\">返回值</td>\n<td align=\"left\">返回的是事件值， 如果期待的事件发生了，返回的是”非阻塞条件成立”时的事件值； 如果是超时退出，返回的是超时时刻的事件值。</td>\n</tr>\n</tbody></table>\n<h3 id=\"任务通知\"><a href=\"#任务通知\" class=\"headerlink\" title=\"任务通知\"></a>任务通知</h3><p>所谓”任务通知”，你可以反过来读”通知任务”。</p>\n<p>我们使用队列、信号量、事件组等等方法时，并不知道对方是谁。使用任务通知时，可以明确指定：通知哪个任务。</p>\n<p>使用队列、信号量、事件组时，我们都要事先创建对应的结构体，双方通过中间的结构体通信：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509161952531.png\" alt=\"img\"></p>\n<p>使用任务通知时，任务结构体TCB中就包含了内部对象，可以直接接收别人发过来的”通知”：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509161952379.png\" alt=\"img\"></p>\n<h4 id=\"任务通知的特性\"><a href=\"#任务通知的特性\" class=\"headerlink\" title=\"任务通知的特性\"></a>任务通知的特性</h4><h5 id=\"优势及限制\"><a href=\"#优势及限制\" class=\"headerlink\" title=\"优势及限制\"></a>优势及限制</h5><p>任务通知的优势：</p>\n<ul>\n<li>效率更高：使用任务通知来发送事件、数据给某个任务时，效率更高。比队列、信号量、事件组都有大的优势。</li>\n<li>更节省内存：使用其他方法时都要先创建对应的结构体，使用任务通知时无需额外创建结构体。</li>\n</ul>\n<p>任务通知的限制：</p>\n<ul>\n<li>不能发送数据给ISR：</li>\n<li>ISR并没有任务结构体，所以无法使用任务通知的功能给ISR发送数据。但是ISR可以使用任务通知的功能，发数据给任务。</li>\n<li>数据只能给该任务独享</li>\n<li>使用队列、信号量、事件组时，数据保存在这些结构体中，其他任务、ISR都可以访问这些数据。使用任务通知时，数据存放入目标任务中，只有它可以访问这些数据。</li>\n<li>在日常工作中，这个限制影响不大。因为很多场合是从多个数据源把数据发给某个任务，而不是把一个数据源的数据发给多个任务。</li>\n<li>无法缓冲数据</li>\n<li>使用队列时，假设队列深度为N，那么它可以保持N个数据。</li>\n<li>使用任务通知时，任务结构体中只有一个任务通知值，只能保持一个数据。</li>\n<li><span style=\"color:#00FFFF;\">无法广播给多个任务</span></li>\n<li>使用事件组可以同时给多个任务发送事件。</li>\n<li>使用任务通知，只能发个一个任务。</li>\n<li>如果发送受阻，发送方无法进入阻塞状态等待</li>\n<li>假设队列已经满了，使用 <strong>xQueueSendToBack()</strong> 给队列发送数据时，任务可以进入阻塞状态等待发送完成。</li>\n<li>使用任务通知时，即使对方无法接收数据，发送方也无法阻塞等待，只能即刻返回错误。</li>\n</ul>\n<h5 id=\"通知状态和通知值\"><a href=\"#通知状态和通知值\" class=\"headerlink\" title=\"通知状态和通知值\"></a>通知状态和通知值</h5><p>每个任务都有一个结构体：TCB(Task Control Block)，里面有2个成员：</p>\n<ul>\n<li>一个是uint8_t类型，用来表示通知状态</li>\n<li>一个是uint32_t类型，用来表示通知值</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tskTaskControlBlock</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    ......</span><br><span class=\"line\">    <span class=\"comment\">/* configTASK_NOTIFICATION_ARRAY_ENTRIES = 1 */</span></span><br><span class=\"line\">    <span class=\"keyword\">volatile</span> <span class=\"type\">uint32_t</span> ulNotifiedValue[ configTASK_NOTIFICATION_ARRAY_ENTRIES ];</span><br><span class=\"line\">    <span class=\"keyword\">volatile</span> <span class=\"type\">uint8_t</span> ucNotifyState[ configTASK_NOTIFICATION_ARRAY_ENTRIES ];</span><br><span class=\"line\">    ......</span><br><span class=\"line\">&#125; tskTCB;</span><br></pre></td></tr></table></figure>\n\n<p>通知状态有3种取值：</p>\n<ul>\n<li>taskNOT_WAITING_NOTIFICATION：任务没有在等待通知</li>\n<li>taskWAITING_NOTIFICATION：任务在等待通知</li>\n<li>taskNOTIFICATION_RECEIVED：任务接收到了通知，也被称为pending(有数据了，待处理)</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#<span class=\"meta\">#<span class=\"keyword\">define</span> taskNOT_WAITING_NOTIFICATION              ( ( uint8_t ) 0 )  <span class=\"comment\">/* 也是初始状态 */</span></span></span><br><span class=\"line\">#<span class=\"meta\">#<span class=\"keyword\">define</span> taskWAITING_NOTIFICATION                  ( ( uint8_t ) 1 )</span></span><br><span class=\"line\">#<span class=\"meta\">#<span class=\"keyword\">define</span> taskNOTIFICATION_RECEIVED                 ( ( uint8_t ) 2 )</span></span><br></pre></td></tr></table></figure>\n\n<p>通知值可以有很多种类型：</p>\n<ul>\n<li>计数值</li>\n<li>位(类似事件组)</li>\n<li>任意数值</li>\n</ul>\n<h4 id=\"任务通知的使用\"><a href=\"#任务通知的使用\" class=\"headerlink\" title=\"任务通知的使用\"></a>任务通知的使用</h4><p>使用任务通知，可以实现轻量级的队列(长度为1)、邮箱(覆盖的队列)、计数型信号量、二进制信号量、事件组。</p>\n<h5 id=\"两类函数\"><a href=\"#两类函数\" class=\"headerlink\" title=\"两类函数\"></a>两类函数</h5><p>任务通知有2套函数，简化版、专业版，列表如下：</p>\n<ul>\n<li>简化版函数的使用比较简单，它实际上也是使用专业版函数实现的</li>\n<li>专业版函数支持很多参数，可以实现很多功能</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>简化版</th>\n<th>专业版</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>发出通知</td>\n<td><code>xTaskNotifyGive </code> <code>vTaskNotifyGiveFromISR</code></td>\n<td><code>xTaskNotify </code> <code>xTaskNotifyFromISR</code></td>\n</tr>\n<tr>\n<td>取出通知</td>\n<td><code>ulTaskNotifyTake</code></td>\n<td><code>xTaskNotifyWait</code></td>\n</tr>\n</tbody></table>\n<h5 id=\"简化版任务通知\"><a href=\"#简化版任务通知\" class=\"headerlink\" title=\"简化版任务通知\"></a>简化版任务通知</h5><p>在任务中使用<code>xTaskNotifyGive</code>函数，在ISR中使用<code>vTaskNotifyGiveFromISR</code>函数，都是直接给其他任务发送通知：</p>\n<ul>\n<li>使得通知值加一</li>\n<li>并使得通知状态变为”pending”，也就是<strong>taskNOTIFICATION_RECEIVED</strong>，表示有数据了、待处理</li>\n</ul>\n<p>可以使用<code>ulTaskNotifyTake</code>函数来取出通知值：</p>\n<ul>\n<li>如果通知值等于0，则阻塞(可以指定超时时间)</li>\n<li>当通知值大于0时，任务从阻塞态进入就绪态</li>\n<li>在ulTaskNotifyTake返回之前，还可以做些清理工作：把通知值减一，或者把通知值清零</li>\n</ul>\n<p>使用ulTaskNotifyTake函数可以实现轻量级的、高效的二进制信号量、计数型信号量。</p>\n<p>这几个函数的原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BaseType_t <span class=\"title function_\">xTaskNotifyGive</span><span class=\"params\">( TaskHandle_t xTaskToNotify )</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">vTaskNotifyGiveFromISR</span><span class=\"params\">( TaskHandle_t xTaskHandle, BaseType_t *pxHigherPriorityTaskWoken )</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">uint32_t</span> <span class=\"title function_\">ulTaskNotifyTake</span><span class=\"params\">( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )</span>;</span><br></pre></td></tr></table></figure>\n\n<p><code>xTaskNotifyGive</code>函数的参数说明如下：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\"><strong>参数</strong></th>\n<th><strong>说明</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><code>xTaskToNotify</code></td>\n<td>任务句柄(创建任务时得到)，给哪个任务发通知</td>\n</tr>\n<tr>\n<td align=\"center\">返回值</td>\n<td>必定返回pdPASS</td>\n</tr>\n</tbody></table>\n<p><code>vTaskNotifyGiveFromISR</code>函数的参数说明如下：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\"><strong>参数</strong></th>\n<th><strong>说明</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><code>xTaskHandle</code></td>\n<td>任务句柄(创建任务时得到)，给哪个任务发通知</td>\n</tr>\n<tr>\n<td align=\"center\"><code>pxHigherPriorityTaskWoken</code></td>\n<td>被通知的任务，可能正处于阻塞状态。 此函数发出通知后，会把它从阻塞状态切换为就绪态。 如果被唤醒的任务的优先级，高于当前任务的优先级， 则”*pxHigherPriorityTaskWoken”被设置为pdTRUE， 这表示在中断返回之前要进行任务切换。</td>\n</tr>\n</tbody></table>\n<p><code>ulTaskNotifyTake</code>函数的参数说明如下：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\"><strong>参数</strong></th>\n<th><strong>说明</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><code>xClearCountOnExit</code></td>\n<td>函数返回前是否清零： pdTRUE：把通知值清零 pdFALSE：如果通知值大于0，则把通知值减一</td>\n</tr>\n<tr>\n<td align=\"center\"><code>xTicksToWait</code></td>\n<td>任务进入阻塞态的超时时间，它在等待通知值大于0。 0：不等待，即刻返回； portMAX_DELAY：一直等待，直到通知值大于0； 其他值：Tick Count，可以用*pdMS_TO_TICKS()*把ms转换为Tick Count</td>\n</tr>\n<tr>\n<td align=\"center\">返回值</td>\n<td>函数返回之前，在清零或减一之前的通知值。 如果xTicksToWait非0，则返回值有2种情况： 1. 大于0：在超时前，通知值被增加了 2. 等于0：一直没有其他任务增加通知值，最后超时返回0</td>\n</tr>\n</tbody></table>\n<h5 id=\"专业版任务通知\"><a href=\"#专业版任务通知\" class=\"headerlink\" title=\"专业版任务通知\"></a>专业版任务通知</h5><p><strong>xTaskNotify</strong> 函数功能更强大，可以使用不同参数实现各类功能，比如：</p>\n<ul>\n<li>让接收任务的通知值加一：这时 <strong>xTaskNotify()</strong> 等同于 <strong>xTaskNotifyGive()</strong></li>\n<li>设置接收任务的通知值的某一位、某些位，这就是一个轻量级的、更高效的事件组</li>\n<li>把一个新值写入接收任务的通知值：上一次的通知值被读走后，写入才成功。这就是轻量级的、长度为1的队列</li>\n<li>用一个新值覆盖接收任务的通知值：无论上一次的通知值是否被读走，覆盖都成功。类似 <strong>xQueueOverwrite()</strong> 函数，这就是轻量级的邮箱。</li>\n</ul>\n<p><strong>xTaskNotify()</strong> 比 <strong>xTaskNotifyGive()</strong> 更灵活、强大，使用上也就更复杂。<strong>xTaskNotifyFromISR()</strong> 是它对应的ISR版本。</p>\n<p>这两个函数用来发出任务通知，使用哪个函数来取出任务通知呢？</p>\n<p>使用 <strong>xTaskNotifyWait()</strong> 函数！它比 <strong>ulTaskNotifyTake()</strong> 更复杂：</p>\n<ul>\n<li>可以让任务等待(可以加上超时时间)，等到任务状态为”pending”(也就是有数据)</li>\n<li>还可以在函数进入、退出时，清除通知值的指定位</li>\n</ul>\n<p>这几个函数的原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BaseType_t <span class=\"title function_\">xTaskNotify</span><span class=\"params\">( TaskHandle_t xTaskToNotify, <span class=\"type\">uint32_t</span> ulValue, eNotifyAction eAction )</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">BaseType_t <span class=\"title function_\">xTaskNotifyFromISR</span><span class=\"params\">( TaskHandle_t xTaskToNotify,</span></span><br><span class=\"line\"><span class=\"params\">                               <span class=\"type\">uint32_t</span> ulValue, </span></span><br><span class=\"line\"><span class=\"params\">                               eNotifyAction eAction, </span></span><br><span class=\"line\"><span class=\"params\">                               BaseType_t *pxHigherPriorityTaskWoken )</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">BaseType_t <span class=\"title function_\">xTaskNotifyWait</span><span class=\"params\">( <span class=\"type\">uint32_t</span> ulBitsToClearOnEntry, </span></span><br><span class=\"line\"><span class=\"params\">                            <span class=\"type\">uint32_t</span> ulBitsToClearOnExit, </span></span><br><span class=\"line\"><span class=\"params\">                            <span class=\"type\">uint32_t</span> *pulNotificationValue, </span></span><br><span class=\"line\"><span class=\"params\">                            TickType_t xTicksToWait )</span>;</span><br></pre></td></tr></table></figure>\n\n<p><code>xTaskNotify</code>函数的参数说明如下：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\"><strong>参数</strong></th>\n<th><strong>说明</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><code>xTaskToNotify</code></td>\n<td>任务句柄(创建任务时得到)，给哪个任务发通知</td>\n</tr>\n<tr>\n<td align=\"center\"><code>ulValue</code></td>\n<td>怎么使用ulValue，由eAction参数决定</td>\n</tr>\n<tr>\n<td align=\"center\"><code>eAction</code></td>\n<td>见下表</td>\n</tr>\n<tr>\n<td align=\"center\">返回值</td>\n<td>pdPASS：成功，大部分调用都会成功 pdFAIL：只有一种情况会失败，当eAction为eSetValueWithoutOverwrite， 并且通知状态为”pending”(表示有新数据未读)，这时就会失败。</td>\n</tr>\n</tbody></table>\n<p><code>eNotifyAction</code>参数说明：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\"><strong>eNotifyAction取值</strong></th>\n<th><strong>说明</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><code>eNoAction</code></td>\n<td>仅仅是更新通知状态为”pending”，未使用ulValue。 这个选项相当于轻量级的、更高效的二进制信号量。</td>\n</tr>\n<tr>\n<td align=\"center\"><code>eSetBits</code></td>\n<td>通知值 &#x3D; 原来的通知值 | ulValue，按位或。 相当于轻量级的、更高效的事件组。</td>\n</tr>\n<tr>\n<td align=\"center\"><code>eIncrement</code></td>\n<td>通知值 &#x3D; 原来的通知值 + 1，未使用ulValue。 相当于轻量级的、更高效的二进制信号量、计数型信号量。 相当于**xTaskNotifyGive()**函数。</td>\n</tr>\n<tr>\n<td align=\"center\">eSetValueWithoutOverwrite</td>\n<td>不覆盖。 如果通知状态为”pending”(表示有数据未读)， 则此次调用xTaskNotify不做任何事，返回pdFAIL。 如果通知状态不是”pending”(表示没有新数据)， 则：通知值 &#x3D; ulValue。</td>\n</tr>\n<tr>\n<td align=\"center\">eSetValueWithOverwrite</td>\n<td>覆盖。 无论如何，不管通知状态是否为”pendng”， 通知值 &#x3D; ulValue。</td>\n</tr>\n</tbody></table>\n<p>xTaskNotifyFromISR函数跟xTaskNotify很类似，就多了最后一个参数<strong>pxHigherPriorityTaskWoken</strong>。在很多ISR函数中，这个参数的作用都是类似的，使用场景如下：</p>\n<ul>\n<li>被通知的任务，可能正处于阻塞状态</li>\n<li><strong>xTaskNotifyFromISR</strong>函数发出通知后，会把接收任务从阻塞状态切换为就绪态</li>\n<li>如果被唤醒的任务的优先级，高于当前任务的优先级，则”*pxHigherPriorityTaskWoken”被设置为pdTRUE，这表示在中断返回之前要进行任务切换。</li>\n</ul>\n<p>xTaskNotifyWait函数列表如下：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\"><strong>参数</strong></th>\n<th><strong>说明</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><code>ulBitsToClearOnEntry</code></td>\n<td>在xTaskNotifyWait入口处，要清除通知值的哪些位？ 通知状态不是”pending”的情况下，才会清除。 它的本意是：我想等待某些事件发生，所以先把”旧数据”的某些位清零。 能清零的话：通知值 &#x3D; 通知值 &amp; ~(ulBitsToClearOnEntry)。 比如传入0x01，表示清除通知值的bit0； 传入0xffffffff即ULONG_MAX，表示清除所有位，即把值设置为0</td>\n</tr>\n<tr>\n<td align=\"center\"><code>ulBitsToClearOnExit</code></td>\n<td>在xTaskNotifyWait出口处，如果不是因为超时推出，而是因为得到了数据而退出时： 通知值 &#x3D; 通知值 &amp; ~(ulBitsToClearOnExit)。 在清除某些位之前，通知值先被赋给”*pulNotificationValue”。 比如入0x03，表示清除通知值的bit0、bit1； 传入0xffffffff即ULONG_MAX，表示清除所有位，即把值设置为0</td>\n</tr>\n<tr>\n<td align=\"center\"><code>pulNotificationValue</code></td>\n<td>用来取出通知值。 在函数退出时，使用ulBitsToClearOnExit清除之前，把通知值赋给”*pulNotificationValue”。 如果不需要取出通知值，可以设为NULL。</td>\n</tr>\n<tr>\n<td align=\"center\"><code>xTicksToWait</code></td>\n<td>任务进入阻塞态的超时时间，它在等待通知状态变为”pending”。 0：不等待，即刻返回； portMAX_DELAY：一直等待，直到通知状态变为”pending”； 其他值：Tick Count，可以用*pdMS_TO_TICKS()*把ms转换为Tick Count</td>\n</tr>\n<tr>\n<td align=\"center\">返回值</td>\n<td>1. pdPASS：成功 这表示xTaskNotifyWait成功获得了通知： 可能是调用函数之前，通知状态就是”pending”； 也可能是在阻塞期间，通知状态变为了”pending”。 2. pdFAIL：没有得到通知。</td>\n</tr>\n</tbody></table>\n"},{"title":"音响实习の学习笔记","date":"2025-05-19T04:08:26.000Z","cover":"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505202214529.png","layout":"page","_content":"\n## 麦克风-话筒\n\n### 分类\n\n| 类型         | 优点                 | 缺点                 | 典型用途                 |\n| ------------ | -------------------- | -------------------- | ------------------------ |\n| **动圈话筒** | 耐用、抗啸叫、便宜   | 灵敏度低、高频细节少 | 现场演出、演讲、鼓麦克风 |\n| **电容话筒** | 高解析度、瞬态响应好 | 易受潮、需外部供电   | 录音棚、人声、乐器收音   |\n| **USB 话筒** | 即插即用、内置声卡   | 延迟较高、不可扩展   | 直播、播客、家庭录音     |\n| **领夹话筒** | 隐蔽、解放双手       | 易摩擦衣物产生噪音   | 视频拍摄、舞台剧         |\n| **枪式话筒** | 远距离定向拾音       | 环境反射影响音质     | 影视同期声、户外采访     |\n\n### 核心参数\n\n#### **频率响应（麦克风对不同频率声音的灵敏度变化曲线）：**\n\n- **理想范围**：人声录制建议 **80Hz-15kHz**，乐器需更宽（如 20Hz-20kHz）。\n- **曲线特性**：平直曲线适合真实还原，高频提升（如 AKG C414）可增强人声明亮度。\n\n#### **灵敏度（Sensitivity）**\n\n- 单位：**mV/Pa** 或 **dBV**（如-32dB > -40dB，<span style=\"color:#FF00FF;\">数值越高越灵敏</span>）。\n- **高灵敏度**：电容麦适合细节捕捉，但易收环境噪音；`一般在-30dB到-40dB`\n- **低灵敏度**：动圈麦抗噪强，适合现场演出。`一般在-54dB到-60dB`\n- **重要规律**：\n  ▶ 每增加 **6dB**，灵敏度翻倍（-38dB 比-44dB 灵敏 2 倍）\n\n#### **指向性（Polar Pattern)**\n\n- **心形（Cardioid）**：最常用，抑制后方噪音，适合独唱/演讲。`像\"手电筒光斑\"，正前方收音最强`\n- **超心形（Supercardioid）**：定向更强，适合嘈杂环境或远距离拾音。`光束更窄，但后方会出现\"小耳朵\"（微弱拾音区）`\n- **全向（Omni）**：360° 拾音，适合会议或合唱，但需安静环境。`像\"灯泡发光\"，360°均匀拾音`\n\n> 血泪教训：\n>\n> - 室内直播用 **心形**→ 抑制显示器风扇噪音\n> - 街头采访用 **超心形**→ 对抗环境噪音\n\n![0679D9F9](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505201936187.gif)\n\n#### **最大声压级（Max SPL）**\n\n- 动圈麦（如 Shure SM58）可承受 **150dB**，适合高音量乐器（如鼓）；电容麦通常 **120-130dB**，需注意过载。\n- 普通说话/弹唱：**100dB** 足够\n  **隐藏陷阱**：\n  某些电容麦标称高 SPL，但需要开启-10dB 衰减档（实质是压缩动态）\n\n![067E4DAE](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505201939640.gif)\n\n#### **信噪比（SNR）**\n\n- 假设麦克风输出信号 **-32dB**，底噪 **-82dB**\n- 信噪比 = **50dB**（-32 - (-82)）\n- **>70dB** 为佳，数值越高背景噪音越少。`60dB以上：专业级（几乎无底噪）` `50dB以下：能听到明显\"嘶嘶\"声`\n\n#### **阻抗（Impedance）**\n\n- 麦克风输出阻抗 **≤200Ω** 为低阻（适合长线缆传输）`阻抗越低，音量越小，音质越好。阻抗越高，音量越大，但容易失真`\n- 输入设备阻抗需 ≥5 倍麦克风阻抗（如麦克风 200Ω→ 声卡输入要 1kΩ）\n  **常见翻车现场**：\n  高阻麦克风（600Ω）接普通声卡 → 声音发闷/音量小\n\n### **终极避坑口诀**\n\n> 频响看曲线，灵敏看负数\n> 指向分角度，声压看极限\n> 信噪比 60 起，阻抗要低阻\n> 找 U 型麦克风（低频不容易影响）\n\n### 采购清单\n\n- 阻抗300Ω      心形         \n\n  | 话筒链接                                                     | 频响范围（Hz） | 阻抗（单位Ω） | 指向性 | 信噪比(单位dB) | 灵敏度 | 续航时长(单位h) | 价格（一拖二）           |\n  | ------------------------------------------------------------ | -------------- | ------------- | ------ | -------------- | ------ | --------------- | ------------------------ |\n  | [2.4g无线麦克风万能防啸叫 舞台k歌充电话筒声卡直播麦克风跨境 - 阿里巴巴](https://detail.1688.com/offer/792895999197.html?spm=a262uh.11734178.favorite-offers-offer-list-offer4.2.52422ef6AHREZ4) | 100-20kHz      | 300           | 心形   | ≥75dB          |        | 12              | 102.7+3（109高配好音质） |\n  | [无线麦克风家用K歌金属U段一拖二音响直播声卡录音高音质充电话筒 - 阿里巴巴](https://detail.1688.com/offer/809251918462.html?spm=a262uh.11734178.favorite-offers-offer-list-offer3.2.52422ef6AHREZ4) | 100-20kHz      |               | 心形   | ≥70db          |        | 6-8h(含)        | 95+8                     |\n  | [跨境无线麦克风话筒U段直播防啸叫一拖二ktv家用唱歌专用无线话筒 - 阿里巴巴](https://detail.1688.com/offer/910830646473.html?spm=a262uh.11734178.favorite-offers-offer-list-offer5.2.52422ef6AHREZ4) | 100-20kHz      | 600Ω          | 心型   | ≥85dB          |        | 1-3h(含)        | 68+5                     |\n  | [<span style=\"color:#33FFFF;\">全金属U段无线话筒一拖二KTV家用唱歌声卡直播功放音响通用麦克风 - 阿里巴巴</span>](https://detail.1688.com/offer/731692801179.html?spm=a262uh.11734178.favorite-offers-offer-list-offer2.2.52422ef6AHREZ4) | 30-20kHz       |               | 心型   | >95dB          |        | 3-6h(含)        | 145+5                    |\n  | [无线麦克风充电防啸叫 户外声卡直播麦克风家用音响k歌舞台话筒 - 阿里巴巴](https://detail.1688.com/offer/683303536027.html?spm=a262uh.11734178.favorite-offers-offer-list-offer1.2.52422ef6AHREZ4) | 80Hz-15kHz     |               | 心型   | \\>60dB         | -70dB  |                 | 70.2+3（VHF方案）        |\n\n   \n","source":"_posts/音响实习.md","raw":"---\ntitle: 音响实习の学习笔记\ndate: 2025-05-19 12:08:26\ncover: \"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505202214529.png\"\ntags:\n  - 音响\n  - 实习\n  - 音频技术\nlayout: page\ncategories: 实习知识\n---\n\n## 麦克风-话筒\n\n### 分类\n\n| 类型         | 优点                 | 缺点                 | 典型用途                 |\n| ------------ | -------------------- | -------------------- | ------------------------ |\n| **动圈话筒** | 耐用、抗啸叫、便宜   | 灵敏度低、高频细节少 | 现场演出、演讲、鼓麦克风 |\n| **电容话筒** | 高解析度、瞬态响应好 | 易受潮、需外部供电   | 录音棚、人声、乐器收音   |\n| **USB 话筒** | 即插即用、内置声卡   | 延迟较高、不可扩展   | 直播、播客、家庭录音     |\n| **领夹话筒** | 隐蔽、解放双手       | 易摩擦衣物产生噪音   | 视频拍摄、舞台剧         |\n| **枪式话筒** | 远距离定向拾音       | 环境反射影响音质     | 影视同期声、户外采访     |\n\n### 核心参数\n\n#### **频率响应（麦克风对不同频率声音的灵敏度变化曲线）：**\n\n- **理想范围**：人声录制建议 **80Hz-15kHz**，乐器需更宽（如 20Hz-20kHz）。\n- **曲线特性**：平直曲线适合真实还原，高频提升（如 AKG C414）可增强人声明亮度。\n\n#### **灵敏度（Sensitivity）**\n\n- 单位：**mV/Pa** 或 **dBV**（如-32dB > -40dB，<span style=\"color:#FF00FF;\">数值越高越灵敏</span>）。\n- **高灵敏度**：电容麦适合细节捕捉，但易收环境噪音；`一般在-30dB到-40dB`\n- **低灵敏度**：动圈麦抗噪强，适合现场演出。`一般在-54dB到-60dB`\n- **重要规律**：\n  ▶ 每增加 **6dB**，灵敏度翻倍（-38dB 比-44dB 灵敏 2 倍）\n\n#### **指向性（Polar Pattern)**\n\n- **心形（Cardioid）**：最常用，抑制后方噪音，适合独唱/演讲。`像\"手电筒光斑\"，正前方收音最强`\n- **超心形（Supercardioid）**：定向更强，适合嘈杂环境或远距离拾音。`光束更窄，但后方会出现\"小耳朵\"（微弱拾音区）`\n- **全向（Omni）**：360° 拾音，适合会议或合唱，但需安静环境。`像\"灯泡发光\"，360°均匀拾音`\n\n> 血泪教训：\n>\n> - 室内直播用 **心形**→ 抑制显示器风扇噪音\n> - 街头采访用 **超心形**→ 对抗环境噪音\n\n![0679D9F9](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505201936187.gif)\n\n#### **最大声压级（Max SPL）**\n\n- 动圈麦（如 Shure SM58）可承受 **150dB**，适合高音量乐器（如鼓）；电容麦通常 **120-130dB**，需注意过载。\n- 普通说话/弹唱：**100dB** 足够\n  **隐藏陷阱**：\n  某些电容麦标称高 SPL，但需要开启-10dB 衰减档（实质是压缩动态）\n\n![067E4DAE](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505201939640.gif)\n\n#### **信噪比（SNR）**\n\n- 假设麦克风输出信号 **-32dB**，底噪 **-82dB**\n- 信噪比 = **50dB**（-32 - (-82)）\n- **>70dB** 为佳，数值越高背景噪音越少。`60dB以上：专业级（几乎无底噪）` `50dB以下：能听到明显\"嘶嘶\"声`\n\n#### **阻抗（Impedance）**\n\n- 麦克风输出阻抗 **≤200Ω** 为低阻（适合长线缆传输）`阻抗越低，音量越小，音质越好。阻抗越高，音量越大，但容易失真`\n- 输入设备阻抗需 ≥5 倍麦克风阻抗（如麦克风 200Ω→ 声卡输入要 1kΩ）\n  **常见翻车现场**：\n  高阻麦克风（600Ω）接普通声卡 → 声音发闷/音量小\n\n### **终极避坑口诀**\n\n> 频响看曲线，灵敏看负数\n> 指向分角度，声压看极限\n> 信噪比 60 起，阻抗要低阻\n> 找 U 型麦克风（低频不容易影响）\n\n### 采购清单\n\n- 阻抗300Ω      心形         \n\n  | 话筒链接                                                     | 频响范围（Hz） | 阻抗（单位Ω） | 指向性 | 信噪比(单位dB) | 灵敏度 | 续航时长(单位h) | 价格（一拖二）           |\n  | ------------------------------------------------------------ | -------------- | ------------- | ------ | -------------- | ------ | --------------- | ------------------------ |\n  | [2.4g无线麦克风万能防啸叫 舞台k歌充电话筒声卡直播麦克风跨境 - 阿里巴巴](https://detail.1688.com/offer/792895999197.html?spm=a262uh.11734178.favorite-offers-offer-list-offer4.2.52422ef6AHREZ4) | 100-20kHz      | 300           | 心形   | ≥75dB          |        | 12              | 102.7+3（109高配好音质） |\n  | [无线麦克风家用K歌金属U段一拖二音响直播声卡录音高音质充电话筒 - 阿里巴巴](https://detail.1688.com/offer/809251918462.html?spm=a262uh.11734178.favorite-offers-offer-list-offer3.2.52422ef6AHREZ4) | 100-20kHz      |               | 心形   | ≥70db          |        | 6-8h(含)        | 95+8                     |\n  | [跨境无线麦克风话筒U段直播防啸叫一拖二ktv家用唱歌专用无线话筒 - 阿里巴巴](https://detail.1688.com/offer/910830646473.html?spm=a262uh.11734178.favorite-offers-offer-list-offer5.2.52422ef6AHREZ4) | 100-20kHz      | 600Ω          | 心型   | ≥85dB          |        | 1-3h(含)        | 68+5                     |\n  | [<span style=\"color:#33FFFF;\">全金属U段无线话筒一拖二KTV家用唱歌声卡直播功放音响通用麦克风 - 阿里巴巴</span>](https://detail.1688.com/offer/731692801179.html?spm=a262uh.11734178.favorite-offers-offer-list-offer2.2.52422ef6AHREZ4) | 30-20kHz       |               | 心型   | >95dB          |        | 3-6h(含)        | 145+5                    |\n  | [无线麦克风充电防啸叫 户外声卡直播麦克风家用音响k歌舞台话筒 - 阿里巴巴](https://detail.1688.com/offer/683303536027.html?spm=a262uh.11734178.favorite-offers-offer-list-offer1.2.52422ef6AHREZ4) | 80Hz-15kHz     |               | 心型   | \\>60dB         | -70dB  |                 | 70.2+3（VHF方案）        |\n\n   \n","slug":"音响实习","published":1,"updated":"2025-09-17T04:21:56.000Z","comments":1,"photos":[],"_id":"cmk8pg6xo00126sk942cr8qjd","content":"<h2 id=\"麦克风-话筒\"><a href=\"#麦克风-话筒\" class=\"headerlink\" title=\"麦克风-话筒\"></a>麦克风-话筒</h2><h3 id=\"分类\"><a href=\"#分类\" class=\"headerlink\" title=\"分类\"></a>分类</h3><table>\n<thead>\n<tr>\n<th>类型</th>\n<th>优点</th>\n<th>缺点</th>\n<th>典型用途</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>动圈话筒</strong></td>\n<td>耐用、抗啸叫、便宜</td>\n<td>灵敏度低、高频细节少</td>\n<td>现场演出、演讲、鼓麦克风</td>\n</tr>\n<tr>\n<td><strong>电容话筒</strong></td>\n<td>高解析度、瞬态响应好</td>\n<td>易受潮、需外部供电</td>\n<td>录音棚、人声、乐器收音</td>\n</tr>\n<tr>\n<td><strong>USB 话筒</strong></td>\n<td>即插即用、内置声卡</td>\n<td>延迟较高、不可扩展</td>\n<td>直播、播客、家庭录音</td>\n</tr>\n<tr>\n<td><strong>领夹话筒</strong></td>\n<td>隐蔽、解放双手</td>\n<td>易摩擦衣物产生噪音</td>\n<td>视频拍摄、舞台剧</td>\n</tr>\n<tr>\n<td><strong>枪式话筒</strong></td>\n<td>远距离定向拾音</td>\n<td>环境反射影响音质</td>\n<td>影视同期声、户外采访</td>\n</tr>\n</tbody></table>\n<h3 id=\"核心参数\"><a href=\"#核心参数\" class=\"headerlink\" title=\"核心参数\"></a>核心参数</h3><h4 id=\"频率响应（麦克风对不同频率声音的灵敏度变化曲线）：\"><a href=\"#频率响应（麦克风对不同频率声音的灵敏度变化曲线）：\" class=\"headerlink\" title=\"频率响应（麦克风对不同频率声音的灵敏度变化曲线）：\"></a><strong>频率响应（麦克风对不同频率声音的灵敏度变化曲线）：</strong></h4><ul>\n<li><strong>理想范围</strong>：人声录制建议 <strong>80Hz-15kHz</strong>，乐器需更宽（如 20Hz-20kHz）。</li>\n<li><strong>曲线特性</strong>：平直曲线适合真实还原，高频提升（如 AKG C414）可增强人声明亮度。</li>\n</ul>\n<h4 id=\"灵敏度（Sensitivity）\"><a href=\"#灵敏度（Sensitivity）\" class=\"headerlink\" title=\"灵敏度（Sensitivity）\"></a><strong>灵敏度（Sensitivity）</strong></h4><ul>\n<li>单位：<strong>mV&#x2F;Pa</strong> 或 <strong>dBV</strong>（如-32dB &gt; -40dB，<span style=\"color:#FF00FF;\">数值越高越灵敏</span>）。</li>\n<li><strong>高灵敏度</strong>：电容麦适合细节捕捉，但易收环境噪音；<code>一般在-30dB到-40dB</code></li>\n<li><strong>低灵敏度</strong>：动圈麦抗噪强，适合现场演出。<code>一般在-54dB到-60dB</code></li>\n<li><strong>重要规律</strong>：<br>▶ 每增加 <strong>6dB</strong>，灵敏度翻倍（-38dB 比-44dB 灵敏 2 倍）</li>\n</ul>\n<h4 id=\"指向性（Polar-Pattern\"><a href=\"#指向性（Polar-Pattern\" class=\"headerlink\" title=\"指向性（Polar Pattern)\"></a><strong>指向性（Polar Pattern)</strong></h4><ul>\n<li><strong>心形（Cardioid）</strong>：最常用，抑制后方噪音，适合独唱&#x2F;演讲。<code>像&quot;手电筒光斑&quot;，正前方收音最强</code></li>\n<li><strong>超心形（Supercardioid）</strong>：定向更强，适合嘈杂环境或远距离拾音。<code>光束更窄，但后方会出现&quot;小耳朵&quot;（微弱拾音区）</code></li>\n<li><strong>全向（Omni）</strong>：360° 拾音，适合会议或合唱，但需安静环境。<code>像&quot;灯泡发光&quot;，360°均匀拾音</code></li>\n</ul>\n<blockquote>\n<p>血泪教训：</p>\n<ul>\n<li>室内直播用 <strong>心形</strong>→ 抑制显示器风扇噪音</li>\n<li>街头采访用 <strong>超心形</strong>→ 对抗环境噪音</li>\n</ul>\n</blockquote>\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505201936187.gif\" alt=\"0679D9F9\"></p>\n<h4 id=\"最大声压级（Max-SPL）\"><a href=\"#最大声压级（Max-SPL）\" class=\"headerlink\" title=\"最大声压级（Max SPL）\"></a><strong>最大声压级（Max SPL）</strong></h4><ul>\n<li>动圈麦（如 Shure SM58）可承受 <strong>150dB</strong>，适合高音量乐器（如鼓）；电容麦通常 <strong>120-130dB</strong>，需注意过载。</li>\n<li>普通说话&#x2F;弹唱：<strong>100dB</strong> 足够<br><strong>隐藏陷阱</strong>：<br>某些电容麦标称高 SPL，但需要开启-10dB 衰减档（实质是压缩动态）</li>\n</ul>\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505201939640.gif\" alt=\"067E4DAE\"></p>\n<h4 id=\"信噪比（SNR）\"><a href=\"#信噪比（SNR）\" class=\"headerlink\" title=\"信噪比（SNR）\"></a><strong>信噪比（SNR）</strong></h4><ul>\n<li>假设麦克风输出信号 <strong>-32dB</strong>，底噪 <strong>-82dB</strong></li>\n<li>信噪比 &#x3D; <strong>50dB</strong>（-32 - (-82)）</li>\n<li><strong>&gt;70dB</strong> 为佳，数值越高背景噪音越少。<code>60dB以上：专业级（几乎无底噪）</code> <code>50dB以下：能听到明显&quot;嘶嘶&quot;声</code></li>\n</ul>\n<h4 id=\"阻抗（Impedance）\"><a href=\"#阻抗（Impedance）\" class=\"headerlink\" title=\"阻抗（Impedance）\"></a><strong>阻抗（Impedance）</strong></h4><ul>\n<li>麦克风输出阻抗 <strong>≤200Ω</strong> 为低阻（适合长线缆传输）<code>阻抗越低，音量越小，音质越好。阻抗越高，音量越大，但容易失真</code></li>\n<li>输入设备阻抗需 ≥5 倍麦克风阻抗（如麦克风 200Ω→ 声卡输入要 1kΩ）<br><strong>常见翻车现场</strong>：<br>高阻麦克风（600Ω）接普通声卡 → 声音发闷&#x2F;音量小</li>\n</ul>\n<h3 id=\"终极避坑口诀\"><a href=\"#终极避坑口诀\" class=\"headerlink\" title=\"终极避坑口诀\"></a><strong>终极避坑口诀</strong></h3><blockquote>\n<p>频响看曲线，灵敏看负数<br>指向分角度，声压看极限<br>信噪比 60 起，阻抗要低阻<br>找 U 型麦克风（低频不容易影响）</p>\n</blockquote>\n<h3 id=\"采购清单\"><a href=\"#采购清单\" class=\"headerlink\" title=\"采购清单\"></a>采购清单</h3><ul>\n<li><p>阻抗300Ω      心形         </p>\n<table>\n<thead>\n<tr>\n<th>话筒链接</th>\n<th>频响范围（Hz）</th>\n<th>阻抗（单位Ω）</th>\n<th>指向性</th>\n<th>信噪比(单位dB)</th>\n<th>灵敏度</th>\n<th>续航时长(单位h)</th>\n<th>价格（一拖二）</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><a href=\"https://detail.1688.com/offer/792895999197.html?spm=a262uh.11734178.favorite-offers-offer-list-offer4.2.52422ef6AHREZ4\">2.4g无线麦克风万能防啸叫 舞台k歌充电话筒声卡直播麦克风跨境 - 阿里巴巴</a></td>\n<td>100-20kHz</td>\n<td>300</td>\n<td>心形</td>\n<td>≥75dB</td>\n<td></td>\n<td>12</td>\n<td>102.7+3（109高配好音质）</td>\n</tr>\n<tr>\n<td><a href=\"https://detail.1688.com/offer/809251918462.html?spm=a262uh.11734178.favorite-offers-offer-list-offer3.2.52422ef6AHREZ4\">无线麦克风家用K歌金属U段一拖二音响直播声卡录音高音质充电话筒 - 阿里巴巴</a></td>\n<td>100-20kHz</td>\n<td></td>\n<td>心形</td>\n<td>≥70db</td>\n<td></td>\n<td>6-8h(含)</td>\n<td>95+8</td>\n</tr>\n<tr>\n<td><a href=\"https://detail.1688.com/offer/910830646473.html?spm=a262uh.11734178.favorite-offers-offer-list-offer5.2.52422ef6AHREZ4\">跨境无线麦克风话筒U段直播防啸叫一拖二ktv家用唱歌专用无线话筒 - 阿里巴巴</a></td>\n<td>100-20kHz</td>\n<td>600Ω</td>\n<td>心型</td>\n<td>≥85dB</td>\n<td></td>\n<td>1-3h(含)</td>\n<td>68+5</td>\n</tr>\n<tr>\n<td><a href=\"https://detail.1688.com/offer/731692801179.html?spm=a262uh.11734178.favorite-offers-offer-list-offer2.2.52422ef6AHREZ4\"><span style=\"color:#33FFFF;\">全金属U段无线话筒一拖二KTV家用唱歌声卡直播功放音响通用麦克风 - 阿里巴巴</span></a></td>\n<td>30-20kHz</td>\n<td></td>\n<td>心型</td>\n<td>&gt;95dB</td>\n<td></td>\n<td>3-6h(含)</td>\n<td>145+5</td>\n</tr>\n<tr>\n<td><a href=\"https://detail.1688.com/offer/683303536027.html?spm=a262uh.11734178.favorite-offers-offer-list-offer1.2.52422ef6AHREZ4\">无线麦克风充电防啸叫 户外声卡直播麦克风家用音响k歌舞台话筒 - 阿里巴巴</a></td>\n<td>80Hz-15kHz</td>\n<td></td>\n<td>心型</td>\n<td>&gt;60dB</td>\n<td>-70dB</td>\n<td></td>\n<td>70.2+3（VHF方案）</td>\n</tr>\n</tbody></table>\n</li>\n</ul>\n","excerpt":"","more":"<h2 id=\"麦克风-话筒\"><a href=\"#麦克风-话筒\" class=\"headerlink\" title=\"麦克风-话筒\"></a>麦克风-话筒</h2><h3 id=\"分类\"><a href=\"#分类\" class=\"headerlink\" title=\"分类\"></a>分类</h3><table>\n<thead>\n<tr>\n<th>类型</th>\n<th>优点</th>\n<th>缺点</th>\n<th>典型用途</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>动圈话筒</strong></td>\n<td>耐用、抗啸叫、便宜</td>\n<td>灵敏度低、高频细节少</td>\n<td>现场演出、演讲、鼓麦克风</td>\n</tr>\n<tr>\n<td><strong>电容话筒</strong></td>\n<td>高解析度、瞬态响应好</td>\n<td>易受潮、需外部供电</td>\n<td>录音棚、人声、乐器收音</td>\n</tr>\n<tr>\n<td><strong>USB 话筒</strong></td>\n<td>即插即用、内置声卡</td>\n<td>延迟较高、不可扩展</td>\n<td>直播、播客、家庭录音</td>\n</tr>\n<tr>\n<td><strong>领夹话筒</strong></td>\n<td>隐蔽、解放双手</td>\n<td>易摩擦衣物产生噪音</td>\n<td>视频拍摄、舞台剧</td>\n</tr>\n<tr>\n<td><strong>枪式话筒</strong></td>\n<td>远距离定向拾音</td>\n<td>环境反射影响音质</td>\n<td>影视同期声、户外采访</td>\n</tr>\n</tbody></table>\n<h3 id=\"核心参数\"><a href=\"#核心参数\" class=\"headerlink\" title=\"核心参数\"></a>核心参数</h3><h4 id=\"频率响应（麦克风对不同频率声音的灵敏度变化曲线）：\"><a href=\"#频率响应（麦克风对不同频率声音的灵敏度变化曲线）：\" class=\"headerlink\" title=\"频率响应（麦克风对不同频率声音的灵敏度变化曲线）：\"></a><strong>频率响应（麦克风对不同频率声音的灵敏度变化曲线）：</strong></h4><ul>\n<li><strong>理想范围</strong>：人声录制建议 <strong>80Hz-15kHz</strong>，乐器需更宽（如 20Hz-20kHz）。</li>\n<li><strong>曲线特性</strong>：平直曲线适合真实还原，高频提升（如 AKG C414）可增强人声明亮度。</li>\n</ul>\n<h4 id=\"灵敏度（Sensitivity）\"><a href=\"#灵敏度（Sensitivity）\" class=\"headerlink\" title=\"灵敏度（Sensitivity）\"></a><strong>灵敏度（Sensitivity）</strong></h4><ul>\n<li>单位：<strong>mV&#x2F;Pa</strong> 或 <strong>dBV</strong>（如-32dB &gt; -40dB，<span style=\"color:#FF00FF;\">数值越高越灵敏</span>）。</li>\n<li><strong>高灵敏度</strong>：电容麦适合细节捕捉，但易收环境噪音；<code>一般在-30dB到-40dB</code></li>\n<li><strong>低灵敏度</strong>：动圈麦抗噪强，适合现场演出。<code>一般在-54dB到-60dB</code></li>\n<li><strong>重要规律</strong>：<br>▶ 每增加 <strong>6dB</strong>，灵敏度翻倍（-38dB 比-44dB 灵敏 2 倍）</li>\n</ul>\n<h4 id=\"指向性（Polar-Pattern\"><a href=\"#指向性（Polar-Pattern\" class=\"headerlink\" title=\"指向性（Polar Pattern)\"></a><strong>指向性（Polar Pattern)</strong></h4><ul>\n<li><strong>心形（Cardioid）</strong>：最常用，抑制后方噪音，适合独唱&#x2F;演讲。<code>像&quot;手电筒光斑&quot;，正前方收音最强</code></li>\n<li><strong>超心形（Supercardioid）</strong>：定向更强，适合嘈杂环境或远距离拾音。<code>光束更窄，但后方会出现&quot;小耳朵&quot;（微弱拾音区）</code></li>\n<li><strong>全向（Omni）</strong>：360° 拾音，适合会议或合唱，但需安静环境。<code>像&quot;灯泡发光&quot;，360°均匀拾音</code></li>\n</ul>\n<blockquote>\n<p>血泪教训：</p>\n<ul>\n<li>室内直播用 <strong>心形</strong>→ 抑制显示器风扇噪音</li>\n<li>街头采访用 <strong>超心形</strong>→ 对抗环境噪音</li>\n</ul>\n</blockquote>\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505201936187.gif\" alt=\"0679D9F9\"></p>\n<h4 id=\"最大声压级（Max-SPL）\"><a href=\"#最大声压级（Max-SPL）\" class=\"headerlink\" title=\"最大声压级（Max SPL）\"></a><strong>最大声压级（Max SPL）</strong></h4><ul>\n<li>动圈麦（如 Shure SM58）可承受 <strong>150dB</strong>，适合高音量乐器（如鼓）；电容麦通常 <strong>120-130dB</strong>，需注意过载。</li>\n<li>普通说话&#x2F;弹唱：<strong>100dB</strong> 足够<br><strong>隐藏陷阱</strong>：<br>某些电容麦标称高 SPL，但需要开启-10dB 衰减档（实质是压缩动态）</li>\n</ul>\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505201939640.gif\" alt=\"067E4DAE\"></p>\n<h4 id=\"信噪比（SNR）\"><a href=\"#信噪比（SNR）\" class=\"headerlink\" title=\"信噪比（SNR）\"></a><strong>信噪比（SNR）</strong></h4><ul>\n<li>假设麦克风输出信号 <strong>-32dB</strong>，底噪 <strong>-82dB</strong></li>\n<li>信噪比 &#x3D; <strong>50dB</strong>（-32 - (-82)）</li>\n<li><strong>&gt;70dB</strong> 为佳，数值越高背景噪音越少。<code>60dB以上：专业级（几乎无底噪）</code> <code>50dB以下：能听到明显&quot;嘶嘶&quot;声</code></li>\n</ul>\n<h4 id=\"阻抗（Impedance）\"><a href=\"#阻抗（Impedance）\" class=\"headerlink\" title=\"阻抗（Impedance）\"></a><strong>阻抗（Impedance）</strong></h4><ul>\n<li>麦克风输出阻抗 <strong>≤200Ω</strong> 为低阻（适合长线缆传输）<code>阻抗越低，音量越小，音质越好。阻抗越高，音量越大，但容易失真</code></li>\n<li>输入设备阻抗需 ≥5 倍麦克风阻抗（如麦克风 200Ω→ 声卡输入要 1kΩ）<br><strong>常见翻车现场</strong>：<br>高阻麦克风（600Ω）接普通声卡 → 声音发闷&#x2F;音量小</li>\n</ul>\n<h3 id=\"终极避坑口诀\"><a href=\"#终极避坑口诀\" class=\"headerlink\" title=\"终极避坑口诀\"></a><strong>终极避坑口诀</strong></h3><blockquote>\n<p>频响看曲线，灵敏看负数<br>指向分角度，声压看极限<br>信噪比 60 起，阻抗要低阻<br>找 U 型麦克风（低频不容易影响）</p>\n</blockquote>\n<h3 id=\"采购清单\"><a href=\"#采购清单\" class=\"headerlink\" title=\"采购清单\"></a>采购清单</h3><ul>\n<li><p>阻抗300Ω      心形         </p>\n<table>\n<thead>\n<tr>\n<th>话筒链接</th>\n<th>频响范围（Hz）</th>\n<th>阻抗（单位Ω）</th>\n<th>指向性</th>\n<th>信噪比(单位dB)</th>\n<th>灵敏度</th>\n<th>续航时长(单位h)</th>\n<th>价格（一拖二）</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><a href=\"https://detail.1688.com/offer/792895999197.html?spm=a262uh.11734178.favorite-offers-offer-list-offer4.2.52422ef6AHREZ4\">2.4g无线麦克风万能防啸叫 舞台k歌充电话筒声卡直播麦克风跨境 - 阿里巴巴</a></td>\n<td>100-20kHz</td>\n<td>300</td>\n<td>心形</td>\n<td>≥75dB</td>\n<td></td>\n<td>12</td>\n<td>102.7+3（109高配好音质）</td>\n</tr>\n<tr>\n<td><a href=\"https://detail.1688.com/offer/809251918462.html?spm=a262uh.11734178.favorite-offers-offer-list-offer3.2.52422ef6AHREZ4\">无线麦克风家用K歌金属U段一拖二音响直播声卡录音高音质充电话筒 - 阿里巴巴</a></td>\n<td>100-20kHz</td>\n<td></td>\n<td>心形</td>\n<td>≥70db</td>\n<td></td>\n<td>6-8h(含)</td>\n<td>95+8</td>\n</tr>\n<tr>\n<td><a href=\"https://detail.1688.com/offer/910830646473.html?spm=a262uh.11734178.favorite-offers-offer-list-offer5.2.52422ef6AHREZ4\">跨境无线麦克风话筒U段直播防啸叫一拖二ktv家用唱歌专用无线话筒 - 阿里巴巴</a></td>\n<td>100-20kHz</td>\n<td>600Ω</td>\n<td>心型</td>\n<td>≥85dB</td>\n<td></td>\n<td>1-3h(含)</td>\n<td>68+5</td>\n</tr>\n<tr>\n<td><a href=\"https://detail.1688.com/offer/731692801179.html?spm=a262uh.11734178.favorite-offers-offer-list-offer2.2.52422ef6AHREZ4\"><span style=\"color:#33FFFF;\">全金属U段无线话筒一拖二KTV家用唱歌声卡直播功放音响通用麦克风 - 阿里巴巴</span></a></td>\n<td>30-20kHz</td>\n<td></td>\n<td>心型</td>\n<td>&gt;95dB</td>\n<td></td>\n<td>3-6h(含)</td>\n<td>145+5</td>\n</tr>\n<tr>\n<td><a href=\"https://detail.1688.com/offer/683303536027.html?spm=a262uh.11734178.favorite-offers-offer-list-offer1.2.52422ef6AHREZ4\">无线麦克风充电防啸叫 户外声卡直播麦克风家用音响k歌舞台话筒 - 阿里巴巴</a></td>\n<td>80Hz-15kHz</td>\n<td></td>\n<td>心型</td>\n<td>&gt;60dB</td>\n<td>-70dB</td>\n<td></td>\n<td>70.2+3（VHF方案）</td>\n</tr>\n</tbody></table>\n</li>\n</ul>\n"},{"title":"西门子嵌入式学习","date":"2025-06-02T08:00:53.000Z","sticky":true,"cover":"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202506021603366.jpg","_content":"\n## 调度器模板\n\n```C\n#include \"scheduler.h\"\n// clang-format off\ntypedef struct\n{\n\tvoid (*task_func)(void);\n\tuint32_t rate_ms;\n\tuint32_t last_ms;\n} task_t;\n\ntask_t tasks[] = {\n};\n\nuint8_t task_count;\n\nvoid scheduler_init(void)\n{\n\ttask_count = sizeof(tasks) / sizeof(task_t);\n}\n\nvoid scheduler_run(void)\n{\n\tuint8_t i;\n\tfor (i = 0; i < task_count; i++)\n\t{\n\t\tuint32_t now_time = HAL_GetTick();\n\t\tif ((uint32_t)(now_time - tasks[i].last_ms) >= tasks[i].rate_ms)\n\t\t{\n\t\t\ttasks[i].last_ms = now_time;\n\t\t\ttasks[i].task_func();\n\t\t}\n\t}\n}\n\n```\n\n\n\n## 时钟配置栏\n\n### 模式设置\n\n![image-20250602161506934](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202506021615783.png)\n\n#### 高速时钟HSE\n\n- `Disable`：不启用外部时钟（默认使用内部时钟） <span style=\"color:#00FFFF;\">内部时钟（内部RC（电阻-电容）振荡器）提供了此便捷性 但精度不如外部时钟（外部低速晶振或陶瓷振荡器）</span>\n\n- `BYPASS Clock Source`：旁路模式，允许直接<span style=\"color:#00FFFF;\">从外部导入时钟信号，而不使用外部晶体</span>。这种模式适用于需要从外部系统或其他设备接收时钟信号的情况。\n\n- `Crystal/Ceramic Resonator`：将外部低速晶振或陶瓷谐振器作为时钟源，一般则是板载上的外部晶振\n\n#### 低速时钟LSE\n\n> 参数同上 通常用于<span style=\"color:#33FFFF;\">实时时钟（RTC</span>）等需要低频稳定时钟的应用。LSE的典型频率为32.768kHz\n\n#### **Master Clock Output**\n\n- 配置是否使能主时钟<span style=\"color:#33FFFF;\">输出到MCO引脚</span>，`即可以通过MCO引脚将时钟信号输出到外部，供其他设备使用`\n\n#### **Audio Clock Input (I2S_CKIN)**：\n\n- 此选项用于配置是否从<span style=\"color:#33FFFF;\">特定的引脚（如I2S_CKIN）输入音频时钟</span>。这对于需要精确音频时钟的音频应用非常重要，`例如I2S音频接口`。\n\n### 参数设置\n\n![image-20250602162859501](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202506021629990.png)\n\n- `TIM Prescaler Selection`：定时器预分频选择，`禁用时使用最大分频值。`\n\n- `HSE Startup Timeout Value (ms)`：HSE（高速外部时钟）启动超时时间，设置为100ms。这是外部晶振启动的最长等待时间，如果超出这个时间晶振还未启动，微控制器会认为启动失败。\n- `LSE Startup Timeout Value (ms)`：LSE（低速外部时钟）启动超时时间，设置为5000ms。这通常用于RTC的时钟源，如果超出这个时间晶振还未启动，微控制器会认为启动失败。\n\n- `Power Regulator Voltage Scale`：电源调节器电压等级，设置为`Power Regulator Voltage Scale 3`。这通常与微控制器的性能和功耗有关，不同的电压等级可以提供不同的性能和功耗平衡。\n\n- `Power Over Drive`：电源过驱，禁用。这通常用于在需要更高性能时<span style=\"color:#33FFFF;\">临时提高微控制器的电压</span>，以支持更高的时钟频率。\n\n### 在何处选择了HSI以及HSE\n\n![image-20250602181824740](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202506021818291.png)\n\n- 第一个框一定一定要看硬件上的晶振是多少频率，<span style=\"color:#00FFFF;\">一定要严格按照硬件资源给的 （不要无脑用默认的）</span>\n\n  > 否则可能会出现串口数据接收乱码\n\n- 第二个框选择了用`相位锁定环（PLL） 调整外部高速时钟（HSE）还是内部高速时钟（HSI）\n\n- 第三个框框则直接选择是否选择 经过PLL调整后的时钟，也可以选择不经过PLL的原生外部高速时钟（HSE），以及内部高速时钟（HSI）。\n\n## SYS调试接口选择\n\n![image-20250602182759796](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202506021828146.png)\n\n### Serial Wire (SW-DP)\n\n- 串口烧录 仅需要两个引脚\n  - `SWCLK`：主机到从机的时钟信号\n  - `SWDIO`：双向数据信号\n\n- 这种模式下，ST-Link工作最稳定，占用引脚少，是日常开发的首选。\n\n### JTAG(JTAG-DP)\n\n- J-Link烧录 需要4或5个引脚：\n  - **TCK：**测试时钟\n  - **TMS：**测试模式选择\n  - **TDI：**测试数据输入\n  - **TDO：**测试数据输出\n  - **TRST：**测试复位（可选，5pin模式才有）\n- JTAG适合复杂的调试场景，尤其是在使用J-Link调试器时。\n\n## LED\n\n### 驱动代码\n\n```C\n#include \"led_app.h\"\n\nuint8_t ucLed[6] = {0, 0, 1, 0, 1, 1};\n\nvoid Led_disp(uint8_t *ucLed)\n{\n\tuint8_t temp = 0x00, i;\n\tstatic uint8_t temp_old = 0xff;\n\tfor (i = 0; i < 6; i++)\n\t{\n\t\tif (ucLed[i])\n\t\t\ttemp |= (1 << i);\n\t}\n\tif (temp != temp_old)\n\t{\n\t\tHAL_GPIO_WritePin(LED1_GPIO_Port, LED1_Pin, (temp & 0x01) ? GPIO_PIN_SET : GPIO_PIN_RESET);\n\t\tHAL_GPIO_WritePin(LED2_GPIO_Port, LED2_Pin, (temp & 0x02) ? GPIO_PIN_SET : GPIO_PIN_RESET);\n\t\tHAL_GPIO_WritePin(LED3_GPIO_Port, LED3_Pin, (temp & 0x04) ? GPIO_PIN_SET : GPIO_PIN_RESET);\n\t\tHAL_GPIO_WritePin(LED4_GPIO_Port, LED4_Pin, (temp & 0x08) ? GPIO_PIN_SET : GPIO_PIN_RESET);\n\t\tHAL_GPIO_WritePin(LED5_GPIO_Port, LED5_Pin, (temp & 0x10) ? GPIO_PIN_SET : GPIO_PIN_RESET);\n\t\tHAL_GPIO_WritePin(LED6_GPIO_Port, LED6_Pin, (temp & 0x20) ? GPIO_PIN_SET : GPIO_PIN_RESET);\n\t\ttemp_old = temp;\n\t}\n}\n\nvoid led_task(void)\n{\n\tLed_disp(ucLed);\n}\n```\n\n### 软件PWM呼吸灯\n\n```C\nvoid led_task(void)\n{\n\tstatic uint32_t breath_counter = 0;\t\t\t// 呼吸效果内部计时器，模拟时间流逝\n\tstatic uint8_t pwm_counter = 0;\t\t\t\t// PWM内部计时器，用于生成PWM波形\n\tstatic uint8_t brightness = 0;\t\t\t\t// 当前的亮度值\n\tstatic const uint16_t breath_period = 2000; // 呼吸效果周期，单位ms 调小可增加速度\n\tstatic const uint16_t pwm_max = 10;\t\t\t// PWM最大计数值  调大会降低pwm频率\n\n\tbreath_counter = (++breath_counter) % breath_period;\n        //(2.0f * 3.14159f * breath_counter / breath_period) 将结果映射为0到2π\n        //sin(2.0f * 3.14159f * breath_counter / breath_period) 将结果映射为-1到1\n        //sin(2.0f * 3.14159f * breath_counter / breath_period) + 1.0f 将结果映射为0到2\n        //(sin(2.0f * 3.14159f * breath_counter / breath_period) + 1.0f) * pwm_max / 2.0f 将实际亮度计算出来 通过(uint8_t)强制类型转换\n\tbrightness = (uint8_t)((sin(2.0f * 3.14159f * breath_counter / breath_period) + 1.0f) * pwm_max / 2.0f);\n\tpwm_counter = (++pwm_counter) % pwm_max;\n\tfor (uint8_t i = 0; i < 6; i++)\n\t\tucLed[i] = (pwm_counter < brightness) ? 1 : 0; //将所有LED置为呼吸灯效果\n\tLed_disp(ucLed);\n}\n```\n\n> 如果是要实时调光，则直接赋值`brightness`即可 （即<span style=\"color:#FF3333;\">不需要</span>`breath_counter`和`breath_period`）\n\n## 按键\n\n> 常用工程上所用按键对比\n>\n> github仓库地址：[bobwenstudy/easy_button: 嵌入式按键处理驱动（Button Driver），支持单击、双击、多击、自动消抖、长按、长长按、超长按 | 低功耗支持 | 组合按键支持 | 静态/动态注册支持](https://github.com/bobwenstudy/easy_button)\n\n![image-20250606171853466](https://fastly.jsdelivr.net/gh/2250272571/tuchuang@main/img/202506061718736.png)\n\n> 整体框架：\n> easy_button\n>  ├── ebtn\n>  │   ├── bit_array.h\n>  │   ├── ebtn.c\n>  │   └── ebtn.h\n>  ├── build.mk\n>  ├── example_user.c\n>  └── example_test.c\n>  ├── main.c\n>  ├── Makefile\n>  └── README.md\n\n### 使用步骤\n\n#### 第一步：新建button_app.c并包含头文件\n\n```C\n#include \"ebtn.h\" // 包含 ebtn 库头文件\n// ... 可能还需要包含你的 HAL 库头文件 ...\n// #include \"stm32xxx_hal.h\"\n```\n\n#### 第二步：定义参数与按键列表\n\n1. **定义按键参数 (`ebtn_btn_param_t`):** 使用 `EBTN_PARAMS_INIT` 宏设定按键的各种时间阈值和行为。这些参数可以被多个按键共用。`可用默认参数 即如下default_param_normal`\n2. **定义按键实例数组 (`ebtn_btn_t`):** 使用 `EBTN_BUTTON_INIT` 宏创建每个物理按键的实例，并指定它的唯一 `key_id` 和使用的参数。\n3. **（可不加）定义组合按键实例数组 (`ebtn_btn_combo_t`, 可选):** 使用 `EBTN_BUTTON_COMBO_INIT` 创建组合键实例，同样指定 `key_id` 和参数。\n\n```C\n/* 1. 定义按键参数实例 */\n// 参数宏: EBTN_PARAMS_INIT(\n//     按下消抖时间ms, 释放消抖时间ms,\n//     单击有效最短按下时间ms, 单击有效最长按下时间ms,\n//     多次单击最大间隔时间ms,\n//     长按(KeepAlive)事件周期ms (0禁用),\n//     最大连续有效点击次数 (e.g., 1=单击, 2=双击, ...)\n// )\nconst ebtn_btn_param_t default_param_normal = EBTN_PARAMS_INIT(\n    20,     // time_debounce: 按下稳定 20ms(消抖)\n    20,     // time_debounce_release: 释放稳定 20ms\n    50,     // time_click_pressed_min: 最短单击按下 50ms\n    500,    // time_click_pressed_max: 最长单击按下 500ms (超过则不算单击)\n    300,    // time_click_multi_max: 多次单击最大间隔 300ms (两次点击间隔超过则重新计数)\n    500,    // time_keepalive_period: 长按事件周期 500ms (按下超过 500ms 后，每 500ms 触发一次)\n    5       // max_consecutive: 最多支持 5 连击\n);\n\n/* 2. 定义静态按键列表 */\n// 宏: EBTN_BUTTON_INIT(按键ID, 参数指针)\nebtn_btn_t static_buttons[] = {\n    EBTN_BUTTON_INIT(1, &default_param_normal), // KEY1, ID=1, 使用 'default_param_normal' 参数\n    EBTN_BUTTON_INIT(2, &default_param_normal), // KEY2, ID=2, 也使用 'default_param_normal' 参数\n};\n\n/* 3. 定义静态组合按键列表 (可选) */\n// 宏: EBTN_BUTTON_COMBO_INIT(按键ID, 参数指针)\nebtn_btn_combo_t static_combos[] = {\n    // 假设 KEY1+KEY2 组合键\n    EBTN_BUTTON_COMBO_INIT(101, &default_param_normal), // 组合键, ID=101 (必须与普通按键ID不同)\n};\n\n```\n\n#### 第三步：编写回调函数\n\n你需要提供两个函数给 `ebtn` 库，告诉它如何与你的硬件交互以及如何通知你事件：\n\n- **`get_state_fn` (状态获取):** 这个函数被 `ebtn` 调用，用于读取指定按键当前的物理电平。\n- **`evt_fn` (事件处理):** 当 `ebtn` 检测到一个有效的按键事件（按下、释放、单击、长按）时，会调用这个函数，并传入触发事件的按键信息和事件类型。\n\n```C\n/* 1. 实现获取按键状态的回调函数 */\n// 函数原型: uint8_t (*ebtn_get_state_fn)(struct ebtn_btn *btn);\nuint8_t my_get_key_state(struct ebtn_btn *btn) {\n    // 根据传入的按钮实例中的 key_id 判断是哪个物理按键\n    switch (btn->key_id) {\n        case 1: // 请求读取 KEY1 的状态\n            // 假设 KEY1 接在 PB0，按下为低电平 (返回 1 代表按下)\n            return (HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_0) == GPIO_PIN_RESET);\n        case 2: // 请求读取 KEY2 的状态\n            // 假设 KEY2 接在 PB1，按下为低电平\n            return (HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_1) == GPIO_PIN_RESET);\n        // ... 可以添加更多按键的读取逻辑 ...\n        default:\n            // 对于库内部处理组合键等情况，或者未知的 key_id，安全起见返回 0 (未按下)\n            return 0;\n    }\n    // 注意：返回值 1 表示 \"活动/按下\"，0 表示 \"非活动/释放\"\n}\n\n/* 2. 实现处理按键事件的回调函数 */\n// 函数原型: void (*ebtn_evt_fn)(struct ebtn_btn *btn, ebtn_evt_t evt);\nvoid my_handle_key_event(struct ebtn_btn *btn, ebtn_evt_t evt) {\n    uint16_t key_id = btn->key_id;                 // 获取触发事件的按键 ID\n    uint16_t click_cnt = ebtn_click_get_count(btn); // 获取连击次数 (仅在 ONCLICK 事件时有意义)\n    // uint16_t kalive_cnt = ebtn_keepalive_get_count(btn); // 获取长按计数 (仅在 KEEPALIVE 事件时有意义)\n\n    // 调试打印 (可选)\n    // printf(\"Key ID: %d, Event: %d\", key_id, evt);\n\n    // 根据事件类型进行处理\n    switch (evt) {\n        case EBTN_EVT_ONPRESS: // 按下事件 (消抖成功后触发一次)\n            // printf(\" - Pressed\\n\");\n            // 可以在这里处理按下即触发的操作，比如点亮提示灯\n            if (key_id == 1) { /* Do something for KEY1 press */ }\n            break;\n\n        case EBTN_EVT_ONRELEASE: // 释放事件 (消抖成功后触发一次)\n            // printf(\" - Released\\n\");\n            // 可以在这里处理释放时触发的操作\n             if (key_id == 1) { /* Do something for KEY1 release */ }\n            break;\n\n        case EBTN_EVT_ONCLICK: // 单击/连击事件 (在释放后，或达到最大连击数，或超时后触发)\n            // printf(\" - Clicked (%d times)\\n\", click_cnt);\n            // --- 根据 key_id 和 click_cnt 执行不同操作 ---\n            if (key_id == 1) { // 如果是 KEY1 触发的 CLICK\n                if (click_cnt == 1) {\n                    // KEY1 单击\n                    // printf(\"  Action: KEY1 Single Click - Toggle LED1\\n\");\n                    // HAL_GPIO_TogglePin(LED1_GPIO_Port, LED1_Pin);\n                } else if (click_cnt == 2) {\n                    // KEY1 双击\n                    // printf(\"  Action: KEY1 Double Click - Switch Mode\\n\");\n                }\n                // ... 可以继续判断 3击, 4击 ...\n            } else if (key_id == 2) { // 如果是 KEY2 触发的 CLICK\n                 if (click_cnt == 1) {\n                    // KEY2 单击\n                    // printf(\"  Action: KEY2 Single Click - Toggle LED2\\n\");\n                 }\n            } else if (key_id == 101) { // 如果是组合键 (KEY1+KEY2) 触发的 CLICK\n                if (click_cnt == 1) {\n                     // 组合键单击\n                     // printf(\"  Action: Combo Key 101 Single Click - Reset System\\n\");\n                }\n            }\n            break;\n\n        case EBTN_EVT_KEEPALIVE: // 保持活动/长按事件 (按下持续时间超过阈值后，按周期触发)\n            // printf(\" - Keep Alive (Long Press, Count: %d)\\n\", kalive_cnt);\n            if (key_id == 1) {\n                // KEY1 长按\n                // printf(\"  Action: KEY1 Long Press - Increase Volume\\n\");\n            }\n            break;\n\n        default: // 未知事件 (理论上不应发生)\n            // printf(\" - Unknown Event\\n\");\n            break;\n    }\n}\n```\n\n#### 第四步：初始化 ebtn 库\n\n在系统启动的初始化阶段（例如 `main` 函数开始处，或专门的初始化函数中），调用 `ebtn_init` 函数，将之前准备好的按键列表和回调函数\"注册\"给 `ebtn` 库。\n\n如果使用了组合按键，还需要在 `ebtn_init` **之后**，调用相关函数将普通按键绑定到组合键上。\n\n```C\nvoid button_init(void)\n{\n    ebtn_init(\n        static_buttons,                 // 静态按键数组的指针\n        EBTN_ARRAY_SIZE(static_buttons), // 静态按键数量 (用宏计算)\n        static_combos,                  // 静态组合按键数组的指针 (如果没有，传 NULL, 0)\n        EBTN_ARRAY_SIZE(static_combos), // 静态组合按键数量 (如果没有，传 0)\n        my_get_key_state,               // 你的状态获取回调函数\n        my_handle_key_event             // 你的事件处理回调函数\n    );\n}\n//下面这个函数可以在调度器中每5秒调用\nvoid button_task(void)\n{\n    ebtn_process(uwTick);\n}\n```\n\n## SD+FATFS\n\n### CubeMX配置\n\n![image-20250923205942773](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509232059309.png)\n\n![image-20250923210029131](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509232100265.png)\n\n![image-20250928114434875](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509281144270.png)\n\n> 注意：如果TF-CARD上的CD引脚有接入gpio的话 可以将platform设置为该引脚 即检测SD卡引脚\n>\n> - 当该引脚为低电平时，则检测到sd卡\n>\n> - 没有接gpio的话，platform不要设置 不然会读取不到卡\n>\n>   ![image-20250923210313143](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509232103277.png)\n>\n>   正点原子探索者v3没有设计该引脚 所以留空即可\n>\n>   ![image-20250923210355410](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509232103527.png)\n\n### 使用步骤\n\n#### 初始化\n\n```C\n SD_Driver.disk_initialize(0); // SD_Driver已经被声明在FATFS/Target/sd_diskio.c\n```\n\n","source":"_posts/西门子.md","raw":"---\ntitle: 西门子嵌入式学习\ndate: 2025-06-02 16:00:53\nsticky: true\ncover: \"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202506021603366.jpg\"\ntags:\n  - 嵌入式基础\n  - GD32学习\ncategories: MCU\n---\n\n## 调度器模板\n\n```C\n#include \"scheduler.h\"\n// clang-format off\ntypedef struct\n{\n\tvoid (*task_func)(void);\n\tuint32_t rate_ms;\n\tuint32_t last_ms;\n} task_t;\n\ntask_t tasks[] = {\n};\n\nuint8_t task_count;\n\nvoid scheduler_init(void)\n{\n\ttask_count = sizeof(tasks) / sizeof(task_t);\n}\n\nvoid scheduler_run(void)\n{\n\tuint8_t i;\n\tfor (i = 0; i < task_count; i++)\n\t{\n\t\tuint32_t now_time = HAL_GetTick();\n\t\tif ((uint32_t)(now_time - tasks[i].last_ms) >= tasks[i].rate_ms)\n\t\t{\n\t\t\ttasks[i].last_ms = now_time;\n\t\t\ttasks[i].task_func();\n\t\t}\n\t}\n}\n\n```\n\n\n\n## 时钟配置栏\n\n### 模式设置\n\n![image-20250602161506934](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202506021615783.png)\n\n#### 高速时钟HSE\n\n- `Disable`：不启用外部时钟（默认使用内部时钟） <span style=\"color:#00FFFF;\">内部时钟（内部RC（电阻-电容）振荡器）提供了此便捷性 但精度不如外部时钟（外部低速晶振或陶瓷振荡器）</span>\n\n- `BYPASS Clock Source`：旁路模式，允许直接<span style=\"color:#00FFFF;\">从外部导入时钟信号，而不使用外部晶体</span>。这种模式适用于需要从外部系统或其他设备接收时钟信号的情况。\n\n- `Crystal/Ceramic Resonator`：将外部低速晶振或陶瓷谐振器作为时钟源，一般则是板载上的外部晶振\n\n#### 低速时钟LSE\n\n> 参数同上 通常用于<span style=\"color:#33FFFF;\">实时时钟（RTC</span>）等需要低频稳定时钟的应用。LSE的典型频率为32.768kHz\n\n#### **Master Clock Output**\n\n- 配置是否使能主时钟<span style=\"color:#33FFFF;\">输出到MCO引脚</span>，`即可以通过MCO引脚将时钟信号输出到外部，供其他设备使用`\n\n#### **Audio Clock Input (I2S_CKIN)**：\n\n- 此选项用于配置是否从<span style=\"color:#33FFFF;\">特定的引脚（如I2S_CKIN）输入音频时钟</span>。这对于需要精确音频时钟的音频应用非常重要，`例如I2S音频接口`。\n\n### 参数设置\n\n![image-20250602162859501](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202506021629990.png)\n\n- `TIM Prescaler Selection`：定时器预分频选择，`禁用时使用最大分频值。`\n\n- `HSE Startup Timeout Value (ms)`：HSE（高速外部时钟）启动超时时间，设置为100ms。这是外部晶振启动的最长等待时间，如果超出这个时间晶振还未启动，微控制器会认为启动失败。\n- `LSE Startup Timeout Value (ms)`：LSE（低速外部时钟）启动超时时间，设置为5000ms。这通常用于RTC的时钟源，如果超出这个时间晶振还未启动，微控制器会认为启动失败。\n\n- `Power Regulator Voltage Scale`：电源调节器电压等级，设置为`Power Regulator Voltage Scale 3`。这通常与微控制器的性能和功耗有关，不同的电压等级可以提供不同的性能和功耗平衡。\n\n- `Power Over Drive`：电源过驱，禁用。这通常用于在需要更高性能时<span style=\"color:#33FFFF;\">临时提高微控制器的电压</span>，以支持更高的时钟频率。\n\n### 在何处选择了HSI以及HSE\n\n![image-20250602181824740](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202506021818291.png)\n\n- 第一个框一定一定要看硬件上的晶振是多少频率，<span style=\"color:#00FFFF;\">一定要严格按照硬件资源给的 （不要无脑用默认的）</span>\n\n  > 否则可能会出现串口数据接收乱码\n\n- 第二个框选择了用`相位锁定环（PLL） 调整外部高速时钟（HSE）还是内部高速时钟（HSI）\n\n- 第三个框框则直接选择是否选择 经过PLL调整后的时钟，也可以选择不经过PLL的原生外部高速时钟（HSE），以及内部高速时钟（HSI）。\n\n## SYS调试接口选择\n\n![image-20250602182759796](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202506021828146.png)\n\n### Serial Wire (SW-DP)\n\n- 串口烧录 仅需要两个引脚\n  - `SWCLK`：主机到从机的时钟信号\n  - `SWDIO`：双向数据信号\n\n- 这种模式下，ST-Link工作最稳定，占用引脚少，是日常开发的首选。\n\n### JTAG(JTAG-DP)\n\n- J-Link烧录 需要4或5个引脚：\n  - **TCK：**测试时钟\n  - **TMS：**测试模式选择\n  - **TDI：**测试数据输入\n  - **TDO：**测试数据输出\n  - **TRST：**测试复位（可选，5pin模式才有）\n- JTAG适合复杂的调试场景，尤其是在使用J-Link调试器时。\n\n## LED\n\n### 驱动代码\n\n```C\n#include \"led_app.h\"\n\nuint8_t ucLed[6] = {0, 0, 1, 0, 1, 1};\n\nvoid Led_disp(uint8_t *ucLed)\n{\n\tuint8_t temp = 0x00, i;\n\tstatic uint8_t temp_old = 0xff;\n\tfor (i = 0; i < 6; i++)\n\t{\n\t\tif (ucLed[i])\n\t\t\ttemp |= (1 << i);\n\t}\n\tif (temp != temp_old)\n\t{\n\t\tHAL_GPIO_WritePin(LED1_GPIO_Port, LED1_Pin, (temp & 0x01) ? GPIO_PIN_SET : GPIO_PIN_RESET);\n\t\tHAL_GPIO_WritePin(LED2_GPIO_Port, LED2_Pin, (temp & 0x02) ? GPIO_PIN_SET : GPIO_PIN_RESET);\n\t\tHAL_GPIO_WritePin(LED3_GPIO_Port, LED3_Pin, (temp & 0x04) ? GPIO_PIN_SET : GPIO_PIN_RESET);\n\t\tHAL_GPIO_WritePin(LED4_GPIO_Port, LED4_Pin, (temp & 0x08) ? GPIO_PIN_SET : GPIO_PIN_RESET);\n\t\tHAL_GPIO_WritePin(LED5_GPIO_Port, LED5_Pin, (temp & 0x10) ? GPIO_PIN_SET : GPIO_PIN_RESET);\n\t\tHAL_GPIO_WritePin(LED6_GPIO_Port, LED6_Pin, (temp & 0x20) ? GPIO_PIN_SET : GPIO_PIN_RESET);\n\t\ttemp_old = temp;\n\t}\n}\n\nvoid led_task(void)\n{\n\tLed_disp(ucLed);\n}\n```\n\n### 软件PWM呼吸灯\n\n```C\nvoid led_task(void)\n{\n\tstatic uint32_t breath_counter = 0;\t\t\t// 呼吸效果内部计时器，模拟时间流逝\n\tstatic uint8_t pwm_counter = 0;\t\t\t\t// PWM内部计时器，用于生成PWM波形\n\tstatic uint8_t brightness = 0;\t\t\t\t// 当前的亮度值\n\tstatic const uint16_t breath_period = 2000; // 呼吸效果周期，单位ms 调小可增加速度\n\tstatic const uint16_t pwm_max = 10;\t\t\t// PWM最大计数值  调大会降低pwm频率\n\n\tbreath_counter = (++breath_counter) % breath_period;\n        //(2.0f * 3.14159f * breath_counter / breath_period) 将结果映射为0到2π\n        //sin(2.0f * 3.14159f * breath_counter / breath_period) 将结果映射为-1到1\n        //sin(2.0f * 3.14159f * breath_counter / breath_period) + 1.0f 将结果映射为0到2\n        //(sin(2.0f * 3.14159f * breath_counter / breath_period) + 1.0f) * pwm_max / 2.0f 将实际亮度计算出来 通过(uint8_t)强制类型转换\n\tbrightness = (uint8_t)((sin(2.0f * 3.14159f * breath_counter / breath_period) + 1.0f) * pwm_max / 2.0f);\n\tpwm_counter = (++pwm_counter) % pwm_max;\n\tfor (uint8_t i = 0; i < 6; i++)\n\t\tucLed[i] = (pwm_counter < brightness) ? 1 : 0; //将所有LED置为呼吸灯效果\n\tLed_disp(ucLed);\n}\n```\n\n> 如果是要实时调光，则直接赋值`brightness`即可 （即<span style=\"color:#FF3333;\">不需要</span>`breath_counter`和`breath_period`）\n\n## 按键\n\n> 常用工程上所用按键对比\n>\n> github仓库地址：[bobwenstudy/easy_button: 嵌入式按键处理驱动（Button Driver），支持单击、双击、多击、自动消抖、长按、长长按、超长按 | 低功耗支持 | 组合按键支持 | 静态/动态注册支持](https://github.com/bobwenstudy/easy_button)\n\n![image-20250606171853466](https://fastly.jsdelivr.net/gh/2250272571/tuchuang@main/img/202506061718736.png)\n\n> 整体框架：\n> easy_button\n>  ├── ebtn\n>  │   ├── bit_array.h\n>  │   ├── ebtn.c\n>  │   └── ebtn.h\n>  ├── build.mk\n>  ├── example_user.c\n>  └── example_test.c\n>  ├── main.c\n>  ├── Makefile\n>  └── README.md\n\n### 使用步骤\n\n#### 第一步：新建button_app.c并包含头文件\n\n```C\n#include \"ebtn.h\" // 包含 ebtn 库头文件\n// ... 可能还需要包含你的 HAL 库头文件 ...\n// #include \"stm32xxx_hal.h\"\n```\n\n#### 第二步：定义参数与按键列表\n\n1. **定义按键参数 (`ebtn_btn_param_t`):** 使用 `EBTN_PARAMS_INIT` 宏设定按键的各种时间阈值和行为。这些参数可以被多个按键共用。`可用默认参数 即如下default_param_normal`\n2. **定义按键实例数组 (`ebtn_btn_t`):** 使用 `EBTN_BUTTON_INIT` 宏创建每个物理按键的实例，并指定它的唯一 `key_id` 和使用的参数。\n3. **（可不加）定义组合按键实例数组 (`ebtn_btn_combo_t`, 可选):** 使用 `EBTN_BUTTON_COMBO_INIT` 创建组合键实例，同样指定 `key_id` 和参数。\n\n```C\n/* 1. 定义按键参数实例 */\n// 参数宏: EBTN_PARAMS_INIT(\n//     按下消抖时间ms, 释放消抖时间ms,\n//     单击有效最短按下时间ms, 单击有效最长按下时间ms,\n//     多次单击最大间隔时间ms,\n//     长按(KeepAlive)事件周期ms (0禁用),\n//     最大连续有效点击次数 (e.g., 1=单击, 2=双击, ...)\n// )\nconst ebtn_btn_param_t default_param_normal = EBTN_PARAMS_INIT(\n    20,     // time_debounce: 按下稳定 20ms(消抖)\n    20,     // time_debounce_release: 释放稳定 20ms\n    50,     // time_click_pressed_min: 最短单击按下 50ms\n    500,    // time_click_pressed_max: 最长单击按下 500ms (超过则不算单击)\n    300,    // time_click_multi_max: 多次单击最大间隔 300ms (两次点击间隔超过则重新计数)\n    500,    // time_keepalive_period: 长按事件周期 500ms (按下超过 500ms 后，每 500ms 触发一次)\n    5       // max_consecutive: 最多支持 5 连击\n);\n\n/* 2. 定义静态按键列表 */\n// 宏: EBTN_BUTTON_INIT(按键ID, 参数指针)\nebtn_btn_t static_buttons[] = {\n    EBTN_BUTTON_INIT(1, &default_param_normal), // KEY1, ID=1, 使用 'default_param_normal' 参数\n    EBTN_BUTTON_INIT(2, &default_param_normal), // KEY2, ID=2, 也使用 'default_param_normal' 参数\n};\n\n/* 3. 定义静态组合按键列表 (可选) */\n// 宏: EBTN_BUTTON_COMBO_INIT(按键ID, 参数指针)\nebtn_btn_combo_t static_combos[] = {\n    // 假设 KEY1+KEY2 组合键\n    EBTN_BUTTON_COMBO_INIT(101, &default_param_normal), // 组合键, ID=101 (必须与普通按键ID不同)\n};\n\n```\n\n#### 第三步：编写回调函数\n\n你需要提供两个函数给 `ebtn` 库，告诉它如何与你的硬件交互以及如何通知你事件：\n\n- **`get_state_fn` (状态获取):** 这个函数被 `ebtn` 调用，用于读取指定按键当前的物理电平。\n- **`evt_fn` (事件处理):** 当 `ebtn` 检测到一个有效的按键事件（按下、释放、单击、长按）时，会调用这个函数，并传入触发事件的按键信息和事件类型。\n\n```C\n/* 1. 实现获取按键状态的回调函数 */\n// 函数原型: uint8_t (*ebtn_get_state_fn)(struct ebtn_btn *btn);\nuint8_t my_get_key_state(struct ebtn_btn *btn) {\n    // 根据传入的按钮实例中的 key_id 判断是哪个物理按键\n    switch (btn->key_id) {\n        case 1: // 请求读取 KEY1 的状态\n            // 假设 KEY1 接在 PB0，按下为低电平 (返回 1 代表按下)\n            return (HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_0) == GPIO_PIN_RESET);\n        case 2: // 请求读取 KEY2 的状态\n            // 假设 KEY2 接在 PB1，按下为低电平\n            return (HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_1) == GPIO_PIN_RESET);\n        // ... 可以添加更多按键的读取逻辑 ...\n        default:\n            // 对于库内部处理组合键等情况，或者未知的 key_id，安全起见返回 0 (未按下)\n            return 0;\n    }\n    // 注意：返回值 1 表示 \"活动/按下\"，0 表示 \"非活动/释放\"\n}\n\n/* 2. 实现处理按键事件的回调函数 */\n// 函数原型: void (*ebtn_evt_fn)(struct ebtn_btn *btn, ebtn_evt_t evt);\nvoid my_handle_key_event(struct ebtn_btn *btn, ebtn_evt_t evt) {\n    uint16_t key_id = btn->key_id;                 // 获取触发事件的按键 ID\n    uint16_t click_cnt = ebtn_click_get_count(btn); // 获取连击次数 (仅在 ONCLICK 事件时有意义)\n    // uint16_t kalive_cnt = ebtn_keepalive_get_count(btn); // 获取长按计数 (仅在 KEEPALIVE 事件时有意义)\n\n    // 调试打印 (可选)\n    // printf(\"Key ID: %d, Event: %d\", key_id, evt);\n\n    // 根据事件类型进行处理\n    switch (evt) {\n        case EBTN_EVT_ONPRESS: // 按下事件 (消抖成功后触发一次)\n            // printf(\" - Pressed\\n\");\n            // 可以在这里处理按下即触发的操作，比如点亮提示灯\n            if (key_id == 1) { /* Do something for KEY1 press */ }\n            break;\n\n        case EBTN_EVT_ONRELEASE: // 释放事件 (消抖成功后触发一次)\n            // printf(\" - Released\\n\");\n            // 可以在这里处理释放时触发的操作\n             if (key_id == 1) { /* Do something for KEY1 release */ }\n            break;\n\n        case EBTN_EVT_ONCLICK: // 单击/连击事件 (在释放后，或达到最大连击数，或超时后触发)\n            // printf(\" - Clicked (%d times)\\n\", click_cnt);\n            // --- 根据 key_id 和 click_cnt 执行不同操作 ---\n            if (key_id == 1) { // 如果是 KEY1 触发的 CLICK\n                if (click_cnt == 1) {\n                    // KEY1 单击\n                    // printf(\"  Action: KEY1 Single Click - Toggle LED1\\n\");\n                    // HAL_GPIO_TogglePin(LED1_GPIO_Port, LED1_Pin);\n                } else if (click_cnt == 2) {\n                    // KEY1 双击\n                    // printf(\"  Action: KEY1 Double Click - Switch Mode\\n\");\n                }\n                // ... 可以继续判断 3击, 4击 ...\n            } else if (key_id == 2) { // 如果是 KEY2 触发的 CLICK\n                 if (click_cnt == 1) {\n                    // KEY2 单击\n                    // printf(\"  Action: KEY2 Single Click - Toggle LED2\\n\");\n                 }\n            } else if (key_id == 101) { // 如果是组合键 (KEY1+KEY2) 触发的 CLICK\n                if (click_cnt == 1) {\n                     // 组合键单击\n                     // printf(\"  Action: Combo Key 101 Single Click - Reset System\\n\");\n                }\n            }\n            break;\n\n        case EBTN_EVT_KEEPALIVE: // 保持活动/长按事件 (按下持续时间超过阈值后，按周期触发)\n            // printf(\" - Keep Alive (Long Press, Count: %d)\\n\", kalive_cnt);\n            if (key_id == 1) {\n                // KEY1 长按\n                // printf(\"  Action: KEY1 Long Press - Increase Volume\\n\");\n            }\n            break;\n\n        default: // 未知事件 (理论上不应发生)\n            // printf(\" - Unknown Event\\n\");\n            break;\n    }\n}\n```\n\n#### 第四步：初始化 ebtn 库\n\n在系统启动的初始化阶段（例如 `main` 函数开始处，或专门的初始化函数中），调用 `ebtn_init` 函数，将之前准备好的按键列表和回调函数\"注册\"给 `ebtn` 库。\n\n如果使用了组合按键，还需要在 `ebtn_init` **之后**，调用相关函数将普通按键绑定到组合键上。\n\n```C\nvoid button_init(void)\n{\n    ebtn_init(\n        static_buttons,                 // 静态按键数组的指针\n        EBTN_ARRAY_SIZE(static_buttons), // 静态按键数量 (用宏计算)\n        static_combos,                  // 静态组合按键数组的指针 (如果没有，传 NULL, 0)\n        EBTN_ARRAY_SIZE(static_combos), // 静态组合按键数量 (如果没有，传 0)\n        my_get_key_state,               // 你的状态获取回调函数\n        my_handle_key_event             // 你的事件处理回调函数\n    );\n}\n//下面这个函数可以在调度器中每5秒调用\nvoid button_task(void)\n{\n    ebtn_process(uwTick);\n}\n```\n\n## SD+FATFS\n\n### CubeMX配置\n\n![image-20250923205942773](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509232059309.png)\n\n![image-20250923210029131](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509232100265.png)\n\n![image-20250928114434875](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509281144270.png)\n\n> 注意：如果TF-CARD上的CD引脚有接入gpio的话 可以将platform设置为该引脚 即检测SD卡引脚\n>\n> - 当该引脚为低电平时，则检测到sd卡\n>\n> - 没有接gpio的话，platform不要设置 不然会读取不到卡\n>\n>   ![image-20250923210313143](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509232103277.png)\n>\n>   正点原子探索者v3没有设计该引脚 所以留空即可\n>\n>   ![image-20250923210355410](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509232103527.png)\n\n### 使用步骤\n\n#### 初始化\n\n```C\n SD_Driver.disk_initialize(0); // SD_Driver已经被声明在FATFS/Target/sd_diskio.c\n```\n\n","slug":"西门子","published":1,"updated":"2025-09-28T07:24:22.000Z","comments":1,"layout":"post","photos":[],"_id":"cmk8pg6xo00166sk9fzj89e2q","content":"<h2 id=\"调度器模板\"><a href=\"#调度器模板\" class=\"headerlink\" title=\"调度器模板\"></a>调度器模板</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;scheduler.h&quot;</span></span></span><br><span class=\"line\"><span class=\"comment\">// clang-format off</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\t<span class=\"type\">void</span> (*task_func)(<span class=\"type\">void</span>);</span><br><span class=\"line\">\t<span class=\"type\">uint32_t</span> rate_ms;</span><br><span class=\"line\">\t<span class=\"type\">uint32_t</span> last_ms;</span><br><span class=\"line\">&#125; <span class=\"type\">task_t</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">task_t</span> tasks[] = &#123;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">uint8_t</span> task_count;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">scheduler_init</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\ttask_count = <span class=\"keyword\">sizeof</span>(tasks) / <span class=\"keyword\">sizeof</span>(<span class=\"type\">task_t</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">scheduler_run</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"type\">uint8_t</span> i;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; task_count; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">uint32_t</span> now_time = HAL_GetTick();</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> ((<span class=\"type\">uint32_t</span>)(now_time - tasks[i].last_ms) &gt;= tasks[i].rate_ms)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\ttasks[i].last_ms = now_time;</span><br><span class=\"line\">\t\t\ttasks[i].task_func();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"时钟配置栏\"><a href=\"#时钟配置栏\" class=\"headerlink\" title=\"时钟配置栏\"></a>时钟配置栏</h2><h3 id=\"模式设置\"><a href=\"#模式设置\" class=\"headerlink\" title=\"模式设置\"></a>模式设置</h3><p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202506021615783.png\" alt=\"image-20250602161506934\"></p>\n<h4 id=\"高速时钟HSE\"><a href=\"#高速时钟HSE\" class=\"headerlink\" title=\"高速时钟HSE\"></a>高速时钟HSE</h4><ul>\n<li><p><code>Disable</code>：不启用外部时钟（默认使用内部时钟） <span style=\"color:#00FFFF;\">内部时钟（内部RC（电阻-电容）振荡器）提供了此便捷性 但精度不如外部时钟（外部低速晶振或陶瓷振荡器）</span></p>\n</li>\n<li><p><code>BYPASS Clock Source</code>：旁路模式，允许直接<span style=\"color:#00FFFF;\">从外部导入时钟信号，而不使用外部晶体</span>。这种模式适用于需要从外部系统或其他设备接收时钟信号的情况。</p>\n</li>\n<li><p><code>Crystal/Ceramic Resonator</code>：将外部低速晶振或陶瓷谐振器作为时钟源，一般则是板载上的外部晶振</p>\n</li>\n</ul>\n<h4 id=\"低速时钟LSE\"><a href=\"#低速时钟LSE\" class=\"headerlink\" title=\"低速时钟LSE\"></a>低速时钟LSE</h4><blockquote>\n<p>参数同上 通常用于<span style=\"color:#33FFFF;\">实时时钟（RTC</span>）等需要低频稳定时钟的应用。LSE的典型频率为32.768kHz</p>\n</blockquote>\n<h4 id=\"Master-Clock-Output\"><a href=\"#Master-Clock-Output\" class=\"headerlink\" title=\"Master Clock Output\"></a><strong>Master Clock Output</strong></h4><ul>\n<li>配置是否使能主时钟<span style=\"color:#33FFFF;\">输出到MCO引脚</span>，<code>即可以通过MCO引脚将时钟信号输出到外部，供其他设备使用</code></li>\n</ul>\n<h4 id=\"Audio-Clock-Input-I2S-CKIN-：\"><a href=\"#Audio-Clock-Input-I2S-CKIN-：\" class=\"headerlink\" title=\"**Audio Clock Input (I2S_CKIN)**：\"></a>**Audio Clock Input (I2S_CKIN)**：</h4><ul>\n<li>此选项用于配置是否从<span style=\"color:#33FFFF;\">特定的引脚（如I2S_CKIN）输入音频时钟</span>。这对于需要精确音频时钟的音频应用非常重要，<code>例如I2S音频接口</code>。</li>\n</ul>\n<h3 id=\"参数设置\"><a href=\"#参数设置\" class=\"headerlink\" title=\"参数设置\"></a>参数设置</h3><p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202506021629990.png\" alt=\"image-20250602162859501\"></p>\n<ul>\n<li><p><code>TIM Prescaler Selection</code>：定时器预分频选择，<code>禁用时使用最大分频值。</code></p>\n</li>\n<li><p><code>HSE Startup Timeout Value (ms)</code>：HSE（高速外部时钟）启动超时时间，设置为100ms。这是外部晶振启动的最长等待时间，如果超出这个时间晶振还未启动，微控制器会认为启动失败。</p>\n</li>\n<li><p><code>LSE Startup Timeout Value (ms)</code>：LSE（低速外部时钟）启动超时时间，设置为5000ms。这通常用于RTC的时钟源，如果超出这个时间晶振还未启动，微控制器会认为启动失败。</p>\n</li>\n<li><p><code>Power Regulator Voltage Scale</code>：电源调节器电压等级，设置为<code>Power Regulator Voltage Scale 3</code>。这通常与微控制器的性能和功耗有关，不同的电压等级可以提供不同的性能和功耗平衡。</p>\n</li>\n<li><p><code>Power Over Drive</code>：电源过驱，禁用。这通常用于在需要更高性能时<span style=\"color:#33FFFF;\">临时提高微控制器的电压</span>，以支持更高的时钟频率。</p>\n</li>\n</ul>\n<h3 id=\"在何处选择了HSI以及HSE\"><a href=\"#在何处选择了HSI以及HSE\" class=\"headerlink\" title=\"在何处选择了HSI以及HSE\"></a>在何处选择了HSI以及HSE</h3><p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202506021818291.png\" alt=\"image-20250602181824740\"></p>\n<ul>\n<li><p>第一个框一定一定要看硬件上的晶振是多少频率，<span style=\"color:#00FFFF;\">一定要严格按照硬件资源给的 （不要无脑用默认的）</span></p>\n<blockquote>\n<p>否则可能会出现串口数据接收乱码</p>\n</blockquote>\n</li>\n<li><p>第二个框选择了用&#96;相位锁定环（PLL） 调整外部高速时钟（HSE）还是内部高速时钟（HSI）</p>\n</li>\n<li><p>第三个框框则直接选择是否选择 经过PLL调整后的时钟，也可以选择不经过PLL的原生外部高速时钟（HSE），以及内部高速时钟（HSI）。</p>\n</li>\n</ul>\n<h2 id=\"SYS调试接口选择\"><a href=\"#SYS调试接口选择\" class=\"headerlink\" title=\"SYS调试接口选择\"></a>SYS调试接口选择</h2><p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202506021828146.png\" alt=\"image-20250602182759796\"></p>\n<h3 id=\"Serial-Wire-SW-DP\"><a href=\"#Serial-Wire-SW-DP\" class=\"headerlink\" title=\"Serial Wire (SW-DP)\"></a>Serial Wire (SW-DP)</h3><ul>\n<li><p>串口烧录 仅需要两个引脚</p>\n<ul>\n<li><code>SWCLK</code>：主机到从机的时钟信号</li>\n<li><code>SWDIO</code>：双向数据信号</li>\n</ul>\n</li>\n<li><p>这种模式下，ST-Link工作最稳定，占用引脚少，是日常开发的首选。</p>\n</li>\n</ul>\n<h3 id=\"JTAG-JTAG-DP\"><a href=\"#JTAG-JTAG-DP\" class=\"headerlink\" title=\"JTAG(JTAG-DP)\"></a>JTAG(JTAG-DP)</h3><ul>\n<li>J-Link烧录 需要4或5个引脚：<ul>\n<li><strong>TCK：</strong>测试时钟</li>\n<li><strong>TMS：</strong>测试模式选择</li>\n<li><strong>TDI：</strong>测试数据输入</li>\n<li><strong>TDO：</strong>测试数据输出</li>\n<li><strong>TRST：</strong>测试复位（可选，5pin模式才有）</li>\n</ul>\n</li>\n<li>JTAG适合复杂的调试场景，尤其是在使用J-Link调试器时。</li>\n</ul>\n<h2 id=\"LED\"><a href=\"#LED\" class=\"headerlink\" title=\"LED\"></a>LED</h2><h3 id=\"驱动代码\"><a href=\"#驱动代码\" class=\"headerlink\" title=\"驱动代码\"></a>驱动代码</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;led_app.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">uint8_t</span> ucLed[<span class=\"number\">6</span>] = &#123;<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">Led_disp</span><span class=\"params\">(<span class=\"type\">uint8_t</span> *ucLed)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"type\">uint8_t</span> temp = <span class=\"number\">0x00</span>, i;</span><br><span class=\"line\">\t<span class=\"type\">static</span> <span class=\"type\">uint8_t</span> temp_old = <span class=\"number\">0xff</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">6</span>; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (ucLed[i])</span><br><span class=\"line\">\t\t\ttemp |= (<span class=\"number\">1</span> &lt;&lt; i);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (temp != temp_old)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tHAL_GPIO_WritePin(LED1_GPIO_Port, LED1_Pin, (temp &amp; <span class=\"number\">0x01</span>) ? GPIO_PIN_SET : GPIO_PIN_RESET);</span><br><span class=\"line\">\t\tHAL_GPIO_WritePin(LED2_GPIO_Port, LED2_Pin, (temp &amp; <span class=\"number\">0x02</span>) ? GPIO_PIN_SET : GPIO_PIN_RESET);</span><br><span class=\"line\">\t\tHAL_GPIO_WritePin(LED3_GPIO_Port, LED3_Pin, (temp &amp; <span class=\"number\">0x04</span>) ? GPIO_PIN_SET : GPIO_PIN_RESET);</span><br><span class=\"line\">\t\tHAL_GPIO_WritePin(LED4_GPIO_Port, LED4_Pin, (temp &amp; <span class=\"number\">0x08</span>) ? GPIO_PIN_SET : GPIO_PIN_RESET);</span><br><span class=\"line\">\t\tHAL_GPIO_WritePin(LED5_GPIO_Port, LED5_Pin, (temp &amp; <span class=\"number\">0x10</span>) ? GPIO_PIN_SET : GPIO_PIN_RESET);</span><br><span class=\"line\">\t\tHAL_GPIO_WritePin(LED6_GPIO_Port, LED6_Pin, (temp &amp; <span class=\"number\">0x20</span>) ? GPIO_PIN_SET : GPIO_PIN_RESET);</span><br><span class=\"line\">\t\ttemp_old = temp;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">led_task</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tLed_disp(ucLed);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"软件PWM呼吸灯\"><a href=\"#软件PWM呼吸灯\" class=\"headerlink\" title=\"软件PWM呼吸灯\"></a>软件PWM呼吸灯</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">led_task</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"type\">static</span> <span class=\"type\">uint32_t</span> breath_counter = <span class=\"number\">0</span>;\t\t\t<span class=\"comment\">// 呼吸效果内部计时器，模拟时间流逝</span></span><br><span class=\"line\">\t<span class=\"type\">static</span> <span class=\"type\">uint8_t</span> pwm_counter = <span class=\"number\">0</span>;\t\t\t\t<span class=\"comment\">// PWM内部计时器，用于生成PWM波形</span></span><br><span class=\"line\">\t<span class=\"type\">static</span> <span class=\"type\">uint8_t</span> brightness = <span class=\"number\">0</span>;\t\t\t\t<span class=\"comment\">// 当前的亮度值</span></span><br><span class=\"line\">\t<span class=\"type\">static</span> <span class=\"type\">const</span> <span class=\"type\">uint16_t</span> breath_period = <span class=\"number\">2000</span>; <span class=\"comment\">// 呼吸效果周期，单位ms 调小可增加速度</span></span><br><span class=\"line\">\t<span class=\"type\">static</span> <span class=\"type\">const</span> <span class=\"type\">uint16_t</span> pwm_max = <span class=\"number\">10</span>;\t\t\t<span class=\"comment\">// PWM最大计数值  调大会降低pwm频率</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tbreath_counter = (++breath_counter) % breath_period;</span><br><span class=\"line\">        <span class=\"comment\">//(2.0f * 3.14159f * breath_counter / breath_period) 将结果映射为0到2π</span></span><br><span class=\"line\">        <span class=\"comment\">//sin(2.0f * 3.14159f * breath_counter / breath_period) 将结果映射为-1到1</span></span><br><span class=\"line\">        <span class=\"comment\">//sin(2.0f * 3.14159f * breath_counter / breath_period) + 1.0f 将结果映射为0到2</span></span><br><span class=\"line\">        <span class=\"comment\">//(sin(2.0f * 3.14159f * breath_counter / breath_period) + 1.0f) * pwm_max / 2.0f 将实际亮度计算出来 通过(uint8_t)强制类型转换</span></span><br><span class=\"line\">\tbrightness = (<span class=\"type\">uint8_t</span>)((<span class=\"built_in\">sin</span>(<span class=\"number\">2.0f</span> * <span class=\"number\">3.14159f</span> * breath_counter / breath_period) + <span class=\"number\">1.0f</span>) * pwm_max / <span class=\"number\">2.0f</span>);</span><br><span class=\"line\">\tpwm_counter = (++pwm_counter) % pwm_max;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">uint8_t</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">6</span>; i++)</span><br><span class=\"line\">\t\tucLed[i] = (pwm_counter &lt; brightness) ? <span class=\"number\">1</span> : <span class=\"number\">0</span>; <span class=\"comment\">//将所有LED置为呼吸灯效果</span></span><br><span class=\"line\">\tLed_disp(ucLed);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>如果是要实时调光，则直接赋值<code>brightness</code>即可 （即<span style=\"color:#FF3333;\">不需要</span><code>breath_counter</code>和<code>breath_period</code>）</p>\n</blockquote>\n<h2 id=\"按键\"><a href=\"#按键\" class=\"headerlink\" title=\"按键\"></a>按键</h2><blockquote>\n<p>常用工程上所用按键对比</p>\n<p>github仓库地址：<a href=\"https://github.com/bobwenstudy/easy_button\">bobwenstudy&#x2F;easy_button: 嵌入式按键处理驱动（Button Driver），支持单击、双击、多击、自动消抖、长按、长长按、超长按 | 低功耗支持 | 组合按键支持 | 静态&#x2F;动态注册支持</a></p>\n</blockquote>\n<p><img src=\"https://fastly.jsdelivr.net/gh/2250272571/tuchuang@main/img/202506061718736.png\" alt=\"image-20250606171853466\"></p>\n<blockquote>\n<p>整体框架：<br>easy_button<br> ├── ebtn<br> │   ├── bit_array.h<br> │   ├── ebtn.c<br> │   └── ebtn.h<br> ├── build.mk<br> ├── example_user.c<br> └── example_test.c<br> ├── main.c<br> ├── Makefile<br> └── README.md</p>\n</blockquote>\n<h3 id=\"使用步骤\"><a href=\"#使用步骤\" class=\"headerlink\" title=\"使用步骤\"></a>使用步骤</h3><h4 id=\"第一步：新建button-app-c并包含头文件\"><a href=\"#第一步：新建button-app-c并包含头文件\" class=\"headerlink\" title=\"第一步：新建button_app.c并包含头文件\"></a>第一步：新建button_app.c并包含头文件</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;ebtn.h&quot;</span> <span class=\"comment\">// 包含 ebtn 库头文件</span></span></span><br><span class=\"line\"><span class=\"comment\">// ... 可能还需要包含你的 HAL 库头文件 ...</span></span><br><span class=\"line\"><span class=\"comment\">// #include &quot;stm32xxx_hal.h&quot;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"第二步：定义参数与按键列表\"><a href=\"#第二步：定义参数与按键列表\" class=\"headerlink\" title=\"第二步：定义参数与按键列表\"></a>第二步：定义参数与按键列表</h4><ol>\n<li><strong>定义按键参数 (<code>ebtn_btn_param_t</code>):</strong> 使用 <code>EBTN_PARAMS_INIT</code> 宏设定按键的各种时间阈值和行为。这些参数可以被多个按键共用。<code>可用默认参数 即如下default_param_normal</code></li>\n<li><strong>定义按键实例数组 (<code>ebtn_btn_t</code>):</strong> 使用 <code>EBTN_BUTTON_INIT</code> 宏创建每个物理按键的实例，并指定它的唯一 <code>key_id</code> 和使用的参数。</li>\n<li><strong>（可不加）定义组合按键实例数组 (<code>ebtn_btn_combo_t</code>, 可选):</strong> 使用 <code>EBTN_BUTTON_COMBO_INIT</code> 创建组合键实例，同样指定 <code>key_id</code> 和参数。</li>\n</ol>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 1. 定义按键参数实例 */</span></span><br><span class=\"line\"><span class=\"comment\">// 参数宏: EBTN_PARAMS_INIT(</span></span><br><span class=\"line\"><span class=\"comment\">//     按下消抖时间ms, 释放消抖时间ms,</span></span><br><span class=\"line\"><span class=\"comment\">//     单击有效最短按下时间ms, 单击有效最长按下时间ms,</span></span><br><span class=\"line\"><span class=\"comment\">//     多次单击最大间隔时间ms,</span></span><br><span class=\"line\"><span class=\"comment\">//     长按(KeepAlive)事件周期ms (0禁用),</span></span><br><span class=\"line\"><span class=\"comment\">//     最大连续有效点击次数 (e.g., 1=单击, 2=双击, ...)</span></span><br><span class=\"line\"><span class=\"comment\">// )</span></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">ebtn_btn_param_t</span> default_param_normal = EBTN_PARAMS_INIT(</span><br><span class=\"line\">    <span class=\"number\">20</span>,     <span class=\"comment\">// time_debounce: 按下稳定 20ms(消抖)</span></span><br><span class=\"line\">    <span class=\"number\">20</span>,     <span class=\"comment\">// time_debounce_release: 释放稳定 20ms</span></span><br><span class=\"line\">    <span class=\"number\">50</span>,     <span class=\"comment\">// time_click_pressed_min: 最短单击按下 50ms</span></span><br><span class=\"line\">    <span class=\"number\">500</span>,    <span class=\"comment\">// time_click_pressed_max: 最长单击按下 500ms (超过则不算单击)</span></span><br><span class=\"line\">    <span class=\"number\">300</span>,    <span class=\"comment\">// time_click_multi_max: 多次单击最大间隔 300ms (两次点击间隔超过则重新计数)</span></span><br><span class=\"line\">    <span class=\"number\">500</span>,    <span class=\"comment\">// time_keepalive_period: 长按事件周期 500ms (按下超过 500ms 后，每 500ms 触发一次)</span></span><br><span class=\"line\">    <span class=\"number\">5</span>       <span class=\"comment\">// max_consecutive: 最多支持 5 连击</span></span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 2. 定义静态按键列表 */</span></span><br><span class=\"line\"><span class=\"comment\">// 宏: EBTN_BUTTON_INIT(按键ID, 参数指针)</span></span><br><span class=\"line\"><span class=\"type\">ebtn_btn_t</span> static_buttons[] = &#123;</span><br><span class=\"line\">    EBTN_BUTTON_INIT(<span class=\"number\">1</span>, &amp;default_param_normal), <span class=\"comment\">// KEY1, ID=1, 使用 &#x27;default_param_normal&#x27; 参数</span></span><br><span class=\"line\">    EBTN_BUTTON_INIT(<span class=\"number\">2</span>, &amp;default_param_normal), <span class=\"comment\">// KEY2, ID=2, 也使用 &#x27;default_param_normal&#x27; 参数</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 3. 定义静态组合按键列表 (可选) */</span></span><br><span class=\"line\"><span class=\"comment\">// 宏: EBTN_BUTTON_COMBO_INIT(按键ID, 参数指针)</span></span><br><span class=\"line\"><span class=\"type\">ebtn_btn_combo_t</span> static_combos[] = &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 假设 KEY1+KEY2 组合键</span></span><br><span class=\"line\">    EBTN_BUTTON_COMBO_INIT(<span class=\"number\">101</span>, &amp;default_param_normal), <span class=\"comment\">// 组合键, ID=101 (必须与普通按键ID不同)</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"第三步：编写回调函数\"><a href=\"#第三步：编写回调函数\" class=\"headerlink\" title=\"第三步：编写回调函数\"></a>第三步：编写回调函数</h4><p>你需要提供两个函数给 <code>ebtn</code> 库，告诉它如何与你的硬件交互以及如何通知你事件：</p>\n<ul>\n<li><strong><code>get_state_fn</code> (状态获取):</strong> 这个函数被 <code>ebtn</code> 调用，用于读取指定按键当前的物理电平。</li>\n<li><strong><code>evt_fn</code> (事件处理):</strong> 当 <code>ebtn</code> 检测到一个有效的按键事件（按下、释放、单击、长按）时，会调用这个函数，并传入触发事件的按键信息和事件类型。</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 1. 实现获取按键状态的回调函数 */</span></span><br><span class=\"line\"><span class=\"comment\">// 函数原型: uint8_t (*ebtn_get_state_fn)(struct ebtn_btn *btn);</span></span><br><span class=\"line\"><span class=\"type\">uint8_t</span> <span class=\"title function_\">my_get_key_state</span><span class=\"params\">(<span class=\"keyword\">struct</span> ebtn_btn *btn)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 根据传入的按钮实例中的 key_id 判断是哪个物理按键</span></span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (btn-&gt;key_id) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">1</span>: <span class=\"comment\">// 请求读取 KEY1 的状态</span></span><br><span class=\"line\">            <span class=\"comment\">// 假设 KEY1 接在 PB0，按下为低电平 (返回 1 代表按下)</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> (HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_0) == GPIO_PIN_RESET);</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">2</span>: <span class=\"comment\">// 请求读取 KEY2 的状态</span></span><br><span class=\"line\">            <span class=\"comment\">// 假设 KEY2 接在 PB1，按下为低电平</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> (HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_1) == GPIO_PIN_RESET);</span><br><span class=\"line\">        <span class=\"comment\">// ... 可以添加更多按键的读取逻辑 ...</span></span><br><span class=\"line\">        <span class=\"keyword\">default</span>:</span><br><span class=\"line\">            <span class=\"comment\">// 对于库内部处理组合键等情况，或者未知的 key_id，安全起见返回 0 (未按下)</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 注意：返回值 1 表示 &quot;活动/按下&quot;，0 表示 &quot;非活动/释放&quot;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 2. 实现处理按键事件的回调函数 */</span></span><br><span class=\"line\"><span class=\"comment\">// 函数原型: void (*ebtn_evt_fn)(struct ebtn_btn *btn, ebtn_evt_t evt);</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">my_handle_key_event</span><span class=\"params\">(<span class=\"keyword\">struct</span> ebtn_btn *btn, <span class=\"type\">ebtn_evt_t</span> evt)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">uint16_t</span> key_id = btn-&gt;key_id;                 <span class=\"comment\">// 获取触发事件的按键 ID</span></span><br><span class=\"line\">    <span class=\"type\">uint16_t</span> click_cnt = ebtn_click_get_count(btn); <span class=\"comment\">// 获取连击次数 (仅在 ONCLICK 事件时有意义)</span></span><br><span class=\"line\">    <span class=\"comment\">// uint16_t kalive_cnt = ebtn_keepalive_get_count(btn); // 获取长按计数 (仅在 KEEPALIVE 事件时有意义)</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 调试打印 (可选)</span></span><br><span class=\"line\">    <span class=\"comment\">// printf(&quot;Key ID: %d, Event: %d&quot;, key_id, evt);</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 根据事件类型进行处理</span></span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (evt) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> EBTN_EVT_ONPRESS: <span class=\"comment\">// 按下事件 (消抖成功后触发一次)</span></span><br><span class=\"line\">            <span class=\"comment\">// printf(&quot; - Pressed\\n&quot;);</span></span><br><span class=\"line\">            <span class=\"comment\">// 可以在这里处理按下即触发的操作，比如点亮提示灯</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (key_id == <span class=\"number\">1</span>) &#123; <span class=\"comment\">/* Do something for KEY1 press */</span> &#125;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">case</span> EBTN_EVT_ONRELEASE: <span class=\"comment\">// 释放事件 (消抖成功后触发一次)</span></span><br><span class=\"line\">            <span class=\"comment\">// printf(&quot; - Released\\n&quot;);</span></span><br><span class=\"line\">            <span class=\"comment\">// 可以在这里处理释放时触发的操作</span></span><br><span class=\"line\">             <span class=\"keyword\">if</span> (key_id == <span class=\"number\">1</span>) &#123; <span class=\"comment\">/* Do something for KEY1 release */</span> &#125;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">case</span> EBTN_EVT_ONCLICK: <span class=\"comment\">// 单击/连击事件 (在释放后，或达到最大连击数，或超时后触发)</span></span><br><span class=\"line\">            <span class=\"comment\">// printf(&quot; - Clicked (%d times)\\n&quot;, click_cnt);</span></span><br><span class=\"line\">            <span class=\"comment\">// --- 根据 key_id 和 click_cnt 执行不同操作 ---</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (key_id == <span class=\"number\">1</span>) &#123; <span class=\"comment\">// 如果是 KEY1 触发的 CLICK</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (click_cnt == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// KEY1 单击</span></span><br><span class=\"line\">                    <span class=\"comment\">// printf(&quot;  Action: KEY1 Single Click - Toggle LED1\\n&quot;);</span></span><br><span class=\"line\">                    <span class=\"comment\">// HAL_GPIO_TogglePin(LED1_GPIO_Port, LED1_Pin);</span></span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (click_cnt == <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// KEY1 双击</span></span><br><span class=\"line\">                    <span class=\"comment\">// printf(&quot;  Action: KEY1 Double Click - Switch Mode\\n&quot;);</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// ... 可以继续判断 3击, 4击 ...</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (key_id == <span class=\"number\">2</span>) &#123; <span class=\"comment\">// 如果是 KEY2 触发的 CLICK</span></span><br><span class=\"line\">                 <span class=\"keyword\">if</span> (click_cnt == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// KEY2 单击</span></span><br><span class=\"line\">                    <span class=\"comment\">// printf(&quot;  Action: KEY2 Single Click - Toggle LED2\\n&quot;);</span></span><br><span class=\"line\">                 &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (key_id == <span class=\"number\">101</span>) &#123; <span class=\"comment\">// 如果是组合键 (KEY1+KEY2) 触发的 CLICK</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (click_cnt == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                     <span class=\"comment\">// 组合键单击</span></span><br><span class=\"line\">                     <span class=\"comment\">// printf(&quot;  Action: Combo Key 101 Single Click - Reset System\\n&quot;);</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">case</span> EBTN_EVT_KEEPALIVE: <span class=\"comment\">// 保持活动/长按事件 (按下持续时间超过阈值后，按周期触发)</span></span><br><span class=\"line\">            <span class=\"comment\">// printf(&quot; - Keep Alive (Long Press, Count: %d)\\n&quot;, kalive_cnt);</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (key_id == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// KEY1 长按</span></span><br><span class=\"line\">                <span class=\"comment\">// printf(&quot;  Action: KEY1 Long Press - Increase Volume\\n&quot;);</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">default</span>: <span class=\"comment\">// 未知事件 (理论上不应发生)</span></span><br><span class=\"line\">            <span class=\"comment\">// printf(&quot; - Unknown Event\\n&quot;);</span></span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"第四步：初始化-ebtn-库\"><a href=\"#第四步：初始化-ebtn-库\" class=\"headerlink\" title=\"第四步：初始化 ebtn 库\"></a>第四步：初始化 ebtn 库</h4><p>在系统启动的初始化阶段（例如 <code>main</code> 函数开始处，或专门的初始化函数中），调用 <code>ebtn_init</code> 函数，将之前准备好的按键列表和回调函数”注册”给 <code>ebtn</code> 库。</p>\n<p>如果使用了组合按键，还需要在 <code>ebtn_init</code> <strong>之后</strong>，调用相关函数将普通按键绑定到组合键上。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">button_init</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ebtn_init(</span><br><span class=\"line\">        static_buttons,                 <span class=\"comment\">// 静态按键数组的指针</span></span><br><span class=\"line\">        EBTN_ARRAY_SIZE(static_buttons), <span class=\"comment\">// 静态按键数量 (用宏计算)</span></span><br><span class=\"line\">        static_combos,                  <span class=\"comment\">// 静态组合按键数组的指针 (如果没有，传 NULL, 0)</span></span><br><span class=\"line\">        EBTN_ARRAY_SIZE(static_combos), <span class=\"comment\">// 静态组合按键数量 (如果没有，传 0)</span></span><br><span class=\"line\">        my_get_key_state,               <span class=\"comment\">// 你的状态获取回调函数</span></span><br><span class=\"line\">        my_handle_key_event             <span class=\"comment\">// 你的事件处理回调函数</span></span><br><span class=\"line\">    );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//下面这个函数可以在调度器中每5秒调用</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">button_task</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ebtn_process(uwTick);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"SD-FATFS\"><a href=\"#SD-FATFS\" class=\"headerlink\" title=\"SD+FATFS\"></a>SD+FATFS</h2><h3 id=\"CubeMX配置\"><a href=\"#CubeMX配置\" class=\"headerlink\" title=\"CubeMX配置\"></a>CubeMX配置</h3><p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509232059309.png\" alt=\"image-20250923205942773\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509232100265.png\" alt=\"image-20250923210029131\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509281144270.png\" alt=\"image-20250928114434875\"></p>\n<blockquote>\n<p>注意：如果TF-CARD上的CD引脚有接入gpio的话 可以将platform设置为该引脚 即检测SD卡引脚</p>\n<ul>\n<li><p>当该引脚为低电平时，则检测到sd卡</p>\n</li>\n<li><p>没有接gpio的话，platform不要设置 不然会读取不到卡</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509232103277.png\" alt=\"image-20250923210313143\"></p>\n<p>正点原子探索者v3没有设计该引脚 所以留空即可</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509232103527.png\" alt=\"image-20250923210355410\"></p>\n</li>\n</ul>\n</blockquote>\n<h3 id=\"使用步骤-1\"><a href=\"#使用步骤-1\" class=\"headerlink\" title=\"使用步骤\"></a>使用步骤</h3><h4 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SD_Driver.disk_initialize(<span class=\"number\">0</span>); <span class=\"comment\">// SD_Driver已经被声明在FATFS/Target/sd_diskio.c</span></span><br></pre></td></tr></table></figure>\n\n","excerpt":"","more":"<h2 id=\"调度器模板\"><a href=\"#调度器模板\" class=\"headerlink\" title=\"调度器模板\"></a>调度器模板</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;scheduler.h&quot;</span></span></span><br><span class=\"line\"><span class=\"comment\">// clang-format off</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\t<span class=\"type\">void</span> (*task_func)(<span class=\"type\">void</span>);</span><br><span class=\"line\">\t<span class=\"type\">uint32_t</span> rate_ms;</span><br><span class=\"line\">\t<span class=\"type\">uint32_t</span> last_ms;</span><br><span class=\"line\">&#125; <span class=\"type\">task_t</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">task_t</span> tasks[] = &#123;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">uint8_t</span> task_count;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">scheduler_init</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\ttask_count = <span class=\"keyword\">sizeof</span>(tasks) / <span class=\"keyword\">sizeof</span>(<span class=\"type\">task_t</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">scheduler_run</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"type\">uint8_t</span> i;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; task_count; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">uint32_t</span> now_time = HAL_GetTick();</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> ((<span class=\"type\">uint32_t</span>)(now_time - tasks[i].last_ms) &gt;= tasks[i].rate_ms)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\ttasks[i].last_ms = now_time;</span><br><span class=\"line\">\t\t\ttasks[i].task_func();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"时钟配置栏\"><a href=\"#时钟配置栏\" class=\"headerlink\" title=\"时钟配置栏\"></a>时钟配置栏</h2><h3 id=\"模式设置\"><a href=\"#模式设置\" class=\"headerlink\" title=\"模式设置\"></a>模式设置</h3><p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202506021615783.png\" alt=\"image-20250602161506934\"></p>\n<h4 id=\"高速时钟HSE\"><a href=\"#高速时钟HSE\" class=\"headerlink\" title=\"高速时钟HSE\"></a>高速时钟HSE</h4><ul>\n<li><p><code>Disable</code>：不启用外部时钟（默认使用内部时钟） <span style=\"color:#00FFFF;\">内部时钟（内部RC（电阻-电容）振荡器）提供了此便捷性 但精度不如外部时钟（外部低速晶振或陶瓷振荡器）</span></p>\n</li>\n<li><p><code>BYPASS Clock Source</code>：旁路模式，允许直接<span style=\"color:#00FFFF;\">从外部导入时钟信号，而不使用外部晶体</span>。这种模式适用于需要从外部系统或其他设备接收时钟信号的情况。</p>\n</li>\n<li><p><code>Crystal/Ceramic Resonator</code>：将外部低速晶振或陶瓷谐振器作为时钟源，一般则是板载上的外部晶振</p>\n</li>\n</ul>\n<h4 id=\"低速时钟LSE\"><a href=\"#低速时钟LSE\" class=\"headerlink\" title=\"低速时钟LSE\"></a>低速时钟LSE</h4><blockquote>\n<p>参数同上 通常用于<span style=\"color:#33FFFF;\">实时时钟（RTC</span>）等需要低频稳定时钟的应用。LSE的典型频率为32.768kHz</p>\n</blockquote>\n<h4 id=\"Master-Clock-Output\"><a href=\"#Master-Clock-Output\" class=\"headerlink\" title=\"Master Clock Output\"></a><strong>Master Clock Output</strong></h4><ul>\n<li>配置是否使能主时钟<span style=\"color:#33FFFF;\">输出到MCO引脚</span>，<code>即可以通过MCO引脚将时钟信号输出到外部，供其他设备使用</code></li>\n</ul>\n<h4 id=\"Audio-Clock-Input-I2S-CKIN-：\"><a href=\"#Audio-Clock-Input-I2S-CKIN-：\" class=\"headerlink\" title=\"**Audio Clock Input (I2S_CKIN)**：\"></a>**Audio Clock Input (I2S_CKIN)**：</h4><ul>\n<li>此选项用于配置是否从<span style=\"color:#33FFFF;\">特定的引脚（如I2S_CKIN）输入音频时钟</span>。这对于需要精确音频时钟的音频应用非常重要，<code>例如I2S音频接口</code>。</li>\n</ul>\n<h3 id=\"参数设置\"><a href=\"#参数设置\" class=\"headerlink\" title=\"参数设置\"></a>参数设置</h3><p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202506021629990.png\" alt=\"image-20250602162859501\"></p>\n<ul>\n<li><p><code>TIM Prescaler Selection</code>：定时器预分频选择，<code>禁用时使用最大分频值。</code></p>\n</li>\n<li><p><code>HSE Startup Timeout Value (ms)</code>：HSE（高速外部时钟）启动超时时间，设置为100ms。这是外部晶振启动的最长等待时间，如果超出这个时间晶振还未启动，微控制器会认为启动失败。</p>\n</li>\n<li><p><code>LSE Startup Timeout Value (ms)</code>：LSE（低速外部时钟）启动超时时间，设置为5000ms。这通常用于RTC的时钟源，如果超出这个时间晶振还未启动，微控制器会认为启动失败。</p>\n</li>\n<li><p><code>Power Regulator Voltage Scale</code>：电源调节器电压等级，设置为<code>Power Regulator Voltage Scale 3</code>。这通常与微控制器的性能和功耗有关，不同的电压等级可以提供不同的性能和功耗平衡。</p>\n</li>\n<li><p><code>Power Over Drive</code>：电源过驱，禁用。这通常用于在需要更高性能时<span style=\"color:#33FFFF;\">临时提高微控制器的电压</span>，以支持更高的时钟频率。</p>\n</li>\n</ul>\n<h3 id=\"在何处选择了HSI以及HSE\"><a href=\"#在何处选择了HSI以及HSE\" class=\"headerlink\" title=\"在何处选择了HSI以及HSE\"></a>在何处选择了HSI以及HSE</h3><p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202506021818291.png\" alt=\"image-20250602181824740\"></p>\n<ul>\n<li><p>第一个框一定一定要看硬件上的晶振是多少频率，<span style=\"color:#00FFFF;\">一定要严格按照硬件资源给的 （不要无脑用默认的）</span></p>\n<blockquote>\n<p>否则可能会出现串口数据接收乱码</p>\n</blockquote>\n</li>\n<li><p>第二个框选择了用&#96;相位锁定环（PLL） 调整外部高速时钟（HSE）还是内部高速时钟（HSI）</p>\n</li>\n<li><p>第三个框框则直接选择是否选择 经过PLL调整后的时钟，也可以选择不经过PLL的原生外部高速时钟（HSE），以及内部高速时钟（HSI）。</p>\n</li>\n</ul>\n<h2 id=\"SYS调试接口选择\"><a href=\"#SYS调试接口选择\" class=\"headerlink\" title=\"SYS调试接口选择\"></a>SYS调试接口选择</h2><p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202506021828146.png\" alt=\"image-20250602182759796\"></p>\n<h3 id=\"Serial-Wire-SW-DP\"><a href=\"#Serial-Wire-SW-DP\" class=\"headerlink\" title=\"Serial Wire (SW-DP)\"></a>Serial Wire (SW-DP)</h3><ul>\n<li><p>串口烧录 仅需要两个引脚</p>\n<ul>\n<li><code>SWCLK</code>：主机到从机的时钟信号</li>\n<li><code>SWDIO</code>：双向数据信号</li>\n</ul>\n</li>\n<li><p>这种模式下，ST-Link工作最稳定，占用引脚少，是日常开发的首选。</p>\n</li>\n</ul>\n<h3 id=\"JTAG-JTAG-DP\"><a href=\"#JTAG-JTAG-DP\" class=\"headerlink\" title=\"JTAG(JTAG-DP)\"></a>JTAG(JTAG-DP)</h3><ul>\n<li>J-Link烧录 需要4或5个引脚：<ul>\n<li><strong>TCK：</strong>测试时钟</li>\n<li><strong>TMS：</strong>测试模式选择</li>\n<li><strong>TDI：</strong>测试数据输入</li>\n<li><strong>TDO：</strong>测试数据输出</li>\n<li><strong>TRST：</strong>测试复位（可选，5pin模式才有）</li>\n</ul>\n</li>\n<li>JTAG适合复杂的调试场景，尤其是在使用J-Link调试器时。</li>\n</ul>\n<h2 id=\"LED\"><a href=\"#LED\" class=\"headerlink\" title=\"LED\"></a>LED</h2><h3 id=\"驱动代码\"><a href=\"#驱动代码\" class=\"headerlink\" title=\"驱动代码\"></a>驱动代码</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;led_app.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">uint8_t</span> ucLed[<span class=\"number\">6</span>] = &#123;<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">Led_disp</span><span class=\"params\">(<span class=\"type\">uint8_t</span> *ucLed)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"type\">uint8_t</span> temp = <span class=\"number\">0x00</span>, i;</span><br><span class=\"line\">\t<span class=\"type\">static</span> <span class=\"type\">uint8_t</span> temp_old = <span class=\"number\">0xff</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">6</span>; i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (ucLed[i])</span><br><span class=\"line\">\t\t\ttemp |= (<span class=\"number\">1</span> &lt;&lt; i);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (temp != temp_old)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tHAL_GPIO_WritePin(LED1_GPIO_Port, LED1_Pin, (temp &amp; <span class=\"number\">0x01</span>) ? GPIO_PIN_SET : GPIO_PIN_RESET);</span><br><span class=\"line\">\t\tHAL_GPIO_WritePin(LED2_GPIO_Port, LED2_Pin, (temp &amp; <span class=\"number\">0x02</span>) ? GPIO_PIN_SET : GPIO_PIN_RESET);</span><br><span class=\"line\">\t\tHAL_GPIO_WritePin(LED3_GPIO_Port, LED3_Pin, (temp &amp; <span class=\"number\">0x04</span>) ? GPIO_PIN_SET : GPIO_PIN_RESET);</span><br><span class=\"line\">\t\tHAL_GPIO_WritePin(LED4_GPIO_Port, LED4_Pin, (temp &amp; <span class=\"number\">0x08</span>) ? GPIO_PIN_SET : GPIO_PIN_RESET);</span><br><span class=\"line\">\t\tHAL_GPIO_WritePin(LED5_GPIO_Port, LED5_Pin, (temp &amp; <span class=\"number\">0x10</span>) ? GPIO_PIN_SET : GPIO_PIN_RESET);</span><br><span class=\"line\">\t\tHAL_GPIO_WritePin(LED6_GPIO_Port, LED6_Pin, (temp &amp; <span class=\"number\">0x20</span>) ? GPIO_PIN_SET : GPIO_PIN_RESET);</span><br><span class=\"line\">\t\ttemp_old = temp;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">led_task</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tLed_disp(ucLed);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"软件PWM呼吸灯\"><a href=\"#软件PWM呼吸灯\" class=\"headerlink\" title=\"软件PWM呼吸灯\"></a>软件PWM呼吸灯</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">led_task</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"type\">static</span> <span class=\"type\">uint32_t</span> breath_counter = <span class=\"number\">0</span>;\t\t\t<span class=\"comment\">// 呼吸效果内部计时器，模拟时间流逝</span></span><br><span class=\"line\">\t<span class=\"type\">static</span> <span class=\"type\">uint8_t</span> pwm_counter = <span class=\"number\">0</span>;\t\t\t\t<span class=\"comment\">// PWM内部计时器，用于生成PWM波形</span></span><br><span class=\"line\">\t<span class=\"type\">static</span> <span class=\"type\">uint8_t</span> brightness = <span class=\"number\">0</span>;\t\t\t\t<span class=\"comment\">// 当前的亮度值</span></span><br><span class=\"line\">\t<span class=\"type\">static</span> <span class=\"type\">const</span> <span class=\"type\">uint16_t</span> breath_period = <span class=\"number\">2000</span>; <span class=\"comment\">// 呼吸效果周期，单位ms 调小可增加速度</span></span><br><span class=\"line\">\t<span class=\"type\">static</span> <span class=\"type\">const</span> <span class=\"type\">uint16_t</span> pwm_max = <span class=\"number\">10</span>;\t\t\t<span class=\"comment\">// PWM最大计数值  调大会降低pwm频率</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tbreath_counter = (++breath_counter) % breath_period;</span><br><span class=\"line\">        <span class=\"comment\">//(2.0f * 3.14159f * breath_counter / breath_period) 将结果映射为0到2π</span></span><br><span class=\"line\">        <span class=\"comment\">//sin(2.0f * 3.14159f * breath_counter / breath_period) 将结果映射为-1到1</span></span><br><span class=\"line\">        <span class=\"comment\">//sin(2.0f * 3.14159f * breath_counter / breath_period) + 1.0f 将结果映射为0到2</span></span><br><span class=\"line\">        <span class=\"comment\">//(sin(2.0f * 3.14159f * breath_counter / breath_period) + 1.0f) * pwm_max / 2.0f 将实际亮度计算出来 通过(uint8_t)强制类型转换</span></span><br><span class=\"line\">\tbrightness = (<span class=\"type\">uint8_t</span>)((<span class=\"built_in\">sin</span>(<span class=\"number\">2.0f</span> * <span class=\"number\">3.14159f</span> * breath_counter / breath_period) + <span class=\"number\">1.0f</span>) * pwm_max / <span class=\"number\">2.0f</span>);</span><br><span class=\"line\">\tpwm_counter = (++pwm_counter) % pwm_max;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">uint8_t</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">6</span>; i++)</span><br><span class=\"line\">\t\tucLed[i] = (pwm_counter &lt; brightness) ? <span class=\"number\">1</span> : <span class=\"number\">0</span>; <span class=\"comment\">//将所有LED置为呼吸灯效果</span></span><br><span class=\"line\">\tLed_disp(ucLed);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>如果是要实时调光，则直接赋值<code>brightness</code>即可 （即<span style=\"color:#FF3333;\">不需要</span><code>breath_counter</code>和<code>breath_period</code>）</p>\n</blockquote>\n<h2 id=\"按键\"><a href=\"#按键\" class=\"headerlink\" title=\"按键\"></a>按键</h2><blockquote>\n<p>常用工程上所用按键对比</p>\n<p>github仓库地址：<a href=\"https://github.com/bobwenstudy/easy_button\">bobwenstudy&#x2F;easy_button: 嵌入式按键处理驱动（Button Driver），支持单击、双击、多击、自动消抖、长按、长长按、超长按 | 低功耗支持 | 组合按键支持 | 静态&#x2F;动态注册支持</a></p>\n</blockquote>\n<p><img src=\"https://fastly.jsdelivr.net/gh/2250272571/tuchuang@main/img/202506061718736.png\" alt=\"image-20250606171853466\"></p>\n<blockquote>\n<p>整体框架：<br>easy_button<br> ├── ebtn<br> │   ├── bit_array.h<br> │   ├── ebtn.c<br> │   └── ebtn.h<br> ├── build.mk<br> ├── example_user.c<br> └── example_test.c<br> ├── main.c<br> ├── Makefile<br> └── README.md</p>\n</blockquote>\n<h3 id=\"使用步骤\"><a href=\"#使用步骤\" class=\"headerlink\" title=\"使用步骤\"></a>使用步骤</h3><h4 id=\"第一步：新建button-app-c并包含头文件\"><a href=\"#第一步：新建button-app-c并包含头文件\" class=\"headerlink\" title=\"第一步：新建button_app.c并包含头文件\"></a>第一步：新建button_app.c并包含头文件</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;ebtn.h&quot;</span> <span class=\"comment\">// 包含 ebtn 库头文件</span></span></span><br><span class=\"line\"><span class=\"comment\">// ... 可能还需要包含你的 HAL 库头文件 ...</span></span><br><span class=\"line\"><span class=\"comment\">// #include &quot;stm32xxx_hal.h&quot;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"第二步：定义参数与按键列表\"><a href=\"#第二步：定义参数与按键列表\" class=\"headerlink\" title=\"第二步：定义参数与按键列表\"></a>第二步：定义参数与按键列表</h4><ol>\n<li><strong>定义按键参数 (<code>ebtn_btn_param_t</code>):</strong> 使用 <code>EBTN_PARAMS_INIT</code> 宏设定按键的各种时间阈值和行为。这些参数可以被多个按键共用。<code>可用默认参数 即如下default_param_normal</code></li>\n<li><strong>定义按键实例数组 (<code>ebtn_btn_t</code>):</strong> 使用 <code>EBTN_BUTTON_INIT</code> 宏创建每个物理按键的实例，并指定它的唯一 <code>key_id</code> 和使用的参数。</li>\n<li><strong>（可不加）定义组合按键实例数组 (<code>ebtn_btn_combo_t</code>, 可选):</strong> 使用 <code>EBTN_BUTTON_COMBO_INIT</code> 创建组合键实例，同样指定 <code>key_id</code> 和参数。</li>\n</ol>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 1. 定义按键参数实例 */</span></span><br><span class=\"line\"><span class=\"comment\">// 参数宏: EBTN_PARAMS_INIT(</span></span><br><span class=\"line\"><span class=\"comment\">//     按下消抖时间ms, 释放消抖时间ms,</span></span><br><span class=\"line\"><span class=\"comment\">//     单击有效最短按下时间ms, 单击有效最长按下时间ms,</span></span><br><span class=\"line\"><span class=\"comment\">//     多次单击最大间隔时间ms,</span></span><br><span class=\"line\"><span class=\"comment\">//     长按(KeepAlive)事件周期ms (0禁用),</span></span><br><span class=\"line\"><span class=\"comment\">//     最大连续有效点击次数 (e.g., 1=单击, 2=双击, ...)</span></span><br><span class=\"line\"><span class=\"comment\">// )</span></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">ebtn_btn_param_t</span> default_param_normal = EBTN_PARAMS_INIT(</span><br><span class=\"line\">    <span class=\"number\">20</span>,     <span class=\"comment\">// time_debounce: 按下稳定 20ms(消抖)</span></span><br><span class=\"line\">    <span class=\"number\">20</span>,     <span class=\"comment\">// time_debounce_release: 释放稳定 20ms</span></span><br><span class=\"line\">    <span class=\"number\">50</span>,     <span class=\"comment\">// time_click_pressed_min: 最短单击按下 50ms</span></span><br><span class=\"line\">    <span class=\"number\">500</span>,    <span class=\"comment\">// time_click_pressed_max: 最长单击按下 500ms (超过则不算单击)</span></span><br><span class=\"line\">    <span class=\"number\">300</span>,    <span class=\"comment\">// time_click_multi_max: 多次单击最大间隔 300ms (两次点击间隔超过则重新计数)</span></span><br><span class=\"line\">    <span class=\"number\">500</span>,    <span class=\"comment\">// time_keepalive_period: 长按事件周期 500ms (按下超过 500ms 后，每 500ms 触发一次)</span></span><br><span class=\"line\">    <span class=\"number\">5</span>       <span class=\"comment\">// max_consecutive: 最多支持 5 连击</span></span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 2. 定义静态按键列表 */</span></span><br><span class=\"line\"><span class=\"comment\">// 宏: EBTN_BUTTON_INIT(按键ID, 参数指针)</span></span><br><span class=\"line\"><span class=\"type\">ebtn_btn_t</span> static_buttons[] = &#123;</span><br><span class=\"line\">    EBTN_BUTTON_INIT(<span class=\"number\">1</span>, &amp;default_param_normal), <span class=\"comment\">// KEY1, ID=1, 使用 &#x27;default_param_normal&#x27; 参数</span></span><br><span class=\"line\">    EBTN_BUTTON_INIT(<span class=\"number\">2</span>, &amp;default_param_normal), <span class=\"comment\">// KEY2, ID=2, 也使用 &#x27;default_param_normal&#x27; 参数</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 3. 定义静态组合按键列表 (可选) */</span></span><br><span class=\"line\"><span class=\"comment\">// 宏: EBTN_BUTTON_COMBO_INIT(按键ID, 参数指针)</span></span><br><span class=\"line\"><span class=\"type\">ebtn_btn_combo_t</span> static_combos[] = &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 假设 KEY1+KEY2 组合键</span></span><br><span class=\"line\">    EBTN_BUTTON_COMBO_INIT(<span class=\"number\">101</span>, &amp;default_param_normal), <span class=\"comment\">// 组合键, ID=101 (必须与普通按键ID不同)</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"第三步：编写回调函数\"><a href=\"#第三步：编写回调函数\" class=\"headerlink\" title=\"第三步：编写回调函数\"></a>第三步：编写回调函数</h4><p>你需要提供两个函数给 <code>ebtn</code> 库，告诉它如何与你的硬件交互以及如何通知你事件：</p>\n<ul>\n<li><strong><code>get_state_fn</code> (状态获取):</strong> 这个函数被 <code>ebtn</code> 调用，用于读取指定按键当前的物理电平。</li>\n<li><strong><code>evt_fn</code> (事件处理):</strong> 当 <code>ebtn</code> 检测到一个有效的按键事件（按下、释放、单击、长按）时，会调用这个函数，并传入触发事件的按键信息和事件类型。</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 1. 实现获取按键状态的回调函数 */</span></span><br><span class=\"line\"><span class=\"comment\">// 函数原型: uint8_t (*ebtn_get_state_fn)(struct ebtn_btn *btn);</span></span><br><span class=\"line\"><span class=\"type\">uint8_t</span> <span class=\"title function_\">my_get_key_state</span><span class=\"params\">(<span class=\"keyword\">struct</span> ebtn_btn *btn)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 根据传入的按钮实例中的 key_id 判断是哪个物理按键</span></span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (btn-&gt;key_id) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">1</span>: <span class=\"comment\">// 请求读取 KEY1 的状态</span></span><br><span class=\"line\">            <span class=\"comment\">// 假设 KEY1 接在 PB0，按下为低电平 (返回 1 代表按下)</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> (HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_0) == GPIO_PIN_RESET);</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">2</span>: <span class=\"comment\">// 请求读取 KEY2 的状态</span></span><br><span class=\"line\">            <span class=\"comment\">// 假设 KEY2 接在 PB1，按下为低电平</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> (HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_1) == GPIO_PIN_RESET);</span><br><span class=\"line\">        <span class=\"comment\">// ... 可以添加更多按键的读取逻辑 ...</span></span><br><span class=\"line\">        <span class=\"keyword\">default</span>:</span><br><span class=\"line\">            <span class=\"comment\">// 对于库内部处理组合键等情况，或者未知的 key_id，安全起见返回 0 (未按下)</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 注意：返回值 1 表示 &quot;活动/按下&quot;，0 表示 &quot;非活动/释放&quot;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 2. 实现处理按键事件的回调函数 */</span></span><br><span class=\"line\"><span class=\"comment\">// 函数原型: void (*ebtn_evt_fn)(struct ebtn_btn *btn, ebtn_evt_t evt);</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">my_handle_key_event</span><span class=\"params\">(<span class=\"keyword\">struct</span> ebtn_btn *btn, <span class=\"type\">ebtn_evt_t</span> evt)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">uint16_t</span> key_id = btn-&gt;key_id;                 <span class=\"comment\">// 获取触发事件的按键 ID</span></span><br><span class=\"line\">    <span class=\"type\">uint16_t</span> click_cnt = ebtn_click_get_count(btn); <span class=\"comment\">// 获取连击次数 (仅在 ONCLICK 事件时有意义)</span></span><br><span class=\"line\">    <span class=\"comment\">// uint16_t kalive_cnt = ebtn_keepalive_get_count(btn); // 获取长按计数 (仅在 KEEPALIVE 事件时有意义)</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 调试打印 (可选)</span></span><br><span class=\"line\">    <span class=\"comment\">// printf(&quot;Key ID: %d, Event: %d&quot;, key_id, evt);</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 根据事件类型进行处理</span></span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (evt) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> EBTN_EVT_ONPRESS: <span class=\"comment\">// 按下事件 (消抖成功后触发一次)</span></span><br><span class=\"line\">            <span class=\"comment\">// printf(&quot; - Pressed\\n&quot;);</span></span><br><span class=\"line\">            <span class=\"comment\">// 可以在这里处理按下即触发的操作，比如点亮提示灯</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (key_id == <span class=\"number\">1</span>) &#123; <span class=\"comment\">/* Do something for KEY1 press */</span> &#125;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">case</span> EBTN_EVT_ONRELEASE: <span class=\"comment\">// 释放事件 (消抖成功后触发一次)</span></span><br><span class=\"line\">            <span class=\"comment\">// printf(&quot; - Released\\n&quot;);</span></span><br><span class=\"line\">            <span class=\"comment\">// 可以在这里处理释放时触发的操作</span></span><br><span class=\"line\">             <span class=\"keyword\">if</span> (key_id == <span class=\"number\">1</span>) &#123; <span class=\"comment\">/* Do something for KEY1 release */</span> &#125;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">case</span> EBTN_EVT_ONCLICK: <span class=\"comment\">// 单击/连击事件 (在释放后，或达到最大连击数，或超时后触发)</span></span><br><span class=\"line\">            <span class=\"comment\">// printf(&quot; - Clicked (%d times)\\n&quot;, click_cnt);</span></span><br><span class=\"line\">            <span class=\"comment\">// --- 根据 key_id 和 click_cnt 执行不同操作 ---</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (key_id == <span class=\"number\">1</span>) &#123; <span class=\"comment\">// 如果是 KEY1 触发的 CLICK</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (click_cnt == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// KEY1 单击</span></span><br><span class=\"line\">                    <span class=\"comment\">// printf(&quot;  Action: KEY1 Single Click - Toggle LED1\\n&quot;);</span></span><br><span class=\"line\">                    <span class=\"comment\">// HAL_GPIO_TogglePin(LED1_GPIO_Port, LED1_Pin);</span></span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (click_cnt == <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// KEY1 双击</span></span><br><span class=\"line\">                    <span class=\"comment\">// printf(&quot;  Action: KEY1 Double Click - Switch Mode\\n&quot;);</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// ... 可以继续判断 3击, 4击 ...</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (key_id == <span class=\"number\">2</span>) &#123; <span class=\"comment\">// 如果是 KEY2 触发的 CLICK</span></span><br><span class=\"line\">                 <span class=\"keyword\">if</span> (click_cnt == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// KEY2 单击</span></span><br><span class=\"line\">                    <span class=\"comment\">// printf(&quot;  Action: KEY2 Single Click - Toggle LED2\\n&quot;);</span></span><br><span class=\"line\">                 &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (key_id == <span class=\"number\">101</span>) &#123; <span class=\"comment\">// 如果是组合键 (KEY1+KEY2) 触发的 CLICK</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (click_cnt == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                     <span class=\"comment\">// 组合键单击</span></span><br><span class=\"line\">                     <span class=\"comment\">// printf(&quot;  Action: Combo Key 101 Single Click - Reset System\\n&quot;);</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">case</span> EBTN_EVT_KEEPALIVE: <span class=\"comment\">// 保持活动/长按事件 (按下持续时间超过阈值后，按周期触发)</span></span><br><span class=\"line\">            <span class=\"comment\">// printf(&quot; - Keep Alive (Long Press, Count: %d)\\n&quot;, kalive_cnt);</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (key_id == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// KEY1 长按</span></span><br><span class=\"line\">                <span class=\"comment\">// printf(&quot;  Action: KEY1 Long Press - Increase Volume\\n&quot;);</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">default</span>: <span class=\"comment\">// 未知事件 (理论上不应发生)</span></span><br><span class=\"line\">            <span class=\"comment\">// printf(&quot; - Unknown Event\\n&quot;);</span></span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"第四步：初始化-ebtn-库\"><a href=\"#第四步：初始化-ebtn-库\" class=\"headerlink\" title=\"第四步：初始化 ebtn 库\"></a>第四步：初始化 ebtn 库</h4><p>在系统启动的初始化阶段（例如 <code>main</code> 函数开始处，或专门的初始化函数中），调用 <code>ebtn_init</code> 函数，将之前准备好的按键列表和回调函数”注册”给 <code>ebtn</code> 库。</p>\n<p>如果使用了组合按键，还需要在 <code>ebtn_init</code> <strong>之后</strong>，调用相关函数将普通按键绑定到组合键上。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">button_init</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ebtn_init(</span><br><span class=\"line\">        static_buttons,                 <span class=\"comment\">// 静态按键数组的指针</span></span><br><span class=\"line\">        EBTN_ARRAY_SIZE(static_buttons), <span class=\"comment\">// 静态按键数量 (用宏计算)</span></span><br><span class=\"line\">        static_combos,                  <span class=\"comment\">// 静态组合按键数组的指针 (如果没有，传 NULL, 0)</span></span><br><span class=\"line\">        EBTN_ARRAY_SIZE(static_combos), <span class=\"comment\">// 静态组合按键数量 (如果没有，传 0)</span></span><br><span class=\"line\">        my_get_key_state,               <span class=\"comment\">// 你的状态获取回调函数</span></span><br><span class=\"line\">        my_handle_key_event             <span class=\"comment\">// 你的事件处理回调函数</span></span><br><span class=\"line\">    );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//下面这个函数可以在调度器中每5秒调用</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">button_task</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ebtn_process(uwTick);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"SD-FATFS\"><a href=\"#SD-FATFS\" class=\"headerlink\" title=\"SD+FATFS\"></a>SD+FATFS</h2><h3 id=\"CubeMX配置\"><a href=\"#CubeMX配置\" class=\"headerlink\" title=\"CubeMX配置\"></a>CubeMX配置</h3><p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509232059309.png\" alt=\"image-20250923205942773\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509232100265.png\" alt=\"image-20250923210029131\"></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509281144270.png\" alt=\"image-20250928114434875\"></p>\n<blockquote>\n<p>注意：如果TF-CARD上的CD引脚有接入gpio的话 可以将platform设置为该引脚 即检测SD卡引脚</p>\n<ul>\n<li><p>当该引脚为低电平时，则检测到sd卡</p>\n</li>\n<li><p>没有接gpio的话，platform不要设置 不然会读取不到卡</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509232103277.png\" alt=\"image-20250923210313143\"></p>\n<p>正点原子探索者v3没有设计该引脚 所以留空即可</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509232103527.png\" alt=\"image-20250923210355410\"></p>\n</li>\n</ul>\n</blockquote>\n<h3 id=\"使用步骤-1\"><a href=\"#使用步骤-1\" class=\"headerlink\" title=\"使用步骤\"></a>使用步骤</h3><h4 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SD_Driver.disk_initialize(<span class=\"number\">0</span>); <span class=\"comment\">// SD_Driver已经被声明在FATFS/Target/sd_diskio.c</span></span><br></pre></td></tr></table></figure>\n\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cmk8pg6xg00066sk92k77gblg","category_id":"cmk8pg6xh00076sk9h0gc321f","_id":"cmk8pg6xi000b6sk92g7u1u9x"},{"post_id":"cmk8pg6xk000p6sk9dd7he1y7","category_id":"cmk8pg6xh00076sk9h0gc321f","_id":"cmk8pg6xm000u6sk9hn919ogr"},{"post_id":"cmk8pg6xl000r6sk9527u942s","category_id":"cmk8pg6xh00076sk9h0gc321f","_id":"cmk8pg6xn000x6sk91ohy8q1y"},{"post_id":"cmk8pg6xm000w6sk93pux042e","category_id":"cmk8pg6xh00076sk9h0gc321f","_id":"cmk8pg6xo00136sk9hw8071cc"},{"post_id":"cmk8pg6xn00106sk91exxffbm","category_id":"cmk8pg6xh00076sk9h0gc321f","_id":"cmk8pg6xp00196sk91ykkav10"},{"post_id":"cmk8pg6xo00166sk9fzj89e2q","category_id":"cmk8pg6xh00076sk9h0gc321f","_id":"cmk8pg6xp001d6sk9cqy30rp3"},{"post_id":"cmk8pg6xo00126sk942cr8qjd","category_id":"cmk8pg6xp00186sk97vjyehyh","_id":"cmk8pg6xp001h6sk96ruk6skc"}],"PostTag":[{"post_id":"cmk8pg6xc00016sk96m9p14kv","tag_id":"cmk8pg6xf00046sk98gts315g","_id":"cmk8pg6xi000a6sk95vce6gb2"},{"post_id":"cmk8pg6xc00016sk96m9p14kv","tag_id":"cmk8pg6xh00086sk9h7865alt","_id":"cmk8pg6xi000c6sk9ffq3dhq4"},{"post_id":"cmk8pg6xe00036sk9apm6ckrv","tag_id":"cmk8pg6xi00096sk92fwx0val","_id":"cmk8pg6xj000g6sk977opbugi"},{"post_id":"cmk8pg6xe00036sk9apm6ckrv","tag_id":"cmk8pg6xi000d6sk94r2y1z1o","_id":"cmk8pg6xj000h6sk9fz2d8bir"},{"post_id":"cmk8pg6xe00036sk9apm6ckrv","tag_id":"cmk8pg6xf00046sk98gts315g","_id":"cmk8pg6xj000j6sk9fqxt5gk0"},{"post_id":"cmk8pg6xg00066sk92k77gblg","tag_id":"cmk8pg6xi00096sk92fwx0val","_id":"cmk8pg6xj000l6sk98mp5a5nn"},{"post_id":"cmk8pg6xg00066sk92k77gblg","tag_id":"cmk8pg6xi000d6sk94r2y1z1o","_id":"cmk8pg6xj000m6sk9cowdeped"},{"post_id":"cmk8pg6xg00066sk92k77gblg","tag_id":"cmk8pg6xf00046sk98gts315g","_id":"cmk8pg6xj000n6sk9cmexfltp"},{"post_id":"cmk8pg6xk000o6sk9d0m7af3i","tag_id":"cmk8pg6xl000q6sk97z8mbdl2","_id":"cmk8pg6xo00116sk98utwgumy"},{"post_id":"cmk8pg6xk000o6sk9d0m7af3i","tag_id":"cmk8pg6xm000v6sk940ow3v79","_id":"cmk8pg6xo00146sk9azsa2aj1"},{"post_id":"cmk8pg6xk000o6sk9d0m7af3i","tag_id":"cmk8pg6xf00046sk98gts315g","_id":"cmk8pg6xo00176sk9dp5pcdvj"},{"post_id":"cmk8pg6xk000p6sk9dd7he1y7","tag_id":"cmk8pg6xn000z6sk942t73uj3","_id":"cmk8pg6xp001a6sk90v2p6h3h"},{"post_id":"cmk8pg6xk000p6sk9dd7he1y7","tag_id":"cmk8pg6xi000d6sk94r2y1z1o","_id":"cmk8pg6xp001c6sk9frhf6r8l"},{"post_id":"cmk8pg6xl000r6sk9527u942s","tag_id":"cmk8pg6xo00156sk96vyv2qrw","_id":"cmk8pg6xp001e6sk95a9da3mv"},{"post_id":"cmk8pg6xl000s6sk9d08s88bb","tag_id":"cmk8pg6xp001b6sk91hc3c7ry","_id":"cmk8pg6xp001g6sk997u6219e"},{"post_id":"cmk8pg6xm000w6sk93pux042e","tag_id":"cmk8pg6xp001f6sk93ajvgewz","_id":"cmk8pg6xp001k6sk9bzfg6ue3"},{"post_id":"cmk8pg6xm000w6sk93pux042e","tag_id":"cmk8pg6xi000d6sk94r2y1z1o","_id":"cmk8pg6xp001l6sk93udw5a3k"},{"post_id":"cmk8pg6xm000w6sk93pux042e","tag_id":"cmk8pg6xp001i6sk99obwfxa6","_id":"cmk8pg6xp001n6sk9ezup75df"},{"post_id":"cmk8pg6xn000y6sk92n1ohuiq","tag_id":"cmk8pg6xp001j6sk994r21fy3","_id":"cmk8pg6xp001o6sk9h6e81vmv"},{"post_id":"cmk8pg6xn00106sk91exxffbm","tag_id":"cmk8pg6xp001f6sk93ajvgewz","_id":"cmk8pg6xq001r6sk976exahv4"},{"post_id":"cmk8pg6xn00106sk91exxffbm","tag_id":"cmk8pg6xi000d6sk94r2y1z1o","_id":"cmk8pg6xq001s6sk93l9i0iaz"},{"post_id":"cmk8pg6xn00106sk91exxffbm","tag_id":"cmk8pg6xp001p6sk9h8pu75tq","_id":"cmk8pg6xq001u6sk9dfa522ms"},{"post_id":"cmk8pg6xo00126sk942cr8qjd","tag_id":"cmk8pg6xq001q6sk92o0ug8nw","_id":"cmk8pg6xq001x6sk9cml44fzu"},{"post_id":"cmk8pg6xo00126sk942cr8qjd","tag_id":"cmk8pg6xq001t6sk97zp20vh6","_id":"cmk8pg6xq001y6sk9e44r0fix"},{"post_id":"cmk8pg6xo00126sk942cr8qjd","tag_id":"cmk8pg6xq001v6sk9a47l78r2","_id":"cmk8pg6xq001z6sk98anb4lyw"},{"post_id":"cmk8pg6xo00166sk9fzj89e2q","tag_id":"cmk8pg6xf00046sk98gts315g","_id":"cmk8pg6xq00206sk9h6x65fno"},{"post_id":"cmk8pg6xo00166sk9fzj89e2q","tag_id":"cmk8pg6xq001w6sk95017cocc","_id":"cmk8pg6xq00216sk9hhfy1jns"}],"Tag":[{"name":"嵌入式基础","_id":"cmk8pg6xf00046sk98gts315g"},{"name":"C语言高级","_id":"cmk8pg6xh00086sk9h7865alt"},{"name":"LVGL v8.2","_id":"cmk8pg6xi00096sk92fwx0val"},{"name":"RTOS","_id":"cmk8pg6xi000d6sk94r2y1z1o"},{"name":"蓝牙相关","_id":"cmk8pg6xl000q6sk97z8mbdl2"},{"name":"BLE学习","_id":"cmk8pg6xm000v6sk940ow3v79"},{"name":"ESP32","_id":"cmk8pg6xn000z6sk942t73uj3"},{"name":"TI","_id":"cmk8pg6xo00156sk96vyv2qrw"},{"name":"git","_id":"cmk8pg6xp001b6sk91hc3c7ry"},{"name":"实时操作系统","_id":"cmk8pg6xp001f6sk93ajvgewz"},{"name":"RT_Thread","_id":"cmk8pg6xp001i6sk99obwfxa6"},{"name":"电赛准备","_id":"cmk8pg6xp001j6sk994r21fy3"},{"name":"FreeRTOS","_id":"cmk8pg6xp001p6sk9h8pu75tq"},{"name":"音响","_id":"cmk8pg6xq001q6sk92o0ug8nw"},{"name":"实习","_id":"cmk8pg6xq001t6sk97zp20vh6"},{"name":"音频技术","_id":"cmk8pg6xq001v6sk9a47l78r2"},{"name":"GD32学习","_id":"cmk8pg6xq001w6sk95017cocc"}]}}