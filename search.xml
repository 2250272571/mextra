<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>linux</title>
      <link href="/2025/09/23/linux/"/>
      <url>/2025/09/23/linux/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ESP32学习</title>
      <link href="/2025/09/09/ESP32%E5%AD%A6%E4%B9%A0/"/>
      <url>/2025/09/09/ESP32%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="ESP32环境搭建"><a href="#ESP32环境搭建" class="headerlink" title="ESP32环境搭建"></a>ESP32环境搭建</h2><h3 id="WSL2安装与配置"><a href="#WSL2安装与配置" class="headerlink" title="WSL2安装与配置"></a>WSL2安装与配置</h3><p>推荐查阅官方文档说明：<a href="https://learn.microsoft.com/zh-cn/windows/wsl/install">安装 WSL | Microsoft Learn</a></p><h4 id="手动下载安装包"><a href="#手动下载安装包" class="headerlink" title="手动下载安装包"></a>手动下载安装包</h4><ol><li><p>访问 WSL 的 GitHub Releases 页面 <a href="https://github.com/microsoft/WSL/releases">https://github.com/microsoft/WSL/releases</a></p></li><li><p>查找并下载最新版本的 .msi 安装包（例如 wsl.2.1.5.0.x64.msi）</p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091112594.png" alt="image-20250909111242531"></p><h4 id="配置控制面板"><a href="#配置控制面板" class="headerlink" title="配置控制面板"></a>配置控制面板</h4><p><img src="https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091115919.png" alt="image-20250909111552848"></p><p><img src="https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091116357.png" alt="image-20250909111621317"></p><blockquote><p>有些Windows 11新系统会没有<code>虚拟机平台</code>这个选项 没有关系！！！！</p><p>配置完后重新启动电脑</p></blockquote><h4 id="管理员身份运行Windows-PowerShell"><a href="#管理员身份运行Windows-PowerShell" class="headerlink" title="管理员身份运行Windows PowerShell"></a>管理员身份运行Windows PowerShell</h4><p><img src="https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091108898.png" alt="img"></p><h4 id="安装Ubuntu"><a href="#安装Ubuntu" class="headerlink" title="安装Ubuntu"></a>安装Ubuntu</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl --install</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091108464.png" alt="img"></p><blockquote><p>如有可选 则选择Uuntu 如 <code>wsl --install -d Ubuntu</code></p></blockquote><h4 id="等待安装完成后重启电脑打开Ubuntu"><a href="#等待安装完成后重启电脑打开Ubuntu" class="headerlink" title="等待安装完成后重启电脑打开Ubuntu"></a>等待安装完成后重启电脑打开Ubuntu</h4><p><img src="https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091121963.png" alt="image-20250909112101810"></p><h4 id="输入账号密码"><a href="#输入账号密码" class="headerlink" title="输入账号密码"></a>输入账号密码</h4><p><img src="https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091121306.png" alt="img"></p><h4 id="更新软件源"><a href="#更新软件源" class="headerlink" title="更新软件源"></a>更新软件源</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt update</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091124279.png" alt="img"></p><h4 id="更新完后输入下方指令，下载espidf依赖库和工具"><a href="#更新完后输入下方指令，下载espidf依赖库和工具" class="headerlink" title="更新完后输入下方指令，下载espidf依赖库和工具"></a>更新完后输入下方指令，下载espidf依赖库和工具</h4><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get install git wget flex bison gperf python3 python3-pip python3-venv cmake ninja-build ccache libffi-dev libssl-dev dfu-util libusb-1.0-0</span><br></pre></td></tr></table></figure></blockquote><p><img src="https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091126525.png" alt="img"></p><h4 id="输入y"><a href="#输入y" class="headerlink" title="输入y"></a>输入y</h4><p><img src="https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091127364.png" alt="image-20250909112720315"></p><h3 id="VScode配置"><a href="#VScode配置" class="headerlink" title="VScode配置"></a>VScode配置</h3><h4 id="选择连接到WSL"><a href="#选择连接到WSL" class="headerlink" title="选择连接到WSL"></a>选择连接到WSL</h4><p><img src="https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091129218.png" alt="img"></p><h4 id="插件安装"><a href="#插件安装" class="headerlink" title="插件安装"></a>插件安装</h4><blockquote><ul><li>安装<code>Chinese</code>插件</li><li>安装<code>C/C++</code>插件</li><li>安装<code>ESP-IDF</code>插件</li></ul></blockquote><h4 id="在linux账户新建文件用于存放espidf内容，方便后续管理"><a href="#在linux账户新建文件用于存放espidf内容，方便后续管理" class="headerlink" title="在linux账户新建文件用于存放espidf内容，方便后续管理"></a>在linux账户新建文件用于存放espidf内容，方便后续管理</h4><p><img src="https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091135250.png" alt="image-20250909113527188"></p><h4 id="ESP-IDF安装"><a href="#ESP-IDF安装" class="headerlink" title="ESP-IDF安装"></a>ESP-IDF安装</h4><p><img src="https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091131190.png" alt="img"></p><h4 id="在安装路径中选择自己新建的文件夹"><a href="#在安装路径中选择自己新建的文件夹" class="headerlink" title="在安装路径中选择自己新建的文件夹"></a>在安装路径中选择自己新建的文件夹</h4><p><img src="https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091135132.png" alt="img"></p><blockquote><p>如果出现下图这个情况</p><p><img src="https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091137839.png" alt="img"></p><p>那就运行一下下面的指令 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">chown</span> -R <span class="variable">$USER</span>:<span class="variable">$USER</span> /home/你的用户名/你的IDF文件名/</span><br><span class="line"><span class="built_in">chmod</span> -R 755 /home/你的用户名/你的IDF文件名/</span><br></pre></td></tr></table></figure></blockquote><h4 id="安装完成之后先搞个工程测试一下编译能不能正常"><a href="#安装完成之后先搞个工程测试一下编译能不能正常" class="headerlink" title="安装完成之后先搞个工程测试一下编译能不能正常"></a>安装完成之后先搞个工程测试一下编译能不能正常</h4><p><img src="https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091140479.png" alt="img"></p><h4 id="选择文件夹来存放代码"><a href="#选择文件夹来存放代码" class="headerlink" title="选择文件夹来存放代码"></a>选择文件夹来存放代码</h4><p><img src="https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091143918.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091143292.png" alt="img"></p><h4 id="设置环境"><a href="#设置环境" class="headerlink" title="设置环境"></a>设置环境</h4><h5 id="设置IDF-tools环境（豆包四条命令搞定）"><a href="#设置IDF-tools环境（豆包四条命令搞定）" class="headerlink" title="设置IDF_tools环境（豆包四条命令搞定）"></a>设置IDF_tools环境（豆包四条命令搞定）</h5><blockquote><p>注意下方命令中：</p><p><code>~/ESP_IDF/v5.5.1/esp-idf</code>：你的IDF文件夹路径 要一直引入到<code>esp-idf</code></p><p><code>~/ESP_IDF/Tools</code>：你的IDF_Tools文件夹路径</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export IDF_PATH=~/ESP_IDF/v5.5.1/esp-idf&#x27;</span> &gt;&gt; ~/.bashrc</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export IDF_TOOLS_PATH=~/ESP_IDF/Tools&#x27;</span> &gt;&gt; ~/.bashrc</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;source ~/ESP_IDF/v5.5.1/esp-idf/export.sh&#x27;</span> &gt;&gt; ~/.bashrc</span><br><span class="line"><span class="built_in">source</span> ~/.bashrc  <span class="comment"># 立即生效</span></span><br></pre></td></tr></table></figure><blockquote><p>成功的话 重启<code>vscode</code>就会自动出现<code>idf</code>的命令</p><p><img src="https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509092218229.png" alt="image-20250909221836025"></p></blockquote><h5 id="若上面还不行-则根据报错情况执行下面"><a href="#若上面还不行-则根据报错情况执行下面" class="headerlink" title="若上面还不行 则根据报错情况执行下面"></a>若上面还不行 则根据报错情况执行下面</h5><h6 id="场景-1：运行-export-sh-时报-“Python-虚拟环境不存在”"><a href="#场景-1：运行-export-sh-时报-“Python-虚拟环境不存在”" class="headerlink" title="场景 1：运行 ./export.sh 时报 “Python 虚拟环境不存在”"></a>场景 1：运行 <code>./export.sh</code> 时报 “Python 虚拟环境不存在”</h6><p><code>报错信息</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ERROR: ESP-IDF Python virtual environment <span class="string">&quot;<span class="variable">$HOME</span>/ESP_IDF/Tools/python_env/idf5.5_py3.12_env/bin/python&quot;</span> not found. Please run the install script to <span class="built_in">set</span> it up before proceeding.</span><br></pre></td></tr></table></figure><p><code>原因</code></p><p>未执行 ESP-IDF 安装脚本，Python 虚拟环境未创建。</p><p><code>解决方案</code></p><p>必须先运行安装脚本，自动创建虚拟环境和安装依赖：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入 ESP-IDF 根目录（替换为你的实际路径）</span></span><br><span class="line"><span class="built_in">cd</span> ~/ESP_IDF/v5.5.1/esp-idf</span><br><span class="line"><span class="comment"># 执行安装脚本（Linux/macOS 用 install.sh，Windows 用 install.bat）</span></span><br><span class="line">./install.sh</span><br><span class="line"><span class="comment"># 安装完成后再执行 export.sh 导出环境</span></span><br><span class="line">. ./export.sh</span><br></pre></td></tr></table></figure><h6 id="场景-2：运行-install-sh-时-“下载工具包卡住”"><a href="#场景-2：运行-install-sh-时-“下载工具包卡住”" class="headerlink" title="场景 2：运行 ./install.sh 时 “下载工具包卡住”"></a>场景 2：运行 <code>./install.sh</code> 时 “下载工具包卡住”</h6><p><code>报错表现</code></p><p>安装过程中卡在某一工具包下载（如 <code>riscv32-esp-elf-gdb</code>），进度条不动或反复重试。</p><p><code>原因</code></p><p>ESP-IDF 工具包托管在 GitHub，国内网络访问速度慢或不稳定，导致下载中断。</p><ol><li><p><strong>用国内镜像加速（推荐）</strong><br>配置 <code>IDF_GITHUB_ASSETS</code> 环境变量，将下载源切换为 Espressif 国内镜像，无需手动下载：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 临时生效，每次打开终端需重新执行（或写入 shell 配置文件）</span></span><br><span class="line"><span class="built_in">export</span> IDF_GITHUB_ASSETS=<span class="string">&quot;dl.espressif.com/github_assets&quot;</span></span><br><span class="line"><span class="comment"># 重新运行安装脚本</span></span><br><span class="line">./install.sh</span><br></pre></td></tr></table></figure></li></ol><h4 id="烧录文件"><a href="#烧录文件" class="headerlink" title="烧录文件"></a>烧录文件</h4><h5 id="下载wsl-usb-manager-exe"><a href="#下载wsl-usb-manager-exe" class="headerlink" title="下载wsl-usb-manager.exe"></a>下载wsl-usb-manager.exe</h5><blockquote><p><a href="https://mextra.netlify.app/download/ESP32/wsl-usb-manager.exe">wsl-usb-manager.exe </a></p></blockquote><h5 id="插上ESP32S3"><a href="#插上ESP32S3" class="headerlink" title="插上ESP32S3"></a>插上ESP32S3</h5><p><img src="https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091454477.jpg" alt="059f326e4709ef71f539677c5da784c2"></p><h5 id="配置WSL-USB"><a href="#配置WSL-USB" class="headerlink" title="配置WSL USB"></a>配置WSL USB</h5><h6 id="管理员身份打开Windows-PowerShell"><a href="#管理员身份打开Windows-PowerShell" class="headerlink" title="管理员身份打开Windows PowerShell"></a>管理员身份打开Windows PowerShell</h6><blockquote><p>输入<code>winget install usbipd</code>，然后输入<code>y</code>（<code>看情况选择开不开魔法</code>，不开也能20s左右下载安装完）</p></blockquote><p>这个指令是安装usbipd-win工具，用于将windows系统的usb设备共享给wsl环境。</p><p><img src="https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509092343890.png" alt="img"></p><p>安装好之后 更改权限</p><blockquote><ul><li><p>输入<code>sudo usermod -aG dialout 你的用户名</code></p></li><li><p>然后<code>重启电脑</code></p></li><li><p>输入<code>groups</code>验证一下</p><ul><li>如果输出中包含 <code>dialout</code> 或 <code>uucp</code>，则表示设置成功，之后就可以正常访问串口了。</li></ul></li></ul></blockquote><h5 id="进入WSL-USB选择端口并烧录"><a href="#进入WSL-USB选择端口并烧录" class="headerlink" title="进入WSL USB选择端口并烧录"></a>进入WSL USB选择端口并烧录</h5><p><img src="https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091457549.png" alt="image-20250909145724459"></p><p><img src="https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091500732.png" alt="image-20250909150034639"></p><p>以上环境参考：<a href="https://blog.csdn.net/QL_SD/article/details/150216599?spm=1001.2014.3001.5502">（二）vscode搭建espidf环境，配置wsl2_wsl 编译idf项目-CSDN博客</a></p><p>感谢<a href="https://blog.csdn.net/QL_SD">QL.ql</a>大博主</p><h2 id="ESP32基础知识"><a href="#ESP32基础知识" class="headerlink" title="ESP32基础知识"></a>ESP32基础知识</h2><p><img src="https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091737219.png" alt="image-20250909173749995"></p><p><img src="https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091738212.png" alt="image-20250909173836126"></p><h3 id="使用命令行创建工程"><a href="#使用命令行创建工程" class="headerlink" title="使用命令行创建工程"></a>使用命令行创建工程</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">idf.py create-project 工程名</span><br></pre></td></tr></table></figure><h4 id="打开vscode-切换到新建的工程"><a href="#打开vscode-切换到新建的工程" class="headerlink" title="打开vscode 切换到新建的工程"></a>打开vscode 切换到新建的工程</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/ESP_Code/刚刚的工程名</span><br><span class="line">code .</span><br><span class="line"></span><br><span class="line">按`ctrl+<span class="built_in">shift</span>+p` 寻找add 添加idf路径</span><br></pre></td></tr></table></figure><blockquote><p>在写代码时候 如果出现宏没定义 则重新设置一下芯片型号 稍等一会就会出现</p><p><img src="https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509101009919.png" alt="image-20250910100948617"></p><p><img src="https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509101026730.png" alt="image-20250910102600612"></p><p>如果想要删除文件夹 则运行以下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line"><span class="built_in">rm</span> -rf 文件夹</span><br></pre></td></tr></table></figure><p>必备头文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;freertos/FreeRTOS.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;freertos/task.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;esp_log.h&quot;</span></span></span><br></pre></td></tr></table></figure></blockquote><h3 id="CMakeList-txt使用说明"><a href="#CMakeList-txt使用说明" class="headerlink" title="CMakeList.txt使用说明"></a>CMakeList.txt使用说明</h3><p>一般CmakeList.txt呈现下面的结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">main</span><br><span class="line">    main.c</span><br><span class="line">    CMakeList.txt</span><br><span class="line">CMakeList.txt</span><br></pre></td></tr></table></figure><h4 id="创建自定义文件夹"><a href="#创建自定义文件夹" class="headerlink" title="创建自定义文件夹"></a>创建自定义文件夹</h4><blockquote><p>如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">components</span><br><span class="line">    led</span><br><span class="line">    led.c</span><br><span class="line">    led.h</span><br><span class="line">    CMakeList.txt</span><br><span class="line">main</span><br><span class="line">    main.c</span><br><span class="line">    CMakeList.txt</span><br></pre></td></tr></table></figure><p>在这个目录下 则<code>components/led</code>文件夹下的<code>CMakeList.txt</code>，可以这么写</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">idf_component_register(SRCS <span class="string">&quot;led.c&quot;</span></span><br><span class="line">                    INCLUDE_DIRS <span class="string">&quot;.&quot;</span></span><br><span class="line">                    REQUIRES esp_driver_gpio</span><br><span class="line">                    )</span><br></pre></td></tr></table></figure><ul><li><p><code>SRCS</code>：<code>.c</code>文件 多个用空格隔开</p></li><li><p><code>INCLUDE_DIRS</code>：文件名 多个同样用空格隔开</p></li><li><p><code>REQUIRES</code>：引入ESP官方的组件库<code>components</code> ，名字为官方<code>idf</code>下的<code>components</code>文件夹下的文件夹名 如此处的<code>esp_driver_gpio</code></p><p><img src="https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509121840992.png" alt="image-20250912184005520"></p></li></ul><p>而若要引用 则<code>main</code>文件夹下的<code>CMakeList.txt</code> 可以这么写</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">idf_component_register(SRCS <span class="string">&quot;main.c&quot;</span> <span class="string">&quot;../components/led/led.c&quot;</span></span><br><span class="line">                    INCLUDE_DIRS <span class="string">&quot;.&quot;</span> <span class="string">&quot;../components&quot;</span>)</span><br></pre></td></tr></table></figure></blockquote><h3 id="FreeRTOS-ESP32-基础API"><a href="#FreeRTOS-ESP32-基础API" class="headerlink" title="FreeRTOS-ESP32 基础API"></a>FreeRTOS-ESP32 基础API</h3><h4 id="任务创建"><a href="#任务创建" class="headerlink" title="任务创建"></a>任务创建</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xTaskCreatePinnedToCore</span><span class="params">(</span></span><br><span class="line"><span class="params">TaskFunction_t pvTaskCode,<span class="comment">//任务函数指针，原型是voidfun(void*param)</span></span></span><br><span class="line"><span class="params"><span class="type">const</span> <span class="type">char</span> *constpcName,<span class="comment">//任务的名称，打印调试可能会有用</span></span></span><br><span class="line"><span class="params"><span class="type">const</span> <span class="type">uint32_t</span> usStackDepth,<span class="comment">//指定的任务堆栈空间大小（字节）</span></span></span><br><span class="line"><span class="params"><span class="type">void</span> *constpvParameters,<span class="comment">//任务参数</span></span></span><br><span class="line"><span class="params">UBaseType_t uxPriority,<span class="comment">//优先级，数字越大，优先级越大，0到(configMAX_PRIORITIES-1) 即0-24</span></span></span><br><span class="line"><span class="params">TaskHandle_t *constpvCreatedTask, <span class="comment">//传回来的任务句柄</span></span></span><br><span class="line"><span class="params"><span class="type">const</span> BaseType_t xCoreID)</span><span class="comment">//分配在哪个内核上运行 ESP32是双核 所以可以选0或1</span></span><br></pre></td></tr></table></figure><blockquote><p>ESP32的任务堆栈空间大小<code>usStackDepth</code>与原生FreeRTOS不一样</p><ul><li>原生FreeRTOS的任务堆栈空间大小单位是<code>字</code>，即目标平台若是32位 则为4个字节</li><li>ESP32的任务堆栈空间大小单位是<code>字节</code>，最小是<code>2048</code></li></ul></blockquote><h4 id="阻塞函数（少用-可替代）"><a href="#阻塞函数（少用-可替代）" class="headerlink" title="阻塞函数（少用 可替代）"></a>阻塞函数（少用 可替代）</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//粗略延时xTicksToDelay个周期 </span></span><br><span class="line"><span class="comment">//使用该函数后 任务进入阻塞 等延时结束且调度到来才会再次运行</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">vTaskDelay</span><span class="params">(<span class="type">const</span> TickType_t xTicksToDelay)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//用于表示精确的解除阻塞时间    </span></span><br><span class="line"><span class="comment">//即使任务的执行时间超过了周期时间，它也能自动调整延迟时间，保证任务的周期性运行</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">vTaskDelayUntil</span><span class="params">(TickType_t *pxPreviousWakeTime,<span class="type">const</span> TickType_t xTimeIncrement)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="打印调试"><a href="#打印调试" class="headerlink" title="打印调试"></a>打印调试</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;freertos/FreeRTOS.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;freertos/task.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;esp_log.h&quot;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">taskA</span><span class="params">(<span class="type">void</span> *param)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ESP_LOGI(<span class="string">&quot;TaskA&quot;</span>, <span class="string">&quot;Hello from Task A%d&quot;</span>, <span class="number">1</span>);<span class="comment">//前面是一个TAG标签，后面是打印内容 他会自动回车换行</span></span><br><span class="line">        vTaskDelay(pdMS_TO_TICKS(<span class="number">500</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">app_main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    xTaskCreatePinnedToCore(taskA, <span class="string">&quot;TaskA&quot;</span>, <span class="number">2048</span>, <span class="literal">NULL</span>, <span class="number">5</span>, <span class="literal">NULL</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>效果如图</p><p><img src="https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509101016442.png" alt="image-20250910101607354"></p><h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><blockquote><p>队列特性：先进先出</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">QueueHandle_t queue_handle = <span class="literal">NULL</span>; <span class="comment">// 创建队列句柄</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 创建一个队列</span></span><br><span class="line"><span class="comment"> * @param uxQueueLength 队列长度</span></span><br><span class="line"><span class="comment"> * @param uxItemSize 每个元素的大小(单位是字节)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">QueueHandle_t <span class="title function_">xQueueCreate</span><span class="params">(UBaseType_t uxQueueLength, UBaseType_t uxItemSize)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 向队列头部发送数据</span></span><br><span class="line"><span class="comment"> * @param xQueue 队列句柄</span></span><br><span class="line"><span class="comment"> * @param pvItemToQueue 要发送的数据的指针</span></span><br><span class="line"><span class="comment"> * @param xTicksToWait 等待的时间(单位是tick)</span></span><br><span class="line"><span class="comment"> * @return 如果在等待时间内发送成功返回pdTRUE，否则返回errQUEUE_FULL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BaseType_t <span class="title function_">xQueueSend</span><span class="params">(QueueHandle_t xQueue, <span class="type">const</span> <span class="type">void</span> *pvItemToQueue, TickType_t xTicksToWait)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 向队列尾部发送数据（新数据放在队尾）</span></span><br><span class="line"><span class="comment"> * @param xQueue 队列句柄</span></span><br><span class="line"><span class="comment"> * @param pvItemToQueue 要发送的数据的指针</span></span><br><span class="line"><span class="comment"> * @param xTicksToWait 等待的时间</span></span><br><span class="line"><span class="comment"> * @return pdTRUE 如果发送成功</span></span><br><span class="line"><span class="comment"> *         errQUEUE_FULL 如果队列已满，发送失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BaseType_t <span class="title function_">xQueueSendToBack</span><span class="params">(QueueHandle_t xQueue, <span class="type">const</span> <span class="type">void</span> *pvItemToQueue, TickType_t xTicksToWait)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 从队列中接收数据</span></span><br><span class="line"><span class="comment"> * @param xQueue 队列句柄</span></span><br><span class="line"><span class="comment"> * @param pvBuffer 用于存储接收数据的缓冲区</span></span><br><span class="line"><span class="comment"> * @param xTicksToWait 等待数据的最大时间，以系统节拍为单位</span></span><br><span class="line"><span class="comment"> * @return pdPASS 表示接收成功，errQUEUE_EMPTY 表示队列为空且等待超时，接收失败。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BaseType_t <span class="title function_">xQueueReceive</span><span class="params">(QueueHandle_t xQueue, <span class="type">void</span> *pvBuffer, TickType_t xTicksToWait)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 该函数在中断中使用，从队列发送数据 这个函数的行为和普通的 xQueueSend 有差异，且不允许阻塞（等待）</span></span><br><span class="line"><span class="comment"> * @param xQueue 队列句柄</span></span><br><span class="line"><span class="comment"> * @param pvItemToQueue 要发送的数据</span></span><br><span class="line"><span class="comment"> * @param pxHigherPriorityTaskWoken 如果发送数据后，有更高优先级的任务被唤醒，则该参数会被置为pdTRUE</span></span><br><span class="line"><span class="comment"> * @return 如果发送成功，返回pdTRUE，否则返回errQUEUE_FULL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BaseType_t <span class="title function_">xQueueSendFromISR</span><span class="params">(QueueHandle_t xQueue, <span class="type">const</span> <span class="type">void</span> *pvItemToQueue, BaseType_t *pxHigherPriorityTaskWoken)</span>;</span><br></pre></td></tr></table></figure><h5 id="调用示例"><a href="#调用示例" class="headerlink" title="调用示例"></a>调用示例</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;freertos/FreeRTOS.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;freertos/task.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;freertos/queue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;esp_log.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">QueueHandle_t queue_handle = <span class="literal">NULL</span>; <span class="comment">// 定义一个队列句柄</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">&#125; <span class="type">queue_date_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">taskA</span><span class="params">(<span class="type">void</span> *param)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 从队列里面接收数据，并打印</span></span><br><span class="line">    <span class="type">queue_date_t</span> data;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (xQueueReceive(queue_handle, &amp;data, <span class="number">100</span>) == pdTRUE) <span class="comment">// 从队列中接收数据，阻塞等待</span></span><br><span class="line">        &#123;</span><br><span class="line">            ESP_LOGI(<span class="string">&quot;re_queue&quot;</span>, <span class="string">&quot;receive queue value:%d&quot;</span>, data.value); <span class="comment">// 前面是一个TAG标签，后面是打印内容 他会自动回车换行</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">taskB</span><span class="params">(<span class="type">void</span> *param)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">queue_date_t</span> data;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;data, <span class="number">0</span>, <span class="keyword">sizeof</span>(data));</span><br><span class="line">    <span class="comment">// 每隔1s向队列里面发送数据</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        xQueueSendToBack(queue_handle, &amp;data, <span class="number">100</span>); <span class="comment">// 向队列中发送数据，阻塞等待</span></span><br><span class="line">        vTaskDelay(pdMS_TO_TICKS(<span class="number">1000</span>));            <span class="comment">// 延时1s</span></span><br><span class="line">        data.value++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">app_main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    queue_handle = xQueueCreate(<span class="number">10</span>, <span class="keyword">sizeof</span>(<span class="type">queue_date_t</span>)); <span class="comment">// 创建一个队列，队列长度为10，每个元素的大小为queue_date_t结构体的大小</span></span><br><span class="line">    xTaskCreatePinnedToCore(taskA, <span class="string">&quot;re_queue&quot;</span>, <span class="number">2048</span>, <span class="literal">NULL</span>, <span class="number">3</span>, <span class="literal">NULL</span>, <span class="number">1</span>);</span><br><span class="line">    xTaskCreatePinnedToCore(taskB, <span class="string">&quot;se_queue&quot;</span>, <span class="number">2048</span>, <span class="literal">NULL</span>, <span class="number">3</span>, <span class="literal">NULL</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><img src="https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509101107988.png" alt="image-20250910110704875"></p></blockquote><h4 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 创建一个二值信号量</span></span><br><span class="line"><span class="comment"> * @return SemaphoreHandle_t 信号量句柄</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">SemaphoreHandle_t <span class="title function_">xSemaphoreCreateBinary</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 创建一个计数信号量</span></span><br><span class="line"><span class="comment"> * @param uxMaxCount 计数信号量的最大值</span></span><br><span class="line"><span class="comment"> * @param uxInitialCount 计数信号量的初始值</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">SemaphoreHandle_t <span class="title function_">xSemaphoreCreateCounting</span><span class="params">(UBaseType_t uxMaxCount, UBaseType_t uxInitialCount)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 创建一个互斥锁</span></span><br><span class="line"><span class="comment"> * @return SemaphoreHandle_t 互斥锁句柄</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">SemaphoreHandle_t <span class="title function_">xSemaphoreCreateMutex</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 取得一个信号量</span></span><br><span class="line"><span class="comment"> * @param xSemaphore 信号量句柄</span></span><br><span class="line"><span class="comment"> * @param xTicksToWait 等待信号量的时间，单位为ticks</span></span><br><span class="line"><span class="comment"> * @return 如果成功取得信号量则返回pdTRUE，否则返回pdFALSE</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BaseType_t <span class="title function_">xSemaphoreTake</span><span class="params">(SemaphoreHandle_t xSemaphore, TickType_t xTicksToWait)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 释放一个信号量</span></span><br><span class="line"><span class="comment"> * @param xSemaphore 信号量句柄</span></span><br><span class="line"><span class="comment"> * @return 如果成功释放信号量则返回pdTRUE，否则返回pdFALSE</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BaseType_t <span class="title function_">xSemaphoreGive</span><span class="params">(SemaphoreHandle_t xSemaphore)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 删除一个信号量</span></span><br><span class="line"><span class="comment"> * @param xSemaphore 要删除的信号量句柄</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">vSemaphoreDelete</span><span class="params">(SemaphoreHandle_t xSemaphore)</span>;</span><br></pre></td></tr></table></figure><h5 id="调用示例-1"><a href="#调用示例-1" class="headerlink" title="调用示例"></a>调用示例</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;freertos/FreeRTOS.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;freertos/task.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;freertos/queue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;freertos/semphr.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;esp_log.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">SemaphoreHandle_t mutex_handle;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">taskA</span><span class="params">(<span class="type">void</span> *param)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        vTaskDelay(pdMS_TO_TICKS(<span class="number">1000</span>));</span><br><span class="line">        xSemaphoreTake(mutex_handle, portMAX_DELAY);</span><br><span class="line">        ESP_LOGI(<span class="string">&quot;TASK_A&quot;</span>, <span class="string">&quot;Task A is running&quot;</span>);</span><br><span class="line"></span><br><span class="line">        xSemaphoreGive(mutex_handle);</span><br><span class="line">        vTaskDelay(pdMS_TO_TICKS(<span class="number">10</span>)); <span class="comment">// 给其他任务机会</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">taskB</span><span class="params">(<span class="type">void</span> *param)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        vTaskDelay(pdMS_TO_TICKS(<span class="number">500</span>));</span><br><span class="line">        xSemaphoreTake(mutex_handle, portMAX_DELAY);</span><br><span class="line">        ESP_LOGI(<span class="string">&quot;TASK_B&quot;</span>, <span class="string">&quot;Task B is running&quot;</span>);</span><br><span class="line"></span><br><span class="line">        xSemaphoreGive(mutex_handle);</span><br><span class="line">        vTaskDelay(pdMS_TO_TICKS(<span class="number">10</span>)); <span class="comment">// 给其他任务机会</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">app_main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    mutex_handle = xSemaphoreCreateMutex();</span><br><span class="line">    xTaskCreatePinnedToCore(taskA, <span class="string">&quot;taskA&quot;</span>, <span class="number">2048</span>, <span class="literal">NULL</span>, <span class="number">6</span>, <span class="literal">NULL</span>, <span class="number">1</span>);</span><br><span class="line">    xTaskCreatePinnedToCore(taskB, <span class="string">&quot;taskB&quot;</span>, <span class="number">2048</span>, <span class="literal">NULL</span>, <span class="number">4</span>, <span class="literal">NULL</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意释放信号量的时候 一般会给个延时 不加的话任务会马上回到<code>while(1)</code>初始的时候 反应出来的现象就是一直是A任务运行</p><p>原因：RTOS任务调度需要时间 并且最少只能是10ms 已测试</p></blockquote><h4 id="事件组"><a href="#事件组" class="headerlink" title="事件组"></a>事件组</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 创建事件组</span></span><br><span class="line"><span class="comment"> * @return EventGroupHandle_t 事件组句柄</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">EventGroupHandle_t <span class="title function_">xEventGroupCreate</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 设置事件位</span></span><br><span class="line"><span class="comment"> * @param xEventGroup 事件组句柄</span></span><br><span class="line"><span class="comment"> * @param uxBitsToSet 要设置的事件位</span></span><br><span class="line"><span class="comment"> * @return 设置后事件组的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">EventBits_t <span class="title function_">xEventGroupSetBits</span><span class="params">(EventGroupHandle_t xEventGroup, <span class="type">const</span> EventBits_t uxBitsToSet)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 事件组等待位函数</span></span><br><span class="line"><span class="comment"> * @param xEventGroup 事件组句柄</span></span><br><span class="line"><span class="comment"> * @param uxBitsToWaitFor 等待的事件位</span></span><br><span class="line"><span class="comment"> * @param xClearOnExit 退出时是否清除事件位 pdTRUE or pdFALSE</span></span><br><span class="line"><span class="comment"> * @param xWaitForAllBits 是否等待所有位 pdTRUE or pdFALSE</span></span><br><span class="line"><span class="comment"> * @param xTicksToWait 等待的最大时间</span></span><br><span class="line"><span class="comment"> * @return 返回实际获得的事件位</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">EventBits_t <span class="title function_">xEventGroupWaitBits</span><span class="params">(<span class="type">const</span> EventGroupHandle_t xEventGroup,</span></span><br><span class="line"><span class="params">                                <span class="type">const</span> EventBits_t uxBitsToWaitFor,</span></span><br><span class="line"><span class="params">                                <span class="type">const</span> BaseType_t xClearOnExit,</span></span><br><span class="line"><span class="params">                                <span class="type">const</span> BaseType_t xWaitForAllBits,</span></span><br><span class="line"><span class="params">                                TickType_t xTicksToWait)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 清除事件组指定事件位</span></span><br><span class="line"><span class="comment"> * @param xEventGroup 事件组句柄</span></span><br><span class="line"><span class="comment"> * @param uxBitsToClear 要清除的事件位</span></span><br><span class="line"><span class="comment"> * @return 清除前的事件组位值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">EventBits_t <span class="title function_">xEventGroupClearBits</span><span class="params">(EventGroupHandle_t xEventGroup, <span class="type">const</span> EventBits_t uxBitsToClear)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 以下使用消息直达机制*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 任务通知函数</span></span><br><span class="line"><span class="comment"> * @param xTaskToNotify 任务句柄</span></span><br><span class="line"><span class="comment"> * @param ulValue 发送的值</span></span><br><span class="line"><span class="comment"> * @param eAction 发送的动作 </span></span><br><span class="line"><span class="comment"> *                eNoAction 不改变任务的通知值(即不更新 会一直发送初始值)</span></span><br><span class="line"><span class="comment"> *                eSetBits 将ulValue的值按位或 到任务的通知值中 </span></span><br><span class="line"><span class="comment"> *                eIncrement 将任务的通知值加1</span></span><br><span class="line"><span class="comment"> *                eSetValueWithOverwrite 将任务的通知值设置为ulValue</span></span><br><span class="line"><span class="comment"> *                eSetValueWithoutOverwrite 如果任务的通知值为0，则将其设置为ulValue，否则不改变任务的通知值</span></span><br><span class="line"><span class="comment"> * @return 如果通知成功返回pdPASS，否则返回errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BaseType_t <span class="title function_">xTaskNotify</span><span class="params">(TaskHandle_t xTaskToNotify,</span></span><br><span class="line"><span class="params">                       <span class="type">uint32_t</span> ulValue,</span></span><br><span class="line"><span class="params">                       eNotifyAction eAction)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 将任务设置为等待接收通知</span></span><br><span class="line"><span class="comment"> * @param ulBitsToClearOnEntry 进入等待前要清除的位</span></span><br><span class="line"><span class="comment"> * @param ulBitsToClearOnExit 退出等待后要清除的位</span></span><br><span class="line"><span class="comment"> * @param pulNotificationValue 指向接收通知值的指针</span></span><br><span class="line"><span class="comment"> * @param xTicksToWait 等待通知的最大时间（以滴答为单位）</span></span><br><span class="line"><span class="comment"> * @return 如果在指定的等待时间内收到通知，则返回pdTRUE；否则返回</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BaseType_t <span class="title function_">xTaskNotifyWait</span><span class="params">(<span class="type">uint32_t</span> ulBitsToClearOnEntry,</span></span><br><span class="line"><span class="params">                           <span class="type">uint32_t</span> ulBitsToClearOnExit,</span></span><br><span class="line"><span class="params">                           <span class="type">uint32_t</span> *pulNotificationValue,</span></span><br><span class="line"><span class="params">                           TickType_t xTicksToWait)</span>;</span><br></pre></td></tr></table></figure><h5 id="调用示例-2"><a href="#调用示例-2" class="headerlink" title="调用示例"></a>调用示例</h5><h6 id="事件组设置"><a href="#事件组设置" class="headerlink" title="事件组设置"></a>事件组设置</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;freertos/FreeRTOS.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;freertos/task.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;freertos/queue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;freertos/semphr.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;freertos/event_groups.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;esp_log.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EVENT_BIT_0 BIT0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EVENT_BIT_1 BIT1</span></span><br><span class="line"></span><br><span class="line">EventGroupHandle_t event_handle;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">taskA</span><span class="params">(<span class="type">void</span> *param)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 定时1s向任务B发送事件消息</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        xEventGroupSetBits(event_handle, EVENT_BIT_0);</span><br><span class="line">        vTaskDelay(pdMS_TO_TICKS(<span class="number">1000</span>));</span><br><span class="line">        xEventGroupSetBits(event_handle, EVENT_BIT_1);</span><br><span class="line">        vTaskDelay(pdMS_TO_TICKS(<span class="number">1000</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">taskB</span><span class="params">(<span class="type">void</span> *param)</span></span><br><span class="line">&#123;</span><br><span class="line">    EventBits_t ev;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ev = xEventGroupWaitBits(event_handle, EVENT_BIT_0 | EVENT_BIT_1, pdTRUE, pdFALSE, pdMS_TO_TICKS(<span class="number">5000</span>));</span><br><span class="line">        <span class="keyword">if</span> (ev &amp; EVENT_BIT_0)</span><br><span class="line">        &#123;</span><br><span class="line">            ESP_LOGI(<span class="string">&quot;ev&quot;</span>, <span class="string">&quot;ev get event0&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ev &amp; EVENT_BIT_1)</span><br><span class="line">        &#123;</span><br><span class="line">            ESP_LOGI(<span class="string">&quot;ev&quot;</span>, <span class="string">&quot;ev get event1&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">app_main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    event_handle = xEventGroupCreate();</span><br><span class="line">    xTaskCreatePinnedToCore(taskA, <span class="string">&quot;taskA&quot;</span>, <span class="number">2048</span>, <span class="literal">NULL</span>, <span class="number">3</span>, <span class="literal">NULL</span>, <span class="number">1</span>);</span><br><span class="line">    xTaskCreatePinnedToCore(taskB, <span class="string">&quot;taskB&quot;</span>, <span class="number">2048</span>, <span class="literal">NULL</span>, <span class="number">3</span>, <span class="literal">NULL</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="消息直达"><a href="#消息直达" class="headerlink" title="消息直达"></a>消息直达</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;freertos/FreeRTOS.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;freertos/task.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;freertos/queue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;freertos/semphr.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;freertos/event_groups.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;esp_log.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> TaskHandle_t taskA_handle;</span><br><span class="line"><span class="type">static</span> TaskHandle_t taskB_handle;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">taskA</span><span class="params">(<span class="type">void</span> *param)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 定时1s向任务B发送事件消息</span></span><br><span class="line">    <span class="type">uint32_t</span> count = <span class="number">0</span>;</span><br><span class="line">    vTaskDelay(pdMS_TO_TICKS(<span class="number">100</span>));</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        xTaskNotify(taskB_handle, count, eSetValueWithoutOverwrite);</span><br><span class="line">        count++;</span><br><span class="line">        vTaskDelay(pdMS_TO_TICKS(<span class="number">1000</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">taskB</span><span class="params">(<span class="type">void</span> *param)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        xTaskNotifyWait(<span class="number">0</span>, <span class="number">0</span>, &amp;count, portMAX_DELAY);</span><br><span class="line">        ESP_LOGI(<span class="string">&quot;taskB&quot;</span>, <span class="string">&quot;Notify count: %lu&quot;</span>, count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">app_main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    xTaskCreatePinnedToCore(taskA, <span class="string">&quot;taskA&quot;</span>, <span class="number">2048</span>, <span class="literal">NULL</span>, <span class="number">3</span>, &amp;taskA_handle, <span class="number">1</span>);</span><br><span class="line">    xTaskCreatePinnedToCore(taskB, <span class="string">&quot;taskB&quot;</span>, <span class="number">2048</span>, <span class="literal">NULL</span>, <span class="number">3</span>, &amp;taskB_handle, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ESP-IDF中的FreeRTOS与原生区别"><a href="#ESP-IDF中的FreeRTOS与原生区别" class="headerlink" title="ESP-IDF中的FreeRTOS与原生区别"></a>ESP-IDF中的FreeRTOS与原生区别</h4><blockquote><ol><li>ESP32是多核的 所以可以完全实现程序并发执行 即不是单核那种 低优先级的任务因为高优先级任务存在而执行不了</li><li>esp-idf自动创建五个任务<ul><li>空闲任务（每个核都会创建一个，<code>优先级为0</code>）</li><li>FreeRTOS定时器任务（<code>优先级为1</code>）</li><li>app_main任务（我们的应用入口，<code>优先级为1</code>）</li><li>IPC任务（每个核创建一个，用于多核协调，<code>优先级为24</code>）</li><li>ESP定时器任务（负责ESP32定时器回调，<code>优先级为22</code>）</li></ul></li><li>esp-idf不使用原生FreeRTOS的内存堆管理，实现了自己的堆</li><li>创建任务使用<code>xTaskCreatePinnedToCore()</code> 可以指定用哪个核创建任务<ul><li>负责处理<code>无线网络的任务（如WiFi蓝牙）</code>将被固定到<code>CPU0</code>，即<code>PRO_CPU</code></li><li>处理<code>应用程序</code>其余部分任务将被固定到<code>CPU1</code>，即<code>APP_CPU</code></li></ul></li><li>如果任务中用到浮点运算，则创建任务的时候必须指定具体运行在哪个核上，不能由系统自动安排</li></ol></blockquote><h2 id="GPIO配置"><a href="#GPIO配置" class="headerlink" title="GPIO配置"></a>GPIO配置</h2><h3 id="引脚基础配置"><a href="#引脚基础配置" class="headerlink" title="引脚基础配置"></a>引脚基础配置</h3><h4 id="gpio-config-：批量配置-GPIO（核心入口）"><a href="#gpio-config-：批量配置-GPIO（核心入口）" class="headerlink" title="gpio_config()：批量配置 GPIO（核心入口）"></a><code>gpio_config()</code>：批量配置 GPIO（核心入口）</h4><ul><li><p><strong>函数原型</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">esp_err_t</span> <span class="title function_">gpio_config</span><span class="params">(<span class="type">const</span> <span class="type">gpio_config_t</span> *pGPIOConfig)</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>作用</strong>：一次性配置一组 GPIO 的模式、上下拉、中断类型（覆盖该引脚当前所有配置）。</p></li><li><p><strong>参数</strong>：<code>pGPIOConfig</code>：指向 <code>gpio_config_t</code> 结构体的指针（需提前初始化）。</p></li><li><p><strong>返回值</strong>：<code>ESP_OK</code>（成功）、<code>ESP_ERR_INVALID_ARG</code>（参数错误，如引脚无效）。</p></li><li><p><strong>示例</strong>：配置 GPIO2、GPIO3 为输出模式，禁用上下拉和中断：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">gpio_config_t</span> io_conf = &#123;</span><br><span class="line">    .pin_bit_mask = (<span class="number">1ULL</span> &lt;&lt; GPIO_NUM_2) | (<span class="number">1ULL</span> &lt;&lt; GPIO_NUM_3),  <span class="comment">// 仅配置 GPIO2</span></span><br><span class="line">    .mode = GPIO_MODE_OUTPUT,</span><br><span class="line">    .pull_up_en = GPIO_PULLUP_DISABLE,</span><br><span class="line">    .pull_down_en = GPIO_PULLDOWN_DISABLE,</span><br><span class="line">    .intr_type = GPIO_INTR_DISABLE</span><br><span class="line">&#125;;</span><br><span class="line">gpio_config(&amp;io_conf);  <span class="comment">// 执行配置</span></span><br></pre></td></tr></table></figure></li></ul><blockquote><p><code>intr_type</code> :</p><ul><li><code>GPIO_INTR_DISABLE</code>：禁用中断</li><li><code>GPIO_INTR_POSEDGE</code>：上升沿触发</li><li><code>GPIO_INTR_NEGEDGE</code>：下降沿触发</li><li><code>GPIO_INTR_ANYEDGE</code>：双边沿触发</li><li><code>GPIO_INTR_LOW_LEVEL</code>：低电平触发</li><li><code>GPIO_INTR_HIGH_LEVEL</code>：高电平触发</li></ul></blockquote><h4 id="gpio-reset-pin-：重置引脚为默认状态"><a href="#gpio-reset-pin-：重置引脚为默认状态" class="headerlink" title="gpio_reset_pin()：重置引脚为默认状态"></a><code>gpio_reset_pin()</code>：重置引脚为默认状态</h4><ul><li><p><strong>函数原型</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">esp_err_t</span> <span class="title function_">gpio_reset_pin</span><span class="params">(<span class="type">gpio_num_t</span> gpio_num)</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>作用</strong>：将指定 GPIO 重置为默认状态（输入模式、禁用上下拉、禁用中断、选择 GPIO 功能）。</p></li><li><p><strong>参数</strong>：<code>gpio_num</code>：要重置的 GPIO 编号（如 <code>GPIO_NUM_4</code>）。</p></li><li><p><strong>示例</strong>：重置 GPIO4，恢复初始状态：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpio_reset_pin(GPIO_NUM_4);</span><br></pre></td></tr></table></figure></li></ul><h4 id="gpio-set-direction-：单独设置引脚方向"><a href="#gpio-set-direction-：单独设置引脚方向" class="headerlink" title="gpio_set_direction()：单独设置引脚方向"></a><code>gpio_set_direction()</code>：单独设置引脚方向</h4><ul><li><p><strong>函数原型</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">esp_err_t</span> <span class="title function_">gpio_set_direction</span><span class="params">(<span class="type">gpio_num_t</span> gpio_num, <span class="type">gpio_mode_t</span> mode)</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>作用</strong>：单独修改某个 GPIO 的模式（输入 &#x2F; 输出 &#x2F; 输入输出），覆盖当前模式。</p></li><li><p><strong>参数</strong></p><ul><li><code>gpio_num</code>：目标 GPIO 编号。</li><li><code>mode</code>：目标模式（如 <code>GPIO_MODE_INPUT</code>）。</li></ul></li><li><p><strong>示例</strong>：将已配置的 GPIO2 改为输入模式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpio_set_direction(GPIO_NUM_2, GPIO_MODE_INPUT);</span><br></pre></td></tr></table></figure></li></ul><h4 id="配置上下拉函数（gpio-pullup-en-gpio-pulldown-en）"><a href="#配置上下拉函数（gpio-pullup-en-gpio-pulldown-en）" class="headerlink" title="配置上下拉函数（gpio_pullup_en&#x2F;gpio_pulldown_en）"></a>配置上下拉函数（<code>gpio_pullup_en</code>&#x2F;<code>gpio_pulldown_en</code>）</h4><ul><li><p><strong>函数原型</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">esp_err_t</span> <span class="title function_">gpio_pullup_en</span><span class="params">(<span class="type">gpio_num_t</span> gpio_num)</span>;    <span class="comment">// 启用上拉</span></span><br><span class="line"><span class="type">esp_err_t</span> <span class="title function_">gpio_pullup_dis</span><span class="params">(<span class="type">gpio_num_t</span> gpio_num)</span>;   <span class="comment">// 禁用上拉</span></span><br><span class="line"><span class="type">esp_err_t</span> <span class="title function_">gpio_pulldown_en</span><span class="params">(<span class="type">gpio_num_t</span> gpio_num)</span>;  <span class="comment">// 启用下拉</span></span><br><span class="line"><span class="type">esp_err_t</span> <span class="title function_">gpio_pulldown_dis</span><span class="params">(<span class="type">gpio_num_t</span> gpio_num)</span>; <span class="comment">// 禁用下拉</span></span><br></pre></td></tr></table></figure></li><li><p><strong>作用</strong>：比 <code>gpio_set_pull_mode</code> 更直观，单独控制上拉 &#x2F; 下拉的启用 &#x2F; 禁用。</p></li><li><p><strong>示例</strong>：启用 GPIO0 下拉，禁用上拉：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gpio_pulldown_en(GPIO_NUM_0);</span><br><span class="line">gpio_pullup_dis(GPIO_NUM_0);</span><br></pre></td></tr></table></figure></li></ul><h3 id="引脚电平控制函数"><a href="#引脚电平控制函数" class="headerlink" title="引脚电平控制函数"></a>引脚电平控制函数</h3><h4 id="gpio-set-level-：设置输出电平"><a href="#gpio-set-level-：设置输出电平" class="headerlink" title="gpio_set_level()：设置输出电平"></a><code>gpio_set_level()</code>：设置输出电平</h4><ul><li><p><strong>函数原型</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">esp_err_t</span> <span class="title function_">gpio_set_level</span><span class="params">(<span class="type">gpio_num_t</span> gpio_num, <span class="type">uint32_t</span> level)</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>作用</strong>：给输出模式的 GPIO 设置高 &#x2F; 低电平（仅输出模式有效）。</p></li><li><p><strong>参数</strong>：</p><ul><li><code>level</code>：<code>0</code>（低电平）、<code>1</code>（高电平）。</li></ul></li></ul><h4 id="gpio-get-level-：读取输入电平"><a href="#gpio-get-level-：读取输入电平" class="headerlink" title="gpio_get_level()：读取输入电平"></a><code>gpio_get_level()</code>：读取输入电平</h4><ul><li><p><strong>函数原型</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">gpio_get_level</span><span class="params">(<span class="type">gpio_num_t</span> gpio_num)</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>作用</strong>：读取 GPIO 的当前输入电平（需引脚为输入 &#x2F; 输入输出模式，否则返回 0）。</p></li><li><p><strong>返回值</strong>：<code>0</code>（低电平）、<code>1</code>（高电平）。</p></li></ul><h2 id="LEDC库学习笔记"><a href="#LEDC库学习笔记" class="headerlink" title="LEDC库学习笔记"></a>LEDC库学习笔记</h2><blockquote><p><strong>定义</strong>：LEDC（Light Emitting Diode Controller）是 ESP32 内置的 LED 控制器，核心功能是生成 PWM（脉冲宽度调制）信号，不仅用于 LED 亮度调节，还可驱动电机、舵机等需 PWM 信号的设备。</p><p><strong>核心优势</strong>：无需手动编写定时器中断逻辑，ESP-IDF 提供完整库接口，配置简单、信号稳定</p><p><strong>注意</strong>：LEDC 控制器有自己<code>专属的 4 个定时器</code>（<code>LEDC_TIMER_0</code> ~ <code>LEDC_TIMER_3</code>），这些定时器是 LEDC 模块内部集成的，专门用于生成 PWM 信号。</p><p>与<code>通用定时器（TIMER_0 ~ TIMER_3）</code>完全分离</p></blockquote><h3 id="LEDC关键概念"><a href="#LEDC关键概念" class="headerlink" title="LEDC关键概念"></a>LEDC关键概念</h3><table><thead><tr><th>概念</th><th>说明</th></tr></thead><tbody><tr><td>通道（Channel）</td><td>ESP32 有 16 个独立通道，每个通道可独立配置 PWM 参数（频率、占空比），并映射到 1 个 GPIO 引脚输出信号。</td></tr><tr><td>定时器（Timer）</td><td>每个通道需绑定定时器，定时器决定 PWM 频率（由预分频和计数范围计算），多个通道可共享同一定时器（频率相同）。</td></tr><tr><td>频率（Frequency）</td><td>PWM 信号周期的倒数（单位：Hz），如 50Hz（舵机常用，对应 20ms 周期）、1000Hz（LED 常用，避免人眼闪烁）。</td></tr><tr><td>占空比（Duty Cycle）</td><td>PWM 高电平持续时间与周期的比值（0<del>100%），LEDC 中用数值表示（如 12 位分辨率对应 0</del>4095）。</td></tr><tr><td>分辨率（Duty Resolution）</td><td>占空比的可调精度，范围 <code>LEDC_TIMER_1_BIT</code><del><code>LEDC_TIMER_20_BIT</code>，如 12 位表示占空比可设为 0</del>4095（共 4096 级）。</td></tr><tr><td>速度模式</td><td>分 <code>LEDC_LOW_SPEED_MODE</code>（低速模式）和 <code>LEDC_HIGH_SPEED_MODE</code>（高速模式），高速模式支持更高 PWM 频率。</td></tr></tbody></table><h3 id="常用API（需包含头文件-driver-ledc-h）"><a href="#常用API（需包含头文件-driver-ledc-h）" class="headerlink" title="常用API（需包含头文件 driver/ledc.h）"></a>常用API（需包含头文件 <code>driver/ledc.h</code>）</h3><h4 id="定时器初始化"><a href="#定时器初始化" class="headerlink" title="定时器初始化"></a>定时器初始化</h4><ul><li><p><strong>作用</strong>：初始化 LEDC 定时器，设置频率、分辨率等核心参数。</p></li><li><p>函数原型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">esp_err_t</span> <span class="title function_">ledc_timer_config</span><span class="params">(<span class="type">const</span> <span class="type">ledc_timer_config_t</span> *timer_conf)</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>参数结构体 <code>ledc_timer_config_t</code> 说明</strong>：</p><table><thead><tr><th>参数</th><th>取值 &#x2F; 说明</th></tr></thead><tbody><tr><td><code>speed_mode</code></td><td>速度模式：<code>LEDC_LOW_SPEED_MODE</code> 或 <code>LEDC_HIGH_SPEED_MODE</code></td></tr><tr><td><code>duty_resolution</code></td><td>占空比分辨率：<code>LEDC_TIMER_1_BIT</code> ~ <code>LEDC_TIMER_20_BIT</code>（如 12 位选 <code>LEDC_TIMER_12_BIT</code>）</td></tr><tr><td><code>timer_num</code></td><td>定时器编号：<code>LEDC_TIMER_0</code> ~ <code>LEDC_TIMER_3</code>（共 4 个定时器）</td></tr><tr><td><code>freq_hz</code></td><td>PWM 频率（如 50、1000，单位：Hz）</td></tr><tr><td><code>clk_cfg</code></td><td>时钟源：通常用 <code>LEDC_AUTO_CLK</code>（自动选择最优时钟）</td></tr></tbody></table></li><li><p><strong>示例</strong>：配置 1000Hz、12 位分辨率的定时器 0（低速模式）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ledc_timer_config_t</span> timer_conf = &#123;</span><br><span class="line">    .speed_mode = LEDC_LOW_SPEED_MODE,</span><br><span class="line">    .duty_resolution = LEDC_TIMER_12_BIT,  <span class="comment">// 0~4095 级占空比</span></span><br><span class="line">    .timer_num = LEDC_TIMER_0,</span><br><span class="line">    .freq_hz = <span class="number">1000</span>,                       <span class="comment">// 1000Hz 频率</span></span><br><span class="line">    .clk_cfg = LEDC_AUTO_CLK</span><br><span class="line">&#125;;</span><br><span class="line">ledc_timer_config(&amp;timer_conf);  <span class="comment">// 执行配置</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="通道配置：ledc-channel-config"><a href="#通道配置：ledc-channel-config" class="headerlink" title="通道配置：ledc_channel_config()"></a>通道配置：<code>ledc_channel_config()</code></h4><h4 id="通道配置：ledc-channel-config-1"><a href="#通道配置：ledc-channel-config-1" class="headerlink" title="通道配置：ledc_channel_config()"></a>通道配置：<code>ledc_channel_config()</code></h4><ul><li><p><strong>作用</strong>：将 LEDC 通道绑定到定时器和 GPIO 引脚，设置初始占空比。</p></li><li><p><strong>函数原型</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">esp_err_t</span> <span class="title function_">ledc_channel_config</span><span class="params">(<span class="type">const</span> <span class="type">ledc_channel_config_t</span> *channel_conf)</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>参数结构体</strong> <code>ledc_channel_config_t</code> <strong>说明</strong></p><table><thead><tr><th>参数</th><th>取值 &#x2F; 说明</th></tr></thead><tbody><tr><td><code>speed_mode</code></td><td>需与绑定的定时器速度模式一致（如 <code>LEDC_LOW_SPEED_MODE</code>）</td></tr><tr><td><code>channel</code></td><td>通道编号：<code>LEDC_CHANNEL_0</code> ~ <code>LEDC_CHANNEL_15</code>（共 16 个通道）</td></tr><tr><td><code>timer_sel</code></td><td>绑定的定时器编号（如 <code>LEDC_TIMER_0</code>）</td></tr><tr><td><code>intr_type</code></td><td>中断类型：通常设 <code>LEDC_INTR_DISABLE</code>（禁用中断）</td></tr><tr><td><code>gpio_num</code></td><td>输出 PWM 的 GPIO 引脚（如 <code>GPIO_NUM_2</code>、<code>GPIO_NUM_4</code>）</td></tr><tr><td><code>duty</code></td><td>初始占空比（0 ~ 分辨率最大值，如 12 位初始为 0 表示 LED 灭）</td></tr><tr><td><code>hpoint</code></td><td>脉冲起点偏移：通常设 0（无偏移）</td></tr></tbody></table></li><li><p>示例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ledc_channel_config_t</span> channel_conf = &#123;</span><br><span class="line">    .speed_mode = LEDC_LOW_SPEED_MODE,</span><br><span class="line">    .channel = LEDC_CHANNEL_0,</span><br><span class="line">    .timer_sel = LEDC_TIMER_0,  <span class="comment">// 绑定定时器 0</span></span><br><span class="line">    .intr_type = LEDC_INTR_DISABLE,</span><br><span class="line">    .gpio_num = GPIO_NUM_2,     <span class="comment">// GPIO2 输出 PWM</span></span><br><span class="line">    .duty = <span class="number">0</span>,                  <span class="comment">// 初始占空比 0（LED 不亮）</span></span><br><span class="line">    .hpoint = <span class="number">0</span></span><br><span class="line">&#125;;</span><br><span class="line">ledc_channel_config(&amp;channel_conf);  <span class="comment">// 执行配置</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="3-占空比修改：ledc-set-duty-ledc-update-duty"><a href="#3-占空比修改：ledc-set-duty-ledc-update-duty" class="headerlink" title="3. 占空比修改：ledc_set_duty() + ledc_update_duty()"></a>3. 占空比修改：<code>ledc_set_duty()</code> + <code>ledc_update_duty()</code></h4><ul><li><p><strong>作用</strong>：动态调整通道的 PWM 占空比（<code>ledc_set_duty</code> 仅修改寄存器，<code>ledc_update_duty</code> 使修改生效）。</p></li><li><p><strong>函数原型</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 设置占空比（不立即生效）</span></span><br><span class="line"><span class="type">esp_err_t</span> <span class="title function_">ledc_set_duty</span><span class="params">(<span class="type">ledc_mode_t</span> speed_mode, <span class="type">ledc_channel_t</span> channel, <span class="type">uint32_t</span> duty)</span>;</span><br><span class="line"><span class="comment">// 2. 使占空比生效</span></span><br><span class="line"><span class="type">esp_err_t</span> <span class="title function_">ledc_update_duty</span><span class="params">(<span class="type">ledc_mode_t</span> speed_mode, <span class="type">ledc_channel_t</span> channel)</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>参数说明</strong></p><ul><li><code>speed_mode</code>：速度模式（与通道一致）</li><li><code>channel</code>：目标通道编号</li><li><code>duty</code>：目标占空比（0 ~ 分辨率最大值）</li></ul></li><li><p><strong>示例</strong>：将通道 0 占空比设为 50%（12 位分辨率对应 2048）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 12 位分辨率下，50% 占空比 = 4096 / 2 = 2048</span></span><br><span class="line">ledc_set_duty(LEDC_LOW_SPEED_MODE, LEDC_CHANNEL_0, <span class="number">2048</span>);</span><br><span class="line">ledc_update_duty(LEDC_LOW_SPEED_MODE, LEDC_CHANNEL_0);  <span class="comment">// 占空比生效</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="4-硬件渐变：ledc-fade-系列函数"><a href="#4-硬件渐变：ledc-fade-系列函数" class="headerlink" title="4. 硬件渐变：ledc_fade_* 系列函数"></a>4. 硬件渐变：<code>ledc_fade_*</code> 系列函数</h4><ul><li><p><strong>作用</strong>：实现硬件自动渐变（无需软件循环），适合 LED 呼吸灯、平滑调光等场景。</p></li><li><p><strong>核心函数</strong>：</p><table><thead><tr><th>函数</th><th>作用</th></tr></thead><tbody><tr><td><code>ledc_fade_func_install()</code></td><td>初始化渐变功能（需开启中断，参数 0 表示不使用中断回调）</td></tr><tr><td><code>ledc_set_fade_with_time()</code></td><td>配置渐变参数（目标占空比、渐变时间）</td></tr><tr><td><code>ledc_fade_start()</code></td><td>启动渐变（可选择阻塞 &#x2F; 非阻塞模式）</td></tr><tr><td><code>ledc_cb_register()</code></td><td>注册 LEDC 回调函数</td></tr></tbody></table></li><li><p><strong>函数原型</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 初始化渐变功能</span></span><br><span class="line"><span class="type">esp_err_t</span> <span class="title function_">ledc_fade_func_install</span><span class="params">(<span class="type">int</span> intr_alloc_flags)</span>;</span><br><span class="line"><span class="comment">// 2. 配置渐变：在指定时间内从当前占空比渐变到目标占空比</span></span><br><span class="line"><span class="type">esp_err_t</span> <span class="title function_">ledc_set_fade_with_time</span><span class="params">(<span class="type">ledc_mode_t</span> speed_mode, <span class="type">ledc_channel_t</span> channel, <span class="type">uint32_t</span> target_duty, <span class="type">uint32_t</span> fade_time_ms)</span>;</span><br><span class="line"><span class="comment">// 3. 启动渐变</span></span><br><span class="line"><span class="type">esp_err_t</span> <span class="title function_">ledc_fade_start</span><span class="params">(<span class="type">ledc_mode_t</span> speed_mode, <span class="type">ledc_channel_t</span> channel, <span class="type">ledc_fade_mode_t</span> fade_mode)</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>参数说明</strong>：</p><ul><li><code>intr_alloc_flags</code>：中断分配标志（设 0 即可）</li><li><code>target_duty</code>：渐变目标占空比</li><li><code>fade_time_ms</code>：渐变总时间（单位：ms）</li><li><code>fade_mode</code>：渐变模式：<code>LEDC_FADE_WAIT_DONE</code>（阻塞，等待渐变完成返回）&#x2F; <code>LEDC_FADE_NO_WAIT</code>（非阻塞）</li></ul></li><li><p><strong>示例</strong>：2 秒内从当前占空比渐变到最大亮度（12 位对应 4095）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 初始化渐变功能</span></span><br><span class="line">ledc_fade_func_install(<span class="number">0</span>);  <span class="comment">// 不使用中断回调</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 配置渐变：2000ms（2秒）内渐变到 4095（最大亮度）</span></span><br><span class="line">ledc_set_fade_with_time(LEDC_LOW_SPEED_MODE, </span><br><span class="line">                        LEDC_CHANNEL_0, </span><br><span class="line">                        <span class="number">4095</span>,        <span class="comment">// 目标占空比（最大）</span></span><br><span class="line">                        <span class="number">2000</span>);       <span class="comment">// 渐变时间（ms）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 启动渐变（阻塞模式，等待渐变完成后再执行后续代码）</span></span><br><span class="line">ledc_fade_start(LEDC_LOW_SPEED_MODE, LEDC_CHANNEL_0, LEDC_FADE_WAIT_DONE);</span><br></pre></td></tr></table></figure></li></ul><h5 id="启用中断模式"><a href="#启用中断模式" class="headerlink" title="启用中断模式"></a>启用中断模式</h5><ul><li><p><strong>函数原型</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">esp_err_t</span> <span class="title function_">ledc_cb_register</span><span class="params">(<span class="type">ledc_mode_t</span> speed_mode, <span class="type">ledc_channel_t</span> channel, <span class="type">ledc_cbs_t</span> *cbs, <span class="type">void</span> *user_arg)</span></span><br></pre></td></tr></table></figure></li><li><p><strong>参数结构体</strong> <code>ledc_cbs_t</code> <strong>说明</strong></p><ul><li><code>fade_cb</code>：需要注册的中断回调函数</li></ul></li><li><p><strong>示例</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;freertos/FreeRTOS.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;freertos/task.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;driver/gpio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;driver/ledc.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_GPIO GPIO_NUM_18</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FULL_EV_BIT BIT0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EMPTY_EV_BIT BIT1</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> EventGroupHandle_t led_fade_handle;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 重写LEDC完成回调函数</span></span><br><span class="line"><span class="comment"> * @note IRAM_ATTR 修饰符表示该函数在IRAM中执行，中断服务程序中不能调用RAM中的函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">bool</span> IRAM_ATTR <span class="title function_">ledc_finish_cb</span><span class="params">(<span class="type">const</span> <span class="type">ledc_cb_param_t</span> *param, <span class="type">void</span> *user_arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    BaseType_t taskWoken;</span><br><span class="line">    <span class="keyword">if</span> (param-&gt;duty)</span><br><span class="line">    &#123;</span><br><span class="line">        xEventGroupSetBitsFromISR(led_fade_handle, FULL_EV_BIT, &amp;taskWoken);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        xEventGroupSetBitsFromISR(led_fade_handle, EMPTY_EV_BIT, &amp;taskWoken);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> taskWoken;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">led_run_task</span><span class="params">(<span class="type">void</span> *param)</span></span><br><span class="line">&#123;</span><br><span class="line">    EventBits_t ev;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ev = xEventGroupWaitBits(led_fade_handle, FULL_EV_BIT | EMPTY_EV_BIT, pdTRUE, pdFALSE, pdMS_TO_TICKS(<span class="number">5000</span>));</span><br><span class="line">        <span class="keyword">if</span> (ev &amp; FULL_EV_BIT)</span><br><span class="line">        &#123;</span><br><span class="line">            ledc_set_fade_with_time(LEDC_LOW_SPEED_MODE, LEDC_CHANNEL_0, <span class="number">0</span>, <span class="number">2000</span>);</span><br><span class="line">            ledc_fade_start(LEDC_LOW_SPEED_MODE, LEDC_CHANNEL_0, LEDC_FADE_NO_WAIT);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ev &amp; EMPTY_EV_BIT)</span><br><span class="line">        &#123;</span><br><span class="line">            ledc_set_fade_with_time(LEDC_LOW_SPEED_MODE, LEDC_CHANNEL_0, <span class="number">8191</span>, <span class="number">2000</span>);</span><br><span class="line">            ledc_fade_start(LEDC_LOW_SPEED_MODE, LEDC_CHANNEL_0, LEDC_FADE_NO_WAIT);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">ledc_cbs_t</span> ledc_cbs = &#123;</span><br><span class="line">            .fade_cb = ledc_finish_cb,</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        ledc_cb_register(LEDC_LOW_SPEED_MODE, LEDC_CHANNEL_0, &amp;ledc_cbs, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">app_main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// gpio_config_t led_cfg = &#123;</span></span><br><span class="line">    <span class="comment">//     .pin_bit_mask = (1 &lt;&lt; LED_GPIO),</span></span><br><span class="line">    <span class="comment">//     .pull_down_en = GPIO_PULLDOWN_DISABLE,</span></span><br><span class="line">    <span class="comment">//     .pull_up_en = GPIO_PULLUP_DISABLE,</span></span><br><span class="line">    <span class="comment">//     .intr_type = GPIO_INTR_DISABLE,</span></span><br><span class="line">    <span class="comment">//     .mode = GPIO_MODE_OUTPUT,</span></span><br><span class="line">    <span class="comment">// &#125;;</span></span><br><span class="line">    <span class="comment">// gpio_config(&amp;led_cfg);</span></span><br><span class="line"></span><br><span class="line">    <span class="type">ledc_timer_config_t</span> ledc_timer = &#123;</span><br><span class="line">        .speed_mode = LEDC_LOW_SPEED_MODE,</span><br><span class="line">        .timer_num = LEDC_TIMER_0,</span><br><span class="line">        .clk_cfg = LEDC_AUTO_CLK,</span><br><span class="line">        .freq_hz = <span class="number">5000</span>,</span><br><span class="line">        .duty_resolution = LEDC_TIMER_13_BIT, <span class="comment">// 占空比分辨率 0-8191</span></span><br><span class="line">    &#125;;</span><br><span class="line">    ledc_timer_config(&amp;ledc_timer);</span><br><span class="line"></span><br><span class="line">    <span class="type">ledc_channel_config_t</span> ledc_channel = &#123;</span><br><span class="line">        .gpio_num = LED_GPIO,</span><br><span class="line">        .channel = LEDC_CHANNEL_0,</span><br><span class="line">        .duty = <span class="number">0</span>,</span><br><span class="line">        .speed_mode = LEDC_LOW_SPEED_MODE,</span><br><span class="line">        .timer_sel = LEDC_TIMER_0,</span><br><span class="line">        .intr_type = LEDC_INTR_DISABLE,</span><br><span class="line">    &#125;;</span><br><span class="line">    ledc_channel_config(&amp;ledc_channel);</span><br><span class="line"></span><br><span class="line">    ledc_fade_func_install(<span class="number">0</span>); <span class="comment">// 使能渐变 不需要自己手动调节占空比</span></span><br><span class="line">    ledc_set_fade_with_time(LEDC_LOW_SPEED_MODE, LEDC_CHANNEL_0, <span class="number">8191</span>, <span class="number">2000</span>);</span><br><span class="line">    ledc_fade_start(LEDC_LOW_SPEED_MODE, LEDC_CHANNEL_0, LEDC_FADE_NO_WAIT);</span><br><span class="line"></span><br><span class="line">    led_fade_handle = xEventGroupCreate();</span><br><span class="line"></span><br><span class="line">    <span class="type">ledc_cbs_t</span> ledc_cbs = &#123;</span><br><span class="line">        .fade_cb = ledc_finish_cb,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    ledc_cb_register(LEDC_LOW_SPEED_MODE, LEDC_CHANNEL_0, &amp;ledc_cbs, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    xTaskCreatePinnedToCore(led_run_task, <span class="string">&quot;led_run_task&quot;</span>, <span class="number">2048</span>, <span class="literal">NULL</span>, <span class="number">3</span>, <span class="literal">NULL</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="UART配置"><a href="#UART配置" class="headerlink" title="UART配置"></a>UART配置</h2><h3 id="ESP32-UART-硬件特性"><a href="#ESP32-UART-硬件特性" class="headerlink" title="ESP32 UART 硬件特性"></a>ESP32 UART 硬件特性</h3><ul><li><strong>硬件资源</strong>：ESP32 内置 3 个 UART 接口（UART0、UART1、UART2），支持不同引脚映射</li><li><strong>通信参数</strong>：可配置波特率（1200 ~ 5000000bps）、数据位（5 ~ 8 位）、校验位（无 &#x2F; 奇 &#x2F; 偶）、停止位（1&#x2F;1.5&#x2F;2 位）</li><li><strong>缓冲区</strong>：每个 UART 支持硬件 FIFO 缓冲区，可通过软件配置环形缓冲区大小</li><li><strong>事件驱动</strong>：支持通过 FreeRTOS 队列触发 UART 事件（数据接收、缓冲区满、溢出等）</li></ul><h3 id="关键API"><a href="#关键API" class="headerlink" title="关键API"></a>关键API</h3><table><thead><tr><th>API 函数</th><th>功能描述</th><th>核心参数说明</th></tr></thead><tbody><tr><td><code>uart_param_config()</code></td><td>配置 UART 通信参数（波特率、数据位等）</td><td>端口号、<code>uart_config_t</code> 结构体</td></tr><tr><td><code>uart_set_pin()</code></td><td>绑定 UART 信号到物理引脚</td><td>端口号、TX 引脚、RX 引脚、RTS 引脚、CTS 引脚</td></tr><tr><td><code>uart_driver_install()</code></td><td>安装 UART 驱动并创建事件队列</td><td>端口号、接收缓冲区大小、发送缓冲区大小、队列容量、队列句柄、标志</td></tr><tr><td><code>uart_read_bytes()</code></td><td>读取 UART 接收数据</td><td>端口号、接收缓冲区、读取长度、超时时间</td></tr><tr><td><code>uart_write_bytes()</code></td><td>发送 UART 数据</td><td>端口号、发送缓冲区、发送长度</td></tr><tr><td><code>uart_flush_input()</code></td><td>清空 UART 接收缓冲区</td><td>端口号</td></tr><tr><td><code>xQueueReceive()</code></td><td>从事件队列接收 UART 事件</td><td>队列句柄、事件存储变量地址、超时时间</td></tr><tr><td><code>xTaskCreate()</code></td><td>创建独立任务处理 UART 事件</td><td>任务函数、任务名称、栈大小、优先级等</td></tr></tbody></table><h3 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h3><h4 id="步骤-1：定义核心参数（宏定义）"><a href="#步骤-1：定义核心参数（宏定义）" class="headerlink" title="步骤 1：定义核心参数（宏定义）"></a>步骤 1：定义核心参数（宏定义）</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 定义 UART 端口号</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> USER_UART_NUM UART_NUM_1  <span class="comment">// 避免 UART0 冲突（默认用于串口打印）</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> USER_UART_BAUD 115200  <span class="comment">// 串口波特率设置</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 定义引脚（需根据硬件接线调整）</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UART_TX_PIN 17  <span class="comment">// TX 发送引脚</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UART_RX_PIN 16  <span class="comment">// RX 接收引脚</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 定义缓冲区和队列参数</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UART_BUFFER_SIZE 1024    <span class="comment">// 数据缓冲区大小</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UART_QUEUE_SIZE 10       <span class="comment">// 事件队列容量（最多缓存 10 个事件）</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UART_TASK_STACK_SIZE 4096<span class="comment">// UART 处理任务栈大小</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UART_TASK_PRIORITY 5     <span class="comment">// UART 任务优先级（1~24，数值越大优先级越高）</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 全局变量声明</span></span><br><span class="line"><span class="type">static</span> QueueHandle_t uart_event_queue;  <span class="comment">// UART 事件队列句柄</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint8_t</span> uart_rx_buffer[UART_BUFFER_SIZE];  <span class="comment">// 接收数据缓冲区</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> *TAG = <span class="string">&quot;UART_DEV&quot;</span>;    <span class="comment">// 日志标签</span></span><br></pre></td></tr></table></figure><h4 id="步骤-2：配置-UART-硬件参数"><a href="#步骤-2：配置-UART-硬件参数" class="headerlink" title="步骤 2：配置 UART 硬件参数"></a>步骤 2：配置 UART 硬件参数</h4><p>通过 <code>uart_config_t</code> 结构体配置通信参数，再调用 <code>uart_param_config()</code> 生效：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 配置 UART 通信参数</span></span><br><span class="line"><span class="type">uart_config_t</span> uart_config = &#123;</span><br><span class="line">    .baud_rate = USER_UART_BAUD,          <span class="comment">// 波特率（常用：9600、115200、1000000）</span></span><br><span class="line">    .data_bits = UART_DATA_8_BITS,<span class="comment">// 数据位：8 位</span></span><br><span class="line">    .parity = UART_PARITY_DISABLE,<span class="comment">// 校验位：禁用</span></span><br><span class="line">    .stop_bits = UART_STOP_BITS_1,<span class="comment">// 停止位：1 位</span></span><br><span class="line">    .flow_ctrl = UART_HW_FLOWCTRL_DISABLE,  <span class="comment">// 硬件流控：禁用（无需 RTS/CTS 引脚）</span></span><br><span class="line">    .source_clk = UART_SCLK_DEFAULT,         <span class="comment">// 时钟源：默认</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 应用配置到指定 UART 端口</span></span><br><span class="line">ESP_ERROR_CHECK(uart_param_config(USER_UART_NUM, &amp;uart_config));</span><br></pre></td></tr></table></figure><h4 id="步骤-3：绑定引脚并安装驱动-（如果用默认串口的话-则不需要绑定引脚）"><a href="#步骤-3：绑定引脚并安装驱动-（如果用默认串口的话-则不需要绑定引脚）" class="headerlink" title="步骤 3：绑定引脚并安装驱动 （如果用默认串口的话 则不需要绑定引脚）"></a>步骤 3：绑定引脚并安装驱动 （如果用默认串口的话 则不需要绑定引脚）</h4><ul><li><strong>引脚绑定</strong>：通过 <code>uart_set_pin()</code> 将 UART 信号映射到 ESP32 物理引脚</li><li><strong>驱动安装</strong>：调用 <code>uart_driver_install()</code> 初始化 UART 驱动，创建事件队列（可选）</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 绑定 UART 引脚（TX/RX，流控引脚填 UART_PIN_NO_CHANGE 表示禁用）</span></span><br><span class="line">ESP_ERROR_CHECK(uart_set_pin(USER_UART_NUM, </span><br><span class="line">                            UART_TX_PIN,  <span class="comment">// TX 引脚</span></span><br><span class="line">                            UART_RX_PIN,  <span class="comment">// RX 引脚</span></span><br><span class="line">                            UART_PIN_NO_CHANGE,  <span class="comment">// RTS 引脚（禁用）</span></span><br><span class="line">                            UART_PIN_NO_CHANGE)); <span class="comment">// CTS 引脚（禁用）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 安装 UART 驱动（参数依次：端口号、接收缓冲区大小、发送缓冲区大小、事件队列容量、队列句柄、标志）</span></span><br><span class="line">ESP_ERROR_CHECK(uart_driver_install(USER_UART_NUM, </span><br><span class="line">                                    UART_BUFFER_SIZE * <span class="number">2</span>,  <span class="comment">// 接收缓冲区（建议比单次接收大）</span></span><br><span class="line">                                    UART_BUFFER_SIZE * <span class="number">2</span>,  <span class="comment">// 发送缓冲区</span></span><br><span class="line">                                    UART_QUEUE_SIZE,       <span class="comment">// 事件队列容量</span></span><br><span class="line">                                    &amp;uart_event_queue,     <span class="comment">// 事件队列句柄（传出）</span></span><br><span class="line">                                    <span class="number">0</span>));                   <span class="comment">// 标志：0（默认）</span></span><br></pre></td></tr></table></figure><h3 id="ESP32-UART-数据处理方式"><a href="#ESP32-UART-数据处理方式" class="headerlink" title="ESP32 UART 数据处理方式"></a>ESP32 UART 数据处理方式</h3><table><thead><tr><th>特性</th><th>轮询方式（简单场景）</th><th>事件驱动方式（高效场景）</th></tr></thead><tbody><tr><td>核心函数</td><td><code>uart_read_bytes()</code>、<code>uart_write_bytes()</code></td><td><code>xQueueReceive()</code>（监听事件队列）</td></tr><tr><td>适用场景</td><td>简单回显、低频率数据交互</td><td>高频率数据、多事件处理（如溢出）</td></tr><tr><td>CPU 占用率</td><td>较高（循环查询）</td><td>较低（事件触发，无轮询）</td></tr><tr><td>代码复杂度</td><td>低</td><td>中（需处理多事件类型）</td></tr><tr><td>看门狗风险</td><td>高（需避免长阻塞）</td><td>低（事件队列超时释放 CPU）</td></tr></tbody></table><h3 id="实战代码示例"><a href="#实战代码示例" class="headerlink" title="实战代码示例"></a>实战代码示例</h3><h4 id="事件驱动方式"><a href="#事件驱动方式" class="headerlink" title="事件驱动方式"></a>事件驱动方式</h4><ul><li><p>通过 FreeRTOS 队列接收 UART 事件，按需处理数据接收、缓冲区满、溢出等场景：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;freertos/FreeRTOS.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;freertos/task.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;driver/uart.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;esp_log.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;driver/gpio.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// -------------- 1. 宏定义参数 --------------</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> USER_UART_NUM UART_NUM_1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> USER_UART_BAUD 115200</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UART_TX_PIN 17</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UART_RX_PIN 16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UART_BUFFER_SIZE 1024</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UART_QUEUE_SIZE 10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UART_TASK_STACK_SIZE 4096</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UART_TASK_PRIORITY 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// -------------- 2. 全局变量 --------------</span></span><br><span class="line"><span class="type">static</span> QueueHandle_t uart_event_queue;</span><br><span class="line"><span class="type">static</span> <span class="type">uint8_t</span> uart_rx_buffer[UART_BUFFER_SIZE];</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> *TAG = <span class="string">&quot;UART_DEV&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -------------- 3. UART 事件处理任务 --------------</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">uart_event_task</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="type">uart_event_t</span> event;  <span class="comment">// 存储 UART 事件的结构体</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 从事件队列接收事件（超时 100ms，避免阻塞触发看门狗）</span></span><br><span class="line">        <span class="keyword">if</span> (xQueueReceive(uart_event_queue, &amp;event, pdMS_TO_TICKS(<span class="number">100</span>)) == pdTRUE) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (event.type) &#123;</span><br><span class="line">                <span class="comment">// 1. 接收数据事件</span></span><br><span class="line">                <span class="keyword">case</span> UART_DATA:</span><br><span class="line">                    ESP_LOGI(TAG, <span class="string">&quot;收到数据，长度：%d 字节&quot;</span>, event.size);</span><br><span class="line">                    <span class="comment">// 读取数据到缓冲区（超时 50ms，确保数据完整性）</span></span><br><span class="line">                    <span class="type">int</span> read_len = uart_read_bytes(USER_UART_NUM, </span><br><span class="line">                                                  uart_rx_buffer, </span><br><span class="line">                                                  event.size, </span><br><span class="line">                                                  pdMS_TO_TICKS(<span class="number">50</span>));</span><br><span class="line">                    <span class="keyword">if</span> (read_len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// 示例1：回显数据（发送收到的数据）</span></span><br><span class="line">                        uart_write_bytes(USER_UART_NUM, uart_rx_buffer, read_len);</span><br><span class="line">                        <span class="comment">// 示例2：打印接收的数据（十六进制）</span></span><br><span class="line">                        ESP_LOGI(TAG, <span class="string">&quot;接收数据（hex）：&quot;</span>);</span><br><span class="line">                        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; read_len; i++) &#123;</span><br><span class="line">                            <span class="built_in">printf</span>(<span class="string">&quot;%02X &quot;</span>, uart_rx_buffer[i]);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 2. 接收缓冲区满事件</span></span><br><span class="line">                <span class="keyword">case</span> UART_BUFFER_FULL:</span><br><span class="line">                    ESP_LOGI(TAG, <span class="string">&quot;接收缓冲区满，清空缓冲区&quot;</span>);</span><br><span class="line">                    uart_flush_input(USER_UART_NUM);  <span class="comment">// 清空接收缓冲区</span></span><br><span class="line">                    xQueueReset(uart_event_queue);    <span class="comment">// 重置事件队列</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 3. FIFO 溢出事件（硬件缓冲区溢出）</span></span><br><span class="line">                <span class="keyword">case</span> UART_FIFO_OVF:</span><br><span class="line">                    ESP_LOGI(TAG, <span class="string">&quot;UART FIFO 溢出，清空缓冲区&quot;</span>);</span><br><span class="line">                    uart_flush_input(USER_UART_NUM);</span><br><span class="line">                    xQueueReset(uart_event_queue);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 4. 帧错误事件（数据格式错误）</span></span><br><span class="line">                <span class="keyword">case</span> UART_FRAME_ERR:</span><br><span class="line">                    ESP_LOGI(TAG, <span class="string">&quot;帧错误（数据格式异常）&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 5. 校验错误事件（启用校验时生效）</span></span><br><span class="line">                <span class="keyword">case</span> UART_PARITY_ERR:</span><br><span class="line">                    ESP_LOGI(TAG, <span class="string">&quot;校验错误（数据校验不匹配）&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 其他未处理事件</span></span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    ESP_LOGI(TAG, <span class="string">&quot;未处理事件类型：%d&quot;</span>, event.type);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -------------- 4. 主函数初始化 --------------</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">app_main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 配置 UART 硬件参数</span></span><br><span class="line">    <span class="type">uart_config_t</span> uart_config = &#123;</span><br><span class="line">        .baud_rate = USER_UART_BAUD,</span><br><span class="line">        .data_bits = UART_DATA_8_BITS,</span><br><span class="line">        .parity = UART_PARITY_DISABLE,</span><br><span class="line">        .stop_bits = UART_STOP_BITS_1,</span><br><span class="line">        .flow_ctrl = UART_HW_FLOWCTRL_DISABLE,</span><br><span class="line">        .source_clk = UART_SCLK_DEFAULT,</span><br><span class="line">    &#125;;</span><br><span class="line">    ESP_ERROR_CHECK(uart_param_config(USER_UART_NUM, &amp;uart_config));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 绑定引脚</span></span><br><span class="line">    ESP_ERROR_CHECK(uart_set_pin(USER_UART_NUM, </span><br><span class="line">                                UART_TX_PIN, </span><br><span class="line">                                UART_RX_PIN, </span><br><span class="line">                                UART_PIN_NO_CHANGE, </span><br><span class="line">                                UART_PIN_NO_CHANGE));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 安装 UART 驱动并创建事件队列</span></span><br><span class="line">    ESP_ERROR_CHECK(uart_driver_install(USER_UART_NUM, </span><br><span class="line">                                        UART_BUFFER_SIZE * <span class="number">2</span>, </span><br><span class="line">                                        UART_BUFFER_SIZE * <span class="number">2</span>, </span><br><span class="line">                                        UART_QUEUE_SIZE, </span><br><span class="line">                                        &amp;uart_event_queue, </span><br><span class="line">                                        <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 创建 UART 事件处理任务（独立任务，避免阻塞 main 任务）</span></span><br><span class="line">    xTaskCreate(uart_event_task,          <span class="comment">// 任务函数</span></span><br><span class="line">                <span class="string">&quot;uart_event_task&quot;</span>,        <span class="comment">// 任务名称</span></span><br><span class="line">                UART_TASK_STACK_SIZE,     <span class="comment">// 栈大小</span></span><br><span class="line">                <span class="literal">NULL</span>,                     <span class="comment">// 任务参数</span></span><br><span class="line">                UART_TASK_PRIORITY,       <span class="comment">// 优先级</span></span><br><span class="line">                <span class="literal">NULL</span>);                    <span class="comment">// 任务句柄（无需则填 NULL）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="轮询方式（简单场景，如回显）"><a href="#轮询方式（简单场景，如回显）" class="headerlink" title="轮询方式（简单场景，如回显）"></a>轮询方式（简单场景，如回显）</h4><ul><li><p>适用于数据量小、交互频率低的场景，代码更简洁：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">app_main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 配置 UART 参数（同事件驱动方式）</span></span><br><span class="line">    <span class="type">uart_config_t</span> uart_config = &#123;</span><br><span class="line">        .baud_rate = <span class="number">115200</span>,</span><br><span class="line">        .data_bits = UART_DATA_8_BITS,</span><br><span class="line">        .parity = UART_PARITY_DISABLE,</span><br><span class="line">        .stop_bits = UART_STOP_BITS_1,</span><br><span class="line">        .flow_ctrl = UART_HW_FLOWCTRL_DISABLE,</span><br><span class="line">    &#125;;</span><br><span class="line">    ESP_ERROR_CHECK(uart_param_config(USER_UART_NUM, &amp;uart_config));</span><br><span class="line">    ESP_ERROR_CHECK(uart_set_pin(USER_UART_NUM, <span class="number">17</span>, <span class="number">16</span>, UART_PIN_NO_CHANGE, UART_PIN_NO_CHANGE));</span><br><span class="line">    ESP_ERROR_CHECK(uart_driver_install(USER_UART_NUM, <span class="number">1024</span>, <span class="number">1024</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 轮询读取数据并回显</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 读取数据（超时 50ms，无数据则返回 0）</span></span><br><span class="line">        <span class="type">int</span> read_len = uart_read_bytes(USER_UART_NUM, uart_rx_buffer, <span class="number">1024</span>, pdMS_TO_TICKS(<span class="number">50</span>));</span><br><span class="line">        <span class="keyword">if</span> (read_len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 回显数据</span></span><br><span class="line">            uart_write_bytes(USER_UART_NUM, uart_rx_buffer, read_len);</span><br><span class="line">            ESP_LOGI(TAG, <span class="string">&quot;轮询接收数据长度：%d&quot;</span>, read_len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 短暂延迟，释放 CPU（避免触发看门狗）</span></span><br><span class="line">        vTaskDelay(pdMS_TO_TICKS(<span class="number">10</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="常见问题与解决方案"><a href="#常见问题与解决方案" class="headerlink" title="常见问题与解决方案"></a>常见问题与解决方案</h3><h4 id="触发-Task-Watchdog（任务看门狗）"><a href="#触发-Task-Watchdog（任务看门狗）" class="headerlink" title="触发 Task Watchdog（任务看门狗）"></a>触发 Task Watchdog（任务看门狗）</h4><ul><li><strong>原因</strong>：<ol><li>轮询方式中 <code>uart_read_bytes()</code> 超时过长，或无 <code>vTaskDelay()</code> 释放 CPU；</li><li>事件驱动方式中 <code>xQueueReceive()</code> 使用 <code>portMAX_DELAY</code> 永久阻塞。</li></ol></li><li><strong>解决方案</strong>：<ul><li>轮询方式：在循环中添加 <code>vTaskDelay(pdMS_TO_TICKS(10))</code>；</li><li>事件驱动方式：<code>xQueueReceive()</code> 超时设为有限值（如 <code>pdMS_TO_TICKS(100)</code>）。</li></ul></li></ul><h4 id="数据接收不完整或丢失"><a href="#数据接收不完整或丢失" class="headerlink" title="数据接收不完整或丢失"></a>数据接收不完整或丢失</h4><ul><li><strong>原因</strong>：<ol><li>接收缓冲区过小，无法容纳单次接收的数据；</li><li><code>uart_read_bytes()</code> 超时过短，数据未完全接收；</li><li>波特率不匹配（发送端与接收端波特率必须一致）。</li></ol></li><li><strong>解决方案</strong>：<ul><li>增大接收缓冲区（如 <code>UART_BUFFER_SIZE * 2</code>）；</li><li>延长 <code>uart_read_bytes()</code> 超时时间（如 50~100ms）；</li><li>确保发送端与 ESP32 UART 波特率、数据位、校验位完全一致。</li></ul></li></ul><h4 id="UART0-与串口打印冲突"><a href="#UART0-与串口打印冲突" class="headerlink" title="UART0 与串口打印冲突"></a>UART0 与串口打印冲突</h4><ul><li><strong>原因</strong>：ESP32 默认将 <code>printf()</code> 映射到 UART0（引脚 TX&#x3D;1，RX&#x3D;3），若使用 UART0 通信会导致打印乱码。</li><li><strong>解决方案</strong>：<ul><li>优先使用 UART1 或 UART2 作为通信端口；</li><li>若必须使用 UART0，需重新映射 <code>printf()</code> 到其他 UART（需修改 ESP-IDF 配置）。</li></ul></li></ul><h2 id="WIFI"><a href="#WIFI" class="headerlink" title="WIFI"></a>WIFI</h2><h3 id="ESP32下WIFI组件三种模式"><a href="#ESP32下WIFI组件三种模式" class="headerlink" title="ESP32下WIFI组件三种模式"></a>ESP32下WIFI组件三种模式</h3><ul><li><p><strong>AP 模式</strong>：ESP32 自身作为接入点，其他设备（如手机、电脑）可连接 ESP32 创建的 WiFi 热点，适用于 “本地设备直连 ESP32” 场景（如配置 ESP32 参数）；</p></li><li><p><strong>AP+STA 混合模式</strong>：ESP32 同时作为接入点和客户端，既允许其他设备连接自身，又能接入外部路由器，适用于 “本地控制 + 远程联网” 复合场景（如智能家居设备）；</p></li><li><p><strong>STA 模式</strong>：仅作为客户端，专注于接入外部网络，是 ESP32 实现联网功能的最常用模式（如传感器数据上传云端、远程控制指令接收）。</p></li></ul><h3 id="STA模式核心工作原理"><a href="#STA模式核心工作原理" class="headerlink" title="STA模式核心工作原理"></a>STA模式核心工作原理</h3><p>ESP32 的 STA 模式连接 WiFi 的过程遵循 IEEE 802.11 协议，核心流程可分为 4 个阶段，各阶段依赖 ESP-IDF 提供的 WiFi 驱动接口实现：</p><ol><li><p><strong>初始化阶段</strong>：</p><ul><li><p>初始化 WiFi 组件（调用esp_wifi_init()），配置 WiFi 工作模式为 STA（通过wifi_init_config_t结构体设置mode &#x3D; WIFI_MODE_STA）；</p></li><li><p>配置 TCP&#x2F;IP 协议栈（ESP-IDF 默认自动初始化，无需手动操作，支持 DHCP 自动获取 IP 或静态 IP 配置）。</p></li></ul></li><li><p><strong>配置连接参数阶段</strong>：</p><ul><li><p>定义wifi_config_t结构体，填入目标 AP 的<strong>SSID（WiFi 名称）</strong> 和<strong>Password（WiFi 密码）</strong>，确保参数与 AP 一致（区分 SSID 大小写，密码长度需符合 AP 要求，如 WPA2-PSK 密码通常为 8-63 位）；</p></li><li><p>通过esp_wifi_set_config(WIFI_IF_STA, &amp;wifi_config)将配置参数写入 ESP32 的 WiFi 接口。</p></li></ul></li><li><p><strong>启动与连接阶段</strong>：</p><ul><li><p>启动 STA 接口（esp_wifi_start()），ESP32 开始扫描周围 WiFi 信号；</p></li><li><p>自动匹配目标 AP 的 SSID，发起连接请求，与 AP 进行<strong>认证（如 WPA2-PSK 认证）</strong> 和<strong>关联</strong>；</p></li><li><p>若认证通过，ESP32 通过 DHCP 向 AP 请求 IP 地址（默认开启 DHCP 客户端），获取到 IP、子网掩码、网关后，完成 “物理连接→网络层连接” 的全流程。</p></li></ul></li><li><p><strong>状态监测阶段</strong>：</p><ul><li><p>ESP32 通过<strong>事件回调机制</strong>（esp_event_loop_create_default()创建事件循环，esp_event_handler_instance_register()注册事件处理函数）反馈连接状态；</p></li><li><p>关键事件包括：WIFI_EVENT_STA_START（STA 接口启动成功）、WIFI_EVENT_STA_CONNECTED（与 AP 物理连接成功）、IP_EVENT_STA_GOT_IP（获取 IP 地址，联网完成）、WIFI_EVENT_STA_DISCONNECTED（与 AP 断开连接）。</p></li></ul></li></ol><h4 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h4><h5 id="重写事件处理函数（核心）"><a href="#重写事件处理函数（核心）" class="headerlink" title="重写事件处理函数（核心）"></a>重写事件处理函数（核心）</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief WiFi事件与IP事件处理回调函数（核心逻辑）</span></span><br><span class="line"><span class="comment"> * @param arg：用户自定义参数，本代码未使用，传入NULL即可</span></span><br><span class="line"><span class="comment"> * @param event_base：事件基础类型，用于区分是WiFi相关事件（WIFI_EVENT）还是IP相关事件（IP_EVENT）</span></span><br><span class="line"><span class="comment"> * @param event_id：具体事件ID，标识当前触发的是该事件类型下的哪一种具体事件</span></span><br><span class="line"><span class="comment"> * @param event_data：事件关联的数据指针，如IP事件中可获取分配的IP地址信息</span></span><br><span class="line"><span class="comment"> * 功能：响应ESP32 WiFi模块的关键事件，更新连接状态、触发重连逻辑、通知外部状态变化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">event_handler</span><span class="params">(<span class="type">void</span> *arg, <span class="type">esp_event_base_t</span> event_base,</span></span><br><span class="line"><span class="params">                          <span class="type">int32_t</span> event_id, <span class="type">void</span> *event_data)</span></span><br></pre></td></tr></table></figure><h5 id="实现-STA-模式初始化函数"><a href="#实现-STA-模式初始化函数" class="headerlink" title="实现 STA 模式初始化函数"></a>实现 STA 模式初始化函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入所需头文件：自定义WiFi管理模块头文件、ESP32 WiFi驱动库、事件处理库</span></span><br><span class="line"><span class="comment">// 日志打印库、FreeRTOS实时操作系统任务调度库、标准输入输出库</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;wifi_manager.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;esp_wifi.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;esp_event.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;esp_log.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;nvs_flash.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;freertos/FreeRTOS.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;freertos/task.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WIFI_SSID <span class="string">&quot;2078&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WIFI_PASSWORD <span class="string">&quot;12345678&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态全局变量：WiFi状态回调函数指针，用于将WiFi连接/断开状态通知给外部调用者</span></span><br><span class="line"><span class="comment">// 外部需通过wifi_manager_init函数传入自定义回调，接收WIFI_STATE_CONNECTED/WIFI_STATE_DISCONNECTED状态</span></span><br><span class="line"><span class="type">static</span> p_wifi_state_cb wifi_state_cb = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 宏定义：STA模式下最大重连次数，限制重连次数避免无限循环占用CPU资源</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_CONNECT_RETRY 10</span></span><br><span class="line"><span class="comment">// 宏定义：日志标签，串口打印时用于区分该模块的日志，方便调试定位</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TAG <span class="string">&quot;wifi_manager&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态全局变量：记录STA模式当前的重连尝试次数，初始值为0，每次重连失败自增1</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> sta_connect_cnt = <span class="number">0</span>; <span class="comment">// 重连次数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态全局变量：标记STA模式是否已成功连接到目标AP，true表示已连接，false表示未连接/已断开</span></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> is_sta_connected = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief WiFi事件与IP事件处理回调函数（核心逻辑）</span></span><br><span class="line"><span class="comment"> * @param arg：用户自定义参数，本代码未使用，传入NULL即可</span></span><br><span class="line"><span class="comment"> * @param event_base：事件基础类型，用于区分是WiFi相关事件（WIFI_EVENT）还是IP相关事件（IP_EVENT）</span></span><br><span class="line"><span class="comment"> * @param event_id：具体事件ID，标识当前触发的是该事件类型下的哪一种具体事件</span></span><br><span class="line"><span class="comment"> * @param event_data：事件关联的数据指针，如IP事件中可获取分配的IP地址信息</span></span><br><span class="line"><span class="comment"> * 功能：响应ESP32 WiFi模块的关键事件，更新连接状态、触发重连逻辑、通知外部状态变化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">event_handler</span><span class="params">(<span class="type">void</span> *arg, <span class="type">esp_event_base_t</span> event_base,</span></span><br><span class="line"><span class="params">                          <span class="type">int32_t</span> event_id, <span class="type">void</span> *event_data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 判断事件类型为WiFi相关事件（WIFI_EVENT）</span></span><br><span class="line">    <span class="keyword">if</span> (event_base == WIFI_EVENT)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 根据具体事件ID处理不同场景</span></span><br><span class="line">        <span class="keyword">switch</span> (event_id)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="comment">// 事件：STA接口启动成功（调用esp_wifi_start()后触发此事件）</span></span><br><span class="line">        <span class="keyword">case</span> WIFI_EVENT_STA_START:</span><br><span class="line">            <span class="comment">// 启动成功后，主动调用esp_wifi_connect()发起WiFi连接请求</span></span><br><span class="line">            esp_wifi_connect();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 事件：STA与已连接的AP断开连接（如信号弱、密码错误、路由器重启等）</span></span><br><span class="line">        <span class="keyword">case</span> WIFI_EVENT_STA_DISCONNECTED:</span><br><span class="line">            <span class="comment">// 若之前处于已连接状态，先更新连接状态并通知外部</span></span><br><span class="line">            <span class="keyword">if</span> (is_sta_connected)</span><br><span class="line">            &#123;</span><br><span class="line">                is_sta_connected = <span class="literal">false</span>; <span class="comment">// 将连接状态标记为未连接</span></span><br><span class="line">                <span class="keyword">if</span> (wifi_state_cb)        <span class="comment">// 若外部注册了回调函数，触发&quot;断开连接&quot;状态通知</span></span><br><span class="line">                    wifi_state_cb(WIFI_STATE_DISCONNECTED);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 检查当前重连次数是否小于最大重连次数，若未达到则继续重试</span></span><br><span class="line">            <span class="keyword">if</span> (sta_connect_cnt &lt; MAX_CONNECT_RETRY)</span><br><span class="line">            &#123;</span><br><span class="line">                sta_connect_cnt++;  <span class="comment">// 重连次数自增1</span></span><br><span class="line">                esp_wifi_connect(); <span class="comment">// 发起新一轮连接请求</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 若已达到最大重连次数，不再重试（避免无限重连）</span></span><br><span class="line">            wifi_state_cb(WIFI_STATE_DISCONNECTED);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 其他未定义的WiFi事件，暂不处理，直接break</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断事件类型为IP相关事件（IP_EVENT）</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (event_base == IP_EVENT)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 事件：STA成功从DHCP服务器获取到IP地址（标志网络层连接完成）</span></span><br><span class="line">        <span class="keyword">if</span> (event_id == IP_EVENT_STA_GOT_IP)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 打印日志提示已获取IP地址，便于调试确认</span></span><br><span class="line">            ESP_LOGI(TAG, <span class="string">&quot;Got IP address&quot;</span>);</span><br><span class="line">            sta_connect_cnt = <span class="number">0</span>;     <span class="comment">// 重置重连次数</span></span><br><span class="line">            is_sta_connected = <span class="literal">true</span>; <span class="comment">// 将连接状态标记为已连接</span></span><br><span class="line">            <span class="keyword">if</span> (wifi_state_cb)       <span class="comment">// 若外部注册了回调函数，触发&quot;连接成功&quot;状态通知</span></span><br><span class="line">                wifi_state_cb(WIFI_STATE_CONNECTED);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief WiFi管理器初始化函数（STA模式初始化入口）</span></span><br><span class="line"><span class="comment"> * @param f：外部传入的WiFi状态回调函数，用于接收连接/断开状态通知</span></span><br><span class="line"><span class="comment"> * 功能：初始化ESP32网络接口、事件循环、WiFi驱动，配置STA模式并启动WiFi模块</span></span><br><span class="line"><span class="comment"> * 注意：使用WiFi功能前必须先调用此函数完成初始化，建议在app_main()中优先执行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">wifi_manager_init</span><span class="params">(p_wifi_state_cb f)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 初始化NVS（ESP32存储WiFi配置的依赖组件，必须先初始化）</span></span><br><span class="line">    <span class="type">esp_err_t</span> ret = nvs_flash_init();</span><br><span class="line">    <span class="keyword">if</span> (ret == ESP_ERR_NVS_NO_FREE_PAGES || ret == ESP_ERR_NVS_NEW_VERSION_FOUND)</span><br><span class="line">    &#123;</span><br><span class="line">        ESP_ERROR_CHECK(nvs_flash_erase()); <span class="comment">// 若NVS有问题，先擦除再初始化</span></span><br><span class="line">        ret = nvs_flash_init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 初始化ESP32网络接口（TCP/IP协议栈初始化，必须在WiFi初始化前执行）</span></span><br><span class="line">    ESP_ERROR_CHECK(esp_netif_init());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 创建默认的事件循环（用于处理WiFi和IP事件）</span></span><br><span class="line">    ESP_ERROR_CHECK(esp_event_loop_create_default());</span><br><span class="line">    esp_netif_create_default_wifi_sta(); <span class="comment">// 使用默认的STA模式网络接口</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 初始化WiFi驱动：使用WIFI_INIT_CONFIG_DEFAULT()获取默认配置（包含时钟、中断等参数）</span></span><br><span class="line">    <span class="type">wifi_init_config_t</span> cfg = WIFI_INIT_CONFIG_DEFAULT();</span><br><span class="line">    ESP_ERROR_CHECK(esp_wifi_init(&amp;cfg)); <span class="comment">// 执行WiFi驱动初始化，若失败则触发错误检查</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 注册事件处理函数：监听WiFi事件和IP事件</span></span><br><span class="line">    <span class="comment">// 5.1注册WiFi事件监听器：监听所有WiFi事件（ESP_EVENT_ANY_ID），触发时调用event_handler处理</span></span><br><span class="line">    ESP_ERROR_CHECK(esp_event_handler_instance_register(WIFI_EVENT,</span><br><span class="line">                                                        ESP_EVENT_ANY_ID,</span><br><span class="line">                                                        &amp;event_handler,</span><br><span class="line">                                                        <span class="literal">NULL</span>,</span><br><span class="line">                                                        <span class="literal">NULL</span>));</span><br><span class="line">    <span class="comment">// 5.2注册IP事件监听器：仅监听&quot;STA获取IP&quot;事件（IP_EVENT_STA_GOT_IP）</span></span><br><span class="line">    ESP_ERROR_CHECK(esp_event_handler_instance_register(IP_EVENT,</span><br><span class="line">                                                        IP_EVENT_STA_GOT_IP,</span><br><span class="line">                                                        &amp;event_handler,</span><br><span class="line">                                                        <span class="literal">NULL</span>,</span><br><span class="line">                                                        <span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 保存外部传入的状态回调函数，后续状态变化时通过此函数通知外部</span></span><br><span class="line">    wifi_state_cb = f;</span><br><span class="line"></span><br><span class="line">    <span class="type">wifi_config_t</span> wifi_config = &#123;</span><br><span class="line">        .sta = &#123;</span><br><span class="line">            <span class="comment">// 配置STA的认证模式为WPA2-PSK（主流家用/工业路由器默认加密方式）</span></span><br><span class="line">            .threshold.authmode = WIFI_AUTH_WPA2_PSK,</span><br><span class="line">            .ssid = WIFI_SSID,</span><br><span class="line">            .password = WIFI_PASSWORD,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7. 配置WiFi工作模式为纯STA模式（仅作为客户端连接外部AP，不开启AP模式）</span></span><br><span class="line">    ESP_ERROR_CHECK(esp_wifi_set_mode(WIFI_MODE_STA));</span><br><span class="line">    ESP_ERROR_CHECK(esp_wifi_set_config(WIFI_IF_STA, &amp;wifi_config)); <span class="comment">// 写入配置</span></span><br><span class="line">    <span class="comment">// 8. 启动WiFi模块（启动后会触发WIFI_EVENT_STA_START事件，进而发起连接）</span></span><br><span class="line">    ESP_ERROR_CHECK(esp_wifi_start());</span><br><span class="line">    ESP_LOGI(TAG, <span class="string">&quot;STA initialization done&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> MCU </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RTOS </tag>
            
            <tag> ESP32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LVGL学习之旅（基于正点原子STM32F407探索者）</title>
      <link href="/2025/09/07/LVGL%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/"/>
      <url>/2025/09/07/LVGL%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/</url>
      
        <content type="html"><![CDATA[<h2 id="LVGL-基础"><a href="#LVGL-基础" class="headerlink" title="LVGL 基础"></a>LVGL 基础</h2><blockquote><p>LVGL（Light and Versatile Graphics Library）轻量级通用型图形库，是一个免费的开源图形库，提供了创建嵌入式 GUI 所需的一切，具有易于使用的组件，美观的视觉效果和低内存占用等特点。支持触摸屏操作，移植简单方便，开发者一直在不断完善更新。</p><p>特点：</p><ul><li>丰富且强大的模块化图形组件：按钮 (buttons)、图表 (charts)、列表 (lists)、滑动条 (sliders)、图片 (images) 等</li><li>高级的图形引擎：动画、抗锯齿、透明度、平滑滚动、图层混合等效果</li><li>不依赖特定的硬件平台，可以在任何显示屏上运行</li><li>配置可裁剪（最低资源占用：<span style="color:#FF0000;">64 kB Flash，16 kB RAM</span>）</li><li>基于<span style="color:#FF0000;">UTF-8</span>的多语种支持，例如中文、日文、韩文、阿拉伯文等</li><li>可以通过类CSS的方式来设计、布局图形界面（例如：Flexbox、Grid）</li><li>支持操作系统、外置内存、以及硬件加速（LVGL已内建支持STM32 DMA2D、NXP PXP和VGLite）</li><li>即便仅有单缓冲区(frame buffer)的情况下，也可保证渲染如丝般顺滑</li><li>全部由C编写完成，并支持C++调用</li><li>支持Micropython编程，参见：LVGL API in Micropython</li><li>支持模拟器仿真，可以无硬件依托进行开发</li></ul></blockquote><h2 id="TFT-LCD配置——移植正点原子官方LCD例程"><a href="#TFT-LCD配置——移植正点原子官方LCD例程" class="headerlink" title="TFT-LCD配置——移植正点原子官方LCD例程"></a>TFT-LCD配置——移植正点原子官方LCD例程</h2><h3 id="点亮LCD——FSMC配置"><a href="#点亮LCD——FSMC配置" class="headerlink" title="点亮LCD——FSMC配置"></a>点亮LCD——FSMC配置</h3><h4 id="先根据原理图配置FSMC"><a href="#先根据原理图配置FSMC" class="headerlink" title="先根据原理图配置FSMC"></a>先根据原理图配置<code>FSMC</code></h4><p><img src="https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071556284.png" alt="image-20250907155616208"></p><p><img src="https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071607256.png" alt="image-20250907160758201"></p><h4 id="详细FSMC参数配置"><a href="#详细FSMC参数配置" class="headerlink" title="详细FSMC参数配置"></a>详细FSMC参数配置</h4><blockquote><p>这里根据正点原子官方<code>lcd_init</code> 来设置 如下图</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071643877.png" alt="image-20250907164335816"></p><p><img src="https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071724936.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071725408.png" alt="img"></p><h4 id="背光引脚配置"><a href="#背光引脚配置" class="headerlink" title="背光引脚配置"></a>背光引脚配置</h4><p><img src="https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071725075.png" alt="img"></p><h4 id="生成代码并将LCD、sys、delay文件夹添加到工程中"><a href="#生成代码并将LCD、sys、delay文件夹添加到工程中" class="headerlink" title="生成代码并将LCD、sys、delay文件夹添加到工程中"></a>生成代码并将LCD、sys、delay文件夹添加到工程中</h4><p><img src="https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509072343199.png" alt="image-20250907234315989"></p><h5 id="首先将HAL-SRAM-MspInit函数整个屏蔽"><a href="#首先将HAL-SRAM-MspInit函数整个屏蔽" class="headerlink" title="首先将HAL_SRAM_MspInit函数整个屏蔽"></a>首先将<em>HAL_SRAM_MspInit</em>函数整个屏蔽</h5><p><img src="https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071718133.png" alt="image-20250907171842072"></p><h5 id="将lcd-init中有关fsmc部分屏蔽"><a href="#将lcd-init中有关fsmc部分屏蔽" class="headerlink" title="将lcd_init中有关fsmc部分屏蔽"></a>将lcd_init中有关fsmc部分屏蔽</h5><blockquote><p>屏蔽部分如下</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">LCD_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;   </span><br><span class="line"><span class="comment">//GPIO_InitTypeDef GPIO_Initure;</span></span><br><span class="line"><span class="comment">//FSMC_NORSRAM_TimingTypeDef FSMC_ReadWriteTim;</span></span><br><span class="line"><span class="comment">//FSMC_NORSRAM_TimingTypeDef FSMC_WriteTim;</span></span><br><span class="line"><span class="comment">//    </span></span><br><span class="line"><span class="comment">//__HAL_RCC_GPIOB_CLK_ENABLE();//开启GPIOB时钟</span></span><br><span class="line"><span class="comment">//GPIO_Initure.Pin=GPIO_PIN_15;          //PB15,背光控制</span></span><br><span class="line"><span class="comment">//GPIO_Initure.Mode=GPIO_MODE_OUTPUT_PP;  //推挽输出</span></span><br><span class="line"><span class="comment">//GPIO_Initure.Pull=GPIO_PULLUP;          //上拉</span></span><br><span class="line"><span class="comment">//GPIO_Initure.Speed=GPIO_SPEED_HIGH;     //高速</span></span><br><span class="line"><span class="comment">//HAL_GPIO_Init(GPIOB,&amp;GPIO_Initure); </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//TFTSRAM_Handler.Instance=FSMC_NORSRAM_DEVICE;                </span></span><br><span class="line"><span class="comment">//TFTSRAM_Handler.Extended=FSMC_NORSRAM_EXTENDED_DEVICE;    </span></span><br><span class="line"><span class="comment">//    </span></span><br><span class="line"><span class="comment">//TFTSRAM_Handler.Init.NSBank=FSMC_NORSRAM_BANK4;     //使用NE4</span></span><br><span class="line"><span class="comment">//TFTSRAM_Handler.Init.DataAddressMux=FSMC_DATA_ADDRESS_MUX_DISABLE; //地址/数据线不复用</span></span><br><span class="line"><span class="comment">//TFTSRAM_Handler.Init.MemoryType=FSMC_MEMORY_TYPE_SRAM;   //SRAM</span></span><br><span class="line"><span class="comment">//TFTSRAM_Handler.Init.MemoryDataWidth=FSMC_NORSRAM_MEM_BUS_WIDTH_16; //16位数据宽度</span></span><br><span class="line"><span class="comment">//TFTSRAM_Handler.Init.BurstAccessMode=FSMC_BURST_ACCESS_MODE_DISABLE; //是否使能突发访问,仅对同步突发存储器有效,此处未用到</span></span><br><span class="line"><span class="comment">//TFTSRAM_Handler.Init.WaitSignalPolarity=FSMC_WAIT_SIGNAL_POLARITY_LOW;//等待信号的极性,仅在突发模式访问下有用</span></span><br><span class="line"><span class="comment">//TFTSRAM_Handler.Init.WaitSignalActive=FSMC_WAIT_TIMING_BEFORE_WS;   //存储器是在等待周期之前的一个时钟周期还是等待周期期间使能NWAIT</span></span><br><span class="line"><span class="comment">//TFTSRAM_Handler.Init.WriteOperation=FSMC_WRITE_OPERATION_ENABLE;    //存储器写使能</span></span><br><span class="line"><span class="comment">//TFTSRAM_Handler.Init.WaitSignal=FSMC_WAIT_SIGNAL_DISABLE;           //等待使能位,此处未用到</span></span><br><span class="line"><span class="comment">//TFTSRAM_Handler.Init.ExtendedMode=FSMC_EXTENDED_MODE_ENABLE;        //读写使用不同的时序</span></span><br><span class="line"><span class="comment">//TFTSRAM_Handler.Init.AsynchronousWait=FSMC_ASYNCHRONOUS_WAIT_DISABLE;//是否使能同步传输模式下的等待信号,此处未用到</span></span><br><span class="line"><span class="comment">//TFTSRAM_Handler.Init.WriteBurst=FSMC_WRITE_BURST_DISABLE;           //禁止突发写</span></span><br><span class="line"><span class="comment">//TFTSRAM_Handler.Init.ContinuousClock=FSMC_CONTINUOUS_CLOCK_SYNC_ASYNC;</span></span><br><span class="line"><span class="comment">//    </span></span><br><span class="line"><span class="comment">////FMC读时序控制寄存器</span></span><br><span class="line"><span class="comment">//FSMC_ReadWriteTim.AddressSetupTime=0x0F;       //地址建立时间（ADDSET）为16个HCLK 1/168M=6ns*16=96ns</span></span><br><span class="line"><span class="comment">//FSMC_ReadWriteTim.AddressHoldTime=0;</span></span><br><span class="line"><span class="comment">//FSMC_ReadWriteTim.DataSetupTime=60;//数据保存时间为60个HCLK=6*60=360ns</span></span><br><span class="line"><span class="comment">//FSMC_ReadWriteTim.AccessMode=FSMC_ACCESS_MODE_A;//模式A</span></span><br><span class="line"><span class="comment">////FMC写时序控制寄存器</span></span><br><span class="line"><span class="comment">//FSMC_WriteTim.BusTurnAroundDuration=0;//总线周转阶段持续时间为0，此变量不赋值的话会莫名其妙的自动修改为4。导致程序运行正常</span></span><br><span class="line"><span class="comment">//FSMC_WriteTim.AddressSetupTime=9;          //地址建立时间（ADDSET）为9个HCLK =54ns </span></span><br><span class="line"><span class="comment">//FSMC_WriteTim.AddressHoldTime=0;</span></span><br><span class="line"><span class="comment">//FSMC_WriteTim.DataSetupTime=8;              //数据保存时间为6ns*9个HCLK=54n</span></span><br><span class="line"><span class="comment">//FSMC_WriteTim.AccessMode=FSMC_ACCESS_MODE_A;    //模式A</span></span><br><span class="line"><span class="comment">//HAL_SRAM_Init(&amp;TFTSRAM_Handler,&amp;FSMC_ReadWriteTim,&amp;FSMC_WriteTim);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//HAL_Delay(50); // delay 50 ms </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//尝试9341 ID的读取</span></span><br><span class="line">LCD_WR_REG(<span class="number">0XD3</span>);</span><br><span class="line">    .........</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意有个坑！！！！</p><p>正点原子官方的<code>lcd_init</code>函数中有个 <code>printf(&quot; LCD ID:%x\r\n&quot;,lcddev.id);</code>，所以在此之前需先进行串口重定向  </p></blockquote><h5 id="替换官方的delay函数"><a href="#替换官方的delay函数" class="headerlink" title="替换官方的delay函数"></a>替换官方的delay函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">delay_us</span><span class="params">(u32 nus)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">uint32_t</span> Delay = nus * <span class="number">168</span> / <span class="number">4</span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">__NOP();</span><br><span class="line">&#125; <span class="keyword">while</span> (Delay--);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 延时nms</span></span><br><span class="line"><span class="comment">// nms:要延时的ms数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay_ms</span><span class="params">(u16 nms)</span></span><br><span class="line">&#123;</span><br><span class="line">HAL_Delay(nms);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="修改点亮背光函数"><a href="#修改点亮背光函数" class="headerlink" title="修改点亮背光函数"></a>修改点亮背光函数</h5><blockquote><p>在<code>lcd_init</code>函数最后 将<code>LCD_BL(1)</code>替换为<code>HAL_GPIO_WritePin(LCD_BL_GPIO_Port, LCD_BL_Pin, GPIO_PIN_SET);</code></p></blockquote><h3 id="触摸屏TOUCH移植"><a href="#触摸屏TOUCH移植" class="headerlink" title="触摸屏TOUCH移植"></a>触摸屏TOUCH移植</h3><h4 id="将BSP文件夹下的24CXX、IIC与TOUCH文件夹添加到项目中"><a href="#将BSP文件夹下的24CXX、IIC与TOUCH文件夹添加到项目中" class="headerlink" title="将BSP文件夹下的24CXX、IIC与TOUCH文件夹添加到项目中"></a>将BSP文件夹下的24CXX、IIC与TOUCH文件夹添加到项目中</h4><p><img src="https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071800663.png" alt="image-20250907180027576"></p><h2 id="LVGL移植国内码云仓库：https-gitee-com-mirrors-lvgl"><a href="#LVGL移植国内码云仓库：https-gitee-com-mirrors-lvgl" class="headerlink" title="LVGL移植国内码云仓库：https://gitee.com/mirrors/lvgl"></a>LVGL移植国内码云仓库：<a href="https://gitee.com/mirrors/lvgl">https://gitee.com/mirrors/lvgl</a></h2><p><img src="https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071809967.png" alt="image-20250907180958855"></p><p><img src="https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071810376.png" alt="image-20250907181022271"></p><blockquote><p>注意不要直接克隆 直接克隆下载的是最新的 可以选择右上角下载zip 就可以选中当前分支</p></blockquote><h3 id="裁剪LVGL源码"><a href="#裁剪LVGL源码" class="headerlink" title="裁剪LVGL源码"></a>裁剪LVGL源码</h3><h4 id="根目录"><a href="#根目录" class="headerlink" title="根目录"></a>根目录</h4><blockquote><p>仅保留 demos、examples、src文件夹以及两个.h文件 如下图</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071813234.png" alt="image-20250907181309155"></p><h4 id="进入examples文件夹-删去除porting文件夹"><a href="#进入examples文件夹-删去除porting文件夹" class="headerlink" title="进入examples文件夹 删去除porting文件夹"></a>进入<code>examples</code>文件夹 删去除<code>porting</code>文件夹</h4><p><img src="https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071814287.png" alt="image-20250907181406209"></p><h4 id="更改lv-conf-template-h"><a href="#更改lv-conf-template-h" class="headerlink" title="更改lv_conf_template.h"></a>更改<code>lv_conf_template.h</code></h4><blockquote><ol><li>将<code>lv_conf_template.h</code>更名为<code>lv_conf.h</code></li><li>进入该文件 将里面的#if 0 改为#if 1</li></ol><p><img src="https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071820299.png" alt="image-20250907182017202"></p></blockquote><h3 id="按以下结构创建文件夹"><a href="#按以下结构创建文件夹" class="headerlink" title="按以下结构创建文件夹"></a>按以下结构创建文件夹</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Project</span><br><span class="line">----Middlewares</span><br><span class="line">--------LVGL</span><br><span class="line">------------GUI</span><br><span class="line">----------------lvgl</span><br><span class="line">------------GUI_APP</span><br></pre></td></tr></table></figure><blockquote><p>将裁剪后的LVGL库文件复制到<code>Middlewares/LVGL/GUI/lvgl</code>文件夹下</p></blockquote><h3 id="Keil配置"><a href="#Keil配置" class="headerlink" title="Keil配置"></a>Keil配置</h3><h4 id="创建如下管理"><a href="#创建如下管理" class="headerlink" title="创建如下管理"></a>创建如下管理</h4><p><img src="https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071948050.png" alt="image-20250907194802955"></p><h4 id="添加路径"><a href="#添加路径" class="headerlink" title="添加路径"></a>添加路径</h4><p><img src="https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071948156.png" alt="image-20250907194859063"></p><blockquote><ul><li>注意一定要开启C99模式</li></ul><p><img src="https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071951544.png" alt="image-20250907195152454"></p><ul><li><p>可以屏蔽MDK警告</p><p>–diag_suppress&#x3D;68 –diag_suppress&#x3D;111 –diag_suppress&#x3D;188 –diag_suppress&#x3D;223 –diag_suppress&#x3D;546  –diag_suppress&#x3D;1295</p></li></ul></blockquote><h4 id="添加文件到项目"><a href="#添加文件到项目" class="headerlink" title="添加文件到项目"></a>添加文件到项目</h4><p><img src="https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071951610.png" alt="image-20250907195111490"></p><h3 id="LVGL文件修改"><a href="#LVGL文件修改" class="headerlink" title="LVGL文件修改"></a>LVGL文件修改</h3><h4 id="配置LCD屏幕显示"><a href="#配置LCD屏幕显示" class="headerlink" title="配置LCD屏幕显示"></a>配置LCD屏幕显示</h4><p><img src="https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071954102.png" alt="image-20250907195420988"></p><h5 id="包含输出设备驱动头文件"><a href="#包含输出设备驱动头文件" class="headerlink" title="包含输出设备驱动头文件"></a>包含输出设备驱动头文件</h5><blockquote><p>在<code>lv_port_disp_template.c</code>引入<code>lcd.h</code> 如<code>#include &quot;../BSP/LCD/lcd.h&quot;</code></p></blockquote><h5 id="在disp-init函数中初始化"><a href="#在disp-init函数中初始化" class="headerlink" title="在disp_init函数中初始化"></a>在<code>disp_init</code>函数中初始化</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">disp_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*You code here*/</span></span><br><span class="line">    LCD_Init();</span><br><span class="line">    LCD_Display_Dir(<span class="number">1</span>); <span class="comment">// 横屏</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="配置图形数据缓冲方式"><a href="#配置图形数据缓冲方式" class="headerlink" title="配置图形数据缓冲方式"></a>配置图形数据缓冲方式</h5><blockquote><p>进入<code>lv_port_disp_init</code>函数</p><p>选择缓冲方式 另外两个将其屏蔽</p><p><img src="https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071958994.png" alt="image-20250907195842896"></p></blockquote><h5 id="修改disp-flush函数"><a href="#修改disp-flush函数" class="headerlink" title="修改disp_flush函数"></a>修改<code>disp_flush</code>函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">disp_flush</span><span class="params">(<span class="type">lv_disp_drv_t</span> *disp_drv, <span class="type">const</span> <span class="type">lv_area_t</span> *area, <span class="type">lv_color_t</span> *color_p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*The most simple case (but also the slowest) to put all pixels to the screen one-by-one*/</span></span><br><span class="line">    <span class="comment">/*官方打点函数 */</span></span><br><span class="line">    <span class="comment">// int32_t x;</span></span><br><span class="line">    <span class="comment">// int32_t y;</span></span><br><span class="line">    <span class="comment">// for (y = area-&gt;y1; y &lt;= area-&gt;y2; y++)</span></span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">//     for (x = area-&gt;x1; x &lt;= area-&gt;x2; x++)</span></span><br><span class="line">    <span class="comment">//     &#123;</span></span><br><span class="line">    <span class="comment">//         /*Put a pixel to the display. For example:*/</span></span><br><span class="line">    <span class="comment">//         /*put_px(x, y, *color_p)*/</span></span><br><span class="line">    <span class="comment">//         color_p++;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    LCD_Color_Fill(area-&gt;x1, area-&gt;y1, area-&gt;x2, area-&gt;y2, (<span class="type">uint16_t</span> *)color_p);</span><br><span class="line">    <span class="comment">/*IMPORTANT!!!</span></span><br><span class="line"><span class="comment">     *Inform the graphics library that you are ready with the flushing*/</span></span><br><span class="line">    lv_disp_flush_ready(disp_drv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="配置输入（触摸）"><a href="#配置输入（触摸）" class="headerlink" title="配置输入（触摸）"></a>配置输入（触摸）</h4><p><img src="https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509072001216.png" alt="image-20250907200123083"></p><h5 id="按需裁剪输入设备"><a href="#按需裁剪输入设备" class="headerlink" title="按需裁剪输入设备"></a>按需裁剪输入设备</h5><blockquote><p>打开<code>lv_port_indev_template.c</code> 此处我们只需要触摸输入 所以把除了touchpad 其他都屏蔽或删去</p><p>注意：一定要把其他无关的屏蔽掉 否则会无法触摸</p></blockquote><h5 id="在touchpad-init函数中初始化触摸屏"><a href="#在touchpad-init函数中初始化触摸屏" class="headerlink" title="在touchpad_init函数中初始化触摸屏"></a>在<code>touchpad_init</code>函数中初始化触摸屏</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">touchpad_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*Your code comes here*/</span></span><br><span class="line">    tp_dev.init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="修改touchpad-is-pressed函数"><a href="#修改touchpad-is-pressed函数" class="headerlink" title="修改touchpad_is_pressed函数"></a>修改<code>touchpad_is_pressed</code>函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">touchpad_is_pressed</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*Your code comes here*/</span></span><br><span class="line">    tp_dev.scan(<span class="number">0</span>); <span class="comment">// É¨ÃèÎïÀí×ø±ê</span></span><br><span class="line">    <span class="keyword">if</span> (tp_dev.sta &amp; TP_PRES_DOWN)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="配置坐标获取函数"><a href="#配置坐标获取函数" class="headerlink" title="配置坐标获取函数"></a>配置坐标获取函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">touchpad_get_xy</span><span class="params">(<span class="type">lv_coord_t</span> *x, <span class="type">lv_coord_t</span> *y)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*Your code comes here*/</span></span><br><span class="line"></span><br><span class="line">    (*x) = tp_dev.x[<span class="number">0</span>];</span><br><span class="line">    (*y) = tp_dev.y[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="提供时基"><a href="#提供时基" class="headerlink" title="提供时基"></a>提供时基</h4><blockquote><ul><li>使用CubeMX生成一个定时1ms的定时器</li><li>在<code>tim.c</code>中引用<code>#include &quot;lvgl.h&quot;</code></li><li>在定时器中断回调函数中<code>lv_tick_inc(1);</code></li></ul></blockquote><p><img src="https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509072010067.png" alt="image-20250907201034944"></p><p><img src="https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509072008331.png" alt="image-20250907200845233"></p><h4 id="main函数部分"><a href="#main函数部分" class="headerlink" title="main函数部分"></a><code>main</code>函数部分</h4><p><img src="https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509072011915.png" alt="image-20250907201115783"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lvgl.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lv_port_disp_template.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lv_port_indev_template.h&quot;</span></span></span><br><span class="line">....</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    .....</span><br><span class="line">  HAL_TIM_Base_Start_IT(&amp;htim3); <span class="comment">// 启动定时器3中断 为lvgl提供时基</span></span><br><span class="line">  lv_init();                     <span class="comment">// 初始化LVGL</span></span><br><span class="line">  lv_port_disp_init();           <span class="comment">// 初始化显示接口</span></span><br><span class="line">  lv_port_indev_init();          <span class="comment">// 初始化输入接口</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    lv_timer_handler(); <span class="comment">// 处理LVGL任务</span></span><br><span class="line">    delay_ms(<span class="number">5</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> MCU </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LVGL v8.2 </tag>
            
            <tag> RTOS </tag>
            
            <tag> 嵌入式基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>freertos</title>
      <link href="/2025/09/05/freertos/"/>
      <url>/2025/09/05/freertos/</url>
      
        <content type="html"><![CDATA[<h2 id="FreeRTOS基础"><a href="#FreeRTOS基础" class="headerlink" title="FreeRTOS基础"></a>FreeRTOS基础</h2><h3 id="获取系统时间"><a href="#获取系统时间" class="headerlink" title="获取系统时间"></a>获取系统时间</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">TickType_t currentTicks;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">     currentTicks = xTaskGetTickCount();</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;[%lu]dev:%u,name:%s\r\n&quot;</span>, currentTicks, data-&gt;dev, data-&gt;data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="堆和栈"><a href="#堆和栈" class="headerlink" title="堆和栈"></a>堆和栈</h3><p>堆：一块空闲的内存 可以使用<code>malloc</code>申请内存 使用完后用<code>free</code>释放内存</p><blockquote><p>堆也可以理解为就是定义了一个堆大小的数组 然后定义一个长度 每次动态改变长度来申请空间（链表）</p><p>在<code>FreeRTOSConfig.h</code>中就有定义堆大小的宏<code>configTOTAL_HEAP_SIZE</code> 他被引用到 <code>heap.c</code>中的 <code>static uint8_t ucHeap[configTOTAL_HEAP_SIZE];</code></p></blockquote><p>栈：一块内存空间，CPU的SP寄存器指向它，它可以用于函数调用、局部变量、<code>多任务系统里保存现场</code></p><blockquote><p>栈是<code>FreeRTOS</code>中非常重要的概念，每个任务都有自己的栈</p></blockquote><h3 id="FreeRTOS源码概述"><a href="#FreeRTOS源码概述" class="headerlink" title="FreeRTOS源码概述"></a>FreeRTOS源码概述</h3><h4 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h4><p><img src="https://photos.100ask.net/renesas-docs/DShanMCU_RA6M5/FreeRTOS/chapter-6/image1.png" alt="img"></p><blockquote><p>主要涉及3个目录：</p><ul><li><code>ra\aws\FreeRTOS\FreeRTOS\Source</code>：存放的是FreeRTOS的核心文件</li><li><code>ra_gen</code>：从main.c可以看到创建任务的函数调用过程</li><li><code>src</code>：使用RASC创建任务时，在src目录下生成任务的入口函数</li></ul></blockquote><h4 id="核心文件"><a href="#核心文件" class="headerlink" title="核心文件"></a>核心文件</h4><blockquote><p>FreeRTOS的最核心文件只有2个：</p><ul><li><code>FreeRTOS/Source/tasks.c</code></li><li><code>FreeRTOS/Source/list.c</code></li></ul></blockquote><p>其他文件的作用也一起列表如下：</p><table><thead><tr><th><strong><code>FreeRTOS/Source/</code>下的文件</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td><code>tasks.c</code></td><td>必需，任务操作</td></tr><tr><td><code>list.c</code></td><td>必须，列表</td></tr><tr><td><code>queue.c</code></td><td>基本必需，提供队列操作、信号量(semaphore)操作</td></tr><tr><td><code>timer.c</code></td><td>可选，software timer</td></tr><tr><td><code>event_groups.c</code></td><td>可选，提供event group功能</td></tr></tbody></table><h4 id="头文件相关"><a href="#头文件相关" class="headerlink" title="头文件相关"></a>头文件相关</h4><h5 id="头文件目录"><a href="#头文件目录" class="headerlink" title="头文件目录"></a>头文件目录</h5><blockquote><p>FreeRTOS需要3个头文件目录：</p><ul><li>FreeRTOS本身的头文件：<code>ra\aws\FreeRTOS\FreeRTOS\Source\include</code></li><li>移植时用到的头文件：<code>ra\fsp\src\rm_freertos_port\portmacro.h</code></li><li>含有配置文件<code>FreeRTOSConfig.h</code>的目录：<code>ra_cfg\aws</code></li></ul></blockquote><h5 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h5><p>列表如下：</p><table><thead><tr><th><strong>头文件</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td><code>FreeRTOSConfig.h</code></td><td>FreeRTOS的配置文件，比如选择调度算法：<code>configUSE_PREEMPTION</code> 每个工程都必定含有<code>FreeRTOSConfig.h</code></td></tr><tr><td><code>FreeRTOS.h</code></td><td>使用FreeRTOS API函数时，<span style="font-weight:bold;">必须</span>包含此文件。 在<code>FreeRTOS.h</code>之后，再去包含其他头文件，比如： <code>task.h</code>、<code>queue.h</code>、<code>semphr.h</code>、<code>event_group.h</code></td></tr></tbody></table><h4 id="独属于FreeRTOS的数据类型和编程规范"><a href="#独属于FreeRTOS的数据类型和编程规范" class="headerlink" title="独属于FreeRTOS的数据类型和编程规范"></a>独属于FreeRTOS的数据类型和编程规范</h4><h5 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h5><p>每个移植的版本都含有自己的 <strong><code>portmacro.h</code></strong> 头文件，里面定义了2个数据类型：</p><ol><li><code>TickType_t</code>：<ul><li>时钟计数单位 （可以是uint16_t 也可以是uint32_t）<br>当<code>FreeRTOSConfig.h</code>中定义<code>configUSE_16_BIT_TICKS时 TickType_t</code>则为uint16_t</li></ul></li></ol><blockquote><p>对于32位架构，建议把TickType_t配置为uint32_t</p></blockquote><ol start="2"><li><code>BaseType_t</code>:这是该架构最高效的数据类型(取决于CPU是多少位的架构)<ul><li><code>BaseType_t</code>通常用作简单的返回值的类型，还有逻辑值，比如 <strong>pdTRUE&#x2F;pdFALSE</strong></li></ul></li></ol><h5 id="变量名"><a href="#变量名" class="headerlink" title="变量名"></a>变量名</h5><p>变量名的前缀 对应其类型 如：<code>pcName</code> (代表着他是一个指向char类型的指针p)</p><table><thead><tr><th><strong>变量名前缀</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>c</td><td>char</td></tr><tr><td>s</td><td>int16_t，short</td></tr><tr><td>l</td><td>int32_t，long</td></tr><tr><td>x</td><td>BaseType_t， 其他非标准的类型：结构体、task handle、queue handle等</td></tr><tr><td>u</td><td>unsigned</td></tr><tr><td>p</td><td>指针</td></tr><tr><td>uc</td><td>uint8_t，unsigned char</td></tr><tr><td>pc</td><td>char指针</td></tr></tbody></table><h5 id="函数名"><a href="#函数名" class="headerlink" title="函数名"></a>函数名</h5><p>函数名的前缀有2部分：返回值类型、在哪个文件定义。</p><table><thead><tr><th><strong>函数名前缀</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>v<span style="font-weight:bold;">Task</span>PrioritySet</td><td>返回值类型：void 在<code>task.c</code>中定义</td></tr><tr><td>x<span style="font-weight:bold;">Queue</span>Receive</td><td>返回值类型：BaseType_t 在<code>queue.c</code>中定义</td></tr><tr><td>pv<span style="font-weight:bold;">Timer</span>GetTimerID</td><td>返回值类型：pointer to void 在<code>tmer.c</code>中定义</td></tr></tbody></table><h5 id="宏的名"><a href="#宏的名" class="headerlink" title="宏的名"></a>宏的名</h5><p>宏的名字是大小，可以添加小写的前缀。前缀是用来表示：宏在<span style="font-weight:bold;">哪个文件</span>中定义。</p><table><thead><tr><th><strong>宏的前缀</strong></th><th><strong>含义：在哪个文件里定义</strong></th></tr></thead><tbody><tr><td>port (比如<span style="font-weight:bold;">port</span>MAX_DELAY)</td><td><code>portable.h</code>或<code>portmacro.h</code></td></tr><tr><td>task (比如<span style="font-weight:bold;">task</span>ENTER_CRITICAL())</td><td><code>task.h</code></td></tr><tr><td>pd (比如<span style="font-weight:bold;">pd</span>TRUE)</td><td><code>projdefs.h</code></td></tr><tr><td>config (比如<span style="font-weight:bold;">config</span>USE_PREEMPTION)</td><td><code>FreeRTOSConfig.h</code></td></tr><tr><td>err (比如<span style="font-weight:bold;">err</span>QUEUE_FULL)</td><td><code>projdefs.h</code></td></tr></tbody></table><p>通用的宏定义如下：</p><table><thead><tr><th><strong>宏</strong></th><th><strong>值</strong></th></tr></thead><tbody><tr><td><code>pdTRUE</code></td><td>1</td></tr><tr><td><code>pdFALSE</code></td><td>0</td></tr><tr><td><code>pdPASS</code></td><td>1</td></tr><tr><td><code>pdFAIL</code></td><td>0</td></tr></tbody></table><h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><blockquote><p> FreeRTOS中内存管理的接口函数为：<code>pvPortMalloc</code> 、<code>vPortFree</code>，对应于C库的<code>malloc</code>、<code>free</code>。 文件在<code>FreeRTOS/Source/portable/MemMang</code>下，它也是放在<code>portable目录</code>下，表示你可以提供自己的函数。</p><p>源码中默认提供了5个文件，对应内存管理的5种方法。</p></blockquote><table><thead><tr><th><strong>文件</strong></th><th><strong>优点</strong></th><th><strong>缺点</strong></th></tr></thead><tbody><tr><td><code>heap_1.c</code></td><td>分配简单，时间确定</td><td>只分配、<span style="color:#FF0000;">不回收</span></td></tr><tr><td><code>heap_2.c</code></td><td>动态分配、最佳匹配</td><td><span style="color:#FF0000;">碎片</span>、时间不定</td></tr><tr><td><code>heap_3.c</code></td><td>调用<span style="color:#FF3333;">标准库</span>函数</td><td><span style="color:#FF0000;">速度慢</span>、时间不定</td></tr><tr><td><code>heap_4.c</code>(常用)</td><td>相邻空闲内存可合并</td><td>可解决碎片问题、时间不定</td></tr><tr><td><code>heap_5.c</code></td><td>在heap_4基础上支持分隔的内存块</td><td>可解决碎片问题、时间不定</td></tr></tbody></table><h4 id="Heap相关的函数"><a href="#Heap相关的函数" class="headerlink" title="Heap相关的函数"></a>Heap相关的函数</h4><h5 id="分配、释放内存"><a href="#分配、释放内存" class="headerlink" title="分配、释放内存"></a>分配、释放内存</h5><p>函数原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> * <span class="title function_">pvPortMalloc</span><span class="params">( <span class="type">size_t</span> xWantedSize )</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">vPortFree</span><span class="params">( <span class="type">void</span> * pv )</span>;</span><br></pre></td></tr></table></figure><p>作用：分配内存、释放内存。</p><p>如果分配内存不成功，则返回值为NULL。</p><h5 id="检测剩余多少空闲内存"><a href="#检测剩余多少空闲内存" class="headerlink" title="检测剩余多少空闲内存"></a>检测剩余多少空闲内存</h5><p>函数原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">xPortGetFreeHeapSize</span><span class="params">( <span class="type">void</span> )</span>;</span><br></pre></td></tr></table></figure><blockquote><p>当前还有多少空闲内存，这函数可以用来优化内存的使用情况。比如当所有内核对象都分配好后，执行此函数返回2000，那么<code>configTOTAL_HEAP_SIZE</code>就可减小2000。</p></blockquote><p>注意：在heap_3中无法使用。</p><h5 id="获取空闲内存容量的最小值"><a href="#获取空闲内存容量的最小值" class="headerlink" title="获取空闲内存容量的最小值"></a>获取空闲内存容量的最小值</h5><p>函数原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">xPortGetMinimumEverFreeHeapSize</span><span class="params">( <span class="type">void</span> )</span>;</span><br></pre></td></tr></table></figure><p>返回：程序运行过程中，空闲内存容量的最小值。</p><p>注意：只有heap_4、heap_5支持此函数。</p><h5 id="malloc失败的钩子函数"><a href="#malloc失败的钩子函数" class="headerlink" title="malloc失败的钩子函数"></a><code>malloc失败的钩子函数</code></h5><p>在pvPortMalloc函数内部：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> * <span class="title function_">pvPortMalloc</span><span class="params">( <span class="type">size_t</span> xWantedSize )</span>vPortDefineHeapRegions</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> ( configUSE_MALLOC_FAILED_HOOK == 1 )</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( pvReturn == <span class="literal">NULL</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">vApplicationMallocFailedHook</span><span class="params">( <span class="type">void</span> )</span>;</span><br><span class="line">                vApplicationMallocFailedHook();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> pvReturn;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，如果想使用这个钩子函数：</p><ul><li>在<code>FreeRTOSConfig.h</code>中，把<code>configUSE_MALLOC_FAILED_HOOK</code>定义为1</li><li>提供<code>vApplicationMallocFailedHook</code>函数</li><li><code>pvPortMalloc</code>失败时，才会调用此函数</li></ul><h3 id="任务管理"><a href="#任务管理" class="headerlink" title="任务管理"></a>任务管理</h3><h4 id="任务创建与删除"><a href="#任务创建与删除" class="headerlink" title="任务创建与删除"></a>任务创建与删除</h4><h5 id="什么是任务"><a href="#什么是任务" class="headerlink" title="什么是任务"></a>什么是任务</h5><p>在FreeRTOS中，任务就是一个函数，原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ATaskFunction</span><span class="params">( <span class="type">void</span> *pvParameters )</span>;</span><br></pre></td></tr></table></figure><p>要注意的是：</p><ul><li>这个函数不能返回</li><li>同一个函数，可以用来创建多个任务；换句话说，多个任务可以运行同一个函数</li><li>函数内部，尽量使用局部变量：<ul><li>每个任务都有自己的栈</li><li>每个任务运行这个函数时<ul><li>任务A的局部变量放在任务A的栈里、任务B的局部变量放在任务B的栈里</li><li>不同任务的局部变量，有自己的副本</li></ul></li><li>函数使用全局变量、静态变量的话<ul><li>只有一个副本：多个任务使用的是同一个副本</li><li>要防止冲突(后续会讲) 下面是一个示例：</li></ul></li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ATaskFunction</span><span class="params">( <span class="type">void</span> *pvParameters )</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 对于不同的任务，局部变量放在任务的栈里，有各自的副本 */</span></span><br><span class="line"><span class="type">int32_t</span> lVariableExample = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 任务函数通常实现为一个无限循环 */</span></span><br><span class="line"><span class="keyword">for</span>( ;; )</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 任务的代码 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果程序从循环中退出，一定要使用vTaskDelete删除自己</span></span><br><span class="line"><span class="comment">     * NULL表示删除的是自己</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">vTaskDelete( <span class="literal">NULL</span> );</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 程序不会执行到这里, 如果执行到这里就出错了 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="创建任务"><a href="#创建任务" class="headerlink" title="创建任务"></a>创建任务</h5><p>创建任务时使用的函数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xTaskCreate</span><span class="params">( TaskFunction_t pxTaskCode, <span class="comment">// 函数指针, 任务函数</span></span></span><br><span class="line"><span class="params">                        <span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> pcName, <span class="comment">// 任务的名字</span></span></span><br><span class="line"><span class="params">                        <span class="type">const</span> configSTACK_DEPTH_TYPE usStackDepth, <span class="comment">// 栈大小,单位为word,10表示40字节</span></span></span><br><span class="line"><span class="params">                        <span class="type">void</span> * <span class="type">const</span> pvParameters, <span class="comment">// 调用任务函数时传入的参数</span></span></span><br><span class="line"><span class="params">                        UBaseType_t uxPriority,    <span class="comment">// 优先级</span></span></span><br><span class="line"><span class="params">                        TaskHandle_t * <span class="type">const</span> pxCreatedTask )</span>; <span class="comment">// 任务句柄, 以后使用它来操作这个任务</span></span><br></pre></td></tr></table></figure><p>参数说明：</p><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>pvTaskCode</td><td>函数指针，任务对应的 C 函数。任务应该永远不退出，或者在退出时调用 “<code>vTaskDelete(NULL)</code>“。</td></tr><tr><td>pcName</td><td>任务的名称，仅用于调试目的，FreeRTOS 内部不使用。pcName 的长度为 <code>configMAX_TASK_NAME_LEN</code>。</td></tr><tr><td>usStackDepth</td><td>每个任务都有自己的栈，usStackDepth 指定了栈的大小，单位为 word。例如，如果传入 100，表示栈的大小为 100 word，即 400 字节。最大值为 uint16_t 的最大值。确定栈的大小并不容易，通常是根据估计来设定。精确的办法是查看反汇编代码。</td></tr><tr><td>pvParameters</td><td>调用 pvTaskCode 函数指针时使用的参数：<code>pvTaskCode(pvParameters)</code>。</td></tr><tr><td>uxPriority</td><td>任务的优先级范围为 0~(<code>configMAX_PRIORITIES – 1</code>)。数值越小，优先级越低。如果传入的值过大，<code>xTaskCreate </code>会将其调整为 (<code>configMAX_PRIORITIES – 1</code>)。</td></tr><tr><td>pxCreatedTask</td><td>用于保存 xTaskCreate 的输出结果，即任务的句柄（task handle）。如果以后需要对该任务进行操作，如修改优先级，则需要使用此句柄。如果不需要使用该句柄，可以传入 NULL。</td></tr><tr><td>返回值</td><td>成功时返回 pdPASS，失败时返回 <code>errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY</code>（失败原因是内存不足）。请注意，文档中提到的失败返回值是 pdFAIL 是不正确的。pdFAIL 的值为 0，而 <code>errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY</code> 的值为 -1。</td></tr></tbody></table><p>使用静态分配内存的函数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">TaskHandle_t <span class="title function_">xTaskCreateStatic</span> <span class="params">( </span></span><br><span class="line"><span class="params">    TaskFunction_t pxTaskCode,   <span class="comment">// 函数指针, 任务函数</span></span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> pcName,   <span class="comment">// 任务的名字</span></span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="type">uint32_t</span> ulStackDepth, <span class="comment">// 栈大小,单位为word,10表示40字节</span></span></span><br><span class="line"><span class="params">    <span class="type">void</span> * <span class="type">const</span> pvParameters,   <span class="comment">// 调用任务函数时传入的参数</span></span></span><br><span class="line"><span class="params">    UBaseType_t uxPriority,      <span class="comment">// 优先级</span></span></span><br><span class="line"><span class="params">    StackType_t * <span class="type">const</span> puxStackBuffer, <span class="comment">// 静态分配的栈，就是一个buffer</span></span></span><br><span class="line"><span class="params">    StaticTask_t * <span class="type">const</span> pxTaskBuffer <span class="comment">// 静态分配的任务结构体的指针，用它来操作这个任务</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p>相比于使用动态分配内存创建任务的函数，最后2个参数不一样：</p><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>pvTaskCode</td><td>函数指针，可以简单地认为任务就是一个C函数。 它稍微特殊一点：永远不退出，或者退出时要调用”<code>vTaskDelete(NULL)</code>“</td></tr><tr><td>pcName</td><td>任务的名字，FreeRTOS内部不使用它，仅仅起调试作用。 长度为：<code>configMAX_TASK_NAME_LEN</code></td></tr><tr><td>usStackDepth</td><td>每个任务都有自己的栈，这里指定栈大小。 单位是word，比如传入100，表示栈大小为100 word，也就是400字节。 最大值为uint16_t的最大值。 怎么确定栈的大小，并不容易，很多时候是估计。 精确的办法是看反汇编码。</td></tr><tr><td>pvParameters</td><td>调用pvTaskCode函数指针时用到：pvTaskCode(pvParameters)</td></tr><tr><td>uxPriority</td><td>优先级范围：0~(<code>configMAX_PRIORITIES – 1</code>) 数值越小优先级越低， 如果传入过大的值，<code>xTaskCreate</code>会把它调整为(<code>configMAX_PRIORITIES – 1</code>)</td></tr><tr><td>puxStackBuffer</td><td>静态分配的栈内存，比如可以传入一个数组， 它的大小是<code>usStackDepth*4</code>。</td></tr><tr><td>pxTaskBuffer</td><td>静态分配的<code>StaticTask_t</code>结构体的指针</td></tr><tr><td>返回值</td><td>成功：返回任务句柄； 失败：NULL</td></tr></tbody></table><h4 id="任务栈大小估算"><a href="#任务栈大小估算" class="headerlink" title="任务栈大小估算"></a>任务栈大小估算</h4><p>任务栈空间包含</p><ul><li>返回地址<code>LR</code>与其他寄存器：可以理解为<span style="color:#FF0000;">函数调用深度</span></li><li>局部变量：如<code>char buff[1000]</code> 直接看类型 此处则可以算1个</li><li>保留现场：可以理解为固定16个寄存器 即<span style="color:#FF3333;">16 * 4 &#x3D; 64b</span></li></ul><blockquote><p>公式如下：</p><ul><li><p>（n层调用 * 36） + 局部变量 + 64b</p></li><li><p>例如：</p><p><img src="https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509142214793.png" alt="image-20250914221448446"></p></li></ul></blockquote><h4 id="使用任务参数"><a href="#使用任务参数" class="headerlink" title="使用任务参数"></a>使用任务参数</h4><p>我们说过，多个任务可以使用同一个函数，怎么体现它们的差别？</p><ul><li>栈不同</li><li>创建任务时可以传入不同的参数</li></ul><p>我们创建2个任务，使用同一个函数，但是在LCD上打印不一样的信息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *str;</span><br><span class="line">&#125;DisplayInfo;</span><br><span class="line"><span class="type">void</span> <span class="title function_">vTaskFunction</span><span class="params">( <span class="type">void</span> *pvParameters )</span></span><br><span class="line">&#123;</span><br><span class="line">DisplayInfo *info = pvParameters;</span><br><span class="line"><span class="type">uint32_t</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="type">uint32_t</span> len;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 任务函数的主体一般都是无限循环 */</span></span><br><span class="line"><span class="keyword">for</span>( ;; )</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 打印任务的信息 */</span></span><br><span class="line">len = LCD_PrintString(info-&gt;x, info-&gt;y, info-&gt;str);</span><br><span class="line">LCD_PrintSignedVal(len+<span class="number">1</span>, info-&gt;y, cnt++);</span><br><span class="line"></span><br><span class="line">mdelay(<span class="number">500</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中的info来自参数pvParameters，pvParameters来自哪里？创建任务时传入的。</p><p>代码如下：</p><ul><li>使用xTaskCreate创建任务时，第4个参数就是pvParameters</li><li>不同的任务，pvParameters不一样</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DisplayInfo g_Task1Info =&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="string">&quot;task1&quot;</span>&#125;;</span><br><span class="line">DisplayInfo g_Task2Info =&#123;<span class="number">3</span>,<span class="number">0</span>,<span class="string">&quot;task2&quot;</span>&#125;;</span><br><span class="line">DisplayInfo g_Task3Info =&#123;<span class="number">6</span>,<span class="number">0</span>,<span class="string">&quot;task3&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使用同一个函数创建不同的任务 */</span></span><br><span class="line">  xTaskCreate(LcdPrintTask, <span class="string">&quot;task1&quot;</span>, <span class="number">128</span>, &amp;g_Task1Info, osPriorityNormal, <span class="literal">NULL</span>);</span><br><span class="line">  xTaskCreate(LcdPrintTask, <span class="string">&quot;task2&quot;</span>, <span class="number">128</span>, &amp;g_Task2Info, osPriorityNormal, <span class="literal">NULL</span>);</span><br><span class="line">  xTaskCreate(LcdPrintTask, <span class="string">&quot;task3&quot;</span>, <span class="number">128</span>, &amp;g_Task3Info, osPriorityNormal, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><h4 id="任务的删除"><a href="#任务的删除" class="headerlink" title="任务的删除"></a>任务的删除</h4><p>删除任务时使用的函数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vTaskDelete</span><span class="params">( TaskHandle_t xTaskToDelete )</span>;</span><br></pre></td></tr></table></figure><p>参数说明：</p><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>pvTaskCode</td><td>任务句柄，使用xTaskCreate创建任务时可以得到一个句柄。 也可传入NULL，这表示删除自己。</td></tr></tbody></table><p>怎么删除任务？举个不好的例子：</p><ul><li>自杀：<code>vTaskDelete(NULL)</code></li><li>被杀：别的任务执行<code>vTaskDelete(pvTaskCode)</code>，<code>pvTaskCode</code>是自己的句柄</li><li>杀人：执行<code>vTaskDelete(pvTaskCode)</code>，<code>pvTaskCode</code>是别的任务的句柄</li></ul><h4 id="任务管理与调度机制"><a href="#任务管理与调度机制" class="headerlink" title="任务管理与调度机制"></a>任务管理与调度机制</h4><h5 id="调度机制"><a href="#调度机制" class="headerlink" title="调度机制"></a>调度机制</h5><blockquote><ul><li>同等优先级的任务 轮流运行</li><li>最高优先级的任务先运行<ul><li>高优先级的任务未运行完，低优先级任务无法运行</li><li>一旦高优先级任务就绪 马上运行</li><li>最高优先级的任务有多个 他们轮流运行</li></ul></li></ul></blockquote><p><img src="https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509151548547.png" alt="img"></p><h5 id="任务管理-1"><a href="#任务管理-1" class="headerlink" title="任务管理"></a>任务管理</h5><p>任务的切换通过链表操作进行切换 RTOS会创建3个链表 分别是就绪链表ReadyList、阻塞链表DelayTaskList、挂起链表</p><ul><li><p>先在优先级数组中按下标从大到小遍历，使用任务创建函数<span style="color:#33FFFF;">本质其实是在对应优先级数组中创建TCB结构体，并且会有一个全局指针——当前执行TCB结构体pxCurrentTCB</span>，这就说明了为什么同等优先级下，最后创建的任务先运行（因为指针最终指向了最后一个任务链表，启动调度器后，开始运行）</p></li><li><p>当调用<code>vTaskDelay</code>后会将当前任务链表丢到阻塞链表上，并根据<code>vTaskDelay</code>的参数等待<code>Tick中断</code>判断到达时间后，该任务链表才能再次回到原先链表上</p></li><li><p>当任务调用<code>vTaskSuspend</code>后 当前任务会被丢到挂起链表，此任务只有调用<code>vTaskResume</code>才能回到原先链表，不能通过<code>Tick中断</code>回归</p></li></ul><blockquote><p>Tick中断是什么？他又做些什么？</p><ul><li><p>Tick中断来源于</p><p><img src="https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509151600535.png" alt="image-20250915160032344"></p></li><li><p>Tick中断做什么？</p><ol><li>有个计数器count，count一直执行++</li><li>判断DelayTaskList里任务是否可以恢复（可恢复则将其丢到ReadyList）</li><li>发起调度（遍历优先级数组，改变pxCurrentTCB指针指向）</li></ol></li></ul></blockquote><h5 id="空闲任务"><a href="#空闲任务" class="headerlink" title="空闲任务"></a>空闲任务</h5><p>空闲任务是Freertos启动调度器时 会自动创建的一个最低优先级的任务<code>prvIdleTask</code></p><ul><li>负责清理用户的自杀任务 如<code>vTaskDelete(NULL)</code>的内存释放</li><li>由于优先级最低 所以当用户任务不释放CPU时，就会导致空闲任务不会运行，因而<code>vTaskDelete(NULL)</code>得不到释放</li><li>因此尽量不要使用死延时，改用<code>vTaskDelay</code>释放CPU 或者不使用自杀函数<code>vTaskDelete(NULL)</code></li></ul><blockquote><p>此外 空闲任务中还有提供钩子函数 可以方便我们在里面打印调试信息</p><p>注意每个任务都要使用while(1)进行死循环</p><ul><li>如果有一个任务没有则会触发任务退出错误中断<code>prvTaskExitError</code></li><li><img src="https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509151634028.png" alt="image-20250915163446773"></li></ul></blockquote><h3 id="同步与互斥"><a href="#同步与互斥" class="headerlink" title="同步与互斥"></a>同步与互斥</h3><h4 id="同步与互斥的概念"><a href="#同步与互斥的概念" class="headerlink" title="同步与互斥的概念"></a>同步与互斥的概念</h4><p>一句话理解同步与互斥：我等你用完厕所，我再用厕所。</p><ul><li>什么叫同步？就是：哎哎哎，我正在用厕所，你等会。 </li><li>什么叫互斥？就是：哎哎哎，我正在用厕所，你不能进来。</li></ul><p>同步与互斥经常放在一起讲，是因为它们之的关系很大，“互斥”操作可以使用“同步”来实现。我“等”你用完厕所，我再用厕所。这不就是用“同步”来实现“互斥”吗？</p><p>再举一个例子。在团队活动里，同事A先写完报表，经理B才能拿去向领导汇报。经理B必须等同事A完成报表，AB之间有依赖，B必须放慢脚步，被称为同步。在团队活动中，同事A已经使用会议室了，经理B也想使用，即使经理B是领导，他也得等着，这就叫互斥。经理B跟同事A说：你用完会议室就提醒我。这就是使用”同步”来实现”互斥”。</p><p>有时候看代码更容易理解，伪代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>  抢厕所(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (有人在用) 我眯一会;</span><br><span class="line">  用厕所;</span><br><span class="line">  喂，醒醒，有人要用厕所吗;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设有A、B两人早起抢厕所，A先行一步占用了；B慢了一步，于是就眯一会；当A用完后叫醒B，B也就愉快地上厕所了。</p><p>在这个过程中，A、B是互斥地访问“厕所”，“厕所”被称之为临界资源。我们使用了“休眠-唤醒”的同步机制实现了“临界资源”的“互斥访问”。</p><p>同一时间只能有一个人使用的资源，被称为临界资源。比如任务A、B都要使用串口来打印，串口就是临界资源。如果A、B同时使用串口，那么打印出来的信息就是A、B混杂，无法分辨。所以使用串口时，应该是这样：A用完，B再用；B用完，A再用</p><h4 id="各类方法的对比"><a href="#各类方法的对比" class="headerlink" title="各类方法的对比"></a>各类方法的对比</h4><p>能实现同步、互斥的内核方法有：任务通知(task notification)、队列(queue)、事件组(event group)、信号量(semaphoe)、互斥量(mutex)。</p><p>它们都有类似的操作方法：获取&#x2F;释放、阻塞&#x2F;唤醒、超时。比如：</p><ul><li>任务A获取资源，用完后任务A释放资源</li><li>任务A获取不到资源则阻塞，任务B释放资源并把任务A唤醒</li><li>任务A获取不到资源则阻塞，并定个闹钟；A要么超时返回，要么在这段时间内因为任务B释放资源而被唤醒。</li></ul><p>这些内核对象五花八门，记不住怎么办？我也记不住，通过对比的方法来区分它们。</p><ul><li>能否传信息？还是只能传递状态？</li><li>为众生（所有任务都可以使用）？只为你（只能指定任务使用）？</li><li>我生产，你们消费？</li><li>我上锁，只能由我开锁</li></ul><table><thead><tr><th><strong>内核对象</strong></th><th><strong>生产者</strong></th><th><strong>消费者</strong></th><th><strong>数据&#x2F;状态</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>队列</td><td>ALL</td><td>ALL</td><td>数据：若干个数据 谁都可以往队列里扔数据， 谁都可以从队列里读数据</td><td>用来传递数据， 发送者、接收者无限制， 一个数据只能唤醒一个接收者</td></tr><tr><td>事件组</td><td>ALL</td><td>ALL</td><td>多个位：或、与 谁都可以设置(生产)多个位， 谁都可以等待某个位、若干个位</td><td>用来传递事件， 可以是N个事件， 发送者、接受者无限制， 可以唤醒多个接收者：像广播</td></tr><tr><td>信号量</td><td>ALL</td><td>ALL</td><td>数量：0~n 谁都可以增加一个数量， 谁都可消耗一个数量</td><td>用来维持资源的个数， 生产者、消费者无限制， 1个资源只能唤醒1个接收者</td></tr><tr><td>任务通知</td><td>ALL</td><td>只有我</td><td>数据、状态都可以传输， 使用任务通知时， 必须指定接受者</td><td>N对1的关系： 发送者无限制， 接收者只能是这个任务</td></tr><tr><td>互斥量</td><td>只能A开锁</td><td>A上锁</td><td>位：0、1 我上锁：1变为0， 只能由我开锁：0变为1</td><td>就像一个空厕所， 谁使用谁上锁， 也只能由他开锁</td></tr></tbody></table><p>使用图形对比如下：</p><ul><li>队列：<ul><li>里面可以放任意数据，可以放多个数据</li><li>任务、ISR都可以放入数据；任务、ISR都可以从中读出数据</li></ul></li><li>事件组：<ul><li>一个事件用一bit表示，1表示事件发生了，0表示事件没发生</li><li>可以用来表示事件、事件的组合发生了，不能传递数据</li><li>有广播效果：事件或事件的组合发生了，等待它的多个任务都会被唤醒</li></ul></li><li>信号量：<ul><li>核心是”计数值”</li><li>任务、ISR释放信号量时让计数值加1</li><li>任务、ISR获得信号量时，让计数值减1</li></ul></li><li>任务通知：<ul><li>核心是任务的TCB里的数值</li><li>会被覆盖</li><li>发通知给谁？必须指定接收任务</li><li>只能由接收任务本身获取该通知</li></ul></li><li>互斥量：<ul><li>数值只有0或1</li><li>谁获得互斥量，就必须由谁释放同一个互斥量</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509151740912.png" alt="img"></p><blockquote><p>为何要引用这些机制呢？</p><ul><li>原本逻辑可以采用全局变量来进行传递信息，但在RTOS下，可能还未来得及改变全局变量的值就被切换到其他任务，这样就会发生全局变量未及时更新的问题</li><li>引入事件阻塞与唤醒大大提高了CPU的利用率<ul><li>当任务A计数1s，任务B负责打印任务A的最终计数值，就不会出现A运行，B也运行，而是等待A运行完后通知任务B，或大概估算任务A结束的时间，让B阻塞这么多的时间，这样就实现了整个时间轴都是任务A在运行</li></ul></li></ul></blockquote><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><h4 id="队列的本质"><a href="#队列的本质" class="headerlink" title="队列的本质"></a>队列的本质</h4><p>队列中，数据的读写就是环形缓冲区，在这个基础上增加了互斥措施、阻塞-唤醒机制</p><ul><li>如果这个队列不传输数据，只调整“数据个数”，他就是信号量（semaphore）</li><li>如果信号量中，限定“数据个数”最大值为1，他就是互斥量（mutex）</li></ul><h4 id="传输数据的两种方法"><a href="#传输数据的两种方法" class="headerlink" title="传输数据的两种方法"></a>传输数据的两种方法</h4><p>使用队列传输数据时有两种方法：</p><ul><li>拷贝：把数据、把变量的值复制进队列里</li><li>引用：把数据、把变量的地址复制进队列里</li></ul><p>FreeRTOS使用拷贝值的方法，这更简单：</p><ul><li>局部变量的值可以发送到队列中，后续即使函数退出、局部变量被回收，也不会影响队列中的数据</li><li>无需分配buffer来保存数据，队列中有buffer</li><li>局部变量可以马上再次使用</li><li>发送任务、接收任务解耦：接收任务不需要知道这数据是谁的、也不需要发送任务来释放数据</li><li>如果数据实在太大，你还是可以使用队列传输它的地址</li><li>队列的空间有FreeRTOS内核分配，无需任务操心</li><li>对于有内存保护功能的系统，如果队列使用引用方法，也就是使用地址，必须确保双方任务对这个地址都有访问权限。使用拷贝方法时，则无此限制：内核有足够的权限，把数据复制进队列、再把数据复制出队列。</li></ul><h4 id="队列的阻塞访问"><a href="#队列的阻塞访问" class="headerlink" title="队列的阻塞访问"></a>队列的阻塞访问</h4><p>只要知道队列的句柄，谁都可以读、写该队列。任务、ISR都可读、写队列。可以多个任务读写队列。</p><p>任务读写队列时，简单地说：如果读写不成功，则阻塞；可以指定超时时间。口语化地说，就是可以定个闹钟：如果能读写了就马上进入就绪态，否则就阻塞直到超时。</p><p>某个任务读队列时，如果队列没有数据，则该任务可以进入阻塞状态：还可以指定阻塞的时间。如果队列有数据了，则该阻塞的任务会变为就绪态。如果一直都没有数据，则时间到之后它也会进入就绪态。</p><p>既然读取队列的任务个数没有限制，那么当多个任务读取空队列时，这些任务都会进入阻塞状态：有多个任务在等待同一个队列的数据。当队列中有数据时，哪个任务会进入就绪态？</p><ul><li>优先级最高的任务</li><li>如果大家的优先级相同，那等待时间最久的任务会进入就绪态</li></ul><p>跟读队列类似，一个任务要写队列时，如果队列满了，该任务也可以进入阻塞状态：还可以指定阻塞的时间。如果队列有空间了，则该阻塞的任务会变为就绪态。如果一直都没有空间，则时间到之后它也会进入就绪态。</p><p>既然写队列的任务个数没有限制，那么当多个任务写”满队列”时，这些任务都会进入阻塞状态：有多个任务在等待同一个队列的空间。当队列中有空间时，哪个任务会进入就绪态？</p><ul><li>优先级最高的任务</li><li>如果大家的优先级相同，那等待时间最久的任务会进入就绪态</li></ul><h4 id="队列函数"><a href="#队列函数" class="headerlink" title="队列函数"></a>队列函数</h4><h5 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h5><p>队列的创建有两种方法：动态分配内存、静态分配内存，</p><ul><li>动态分配内存：xQueueCreate，队列的内存在函数内部动态分配</li></ul><p>函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QueueHandle_t <span class="title function_">xQueueCreate</span><span class="params">( UBaseType_t uxQueueLength, UBaseType_t uxItemSize )</span>;</span><br></pre></td></tr></table></figure><table><thead><tr><th><strong>参数</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><code>uxQueueLength</code></td><td>队列长度，最多能存放多少个数据(item)</td></tr><tr><td><code>uxItemSize</code></td><td>每个数据(item)的大小：以字节为单位（可以定义一个结构体存放，然后sizeof(结构体)）</td></tr><tr><td>返回值</td><td>非0：成功，返回句柄，以后使用句柄来操作队列 NULL：失败，因为内存不足</td></tr></tbody></table><ul><li>静态分配内存：<code>xQueueCreateStatic</code>，队列的内存要事先分配好</li></ul><p>函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">QueueHandle_t <span class="title function_">xQueueCreateStatic</span><span class="params">(*</span></span><br><span class="line"><span class="params">              UBaseType_t uxQueueLength,*</span></span><br><span class="line"><span class="params">              UBaseType_t uxItemSize,*</span></span><br><span class="line"><span class="params">              <span class="type">uint8_t</span> *pucQueueStorageBuffer,*</span></span><br><span class="line"><span class="params">              StaticQueue_t *pxQueueBuffer*</span></span><br><span class="line"><span class="params">            )</span>;</span><br></pre></td></tr></table></figure><table><thead><tr><th><strong>参数</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><code>uxQueueLength</code></td><td>队列长度，最多能存放多少个数据(item)</td></tr><tr><td><code>uxItemSize</code></td><td>每个数据(item)的大小：以字节为单位</td></tr><tr><td><code>pucQueueStorageBuffer</code></td><td>如果uxItemSize非0，<code>pucQueueStorageBuffer</code>必须指向一个uint8_t数组， 此数组大小至少为”uxQueueLength * uxItemSize”</td></tr><tr><td><code>pxQueueBuffer</code></td><td>必须执行一个<code>StaticQueue_t</code>结构体，用来保存队列的数据结构</td></tr><tr><td>返回值</td><td>非0：成功，返回句柄，以后使用句柄来操作队列 NULL：失败，因为<code>pxQueueBuffer</code>为NULL</td></tr></tbody></table><h5 id="复位"><a href="#复位" class="headerlink" title="复位"></a>复位</h5><p>队列刚被创建时，里面没有数据；使用过程中可以调用 <strong>xQueueReset()</strong> 把队列恢复为初始状态，此函数原型为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  pxQueue : 复位哪个队列;</span></span><br><span class="line"><span class="comment"> * 返回值: pdPASS(必定成功)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">BaseType_t <span class="title function_">xQueueReset</span><span class="params">( QueueHandle_t pxQueue)</span>;</span><br></pre></td></tr></table></figure><h5 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h5><p>删除队列的函数为 <strong>vQueueDelete()</strong> ，只能删除使用动态方法创建的队列，它会释放内存。原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vQueueDelete</span><span class="params">( QueueHandle_t xQueue )</span>;</span><br></pre></td></tr></table></figure><h5 id="写队列"><a href="#写队列" class="headerlink" title="写队列"></a>写队列</h5><p>可以把数据写到队列头部，也可以写到尾部，这些函数有两个版本：在任务中使用、在ISR中使用。函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 等同于xQueueSendToBack</span></span><br><span class="line"><span class="comment"> * 往队列尾部写入数据，如果没有空间，阻塞时间为xTicksToWait</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BaseType_t <span class="title function_">xQueueSend</span><span class="params">(</span></span><br><span class="line"><span class="params">                                QueueHandle_t    xQueue,</span></span><br><span class="line"><span class="params">                                <span class="type">const</span> <span class="type">void</span>       *pvItemToQueue,</span></span><br><span class="line"><span class="params">                                TickType_t       xTicksToWait</span></span><br><span class="line"><span class="params">                            )</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 往队列尾部写入数据，如果没有空间，阻塞时间为xTicksToWait</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BaseType_t <span class="title function_">xQueueSendToBack</span><span class="params">(</span></span><br><span class="line"><span class="params">                                QueueHandle_t    xQueue,</span></span><br><span class="line"><span class="params">                                <span class="type">const</span> <span class="type">void</span>       *pvItemToQueue,</span></span><br><span class="line"><span class="params">                                TickType_t       xTicksToWait</span></span><br><span class="line"><span class="params">                            )</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 往队列尾部写入数据，此函数可以在中断函数中使用，不可阻塞</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BaseType_t <span class="title function_">xQueueSendToBackFromISR</span><span class="params">(</span></span><br><span class="line"><span class="params">                                      QueueHandle_t xQueue,</span></span><br><span class="line"><span class="params">                                      <span class="type">const</span> <span class="type">void</span> *pvItemToQueue,</span></span><br><span class="line"><span class="params">                                      BaseType_t *pxHigherPriorityTaskWoken</span></span><br><span class="line"><span class="params">                                   )</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 往队列头部写入数据，如果没有空间，阻塞时间为xTicksToWait</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BaseType_t <span class="title function_">xQueueSendToFront</span><span class="params">(</span></span><br><span class="line"><span class="params">                                QueueHandle_t    xQueue,</span></span><br><span class="line"><span class="params">                                <span class="type">const</span> <span class="type">void</span>       *pvItemToQueue,</span></span><br><span class="line"><span class="params">                                TickType_t       xTicksToWait</span></span><br><span class="line"><span class="params">                            )</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 往队列头部写入数据，此函数可以在中断函数中使用，不可阻塞</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BaseType_t <span class="title function_">xQueueSendFromISR</span><span class="params">(</span></span><br><span class="line"><span class="params">                                      QueueHandle_t xQueue,</span></span><br><span class="line"><span class="params">                                      <span class="type">const</span> <span class="type">void</span> *pvItemToQueue,</span></span><br><span class="line"><span class="params">                                      BaseType_t *pxHigherPriorityTaskWoken</span></span><br><span class="line"><span class="params">                                   )</span>;</span><br></pre></td></tr></table></figure><p>这些函数用到的参数是类似的，统一说明如下：</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><code>xQueue</code></td><td>队列句柄，要写哪个队列</td></tr><tr><td><code>pvItemToQueue</code></td><td>数据指针，这个数据的值会被复制进队列， 复制多大的数据？在创建队列时已经指定了数据大小</td></tr><tr><td><code>xTicksToWait</code></td><td>如果队列满则无法写入新数据，可以让任务进入阻塞状态， <code>xTicksToWait</code>表示阻塞的最大时间(Tick Count)。 如果被设为0，无法写入数据时函数会立刻返回； 如果被设为<code>portMAX_DELAY</code>，则会一直阻塞直到有空间可写</td></tr><tr><td>返回值</td><td>pdPASS：数据成功写入了队列 <code>errQUEUE_FULL</code>：写入失败，因为队列满了。</td></tr></tbody></table><h5 id="读队列"><a href="#读队列" class="headerlink" title="读队列"></a>读队列</h5><p>使用 <strong>xQueueReceive()</strong> 函数读队列，读到一个数据后，队列中该数据会被移除。这个函数有两个版本：在任务中使用、在ISR中使用。函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xQueueReceive</span><span class="params">( QueueHandle_t xQueue,</span></span><br><span class="line"><span class="params">                          <span class="type">void</span> * <span class="type">const</span> pvBuffer,</span></span><br><span class="line"><span class="params">                          TickType_t xTicksToWait )</span>;</span><br><span class="line"></span><br><span class="line">BaseType_t <span class="title function_">xQueueReceiveFromISR</span><span class="params">(</span></span><br><span class="line"><span class="params">                                    QueueHandle_t    xQueue,</span></span><br><span class="line"><span class="params">                                    <span class="type">void</span>             *pvBuffer,</span></span><br><span class="line"><span class="params">                                    BaseType_t       *pxTaskWoken</span></span><br><span class="line"><span class="params">                                )</span>;</span><br></pre></td></tr></table></figure><p>参数说明如下：</p><table><thead><tr><th><strong>参数</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><code>xQueue</code></td><td>队列句柄，要读哪个队列</td></tr><tr><td><code>pvBuffer</code></td><td>buffer指针，队列的数据会被复制到这个buffer 复制多大的数据？在创建队列时已经指定了数据大小</td></tr><tr><td><code>xTicksToWait</code></td><td>果队列空则无法读出数据，可以让任务进入阻塞状态， xTicksToWait表示阻塞的最大时间(Tick Count)。 如果被设为0，无法读出数据时函数会立刻返回； 如果被设为portMAX_DELAY，则会一直阻塞直到有数据可写</td></tr><tr><td>返回值</td><td>pdPASS：从队列读出数据入 <code>errQUEUE_EMPTY</code>：读取失败，因为队列空了。</td></tr></tbody></table><h5 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h5><p>可以查询队列中有多少个数据、有多少空余空间。函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 返回队列中可用数据的个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">UBaseType_t <span class="title function_">uxQueueMessagesWaiting</span><span class="params">( <span class="type">const</span> QueueHandle_t xQueue )</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 返回队列中可用空间的个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">UBaseType_t <span class="title function_">uxQueueSpacesAvailable</span><span class="params">( <span class="type">const</span> QueueHandle_t xQueue )</span>;</span><br></pre></td></tr></table></figure><h5 id="覆盖-偷看"><a href="#覆盖-偷看" class="headerlink" title="覆盖&#x2F;偷看"></a>覆盖&#x2F;偷看</h5><p>当队列长度为1时，可以使用 <strong>xQueueOverwrite()</strong> 或 <strong>xQueueOverwriteFromISR()</strong> 来覆盖数据。</p><p>注意，队列长度必须为1。当队列满时，这些函数会覆盖里面的数据，这也以为着这些函数不会被阻塞。</p><p>函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 覆盖队列</span></span><br><span class="line"><span class="comment"> * xQueue: 写哪个队列</span></span><br><span class="line"><span class="comment"> * pvItemToQueue: 数据地址</span></span><br><span class="line"><span class="comment"> * 返回值: pdTRUE表示成功, pdFALSE表示失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BaseType_t <span class="title function_">xQueueOverwrite</span><span class="params">(</span></span><br><span class="line"><span class="params">                           QueueHandle_t xQueue,</span></span><br><span class="line"><span class="params">                           <span class="type">const</span> <span class="type">void</span> * pvItemToQueue</span></span><br><span class="line"><span class="params">                      )</span>;</span><br><span class="line"></span><br><span class="line">BaseType_t <span class="title function_">xQueueOverwriteFromISR</span><span class="params">(</span></span><br><span class="line"><span class="params">                           QueueHandle_t xQueue,</span></span><br><span class="line"><span class="params">                           <span class="type">const</span> <span class="type">void</span> * pvItemToQueue,</span></span><br><span class="line"><span class="params">                           BaseType_t *pxHigherPriorityTaskWoken</span></span><br><span class="line"><span class="params">                      )</span>;</span><br></pre></td></tr></table></figure><p>如果想让队列中的数据供多方读取，也就是说读取时不要移除数据，要留给后来人。那么可以使用”窥视”，也就是**xQueuePeek()**或**xQueuePeekFromISR()**。这些函数会从队列中复制出数据，但是不移除数据。这也意味着，如果队列中没有数据，那么”偷看”时会导致阻塞；一旦队列中有数据，以后每次”偷看”都会成功。</p><p>函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 偷看队列</span></span><br><span class="line"><span class="comment"> * xQueue: 偷看哪个队列</span></span><br><span class="line"><span class="comment"> * pvItemToQueue: 数据地址, 用来保存复制出来的数据</span></span><br><span class="line"><span class="comment"> * xTicksToWait: 没有数据的话阻塞一会</span></span><br><span class="line"><span class="comment"> * 返回值: pdTRUE表示成功, pdFALSE表示失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BaseType_t <span class="title function_">xQueuePeek</span><span class="params">(</span></span><br><span class="line"><span class="params">                          QueueHandle_t xQueue,</span></span><br><span class="line"><span class="params">                          <span class="type">void</span> * <span class="type">const</span> pvBuffer,</span></span><br><span class="line"><span class="params">                          TickType_t xTicksToWait</span></span><br><span class="line"><span class="params">                      )</span>;</span><br><span class="line"></span><br><span class="line">BaseType_t <span class="title function_">xQueuePeekFromISR</span><span class="params">(</span></span><br><span class="line"><span class="params">                                 QueueHandle_t xQueue,</span></span><br><span class="line"><span class="params">                                 <span class="type">void</span> *pvBuffer,</span></span><br><span class="line"><span class="params">                             )</span>;</span><br></pre></td></tr></table></figure><h4 id="使用队列时注意"><a href="#使用队列时注意" class="headerlink" title="使用队列时注意"></a>使用队列时注意</h4><blockquote><p>写队列与读队列 所传入的<code>buffer</code>一定要严格按照初始创建时的类型，否则就会出现死机</p><ul><li>情况一：创建时类型为指针（常用，可以接收多种类型）</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint8_t</span> data[<span class="number">128</span>];</span><br><span class="line">    <span class="type">uint8_t</span> index;</span><br><span class="line">&#125;Uart_RxTypeDef;</span><br><span class="line"></span><br><span class="line">Uart_RxTypeDef UartRx = &#123;&#123;<span class="number">0</span>&#125;,<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">task</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    Uart_RxTypeDef *data = &amp;UartRx;</span><br><span class="line">    debug_TX_QueueHandle = osMessageQueueNew(<span class="number">5</span>, <span class="keyword">sizeof</span>(<span class="type">void</span> *), &amp;debug_TX_Queue_attributes);</span><br><span class="line">    xQueueSend(debug_TX_QueueHandle,&amp;data,<span class="literal">NULL</span>);<span class="comment">//此处一定要&amp;data 因为创建队列的时候是指针 直接写data 相当于&amp;UartRx 他并不是一个指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>情况二：创建时类型为数据</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint8_t</span> data[<span class="number">128</span>];</span><br><span class="line">    <span class="type">uint8_t</span> index;</span><br><span class="line">&#125;Uart_RxTypeDef;</span><br><span class="line"></span><br><span class="line">Uart_RxTypeDef UartRx = &#123;&#123;<span class="number">0</span>&#125;,<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">task</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    Uart_RxTypeDef data = &#123;&#123;<span class="number">0</span>&#125;,<span class="number">0</span>&#125;;</span><br><span class="line">    debug_TX_QueueHandle = osMessageQueueNew(<span class="number">5</span>, <span class="keyword">sizeof</span>(Uart_RxTypeDef), &amp;debug_TX_Queue_attributes);</span><br><span class="line">    xQueueSend(debug_TX_QueueHandle,&amp;data,<span class="literal">NULL</span>);<span class="comment">//此处的&amp;data与情况一不一样 这个是参数要求要地址 所以需要将结构体的地址赋值过去</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h4 id="队列集"><a href="#队列集" class="headerlink" title="队列集"></a>队列集</h4><blockquote><p>当多个队列需要上报到同一个处理任务时，队列集可以实现统合多个队列，再往上传递到同一个任务</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509152131801.png" alt="image-20250915213146479"></p><h5 id="创建队列集"><a href="#创建队列集" class="headerlink" title="创建队列集"></a>创建队列集</h5><blockquote><p>注意要使用队列集 需要先在<code>Core/inc/FreeRTOSConfig.h</code> 定义</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#define configUSE_QUEUE_SETS 1</span></span><br></pre></td></tr></table></figure></blockquote><p>函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QueueSetHandle_t <span class="title function_">xQueueCreateSet</span><span class="params">( <span class="type">const</span> UBaseType_t uxEventQueueLength )</span></span><br></pre></td></tr></table></figure><table><thead><tr><th><strong>参数</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>uxQueueLength</td><td>队列集长度，最多能存放多少个数据(队列句柄)</td></tr><tr><td>返回值</td><td>非0：成功，返回句柄，以后使用句柄来操作队列NULL：失败，因为内存不足</td></tr></tbody></table><h5 id="把队列加入队列集"><a href="#把队列加入队列集" class="headerlink" title="把队列加入队列集"></a>把队列加入队列集</h5><p>函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xQueueAddToSet</span><span class="params">( QueueSetMemberHandle_t xQueueOrSemaphore,</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">                QueueSetHandle_t xQueueSet )</span>;</span><br><span class="line"></span><br><span class="line"> </span><br></pre></td></tr></table></figure><table><thead><tr><th><strong>参数</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>xQueueOrSemaphore</td><td>队列句柄，这个队列要加入队列集</td></tr><tr><td>xQueueSet</td><td>队列集句柄</td></tr><tr><td>返回值</td><td>pdTRUE：成功pdFALSE：失败</td></tr></tbody></table><h5 id="读取队列集"><a href="#读取队列集" class="headerlink" title="读取队列集"></a>读取队列集</h5><p>函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QueueSetMemberHandle_t <span class="title function_">xQueueSelectFromSet</span><span class="params">( QueueSetHandle_t xQueueSet,</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">                        TickType_t <span class="type">const</span> xTicksToWait )</span>;</span><br></pre></td></tr></table></figure><table><thead><tr><th><strong>参数</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>xQueueSet</td><td>队列集句柄</td></tr><tr><td>xTicksToWait</td><td>如果队列集空则无法读出数据，可以让任务进入阻塞状态，xTicksToWait表示阻塞的最大时间(Tick Count)。如果被设为0，无法读出数据时函数会立刻返回；如果被设为portMAX_DELAY，则会一直阻塞直到有数据可写</td></tr><tr><td>返回值</td><td>NULL：失败，队列句柄：成功</td></tr></tbody></table><h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>前面介绍的队列(queue)可以用于传输数据：在任务之间、任务和中断之间。</p><p>消息队列用于传输多个数据，但是有时候我们只需要传递状态，这个状态值需要用一个数值表示，比如：</p><ul><li>卖家：做好了1个包子！做好了2个包子！做好了3个包子！</li><li>买家：买了1个包子，包子数量减1</li><li>这个停车位我占了，停车位减1</li><li>我开车走了，停车位加1</li></ul><p>在这种情况下我们只需要维护一个数值，使用信号量效率更高、更节省内存 本章涉及如下内容：</p><ul><li>怎么创建、删除信号量</li><li>怎么发送、获得信号量</li><li>什么是计数型信号量？什么是二进制信号量？</li></ul><h4 id="信号量的特性"><a href="#信号量的特性" class="headerlink" title="信号量的特性"></a>信号量的特性</h4><h5 id="信号量的常规操作"><a href="#信号量的常规操作" class="headerlink" title="信号量的常规操作"></a>信号量的常规操作</h5><p>信号量这个名字很恰当：</p><ul><li>信号：起通知作用</li><li>量：还可以用来表示资源的数量<ul><li>当”量”没有限制时，它就是”计数型信号量”(Counting Semaphores)</li><li>当”量”只有0、1两个取值时，它就是”二进制信号量”(Binary Semaphores)</li></ul></li><li>支持的动作：”give”给出资源，计数值加1；”take”获得资源，计数值减1</li></ul><p>计数型信号量的典型场景是：</p><ul><li>计数：事件产生时”give”信号量，让计数值加1；处理事件时要先”take”信号量，就是获得信号量，让计数值减1。</li><li>资源管理：要想访问资源需要先”take”信号量，让计数值减1；用完资源后”give”信号量，让计数值加1。 信号量的”give”、”take”双方并不需要相同，可以用于生产者-消费者场合：</li><li>生产者为任务A、B，消费者为任务C、D</li><li>一开始信号量的计数值为0，如果任务C、D想获得信号量，会有两种结果：<ul><li>阻塞：买不到东西咱就等等吧，可以定个闹钟(超时时间)</li><li>即刻返回失败：不等</li></ul></li><li>任务A、B可以生产资源，就是让信号量的计数值增加1，并且把等待这个资源的顾客唤醒</li><li>唤醒谁？谁优先级高就唤醒谁，如果大家优先级一样就唤醒等待时间最长的人</li></ul><p>二进制信号量跟计数型的唯一差别，就是计数值的最大值被限定为1。</p><p><img src="https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509161022312.png" alt="img"></p><h5 id="信号量跟队列的对比"><a href="#信号量跟队列的对比" class="headerlink" title="信号量跟队列的对比"></a>信号量跟队列的对比</h5><p>差异列表如下：</p><table><thead><tr><th>队列</th><th>信号量</th></tr></thead><tbody><tr><td>可以容纳多个数据， 创建队列时有2部分内存: 队列结构体、存储数据的空间</td><td>只有计数值，无法容纳其他数据。 创建信号量时，只需要分配信号量结构体</td></tr><tr><td>生产者：没有空间存入数据时可以阻塞</td><td>生产者：用于不阻塞，计数值已经达到最大时返回失败</td></tr><tr><td>消费者：没有数据时可以阻塞</td><td>消费者：没有资源时可以阻塞</td></tr></tbody></table><h5 id="两种信号量的对比"><a href="#两种信号量的对比" class="headerlink" title="两种信号量的对比"></a>两种信号量的对比</h5><p>信号量的计数值都有限制：限定了最大值。如果最大值被限定为1，那么它就是二进制信号量；如果最大值不是1，它就是计数型信号量。</p><p>差别列表如下：</p><table><thead><tr><th>二进制信号量</th><th>计数型信号量</th></tr></thead><tbody><tr><td>被创建时初始值为0</td><td>被创建时初始值可以设定</td></tr><tr><td>其他操作是一样的</td><td>其他操作是一样的</td></tr></tbody></table><h4 id="信号量函数"><a href="#信号量函数" class="headerlink" title="信号量函数"></a>信号量函数</h4><p>使用信号量时，先创建、然后去添加资源、获得资源。使用句柄来表示一个信号量。</p><h5 id="创建-1"><a href="#创建-1" class="headerlink" title="创建"></a>创建</h5><p>使用信号量之前，要先创建，得到一个句柄；使用信号量时，要使用句柄来表明使用哪个信号量。 对于二进制信号量、计数型信号量，它们的创建函数不一样：</p><table><thead><tr><th></th><th>二进制信号量</th><th>计数型信号量</th></tr></thead><tbody><tr><td>动态创建</td><td><code>xSemaphoreCreateBinary </code>计数值初始值为0</td><td><code>xSemaphoreCreateCounting</code></td></tr><tr><td></td><td><code>vSemaphoreCreateBinary</code>(过时了) 计数值初始值为1</td><td></td></tr><tr><td>静态创建</td><td><code>xSemaphoreCreateBinaryStatic</code></td><td><code>xSemaphoreCreateCountingStatic</code></td></tr></tbody></table><p>创建二进制信号量的函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 创建一个二进制信号量，返回它的句柄。</span></span><br><span class="line"><span class="comment"> * 此函数内部会分配信号量结构体 </span></span><br><span class="line"><span class="comment"> * 返回值: 返回句柄，非NULL表示成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">SemaphoreHandle_t <span class="title function_">xSemaphoreCreateBinary</span><span class="params">( <span class="type">void</span> )</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建一个二进制信号量，返回它的句柄。</span></span><br><span class="line"><span class="comment"> * 此函数无需动态分配内存，所以需要先有一个StaticSemaphore_t结构体，并传入它的指针</span></span><br><span class="line"><span class="comment"> * 返回值: 返回句柄，非NULL表示成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">SemaphoreHandle_t <span class="title function_">xSemaphoreCreateBinaryStatic</span><span class="params">( StaticSemaphore_t *pxSemaphoreBuffer )</span>;</span><br></pre></td></tr></table></figure><p>创建计数型信号量的函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 创建一个计数型信号量，返回它的句柄。</span></span><br><span class="line"><span class="comment"> * 此函数内部会分配信号量结构体 </span></span><br><span class="line"><span class="comment"> * uxMaxCount: 最大计数值</span></span><br><span class="line"><span class="comment"> * uxInitialCount: 初始计数值</span></span><br><span class="line"><span class="comment"> * 返回值: 返回句柄，非NULL表示成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">SemaphoreHandle_t <span class="title function_">xSemaphoreCreateCounting</span><span class="params">(UBaseType_t uxMaxCount, UBaseType_t uxInitialCount)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建一个计数型信号量，返回它的句柄。</span></span><br><span class="line"><span class="comment"> * 此函数无需动态分配内存，所以需要先有一个StaticSemaphore_t结构体，并传入它的指针</span></span><br><span class="line"><span class="comment"> * uxMaxCount: 最大计数值</span></span><br><span class="line"><span class="comment"> * uxInitialCount: 初始计数值</span></span><br><span class="line"><span class="comment"> * pxSemaphoreBuffer: StaticSemaphore_t结构体指针</span></span><br><span class="line"><span class="comment"> * 返回值: 返回句柄，非NULL表示成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">SemaphoreHandle_t <span class="title function_">xSemaphoreCreateCountingStatic</span><span class="params">( UBaseType_t uxMaxCount, </span></span><br><span class="line"><span class="params">                                                 UBaseType_t uxInitialCount, </span></span><br><span class="line"><span class="params">                                                 StaticSemaphore_t *pxSemaphoreBuffer )</span>;</span><br></pre></td></tr></table></figure><h5 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h5><p>对于动态创建的信号量，不再需要它们时，可以删除它们以回收内存。</p><p>vSemaphoreDelete可以用来删除二进制信号量、计数型信号量，函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * xSemaphore: 信号量句柄，你要删除哪个信号量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">vSemaphoreDelete</span><span class="params">( SemaphoreHandle_t xSemaphore )</span>;</span><br></pre></td></tr></table></figure><h5 id="释放-获取信号量"><a href="#释放-获取信号量" class="headerlink" title="释放&#x2F;获取信号量"></a>释放&#x2F;获取信号量</h5><p>二进制信号量、计数型信号量的give、take操作函数是一样的。这些函数也分为2个版本：给任务使用，给ISR使用。列表如下：</p><table><thead><tr><th></th><th>在任务中使用</th><th>在ISR中使用</th></tr></thead><tbody><tr><td>give</td><td><code>xSemaphoreGive</code></td><td><code>xSemaphoreGiveFromISR</code></td></tr><tr><td>take</td><td><code>xSemaphoreTake</code></td><td><code>xSemaphoreTakeFromISR</code></td></tr></tbody></table><p>xSemaphoreGive的函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xSemaphoreGive</span><span class="params">( SemaphoreHandle_t xSemaphore )</span>;</span><br></pre></td></tr></table></figure><p>xSemaphoreGive函数的参数与返回值列表如下：</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>xSemaphore</td><td>信号量句柄，释放哪个信号量</td></tr><tr><td>返回值</td><td>pdTRUE表示成功, 如果二进制信号量的计数值已经是1，再次调用此函数则返回失败； 如果计数型信号量的计数值已经是最大值，再次调用此函数则返回失败</td></tr></tbody></table><p>pxHigherPriorityTaskWoken的函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xSemaphoreGiveFromISR</span><span class="params">(</span></span><br><span class="line"><span class="params">                        SemaphoreHandle_t xSemaphore,</span></span><br><span class="line"><span class="params">                        BaseType_t *pxHigherPriorityTaskWoken</span></span><br><span class="line"><span class="params">                    )</span>;</span><br></pre></td></tr></table></figure><p>xSemaphoreGiveFromISR函数的参数与返回值列表如下：</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>xSemaphore</td><td>信号量句柄，释放哪个信号量</td></tr><tr><td>pxHigherPriorityTaskWoken</td><td>如果释放信号量导致更高优先级的任务变为了就绪态， 则*pxHigherPriorityTaskWoken &#x3D; pdTRUE</td></tr><tr><td>返回值</td><td>pdTRUE表示成功, 如果二进制信号量的计数值已经是1，再次调用此函数则返回失败； 如果计数型信号量的计数值已经是最大值，再次调用此函数则返回失败</td></tr></tbody></table><p>xSemaphoreTake的函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xSemaphoreTake</span><span class="params">(</span></span><br><span class="line"><span class="params">                   SemaphoreHandle_t xSemaphore,</span></span><br><span class="line"><span class="params">                   TickType_t xTicksToWait</span></span><br><span class="line"><span class="params">               )</span>;</span><br></pre></td></tr></table></figure><p>xSemaphoreTake函数的参数与返回值列表如下：</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><code>xSemaphore</code></td><td>信号量句柄，获取哪个信号量</td></tr><tr><td><code>xTicksToWait</code></td><td>如果无法马上获得信号量，阻塞一会： 0：不阻塞，马上返回 <code>portMAX_DELAY</code>: 一直阻塞直到成功 其他值: 阻塞的Tick个数，可以使用*<code>pdMS_TO_TICKS</code>()*来指定阻塞时间为若干<code>ms</code></td></tr><tr><td>返回值</td><td>pdTRUE表示成功</td></tr></tbody></table><p>xSemaphoreTakeFromISR的函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xSemaphoreTakeFromISR</span><span class="params">(</span></span><br><span class="line"><span class="params">                        SemaphoreHandle_t xSemaphore,</span></span><br><span class="line"><span class="params">                        BaseType_t *pxHigherPriorityTaskWoken</span></span><br><span class="line"><span class="params">                    )</span>;</span><br></pre></td></tr></table></figure><p>xSemaphoreTakeFromISR函数的参数与返回值列表如下：</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><code>xSemaphore</code></td><td>信号量句柄，获取哪个信号量</td></tr><tr><td><code>pxHigherPriorityTaskWoken</code></td><td>如果获取信号量导致更高优先级的任务变为了就绪态， 则<code>*pxHigherPriorityTaskWoken = pdTRUE</code></td></tr><tr><td>返回值</td><td>pdTRUE表示成功</td></tr></tbody></table><h4 id="优先级反转"><a href="#优先级反转" class="headerlink" title="优先级反转"></a>优先级反转</h4><p>信号量使用不当 就会出现优先级反转的问题——任务执行顺序：任务1、任务2、任务1、任务3</p><p>即最高优先级的任务最后运行</p><blockquote><p>优先级反转：假设信号量值为1，同时创建了低、中等、高优先级任务</p><ul><li>低优先级任务获取信号量，中等优先级先阻塞一段时间，确保低优先级任务先成功获取到信号量</li><li>高优先级任务先阻塞一段时间，确保低优先级、中等优先级先完成任务，然后尝试获取信号量</li><li>此时由于低优先级获取了信号量，高优先级任务就会被阻塞</li><li>中等优先级不释放信号量，那么就会发生高优先级任务无法运行</li></ul></blockquote><h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;uart.h&quot;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">FILE</span> <span class="title">FILE</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> SemaphoreHandle_t task_mutex = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint8_t</span> dev;</span><br><span class="line">    <span class="type">uint8_t</span> *data;</span><br><span class="line">&#125; <span class="type">uart_info_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">uart_info_t</span> task1_data = &#123;<span class="number">1</span>, <span class="string">&quot;task1&quot;</span>&#125;;</span><br><span class="line"><span class="type">uart_info_t</span> task2_data = &#123;<span class="number">2</span>, <span class="string">&quot;task2&quot;</span>&#125;;</span><br><span class="line"><span class="type">uart_info_t</span> task3_data = &#123;<span class="number">3</span>, <span class="string">&quot;task3&quot;</span>&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fputc</span><span class="params">(<span class="type">int</span> ch, FILE *f)</span></span><br><span class="line">&#123;</span><br><span class="line">    HAL_UART_Transmit(&amp;huart1, (<span class="type">uint8_t</span> *)&amp;ch, <span class="number">1</span>, <span class="number">0xFFFF</span>);</span><br><span class="line">    <span class="keyword">return</span> ch;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">task1</span><span class="params">(<span class="type">void</span> *param)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> cnt = <span class="number">0</span>;</span><br><span class="line">    xSemaphoreTake(task_mutex, portMAX_DELAY);</span><br><span class="line">    <span class="type">uart_info_t</span> *data = param;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;dev:%u,name:%s\r\n&quot;</span>, data-&gt;dev, data-&gt;data);</span><br><span class="line">        <span class="keyword">if</span> (++cnt == <span class="number">5</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            xSemaphoreGive(task_mutex);</span><br><span class="line">        &#125;</span><br><span class="line">        vTaskDelay(<span class="number">50</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">task2</span><span class="params">(<span class="type">void</span> *param)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> cnt = <span class="number">0</span>;</span><br><span class="line">    vTaskDelay(<span class="number">300</span>);<span class="comment">//先阻塞一段时间 确保任务1成功获取信号量且能够被切换为任务2</span></span><br><span class="line">    <span class="type">uart_info_t</span> *data = param;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;dev:%u,name:%s\r\n&quot;</span>, data-&gt;dev, data-&gt;data);</span><br><span class="line">        <span class="keyword">if</span> (++cnt == <span class="number">5</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            vTaskDelete(<span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        HAL_Delay(<span class="number">50</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">task3</span><span class="params">(<span class="type">void</span> *param)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> cnt = <span class="number">0</span>;</span><br><span class="line">    vTaskDelay(<span class="number">500</span>);<span class="comment">//先阻塞一段时间 确保任务1先成功获取信号量且能够被切换为任务2</span></span><br><span class="line">    xSemaphoreTake(task_mutex, portMAX_DELAY);</span><br><span class="line">    <span class="type">uart_info_t</span> *data = param;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;dev:%u,name:%s\r\n&quot;</span>, data-&gt;dev, data-&gt;data);</span><br><span class="line">        <span class="keyword">if</span> (++cnt == <span class="number">5</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            vTaskDelete(<span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">uart_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    task_mutex = xSemaphoreCreateBinary();</span><br><span class="line">    xSemaphoreGive(task_mutex);</span><br><span class="line">    xTaskCreate(task1, <span class="string">&quot;task1&quot;</span>, <span class="number">128</span>, &amp;task1_data, osPriorityNormal, <span class="literal">NULL</span>);<span class="comment">//低优先级任务</span></span><br><span class="line">    xTaskCreate(task2, <span class="string">&quot;task2&quot;</span>, <span class="number">128</span>, &amp;task2_data, osPriorityNormal1, <span class="literal">NULL</span>);<span class="comment">//中等优先级任务</span></span><br><span class="line">    xTaskCreate(task3, <span class="string">&quot;task3&quot;</span>, <span class="number">128</span>, &amp;task3_data, osPriorityNormal2, <span class="literal">NULL</span>);<span class="comment">//高优先级任务</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509161600972.png" alt="image-20250916160014655"></p><h4 id="解决优先级反转"><a href="#解决优先级反转" class="headerlink" title="解决优先级反转"></a>解决优先级反转</h4><blockquote><p>使用互斥量 （实现优先级继承），当最高优先级任务等待互斥量时，可以将低优先级任务继承最高优先级，使得最高优先级任务也可以先运行</p><p>现象：任务1执行一小段时间被任务2抢占，当任务3时间到来，任务1继承任务3优先级，所以任务1运行释放后，任务1恢复原先优先级，任务3启动</p></blockquote><h3 id="事件组"><a href="#事件组" class="headerlink" title="事件组"></a>事件组</h3><blockquote><p>上述任务同步与互斥的方法都是一对一通知，难以实现一对多通知（广播），因此引入了事件组</p></blockquote><h4 id="事件组的概念"><a href="#事件组的概念" class="headerlink" title="事件组的概念"></a>事件组的概念</h4><p>事件组可以简单地认为就是一个整数：</p><ul><li>的每一位表示一个事件</li><li>每一位事件的含义由程序员决定，比如：Bit0表示用来串口是否就绪，Bit1表示按键是否被按下</li><li>这些位，值为1表示事件发生了，值为0表示事件没发生</li><li>一个或多个任务、ISR都可以去写这些位；一个或多个任务、ISR都可以去读这些位</li><li>可以等待某一位、某些位中的任意一个，也可以等待多位</li></ul><p><img src="https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509161809736.png" alt="img"></p><p>事件组用一个整数来表示，其中的高8位留给内核使用，只能用其他的位来表示事件。那么这个整数是多少位的？</p><ul><li>如果configUSE_16_BIT_TICKS是1，那么这个整数就是16位的，低8位用来表示事件</li><li>如果configUSE_16_BIT_TICKS是0，那么这个整数就是32位的，低24位用来表示事件</li><li>configUSE_16_BIT_TICKS是用来表示Tick Count的，怎么会影响事件组？这只是基于效率来考虑<ul><li>如果configUSE_16_BIT_TICKS是1，就表示该处理器使用16位更高效，所以事件组也使用16位</li><li>如果configUSE_16_BIT_TICKS是0，就表示该处理器使用32位更高效，所以事件组也使用32位</li></ul></li></ul><h4 id="事件组的操作"><a href="#事件组的操作" class="headerlink" title="事件组的操作"></a>事件组的操作</h4><p>事件组和队列、信号量等不太一样，主要集中在2个地方：</p><ul><li>唤醒谁？<ul><li>队列、信号量：事件发生时，只会唤醒一个任务</li><li>事件组：事件发生时，会唤醒所有符号条件的任务，简单地说它有”广播”的作用</li></ul></li><li>是否清除事件？<ul><li>队列、信号量：是消耗型的资源，队列的数据被读走就没了；信号量被获取后就减少了</li><li>事件组：被唤醒的任务有两个选择，可以让事件保留不动，也可以清除事件</li></ul></li></ul><p>以上图为列，事件组的常规操作如下：</p><ul><li>先创建事件组</li><li>任务C、D等待事件：<ul><li>等待什么事件？可以等待某一位、某些位中的任意一个，也可以等待多位。简单地说就是”或”、”与”的关系。</li><li>得到事件时，要不要清除？可选择清除、不清除。</li></ul></li><li>任务A、B产生事件：设置事件组里的某一位、某些位</li></ul><h4 id="事件组函数"><a href="#事件组函数" class="headerlink" title="事件组函数"></a>事件组函数</h4><h5 id="创建-2"><a href="#创建-2" class="headerlink" title="创建"></a>创建</h5><p>使用事件组之前，要先创建，得到一个句柄；使用事件组时，要使用句柄来表明使用哪个事件组。</p><p>有两种创建方法：动态分配内存、静态分配内存。函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 创建一个事件组，返回它的句柄。</span></span><br><span class="line"><span class="comment"> * 此函数内部会分配事件组结构体 </span></span><br><span class="line"><span class="comment"> * 返回值: 返回句柄，非NULL表示成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">EventGroupHandle_t <span class="title function_">xEventGroupCreate</span><span class="params">( <span class="type">void</span> )</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建一个事件组，返回它的句柄。</span></span><br><span class="line"><span class="comment"> * 此函数无需动态分配内存，所以需要先有一个StaticEventGroup_t结构体，并传入它的指针</span></span><br><span class="line"><span class="comment"> * 返回值: 返回句柄，非NULL表示成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">EventGroupHandle_t <span class="title function_">xEventGroupCreateStatic</span><span class="params">( StaticEventGroup_t * pxEventGroupBuffer )</span>;</span><br></pre></td></tr></table></figure><h5 id="删除-2"><a href="#删除-2" class="headerlink" title="删除"></a>删除</h5><p>对于动态创建的事件组，不再需要它们时，可以删除它们以回收内存。</p><p><strong>vEventGroupDelete</strong>可以用来删除事件组，函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * xEventGroup: 事件组句柄，你要删除哪个事件组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">vEventGroupDelete</span><span class="params">( EventGroupHandle_t xEventGroup )</span></span><br></pre></td></tr></table></figure><h5 id="设置事件"><a href="#设置事件" class="headerlink" title="设置事件"></a>设置事件</h5><p>可以设置事件组的某个位、某些位，使用的函数有2个：</p><ul><li>在任务中使用<strong>xEventGroupSetBits()</strong></li><li>在ISR中使用<strong>xEventGroupSetBitsFromISR()</strong></li></ul><p>有一个或多个任务在等待事件，如果这些事件符合这些任务的期望，那么任务还会被唤醒。</p><p>函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 设置事件组中的位</span></span><br><span class="line"><span class="comment"> * xEventGroup: 哪个事件组</span></span><br><span class="line"><span class="comment"> * uxBitsToSet: 设置哪些位? </span></span><br><span class="line"><span class="comment"> *              如果uxBitsToSet的bitX, bitY为1, 那么事件组中的bitX, bitY被设置为1</span></span><br><span class="line"><span class="comment"> *              可以用来设置多个位，比如 0x15 就表示设置bit4, bit2, bit0</span></span><br><span class="line"><span class="comment"> * 返回值: 返回原来的事件值(没什么意义, 因为很可能已经被其他任务修改了)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">EventBits_t <span class="title function_">xEventGroupSetBits</span><span class="params">( EventGroupHandle_t xEventGroup,</span></span><br><span class="line"><span class="params">                                    <span class="type">const</span> EventBits_t uxBitsToSet )</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置事件组中的位</span></span><br><span class="line"><span class="comment"> * xEventGroup: 哪个事件组</span></span><br><span class="line"><span class="comment"> * uxBitsToSet: 设置哪些位? </span></span><br><span class="line"><span class="comment"> *              如果uxBitsToSet的bitX, bitY为1, 那么事件组中的bitX, bitY被设置为1</span></span><br><span class="line"><span class="comment"> *              可以用来设置多个位，比如 0x15 就表示设置bit4, bit2, bit0</span></span><br><span class="line"><span class="comment"> * pxHigherPriorityTaskWoken: 有没有导致更高优先级的任务进入就绪态? pdTRUE-有, pdFALSE-没有</span></span><br><span class="line"><span class="comment"> * 返回值: pdPASS-成功, pdFALSE-失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BaseType_t <span class="title function_">xEventGroupSetBitsFromISR</span><span class="params">( EventGroupHandle_t xEventGroup,</span></span><br><span class="line"><span class="params">  <span class="type">const</span> EventBits_t uxBitsToSet,</span></span><br><span class="line"><span class="params">  BaseType_t * pxHigherPriorityTaskWoken )</span>;</span><br></pre></td></tr></table></figure><p>值得注意的是，ISR中的函数，比如队列函数<strong>xQueueSendToBackFromISR</strong>、信号量函数<strong>xSemaphoreGiveFromISR</strong>，它们会唤醒某个任务，最多只会唤醒1个任务。</p><p>但是设置事件组时，有可能导致多个任务被唤醒，这会带来很大的不确定性。所以<strong>xEventGroupSetBitsFromISR</strong>函数不是直接去设置事件组，而是给一个FreeRTOS后台任务(daemon task)发送队列数据，由这个任务来设置事件组。</p><p>如果后台任务的优先级比当前被中断的任务优先级高，<strong>xEventGroupSetBitsFromISR</strong>会设置<strong>pxHigherPriorityTaskWoken</strong>为pdTRUE。</p><p>如果daemon task成功地把队列数据发送给了后台任务，那么<strong>xEventGroupSetBitsFromISR</strong>的返回值就是pdPASS。</p><h5 id="等待事件"><a href="#等待事件" class="headerlink" title="等待事件"></a>等待事件</h5><p>使用<strong>xEventGroupWaitBits</strong>来等待事件，可以等待某一位、某些位中的任意一个，也可以等待多位；等到期望的事件后，还可以清除某些位。</p><p>函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">EventBits_t <span class="title function_">xEventGroupWaitBits</span><span class="params">( EventGroupHandle_t xEventGroup,</span></span><br><span class="line"><span class="params">                                 <span class="type">const</span> EventBits_t uxBitsToWaitFor,</span></span><br><span class="line"><span class="params">                                 <span class="type">const</span> BaseType_t xClearOnExit,</span></span><br><span class="line"><span class="params">                                 <span class="type">const</span> BaseType_t xWaitForAllBits,</span></span><br><span class="line"><span class="params">                                 TickType_t xTicksToWait )</span>;</span><br></pre></td></tr></table></figure><p>先引入一个概念：unblock condition。一个任务在等待事件发生时，它处于阻塞状态；当期望的时间发生时，这个状态就叫”unblock condition”，非阻塞条件，或称为”非阻塞条件成立”；当”非阻塞条件成立”后，该任务就可以变为就绪态。</p><p>函数参数说明列表如下：</p><table><thead><tr><th align="center"><strong>参数</strong></th><th align="left"><strong>说明</strong></th></tr></thead><tbody><tr><td align="center">xEventGroup</td><td align="left">等待哪个事件组？</td></tr><tr><td align="center">uxBitsToWaitFor</td><td align="left">等待哪些位？哪些位要被测试？</td></tr><tr><td align="center">xWaitForAllBits</td><td align="left">怎么测试？是”AND”还是”OR”？ pdTRUE: 等待的位，全部为1; pdFALSE: 等待的位，某一个为1即可</td></tr><tr><td align="center">xClearOnExit</td><td align="left">函数提出前是否要清除事件？ pdTRUE: 清除uxBitsToWaitFor指定的位 pdFALSE: 不清除</td></tr><tr><td align="center">xTicksToWait</td><td align="left">如果期待的事件未发生，阻塞多久。 可以设置为0：判断后即刻返回； 可设置为portMAX_DELAY：一定等到成功才返回； 可以设置为期望的Tick Count，一般用*pdMS_TO_TICKS()*把ms转换为Tick Count</td></tr><tr><td align="center">返回值</td><td align="left">返回的是事件值， 如果期待的事件发生了，返回的是”非阻塞条件成立”时的事件值； 如果是超时退出，返回的是超时时刻的事件值。</td></tr></tbody></table><p>举例如下：</p><table><thead><tr><th align="center">事件组的值</th><th align="center">uxBitsToWaitFor</th><th align="center">xWaitForAllBits</th><th align="left">说明</th></tr></thead><tbody><tr><td align="center">0100</td><td align="center">0101</td><td align="center">pdTRUE</td><td align="left">任务期望bit0,bit2都为1， 当前值只有bit2满足，任务进入阻塞态； 当事件组中bit0,bit2都为1时退出阻塞态</td></tr><tr><td align="center">0100</td><td align="center">0110</td><td align="center">pdFALSE</td><td align="left">任务期望bit0,bit2某一个为1， 当前值满足，所以任务成功退出</td></tr><tr><td align="center">0100</td><td align="center">0110</td><td align="center">pdTRUE</td><td align="left">任务期望bit1,bit2都为1， 当前值不满足，任务进入阻塞态； 当事件组中bit1,bit2都为1时退出阻塞态</td></tr></tbody></table><p>你可以使用*xEventGroupWaitBits()<em>等待期望的事件，它发生之后再使用</em>xEventGroupClearBits()*来清除。但是这两个函数之间，有可能被其他任务或中断抢占，它们可能会修改事件组。</p><p>可以使用设置<em>xClearOnExit</em>为pdTRUE，使得对事件组的测试、清零都在*xEventGroupWaitBits()*函数内部完成，这是一个原子操作。</p><h5 id="同步点"><a href="#同步点" class="headerlink" title="同步点"></a>同步点</h5><p>有一个事情需要多个任务协同，比如：</p><ul><li>任务A：炒菜</li><li>任务B：买酒</li><li>任务C：摆台</li><li>A、B、C做好自己的事后，还要等别人做完；大家一起做完，才可开饭</li></ul><p>使用 <strong>xEventGroupSync()</strong> 函数可以同步多个任务：</p><ul><li>可以设置某位、某些位，表示自己做了什么事</li><li>可以等待某位、某些位，表示要等等其他任务</li><li>期望的时间发生后， <strong>xEventGroupSync()</strong> 才会成功返回。</li><li><strong>xEventGroupSync</strong>成功返回后，会清除事件</li></ul><p><strong>xEventGroupSync</strong> 函数原型如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EventBits_t xEventGroupSync(    EventGroupHandle_t xEventGroup,</span><br><span class="line">                                const EventBits_t uxBitsToSet,</span><br><span class="line">                                const EventBits_t uxBitsToWaitFor,</span><br><span class="line">                                TickType_t xTicksToWait );</span><br></pre></td></tr></table></figure><p>参数列表如下：</p><table><thead><tr><th align="center"><strong>参数</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td align="center">xEventGroup</td><td>哪个事件组？</td></tr><tr><td align="center">uxBitsToSet</td><td>要设置哪些事件？我完成了哪些事件？ 比如0x05(二进制为0101)会导致事件组的bit0,bit2被设置为1</td></tr><tr><td align="center">uxBitsToWaitFor</td><td>等待那个位、哪些位？ 比如0x15(二级制10101)，表示要等待bit0,bit2,bit4都为1</td></tr><tr><td align="center">xTicksToWait</td><td>如果期待的事件未发生，阻塞多久。 可以设置为0：判断后即刻返回； 可设置为portMAX_DELAY：一定等到成功才返回； 可以设置为期望的Tick Count，一般用*pdMS_TO_TICKS()*把ms转换为Tick Count</td></tr><tr><td align="center">返回值</td><td>返回的是事件值， 如果期待的事件发生了，返回的是”非阻塞条件成立”时的事件值； 如果是超时退出，返回的是超时时刻的事件值。</td></tr></tbody></table><p>参数列表如下：</p><table><thead><tr><th align="center"><strong>参数</strong></th><th align="left"><strong>说明</strong></th></tr></thead><tbody><tr><td align="center">xEventGroup</td><td align="left">哪个事件组？</td></tr><tr><td align="center">uxBitsToSet</td><td align="left">要设置哪些事件？我完成了哪些事件？ 比如0x05(二进制为0101)会导致事件组的bit0,bit2被设置为1</td></tr><tr><td align="center">uxBitsToWaitFor</td><td align="left">等待那个位、哪些位？ 比如0x15(二级制10101)，表示要等待bit0,bit2,bit4都为1</td></tr><tr><td align="center">xTicksToWait</td><td align="left">如果期待的事件未发生，阻塞多久。 可以设置为0：判断后即刻返回； 可设置为portMAX_DELAY：一定等到成功才返回； 可以设置为期望的Tick Count，一般用*pdMS_TO_TICKS()*把ms转换为Tick Count</td></tr><tr><td align="center">返回值</td><td align="left">返回的是事件值， 如果期待的事件发生了，返回的是”非阻塞条件成立”时的事件值； 如果是超时退出，返回的是超时时刻的事件值。</td></tr></tbody></table><h3 id="任务通知"><a href="#任务通知" class="headerlink" title="任务通知"></a>任务通知</h3><p>所谓”任务通知”，你可以反过来读”通知任务”。</p><p>我们使用队列、信号量、事件组等等方法时，并不知道对方是谁。使用任务通知时，可以明确指定：通知哪个任务。</p><p>使用队列、信号量、事件组时，我们都要事先创建对应的结构体，双方通过中间的结构体通信：</p><p><img src="https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509161952531.png" alt="img"></p><p>使用任务通知时，任务结构体TCB中就包含了内部对象，可以直接接收别人发过来的”通知”：</p><p><img src="https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509161952379.png" alt="img"></p><h4 id="任务通知的特性"><a href="#任务通知的特性" class="headerlink" title="任务通知的特性"></a>任务通知的特性</h4><h5 id="优势及限制"><a href="#优势及限制" class="headerlink" title="优势及限制"></a>优势及限制</h5><p>任务通知的优势：</p><ul><li>效率更高：使用任务通知来发送事件、数据给某个任务时，效率更高。比队列、信号量、事件组都有大的优势。</li><li>更节省内存：使用其他方法时都要先创建对应的结构体，使用任务通知时无需额外创建结构体。</li></ul><p>任务通知的限制：</p><ul><li>不能发送数据给ISR：</li><li>ISR并没有任务结构体，所以无法使用任务通知的功能给ISR发送数据。但是ISR可以使用任务通知的功能，发数据给任务。</li><li>数据只能给该任务独享</li><li>使用队列、信号量、事件组时，数据保存在这些结构体中，其他任务、ISR都可以访问这些数据。使用任务通知时，数据存放入目标任务中，只有它可以访问这些数据。</li><li>在日常工作中，这个限制影响不大。因为很多场合是从多个数据源把数据发给某个任务，而不是把一个数据源的数据发给多个任务。</li><li>无法缓冲数据</li><li>使用队列时，假设队列深度为N，那么它可以保持N个数据。</li><li>使用任务通知时，任务结构体中只有一个任务通知值，只能保持一个数据。</li><li><span style="color:#00FFFF;">无法广播给多个任务</span></li><li>使用事件组可以同时给多个任务发送事件。</li><li>使用任务通知，只能发个一个任务。</li><li>如果发送受阻，发送方无法进入阻塞状态等待</li><li>假设队列已经满了，使用 <strong>xQueueSendToBack()</strong> 给队列发送数据时，任务可以进入阻塞状态等待发送完成。</li><li>使用任务通知时，即使对方无法接收数据，发送方也无法阻塞等待，只能即刻返回错误。</li></ul><h5 id="通知状态和通知值"><a href="#通知状态和通知值" class="headerlink" title="通知状态和通知值"></a>通知状态和通知值</h5><p>每个任务都有一个结构体：TCB(Task Control Block)，里面有2个成员：</p><ul><li>一个是uint8_t类型，用来表示通知状态</li><li>一个是uint32_t类型，用来表示通知值</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tskTaskControlBlock</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">/* configTASK_NOTIFICATION_ARRAY_ENTRIES = 1 */</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">uint32_t</span> ulNotifiedValue[ configTASK_NOTIFICATION_ARRAY_ENTRIES ];</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">uint8_t</span> ucNotifyState[ configTASK_NOTIFICATION_ARRAY_ENTRIES ];</span><br><span class="line">    ......</span><br><span class="line">&#125; tskTCB;</span><br></pre></td></tr></table></figure><p>通知状态有3种取值：</p><ul><li>taskNOT_WAITING_NOTIFICATION：任务没有在等待通知</li><li>taskWAITING_NOTIFICATION：任务在等待通知</li><li>taskNOTIFICATION_RECEIVED：任务接收到了通知，也被称为pending(有数据了，待处理)</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">define</span> taskNOT_WAITING_NOTIFICATION              ( ( uint8_t ) 0 )  <span class="comment">/* 也是初始状态 */</span></span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> taskWAITING_NOTIFICATION                  ( ( uint8_t ) 1 )</span></span><br><span class="line">#<span class="meta">#<span class="keyword">define</span> taskNOTIFICATION_RECEIVED                 ( ( uint8_t ) 2 )</span></span><br></pre></td></tr></table></figure><p>通知值可以有很多种类型：</p><ul><li>计数值</li><li>位(类似事件组)</li><li>任意数值</li></ul><h4 id="任务通知的使用"><a href="#任务通知的使用" class="headerlink" title="任务通知的使用"></a>任务通知的使用</h4><p>使用任务通知，可以实现轻量级的队列(长度为1)、邮箱(覆盖的队列)、计数型信号量、二进制信号量、事件组。</p><h5 id="两类函数"><a href="#两类函数" class="headerlink" title="两类函数"></a>两类函数</h5><p>任务通知有2套函数，简化版、专业版，列表如下：</p><ul><li>简化版函数的使用比较简单，它实际上也是使用专业版函数实现的</li><li>专业版函数支持很多参数，可以实现很多功能</li></ul><table><thead><tr><th></th><th>简化版</th><th>专业版</th></tr></thead><tbody><tr><td>发出通知</td><td><code>xTaskNotifyGive </code> <code>vTaskNotifyGiveFromISR</code></td><td><code>xTaskNotify </code> <code>xTaskNotifyFromISR</code></td></tr><tr><td>取出通知</td><td><code>ulTaskNotifyTake</code></td><td><code>xTaskNotifyWait</code></td></tr></tbody></table><h5 id="简化版任务通知"><a href="#简化版任务通知" class="headerlink" title="简化版任务通知"></a>简化版任务通知</h5><p>在任务中使用<code>xTaskNotifyGive</code>函数，在ISR中使用<code>vTaskNotifyGiveFromISR</code>函数，都是直接给其他任务发送通知：</p><ul><li>使得通知值加一</li><li>并使得通知状态变为”pending”，也就是<strong>taskNOTIFICATION_RECEIVED</strong>，表示有数据了、待处理</li></ul><p>可以使用<code>ulTaskNotifyTake</code>函数来取出通知值：</p><ul><li>如果通知值等于0，则阻塞(可以指定超时时间)</li><li>当通知值大于0时，任务从阻塞态进入就绪态</li><li>在ulTaskNotifyTake返回之前，还可以做些清理工作：把通知值减一，或者把通知值清零</li></ul><p>使用ulTaskNotifyTake函数可以实现轻量级的、高效的二进制信号量、计数型信号量。</p><p>这几个函数的原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xTaskNotifyGive</span><span class="params">( TaskHandle_t xTaskToNotify )</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">vTaskNotifyGiveFromISR</span><span class="params">( TaskHandle_t xTaskHandle, BaseType_t *pxHigherPriorityTaskWoken )</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">ulTaskNotifyTake</span><span class="params">( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )</span>;</span><br></pre></td></tr></table></figure><p><code>xTaskNotifyGive</code>函数的参数说明如下：</p><table><thead><tr><th align="center"><strong>参数</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td align="center"><code>xTaskToNotify</code></td><td>任务句柄(创建任务时得到)，给哪个任务发通知</td></tr><tr><td align="center">返回值</td><td>必定返回pdPASS</td></tr></tbody></table><p><code>vTaskNotifyGiveFromISR</code>函数的参数说明如下：</p><table><thead><tr><th align="center"><strong>参数</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td align="center"><code>xTaskHandle</code></td><td>任务句柄(创建任务时得到)，给哪个任务发通知</td></tr><tr><td align="center"><code>pxHigherPriorityTaskWoken</code></td><td>被通知的任务，可能正处于阻塞状态。 此函数发出通知后，会把它从阻塞状态切换为就绪态。 如果被唤醒的任务的优先级，高于当前任务的优先级， 则”*pxHigherPriorityTaskWoken”被设置为pdTRUE， 这表示在中断返回之前要进行任务切换。</td></tr></tbody></table><p><code>ulTaskNotifyTake</code>函数的参数说明如下：</p><table><thead><tr><th align="center"><strong>参数</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td align="center"><code>xClearCountOnExit</code></td><td>函数返回前是否清零： pdTRUE：把通知值清零 pdFALSE：如果通知值大于0，则把通知值减一</td></tr><tr><td align="center"><code>xTicksToWait</code></td><td>任务进入阻塞态的超时时间，它在等待通知值大于0。 0：不等待，即刻返回； portMAX_DELAY：一直等待，直到通知值大于0； 其他值：Tick Count，可以用*pdMS_TO_TICKS()*把ms转换为Tick Count</td></tr><tr><td align="center">返回值</td><td>函数返回之前，在清零或减一之前的通知值。 如果xTicksToWait非0，则返回值有2种情况： 1. 大于0：在超时前，通知值被增加了 2. 等于0：一直没有其他任务增加通知值，最后超时返回0</td></tr></tbody></table><h5 id="专业版任务通知"><a href="#专业版任务通知" class="headerlink" title="专业版任务通知"></a>专业版任务通知</h5><p><strong>xTaskNotify</strong> 函数功能更强大，可以使用不同参数实现各类功能，比如：</p><ul><li>让接收任务的通知值加一：这时 <strong>xTaskNotify()</strong> 等同于 <strong>xTaskNotifyGive()</strong></li><li>设置接收任务的通知值的某一位、某些位，这就是一个轻量级的、更高效的事件组</li><li>把一个新值写入接收任务的通知值：上一次的通知值被读走后，写入才成功。这就是轻量级的、长度为1的队列</li><li>用一个新值覆盖接收任务的通知值：无论上一次的通知值是否被读走，覆盖都成功。类似 <strong>xQueueOverwrite()</strong> 函数，这就是轻量级的邮箱。</li></ul><p><strong>xTaskNotify()</strong> 比 <strong>xTaskNotifyGive()</strong> 更灵活、强大，使用上也就更复杂。<strong>xTaskNotifyFromISR()</strong> 是它对应的ISR版本。</p><p>这两个函数用来发出任务通知，使用哪个函数来取出任务通知呢？</p><p>使用 <strong>xTaskNotifyWait()</strong> 函数！它比 <strong>ulTaskNotifyTake()</strong> 更复杂：</p><ul><li>可以让任务等待(可以加上超时时间)，等到任务状态为”pending”(也就是有数据)</li><li>还可以在函数进入、退出时，清除通知值的指定位</li></ul><p>这几个函数的原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xTaskNotify</span><span class="params">( TaskHandle_t xTaskToNotify, <span class="type">uint32_t</span> ulValue, eNotifyAction eAction )</span>;</span><br><span class="line"></span><br><span class="line">BaseType_t <span class="title function_">xTaskNotifyFromISR</span><span class="params">( TaskHandle_t xTaskToNotify,</span></span><br><span class="line"><span class="params">                               <span class="type">uint32_t</span> ulValue, </span></span><br><span class="line"><span class="params">                               eNotifyAction eAction, </span></span><br><span class="line"><span class="params">                               BaseType_t *pxHigherPriorityTaskWoken )</span>;</span><br><span class="line"></span><br><span class="line">BaseType_t <span class="title function_">xTaskNotifyWait</span><span class="params">( <span class="type">uint32_t</span> ulBitsToClearOnEntry, </span></span><br><span class="line"><span class="params">                            <span class="type">uint32_t</span> ulBitsToClearOnExit, </span></span><br><span class="line"><span class="params">                            <span class="type">uint32_t</span> *pulNotificationValue, </span></span><br><span class="line"><span class="params">                            TickType_t xTicksToWait )</span>;</span><br></pre></td></tr></table></figure><p><code>xTaskNotify</code>函数的参数说明如下：</p><table><thead><tr><th align="center"><strong>参数</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td align="center"><code>xTaskToNotify</code></td><td>任务句柄(创建任务时得到)，给哪个任务发通知</td></tr><tr><td align="center"><code>ulValue</code></td><td>怎么使用ulValue，由eAction参数决定</td></tr><tr><td align="center"><code>eAction</code></td><td>见下表</td></tr><tr><td align="center">返回值</td><td>pdPASS：成功，大部分调用都会成功 pdFAIL：只有一种情况会失败，当eAction为eSetValueWithoutOverwrite， 并且通知状态为”pending”(表示有新数据未读)，这时就会失败。</td></tr></tbody></table><p><code>eNotifyAction</code>参数说明：</p><table><thead><tr><th align="center"><strong>eNotifyAction取值</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td align="center"><code>eNoAction</code></td><td>仅仅是更新通知状态为”pending”，未使用ulValue。 这个选项相当于轻量级的、更高效的二进制信号量。</td></tr><tr><td align="center"><code>eSetBits</code></td><td>通知值 &#x3D; 原来的通知值 | ulValue，按位或。 相当于轻量级的、更高效的事件组。</td></tr><tr><td align="center"><code>eIncrement</code></td><td>通知值 &#x3D; 原来的通知值 + 1，未使用ulValue。 相当于轻量级的、更高效的二进制信号量、计数型信号量。 相当于**xTaskNotifyGive()**函数。</td></tr><tr><td align="center">eSetValueWithoutOverwrite</td><td>不覆盖。 如果通知状态为”pending”(表示有数据未读)， 则此次调用xTaskNotify不做任何事，返回pdFAIL。 如果通知状态不是”pending”(表示没有新数据)， 则：通知值 &#x3D; ulValue。</td></tr><tr><td align="center">eSetValueWithOverwrite</td><td>覆盖。 无论如何，不管通知状态是否为”pendng”， 通知值 &#x3D; ulValue。</td></tr></tbody></table><p>xTaskNotifyFromISR函数跟xTaskNotify很类似，就多了最后一个参数<strong>pxHigherPriorityTaskWoken</strong>。在很多ISR函数中，这个参数的作用都是类似的，使用场景如下：</p><ul><li>被通知的任务，可能正处于阻塞状态</li><li><strong>xTaskNotifyFromISR</strong>函数发出通知后，会把接收任务从阻塞状态切换为就绪态</li><li>如果被唤醒的任务的优先级，高于当前任务的优先级，则”*pxHigherPriorityTaskWoken”被设置为pdTRUE，这表示在中断返回之前要进行任务切换。</li></ul><p>xTaskNotifyWait函数列表如下：</p><table><thead><tr><th align="center"><strong>参数</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td align="center"><code>ulBitsToClearOnEntry</code></td><td>在xTaskNotifyWait入口处，要清除通知值的哪些位？ 通知状态不是”pending”的情况下，才会清除。 它的本意是：我想等待某些事件发生，所以先把”旧数据”的某些位清零。 能清零的话：通知值 &#x3D; 通知值 &amp; ~(ulBitsToClearOnEntry)。 比如传入0x01，表示清除通知值的bit0； 传入0xffffffff即ULONG_MAX，表示清除所有位，即把值设置为0</td></tr><tr><td align="center"><code>ulBitsToClearOnExit</code></td><td>在xTaskNotifyWait出口处，如果不是因为超时推出，而是因为得到了数据而退出时： 通知值 &#x3D; 通知值 &amp; ~(ulBitsToClearOnExit)。 在清除某些位之前，通知值先被赋给”*pulNotificationValue”。 比如入0x03，表示清除通知值的bit0、bit1； 传入0xffffffff即ULONG_MAX，表示清除所有位，即把值设置为0</td></tr><tr><td align="center"><code>pulNotificationValue</code></td><td>用来取出通知值。 在函数退出时，使用ulBitsToClearOnExit清除之前，把通知值赋给”*pulNotificationValue”。 如果不需要取出通知值，可以设为NULL。</td></tr><tr><td align="center"><code>xTicksToWait</code></td><td>任务进入阻塞态的超时时间，它在等待通知状态变为”pending”。 0：不等待，即刻返回； portMAX_DELAY：一直等待，直到通知状态变为”pending”； 其他值：Tick Count，可以用*pdMS_TO_TICKS()*把ms转换为Tick Count</td></tr><tr><td align="center">返回值</td><td>1. pdPASS：成功 这表示xTaskNotifyWait成功获得了通知： 可能是调用函数之前，通知状态就是”pending”； 也可能是在阻塞期间，通知状态变为了”pending”。 2. pdFAIL：没有得到通知。</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> MCU </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RTOS </tag>
            
            <tag> 实时操作系统 </tag>
            
            <tag> FreeRTOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于const的进一步思考</title>
      <link href="/2025/09/02/const/"/>
      <url>/2025/09/02/const/</url>
      
        <content type="html"><![CDATA[<blockquote><p>背景：在进行宿舍精灵项目的代码编写时， 我使用了映射表来表现楼栋，我使用了const来修饰 以稳定内容 </p><p>但是在我尝试将楼栋的内容分离出来时（例如中1C 在oled上需把中文提取出来 然后剩下用oled_print来显示在oled上） 但却出现了指针错误 </p></blockquote><p>分析了一下：const是将对应的字符数组存放在只读存储区中 而我因为想要分离 从而修改了指针的内容 故造成指针错误</p><p><code>解决措施</code>：通过malloc来申请内存，然后使用strcpy或者sprintf来存放在新申请的内存中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">get_building_map_remain</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *<span class="built_in">map</span> = get_building_map();</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">map</span> == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> len = <span class="built_in">strlen</span>(<span class="built_in">map</span>);</span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 返回空字符串</span></span><br><span class="line">        <span class="type">char</span> *result = <span class="built_in">malloc</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (result)</span><br><span class="line">        &#123;</span><br><span class="line">            result[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配新内存并复制跳过前3字节的内容</span></span><br><span class="line">    <span class="type">char</span> *result = <span class="built_in">malloc</span>(len - <span class="number">3</span> + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span>(result, <span class="built_in">map</span> + <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="post-link-card-wrap">    <div class="post-link-card">      <a href="https://mextra.netlify.app/2025/09/05/freertos/" title="freertos" rel="noopener external nofollow noreferrer" target="_blank"></a>      <div class="post-link-card-cover-wrap"><img src="https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071511987.png" class="no-lightbox" title="freertos" alt="freertos"/></div>      <div class="post-link-card-item-wrap">        <div class="post-link-card-title">freertos</div>        <div class="post-link-card-excerpt"><span class="icon-link"></span>https://mextra.netlify.app/2025/09/05/freertos/</div>      </div>    </div>  </div>]]></content>
      
      
      
        <tags>
            
            <tag> 嵌入式基础 </tag>
            
            <tag> 对于const的思考 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>电赛</title>
      <link href="/2025/06/08/%E7%94%B5%E8%B5%9B/"/>
      <url>/2025/06/08/%E7%94%B5%E8%B5%9B/</url>
      
        <content type="html"><![CDATA[<h2 id="PID"><a href="#PID" class="headerlink" title="PID"></a>PID</h2><p><img src="https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202506081334606.png" alt="image-20250608132624784"></p><ul><li>其中 e 为误差</li><li>P：正比  即控制摆动</li><li>I：积分 积累误差，可用来消除稳定误差 （比如无人机中，向下吹的风刚好是1米，但p中最后上升也是1米 即形成一种稳态）</li><li>D：微分 速度控制 可用来让系统快速停下来</li></ul><h2 id="编码器"><a href="#编码器" class="headerlink" title="编码器"></a>编码器</h2><h3 id="CubeMX配置"><a href="#CubeMX配置" class="headerlink" title="CubeMX配置"></a>CubeMX配置</h3><p><img src="https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202506122126276.png" alt="image-20250612212624882"></p><h4 id="参数解析"><a href="#参数解析" class="headerlink" title="参数解析"></a>参数解析</h4><ol><li>Encoder Mode</li></ol><ul><li><p><code>Encoder Mode TI1</code> ：只保留A相，滤除B相数据</p></li><li><p><code>Encoder Mode TI2</code> ：只保留B相，滤除A相数据</p></li><li><p><code>Encoder Mode TI1 and TI2</code>：A、B相都保留，数据波长会是第一、二模式的两倍</p><blockquote><p>一般用于高精度场合 如小车</p></blockquote></li></ul><h3 id="代码编写"><a href="#代码编写" class="headerlink" title="代码编写"></a>代码编写</h3><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HAL_TIM_Encoder_Start(&amp;htim3, TIM_CHANNEL_1); <span class="comment">// 开启编码器A</span></span><br><span class="line">HAL_TIM_Encoder_Start(&amp;htim3, TIM_CHANNEL_2); <span class="comment">// 开启编码器A</span></span><br></pre></td></tr></table></figure><h4 id="获取编码器值"><a href="#获取编码器值" class="headerlink" title="获取编码器值"></a>获取编码器值</h4><blockquote><p>记得先接上编码器的电源 他与电机是分开的电源  工作电压为3.3V~5V</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g_nMotor_Lef_Pulse = (<span class="type">short</span>)(__HAL_TIM_GET_COUNTER(&amp;htim3)); <span class="comment">// 获取计数器值</span></span><br><span class="line">__HAL_TIM_SET_COUNTER(&amp;htim3, <span class="number">0</span>); <span class="comment">// 左编码器TIM3计数器清零</span></span><br></pre></td></tr></table></figure><h2 id="超声波"><a href="#超声波" class="headerlink" title="超声波"></a>超声波</h2><h3 id="CubeMX配置-1"><a href="#CubeMX配置-1" class="headerlink" title="CubeMX配置"></a>CubeMX配置</h3><p><img src="https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202506122134910.png" alt="image-20250612213408605"></p><p><img src="https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202506122148018.png" alt="image-20250612214851115"></p><h3 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hcsr04Init(&amp;htim11, TIM_CHANNEL_1); <span class="comment">//  超声波模块初始化</span></span><br></pre></td></tr></table></figure><h3 id="注册回调函数与绑定定时器溢出回调函数"><a href="#注册回调函数与绑定定时器溢出回调函数" class="headerlink" title="注册回调函数与绑定定时器溢出回调函数"></a>注册回调函数与绑定定时器溢出回调函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">HAL_TIM_IC_CaptureCallback</span><span class="params">(TIM_HandleTypeDef *htim)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (htim-&gt;Instance == TIM11)</span><br><span class="line">Hcsr04TimIcIsr(&amp;htim11);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_TIM_PeriodElapsedCallback</span><span class="params">(TIM_HandleTypeDef *htim)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (htim-&gt;Instance == TIM11)</span><br><span class="line">  &#123;</span><br><span class="line">    Hcsr04TimOverflowIsr(&amp;htim11);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取距离值"><a href="#获取距离值" class="headerlink" title="获取距离值"></a>获取距离值</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Hcsr04Start();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;distance:%.1f cm\r\n&quot;</span>, Hcsr04Read());</span><br><span class="line">HAL_Delay(<span class="number">300</span>); <span class="comment">// 可适当加些延时</span></span><br></pre></td></tr></table></figure><h2 id="JY60陀螺仪"><a href="#JY60陀螺仪" class="headerlink" title="JY60陀螺仪"></a>JY60陀螺仪</h2><h3 id="CubeMX配置-2"><a href="#CubeMX配置-2" class="headerlink" title="CubeMX配置"></a>CubeMX配置</h3><p><img src="https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202506122159648.png" alt="image-20250612215946547"></p><p><img src="https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202506122200718.png" alt="image-20250612220017334"></p><h3 id="初始化-2"><a href="#初始化-2" class="headerlink" title="初始化"></a>初始化</h3><ul><li>引入官方sdk <code>wit_c_sdk.h与wit_c_sdk.c</code></li><li>新建驱动文件 <code>jy60.c</code>与 <code>jy60.h</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">jy60_init();</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">void jy60_init(void)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">WitInit(WIT_PROTOCOL_NORMAL, 0x50);</span></span><br><span class="line"><span class="comment">WitSerialWriteRegister(SensorUartSend);</span></span><br><span class="line"><span class="comment">WitRegisterCallBack(SensorDataUpdata);</span></span><br><span class="line"><span class="comment">WitDelayMsRegister(Delayms);</span></span><br><span class="line"><span class="comment">HAL_Delay(100);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="获取加速度、角速度、姿态角"><a href="#获取加速度、角速度、姿态角" class="headerlink" title="获取加速度、角速度、姿态角"></a>获取加速度、角速度、姿态角</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">jy60_read();</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">void jy60_read(void)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">if(s_cDataUpdate)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">for(uint8_t i = 0; i &lt; 3; i++)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">fAcc[i] = sReg[AX+i] / 32768.0f * 16.0f;</span></span><br><span class="line"><span class="comment">fGyro[i] = sReg[GX+i] / 32768.0f * 2000.0f;</span></span><br><span class="line"><span class="comment">fAngle[i] = sReg[Roll+i] / 32768.0f * 180.0f;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">//uint8_t strff[21];</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//sprintf(strff,&quot;%.2f&quot;,fAngle[2]);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//OLED_ShowStr(0,3,strff,1);</span></span><br><span class="line"><span class="comment">if(s_cDataUpdate &amp; ACC_UPDATE)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">//printf(&quot;acc:%.3f %.3f %.3f\r\n&quot;, fAcc[0], fAcc[1], fAcc[2]);</span></span><br><span class="line"><span class="comment">s_cDataUpdate &amp;= ~ACC_UPDATE;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">if(s_cDataUpdate &amp; GYRO_UPDATE)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">//printf(&quot;gyro:%.3f %.3f %.3f\r\n&quot;, fGyro[0], fGyro[1], fGyro[2]);</span></span><br><span class="line"><span class="comment">s_cDataUpdate &amp;= ~GYRO_UPDATE;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">if(s_cDataUpdate &amp; ANGLE_UPDATE)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">printf(&quot;angle:%.3f %.3f %.3f\r\n&quot;, fAngle[0], fAngle[1], fAngle[2]);</span></span><br><span class="line"><span class="comment">s_cDataUpdate &amp;= ~ANGLE_UPDATE;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">if(s_cDataUpdate &amp; MAG_UPDATE)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">//printf(&quot;mag:%d %d %d\r\n&quot;, sReg[HX], sReg[HY], sReg[HZ]);</span></span><br><span class="line"><span class="comment">s_cDataUpdate &amp;= ~MAG_UPDATE;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>变量名</th><th>含义</th><th>单位</th><th>来源寄存器</th></tr></thead><tbody><tr><td><code>fAcc</code></td><td>加速度（Accelerometer）</td><td>M&#x2F;s²</td><td><code>AX</code>、<code>AY</code>、<code>AZ</code></td></tr><tr><td><code>fGyro</code></td><td>角速度（Gyroscope）</td><td>°&#x2F;s（角度每秒）</td><td><code>GX</code>、<code>GY</code>、<code>GZ</code></td></tr><tr><td><code>fAngle</code></td><td>姿态角（Angle）</td><td>°（角度）</td><td><code>Roll</code>、<code>Pitch</code>、<code>Yaw</code></td></tr></tbody></table><table><thead><tr><th>下标</th><th>fAcc</th><th>fGyro</th><th>fAngle</th></tr></thead><tbody><tr><td>[0]</td><td>X 轴加速度</td><td>X 轴角速度</td><td>横滚角（Roll）</td></tr><tr><td>[1]</td><td>Y 轴加速度</td><td>Y 轴角速度</td><td>俯仰角（Pitch）</td></tr><tr><td>[2]</td><td>Z 轴加速度</td><td>Z 轴角速度</td><td>偏航角（Yaw）</td></tr></tbody></table><h3 id="数据分析"><a href="#数据分析" class="headerlink" title="数据分析"></a>数据分析</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fAcc[i] = sReg[AX+i] / <span class="number">32768.0f</span> * <span class="number">16.0f</span>;</span><br><span class="line">fGyro[i] = sReg[GX+i] / <span class="number">32768.0f</span> * <span class="number">2000.0f</span>;</span><br><span class="line">fAngle[i] = sReg[Roll+i] / <span class="number">32768.0f</span> * <span class="number">180.0f</span>;</span><br><span class="line"><span class="comment">/*以上数据均来源于这里*/</span></span><br><span class="line"><span class="comment">//后面的 * 16.0f 表示限幅 即 加速度范围为 ± 16M/s²</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 电赛准备 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>西门子嵌入式学习</title>
      <link href="/2025/06/02/%E8%A5%BF%E9%97%A8%E5%AD%90/"/>
      <url>/2025/06/02/%E8%A5%BF%E9%97%A8%E5%AD%90/</url>
      
        <content type="html"><![CDATA[<h2 id="调度器模板"><a href="#调度器模板" class="headerlink" title="调度器模板"></a>调度器模板</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;scheduler.h&quot;</span></span></span><br><span class="line"><span class="comment">// clang-format off</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">void</span> (*task_func)(<span class="type">void</span>);</span><br><span class="line"><span class="type">uint32_t</span> rate_ms;</span><br><span class="line"><span class="type">uint32_t</span> last_ms;</span><br><span class="line">&#125; <span class="type">task_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">task_t</span> tasks[] = &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> task_count;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">scheduler_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">task_count = <span class="keyword">sizeof</span>(tasks) / <span class="keyword">sizeof</span>(<span class="type">task_t</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">scheduler_run</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">uint8_t</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; task_count; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">uint32_t</span> now_time = HAL_GetTick();</span><br><span class="line"><span class="keyword">if</span> ((<span class="type">uint32_t</span>)(now_time - tasks[i].last_ms) &gt;= tasks[i].rate_ms)</span><br><span class="line">&#123;</span><br><span class="line">tasks[i].last_ms = now_time;</span><br><span class="line">tasks[i].task_func();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="时钟配置栏"><a href="#时钟配置栏" class="headerlink" title="时钟配置栏"></a>时钟配置栏</h2><h3 id="模式设置"><a href="#模式设置" class="headerlink" title="模式设置"></a>模式设置</h3><p><img src="https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202506021615783.png" alt="image-20250602161506934"></p><h4 id="高速时钟HSE"><a href="#高速时钟HSE" class="headerlink" title="高速时钟HSE"></a>高速时钟HSE</h4><ul><li><p><code>Disable</code>：不启用外部时钟（默认使用内部时钟） <span style="color:#00FFFF;">内部时钟（内部RC（电阻-电容）振荡器）提供了此便捷性 但精度不如外部时钟（外部低速晶振或陶瓷振荡器）</span></p></li><li><p><code>BYPASS Clock Source</code>：旁路模式，允许直接<span style="color:#00FFFF;">从外部导入时钟信号，而不使用外部晶体</span>。这种模式适用于需要从外部系统或其他设备接收时钟信号的情况。</p></li><li><p><code>Crystal/Ceramic Resonator</code>：将外部低速晶振或陶瓷谐振器作为时钟源，一般则是板载上的外部晶振</p></li></ul><h4 id="低速时钟LSE"><a href="#低速时钟LSE" class="headerlink" title="低速时钟LSE"></a>低速时钟LSE</h4><blockquote><p>参数同上 通常用于<span style="color:#33FFFF;">实时时钟（RTC</span>）等需要低频稳定时钟的应用。LSE的典型频率为32.768kHz</p></blockquote><h4 id="Master-Clock-Output"><a href="#Master-Clock-Output" class="headerlink" title="Master Clock Output"></a><strong>Master Clock Output</strong></h4><ul><li>配置是否使能主时钟<span style="color:#33FFFF;">输出到MCO引脚</span>，<code>即可以通过MCO引脚将时钟信号输出到外部，供其他设备使用</code></li></ul><h4 id="Audio-Clock-Input-I2S-CKIN-："><a href="#Audio-Clock-Input-I2S-CKIN-：" class="headerlink" title="**Audio Clock Input (I2S_CKIN)**："></a>**Audio Clock Input (I2S_CKIN)**：</h4><ul><li>此选项用于配置是否从<span style="color:#33FFFF;">特定的引脚（如I2S_CKIN）输入音频时钟</span>。这对于需要精确音频时钟的音频应用非常重要，<code>例如I2S音频接口</code>。</li></ul><h3 id="参数设置"><a href="#参数设置" class="headerlink" title="参数设置"></a>参数设置</h3><p><img src="https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202506021629990.png" alt="image-20250602162859501"></p><ul><li><p><code>TIM Prescaler Selection</code>：定时器预分频选择，<code>禁用时使用最大分频值。</code></p></li><li><p><code>HSE Startup Timeout Value (ms)</code>：HSE（高速外部时钟）启动超时时间，设置为100ms。这是外部晶振启动的最长等待时间，如果超出这个时间晶振还未启动，微控制器会认为启动失败。</p></li><li><p><code>LSE Startup Timeout Value (ms)</code>：LSE（低速外部时钟）启动超时时间，设置为5000ms。这通常用于RTC的时钟源，如果超出这个时间晶振还未启动，微控制器会认为启动失败。</p></li><li><p><code>Power Regulator Voltage Scale</code>：电源调节器电压等级，设置为<code>Power Regulator Voltage Scale 3</code>。这通常与微控制器的性能和功耗有关，不同的电压等级可以提供不同的性能和功耗平衡。</p></li><li><p><code>Power Over Drive</code>：电源过驱，禁用。这通常用于在需要更高性能时<span style="color:#33FFFF;">临时提高微控制器的电压</span>，以支持更高的时钟频率。</p></li></ul><h3 id="在何处选择了HSI以及HSE"><a href="#在何处选择了HSI以及HSE" class="headerlink" title="在何处选择了HSI以及HSE"></a>在何处选择了HSI以及HSE</h3><p><img src="https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202506021818291.png" alt="image-20250602181824740"></p><ul><li><p>第一个框一定一定要看硬件上的晶振是多少频率，<span style="color:#00FFFF;">一定要严格按照硬件资源给的 （不要无脑用默认的）</span></p><blockquote><p>否则可能会出现串口数据接收乱码</p></blockquote></li><li><p>第二个框选择了用&#96;相位锁定环（PLL） 调整外部高速时钟（HSE）还是内部高速时钟（HSI）</p></li><li><p>第三个框框则直接选择是否选择 经过PLL调整后的时钟，也可以选择不经过PLL的原生外部高速时钟（HSE），以及内部高速时钟（HSI）。</p></li></ul><h2 id="SYS调试接口选择"><a href="#SYS调试接口选择" class="headerlink" title="SYS调试接口选择"></a>SYS调试接口选择</h2><p><img src="https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202506021828146.png" alt="image-20250602182759796"></p><h3 id="Serial-Wire-SW-DP"><a href="#Serial-Wire-SW-DP" class="headerlink" title="Serial Wire (SW-DP)"></a>Serial Wire (SW-DP)</h3><ul><li><p>串口烧录 仅需要两个引脚</p><ul><li><code>SWCLK</code>：主机到从机的时钟信号</li><li><code>SWDIO</code>：双向数据信号</li></ul></li><li><p>这种模式下，ST-Link工作最稳定，占用引脚少，是日常开发的首选。</p></li></ul><h3 id="JTAG-JTAG-DP"><a href="#JTAG-JTAG-DP" class="headerlink" title="JTAG(JTAG-DP)"></a>JTAG(JTAG-DP)</h3><ul><li>J-Link烧录 需要4或5个引脚：<ul><li><strong>TCK：</strong>测试时钟</li><li><strong>TMS：</strong>测试模式选择</li><li><strong>TDI：</strong>测试数据输入</li><li><strong>TDO：</strong>测试数据输出</li><li><strong>TRST：</strong>测试复位（可选，5pin模式才有）</li></ul></li><li>JTAG适合复杂的调试场景，尤其是在使用J-Link调试器时。</li></ul><h2 id="LED"><a href="#LED" class="headerlink" title="LED"></a>LED</h2><h3 id="驱动代码"><a href="#驱动代码" class="headerlink" title="驱动代码"></a>驱动代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;led_app.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> ucLed[<span class="number">6</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Led_disp</span><span class="params">(<span class="type">uint8_t</span> *ucLed)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">uint8_t</span> temp = <span class="number">0x00</span>, i;</span><br><span class="line"><span class="type">static</span> <span class="type">uint8_t</span> temp_old = <span class="number">0xff</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (ucLed[i])</span><br><span class="line">temp |= (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (temp != temp_old)</span><br><span class="line">&#123;</span><br><span class="line">HAL_GPIO_WritePin(LED1_GPIO_Port, LED1_Pin, (temp &amp; <span class="number">0x01</span>) ? GPIO_PIN_SET : GPIO_PIN_RESET);</span><br><span class="line">HAL_GPIO_WritePin(LED2_GPIO_Port, LED2_Pin, (temp &amp; <span class="number">0x02</span>) ? GPIO_PIN_SET : GPIO_PIN_RESET);</span><br><span class="line">HAL_GPIO_WritePin(LED3_GPIO_Port, LED3_Pin, (temp &amp; <span class="number">0x04</span>) ? GPIO_PIN_SET : GPIO_PIN_RESET);</span><br><span class="line">HAL_GPIO_WritePin(LED4_GPIO_Port, LED4_Pin, (temp &amp; <span class="number">0x08</span>) ? GPIO_PIN_SET : GPIO_PIN_RESET);</span><br><span class="line">HAL_GPIO_WritePin(LED5_GPIO_Port, LED5_Pin, (temp &amp; <span class="number">0x10</span>) ? GPIO_PIN_SET : GPIO_PIN_RESET);</span><br><span class="line">HAL_GPIO_WritePin(LED6_GPIO_Port, LED6_Pin, (temp &amp; <span class="number">0x20</span>) ? GPIO_PIN_SET : GPIO_PIN_RESET);</span><br><span class="line">temp_old = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">led_task</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">Led_disp(ucLed);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="软件PWM呼吸灯"><a href="#软件PWM呼吸灯" class="headerlink" title="软件PWM呼吸灯"></a>软件PWM呼吸灯</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">led_task</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">static</span> <span class="type">uint32_t</span> breath_counter = <span class="number">0</span>;<span class="comment">// 呼吸效果内部计时器，模拟时间流逝</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint8_t</span> pwm_counter = <span class="number">0</span>;<span class="comment">// PWM内部计时器，用于生成PWM波形</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint8_t</span> brightness = <span class="number">0</span>;<span class="comment">// 当前的亮度值</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">uint16_t</span> breath_period = <span class="number">2000</span>; <span class="comment">// 呼吸效果周期，单位ms 调小可增加速度</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">uint16_t</span> pwm_max = <span class="number">10</span>;<span class="comment">// PWM最大计数值  调大会降低pwm频率</span></span><br><span class="line"></span><br><span class="line">breath_counter = (++breath_counter) % breath_period;</span><br><span class="line">        <span class="comment">//(2.0f * 3.14159f * breath_counter / breath_period) 将结果映射为0到2π</span></span><br><span class="line">        <span class="comment">//sin(2.0f * 3.14159f * breath_counter / breath_period) 将结果映射为-1到1</span></span><br><span class="line">        <span class="comment">//sin(2.0f * 3.14159f * breath_counter / breath_period) + 1.0f 将结果映射为0到2</span></span><br><span class="line">        <span class="comment">//(sin(2.0f * 3.14159f * breath_counter / breath_period) + 1.0f) * pwm_max / 2.0f 将实际亮度计算出来 通过(uint8_t)强制类型转换</span></span><br><span class="line">brightness = (<span class="type">uint8_t</span>)((<span class="built_in">sin</span>(<span class="number">2.0f</span> * <span class="number">3.14159f</span> * breath_counter / breath_period) + <span class="number">1.0f</span>) * pwm_max / <span class="number">2.0f</span>);</span><br><span class="line">pwm_counter = (++pwm_counter) % pwm_max;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">uint8_t</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)</span><br><span class="line">ucLed[i] = (pwm_counter &lt; brightness) ? <span class="number">1</span> : <span class="number">0</span>; <span class="comment">//将所有LED置为呼吸灯效果</span></span><br><span class="line">Led_disp(ucLed);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果是要实时调光，则直接赋值<code>brightness</code>即可 （即<span style="color:#FF3333;">不需要</span><code>breath_counter</code>和<code>breath_period</code>）</p></blockquote><h2 id="按键"><a href="#按键" class="headerlink" title="按键"></a>按键</h2><blockquote><p>常用工程上所用按键对比</p><p>github仓库地址：<a href="https://github.com/bobwenstudy/easy_button">bobwenstudy&#x2F;easy_button: 嵌入式按键处理驱动（Button Driver），支持单击、双击、多击、自动消抖、长按、长长按、超长按 | 低功耗支持 | 组合按键支持 | 静态&#x2F;动态注册支持</a></p></blockquote><p><img src="https://fastly.jsdelivr.net/gh/2250272571/tuchuang@main/img/202506061718736.png" alt="image-20250606171853466"></p><blockquote><p>整体框架：<br>easy_button<br> ├── ebtn<br> │   ├── bit_array.h<br> │   ├── ebtn.c<br> │   └── ebtn.h<br> ├── build.mk<br> ├── example_user.c<br> └── example_test.c<br> ├── main.c<br> ├── Makefile<br> └── README.md</p></blockquote><h3 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h3><h4 id="第一步：新建button-app-c并包含头文件"><a href="#第一步：新建button-app-c并包含头文件" class="headerlink" title="第一步：新建button_app.c并包含头文件"></a>第一步：新建button_app.c并包含头文件</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ebtn.h&quot;</span> <span class="comment">// 包含 ebtn 库头文件</span></span></span><br><span class="line"><span class="comment">// ... 可能还需要包含你的 HAL 库头文件 ...</span></span><br><span class="line"><span class="comment">// #include &quot;stm32xxx_hal.h&quot;</span></span><br></pre></td></tr></table></figure><h4 id="第二步：定义参数与按键列表"><a href="#第二步：定义参数与按键列表" class="headerlink" title="第二步：定义参数与按键列表"></a>第二步：定义参数与按键列表</h4><ol><li><strong>定义按键参数 (<code>ebtn_btn_param_t</code>):</strong> 使用 <code>EBTN_PARAMS_INIT</code> 宏设定按键的各种时间阈值和行为。这些参数可以被多个按键共用。<code>可用默认参数 即如下default_param_normal</code></li><li><strong>定义按键实例数组 (<code>ebtn_btn_t</code>):</strong> 使用 <code>EBTN_BUTTON_INIT</code> 宏创建每个物理按键的实例，并指定它的唯一 <code>key_id</code> 和使用的参数。</li><li><strong>（可不加）定义组合按键实例数组 (<code>ebtn_btn_combo_t</code>, 可选):</strong> 使用 <code>EBTN_BUTTON_COMBO_INIT</code> 创建组合键实例，同样指定 <code>key_id</code> 和参数。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 1. 定义按键参数实例 */</span></span><br><span class="line"><span class="comment">// 参数宏: EBTN_PARAMS_INIT(</span></span><br><span class="line"><span class="comment">//     按下消抖时间ms, 释放消抖时间ms,</span></span><br><span class="line"><span class="comment">//     单击有效最短按下时间ms, 单击有效最长按下时间ms,</span></span><br><span class="line"><span class="comment">//     多次单击最大间隔时间ms,</span></span><br><span class="line"><span class="comment">//     长按(KeepAlive)事件周期ms (0禁用),</span></span><br><span class="line"><span class="comment">//     最大连续有效点击次数 (e.g., 1=单击, 2=双击, ...)</span></span><br><span class="line"><span class="comment">// )</span></span><br><span class="line"><span class="type">const</span> <span class="type">ebtn_btn_param_t</span> default_param_normal = EBTN_PARAMS_INIT(</span><br><span class="line">    <span class="number">20</span>,     <span class="comment">// time_debounce: 按下稳定 20ms(消抖)</span></span><br><span class="line">    <span class="number">20</span>,     <span class="comment">// time_debounce_release: 释放稳定 20ms</span></span><br><span class="line">    <span class="number">50</span>,     <span class="comment">// time_click_pressed_min: 最短单击按下 50ms</span></span><br><span class="line">    <span class="number">500</span>,    <span class="comment">// time_click_pressed_max: 最长单击按下 500ms (超过则不算单击)</span></span><br><span class="line">    <span class="number">300</span>,    <span class="comment">// time_click_multi_max: 多次单击最大间隔 300ms (两次点击间隔超过则重新计数)</span></span><br><span class="line">    <span class="number">500</span>,    <span class="comment">// time_keepalive_period: 长按事件周期 500ms (按下超过 500ms 后，每 500ms 触发一次)</span></span><br><span class="line">    <span class="number">5</span>       <span class="comment">// max_consecutive: 最多支持 5 连击</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 2. 定义静态按键列表 */</span></span><br><span class="line"><span class="comment">// 宏: EBTN_BUTTON_INIT(按键ID, 参数指针)</span></span><br><span class="line"><span class="type">ebtn_btn_t</span> static_buttons[] = &#123;</span><br><span class="line">    EBTN_BUTTON_INIT(<span class="number">1</span>, &amp;default_param_normal), <span class="comment">// KEY1, ID=1, 使用 &#x27;default_param_normal&#x27; 参数</span></span><br><span class="line">    EBTN_BUTTON_INIT(<span class="number">2</span>, &amp;default_param_normal), <span class="comment">// KEY2, ID=2, 也使用 &#x27;default_param_normal&#x27; 参数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 3. 定义静态组合按键列表 (可选) */</span></span><br><span class="line"><span class="comment">// 宏: EBTN_BUTTON_COMBO_INIT(按键ID, 参数指针)</span></span><br><span class="line"><span class="type">ebtn_btn_combo_t</span> static_combos[] = &#123;</span><br><span class="line">    <span class="comment">// 假设 KEY1+KEY2 组合键</span></span><br><span class="line">    EBTN_BUTTON_COMBO_INIT(<span class="number">101</span>, &amp;default_param_normal), <span class="comment">// 组合键, ID=101 (必须与普通按键ID不同)</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="第三步：编写回调函数"><a href="#第三步：编写回调函数" class="headerlink" title="第三步：编写回调函数"></a>第三步：编写回调函数</h4><p>你需要提供两个函数给 <code>ebtn</code> 库，告诉它如何与你的硬件交互以及如何通知你事件：</p><ul><li><strong><code>get_state_fn</code> (状态获取):</strong> 这个函数被 <code>ebtn</code> 调用，用于读取指定按键当前的物理电平。</li><li><strong><code>evt_fn</code> (事件处理):</strong> 当 <code>ebtn</code> 检测到一个有效的按键事件（按下、释放、单击、长按）时，会调用这个函数，并传入触发事件的按键信息和事件类型。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 1. 实现获取按键状态的回调函数 */</span></span><br><span class="line"><span class="comment">// 函数原型: uint8_t (*ebtn_get_state_fn)(struct ebtn_btn *btn);</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">my_get_key_state</span><span class="params">(<span class="keyword">struct</span> ebtn_btn *btn)</span> &#123;</span><br><span class="line">    <span class="comment">// 根据传入的按钮实例中的 key_id 判断是哪个物理按键</span></span><br><span class="line">    <span class="keyword">switch</span> (btn-&gt;key_id) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>: <span class="comment">// 请求读取 KEY1 的状态</span></span><br><span class="line">            <span class="comment">// 假设 KEY1 接在 PB0，按下为低电平 (返回 1 代表按下)</span></span><br><span class="line">            <span class="keyword">return</span> (HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_0) == GPIO_PIN_RESET);</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>: <span class="comment">// 请求读取 KEY2 的状态</span></span><br><span class="line">            <span class="comment">// 假设 KEY2 接在 PB1，按下为低电平</span></span><br><span class="line">            <span class="keyword">return</span> (HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_1) == GPIO_PIN_RESET);</span><br><span class="line">        <span class="comment">// ... 可以添加更多按键的读取逻辑 ...</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="comment">// 对于库内部处理组合键等情况，或者未知的 key_id，安全起见返回 0 (未按下)</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 注意：返回值 1 表示 &quot;活动/按下&quot;，0 表示 &quot;非活动/释放&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 2. 实现处理按键事件的回调函数 */</span></span><br><span class="line"><span class="comment">// 函数原型: void (*ebtn_evt_fn)(struct ebtn_btn *btn, ebtn_evt_t evt);</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">my_handle_key_event</span><span class="params">(<span class="keyword">struct</span> ebtn_btn *btn, <span class="type">ebtn_evt_t</span> evt)</span> &#123;</span><br><span class="line">    <span class="type">uint16_t</span> key_id = btn-&gt;key_id;                 <span class="comment">// 获取触发事件的按键 ID</span></span><br><span class="line">    <span class="type">uint16_t</span> click_cnt = ebtn_click_get_count(btn); <span class="comment">// 获取连击次数 (仅在 ONCLICK 事件时有意义)</span></span><br><span class="line">    <span class="comment">// uint16_t kalive_cnt = ebtn_keepalive_get_count(btn); // 获取长按计数 (仅在 KEEPALIVE 事件时有意义)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调试打印 (可选)</span></span><br><span class="line">    <span class="comment">// printf(&quot;Key ID: %d, Event: %d&quot;, key_id, evt);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据事件类型进行处理</span></span><br><span class="line">    <span class="keyword">switch</span> (evt) &#123;</span><br><span class="line">        <span class="keyword">case</span> EBTN_EVT_ONPRESS: <span class="comment">// 按下事件 (消抖成功后触发一次)</span></span><br><span class="line">            <span class="comment">// printf(&quot; - Pressed\n&quot;);</span></span><br><span class="line">            <span class="comment">// 可以在这里处理按下即触发的操作，比如点亮提示灯</span></span><br><span class="line">            <span class="keyword">if</span> (key_id == <span class="number">1</span>) &#123; <span class="comment">/* Do something for KEY1 press */</span> &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> EBTN_EVT_ONRELEASE: <span class="comment">// 释放事件 (消抖成功后触发一次)</span></span><br><span class="line">            <span class="comment">// printf(&quot; - Released\n&quot;);</span></span><br><span class="line">            <span class="comment">// 可以在这里处理释放时触发的操作</span></span><br><span class="line">             <span class="keyword">if</span> (key_id == <span class="number">1</span>) &#123; <span class="comment">/* Do something for KEY1 release */</span> &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> EBTN_EVT_ONCLICK: <span class="comment">// 单击/连击事件 (在释放后，或达到最大连击数，或超时后触发)</span></span><br><span class="line">            <span class="comment">// printf(&quot; - Clicked (%d times)\n&quot;, click_cnt);</span></span><br><span class="line">            <span class="comment">// --- 根据 key_id 和 click_cnt 执行不同操作 ---</span></span><br><span class="line">            <span class="keyword">if</span> (key_id == <span class="number">1</span>) &#123; <span class="comment">// 如果是 KEY1 触发的 CLICK</span></span><br><span class="line">                <span class="keyword">if</span> (click_cnt == <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="comment">// KEY1 单击</span></span><br><span class="line">                    <span class="comment">// printf(&quot;  Action: KEY1 Single Click - Toggle LED1\n&quot;);</span></span><br><span class="line">                    <span class="comment">// HAL_GPIO_TogglePin(LED1_GPIO_Port, LED1_Pin);</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (click_cnt == <span class="number">2</span>) &#123;</span><br><span class="line">                    <span class="comment">// KEY1 双击</span></span><br><span class="line">                    <span class="comment">// printf(&quot;  Action: KEY1 Double Click - Switch Mode\n&quot;);</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// ... 可以继续判断 3击, 4击 ...</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key_id == <span class="number">2</span>) &#123; <span class="comment">// 如果是 KEY2 触发的 CLICK</span></span><br><span class="line">                 <span class="keyword">if</span> (click_cnt == <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="comment">// KEY2 单击</span></span><br><span class="line">                    <span class="comment">// printf(&quot;  Action: KEY2 Single Click - Toggle LED2\n&quot;);</span></span><br><span class="line">                 &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key_id == <span class="number">101</span>) &#123; <span class="comment">// 如果是组合键 (KEY1+KEY2) 触发的 CLICK</span></span><br><span class="line">                <span class="keyword">if</span> (click_cnt == <span class="number">1</span>) &#123;</span><br><span class="line">                     <span class="comment">// 组合键单击</span></span><br><span class="line">                     <span class="comment">// printf(&quot;  Action: Combo Key 101 Single Click - Reset System\n&quot;);</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> EBTN_EVT_KEEPALIVE: <span class="comment">// 保持活动/长按事件 (按下持续时间超过阈值后，按周期触发)</span></span><br><span class="line">            <span class="comment">// printf(&quot; - Keep Alive (Long Press, Count: %d)\n&quot;, kalive_cnt);</span></span><br><span class="line">            <span class="keyword">if</span> (key_id == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// KEY1 长按</span></span><br><span class="line">                <span class="comment">// printf(&quot;  Action: KEY1 Long Press - Increase Volume\n&quot;);</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>: <span class="comment">// 未知事件 (理论上不应发生)</span></span><br><span class="line">            <span class="comment">// printf(&quot; - Unknown Event\n&quot;);</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="第四步：初始化-ebtn-库"><a href="#第四步：初始化-ebtn-库" class="headerlink" title="第四步：初始化 ebtn 库"></a>第四步：初始化 ebtn 库</h4><p>在系统启动的初始化阶段（例如 <code>main</code> 函数开始处，或专门的初始化函数中），调用 <code>ebtn_init</code> 函数，将之前准备好的按键列表和回调函数”注册”给 <code>ebtn</code> 库。</p><p>如果使用了组合按键，还需要在 <code>ebtn_init</code> <strong>之后</strong>，调用相关函数将普通按键绑定到组合键上。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">button_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ebtn_init(</span><br><span class="line">        static_buttons,                 <span class="comment">// 静态按键数组的指针</span></span><br><span class="line">        EBTN_ARRAY_SIZE(static_buttons), <span class="comment">// 静态按键数量 (用宏计算)</span></span><br><span class="line">        static_combos,                  <span class="comment">// 静态组合按键数组的指针 (如果没有，传 NULL, 0)</span></span><br><span class="line">        EBTN_ARRAY_SIZE(static_combos), <span class="comment">// 静态组合按键数量 (如果没有，传 0)</span></span><br><span class="line">        my_get_key_state,               <span class="comment">// 你的状态获取回调函数</span></span><br><span class="line">        my_handle_key_event             <span class="comment">// 你的事件处理回调函数</span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//下面这个函数可以在调度器中每5秒调用</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">button_task</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ebtn_process(uwTick);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SD-FATFS"><a href="#SD-FATFS" class="headerlink" title="SD+FATFS"></a>SD+FATFS</h2><h3 id="CubeMX配置"><a href="#CubeMX配置" class="headerlink" title="CubeMX配置"></a>CubeMX配置</h3><p><img src="https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509232059309.png" alt="image-20250923205942773"></p><p><img src="https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509232100265.png" alt="image-20250923210029131"></p><p><img src="https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509281144270.png" alt="image-20250928114434875"></p><blockquote><p>注意：如果TF-CARD上的CD引脚有接入gpio的话 可以将platform设置为该引脚 即检测SD卡引脚</p><ul><li><p>当该引脚为低电平时，则检测到sd卡</p></li><li><p>没有接gpio的话，platform不要设置 不然会读取不到卡</p><p><img src="https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509232103277.png" alt="image-20250923210313143"></p><p>正点原子探索者v3没有设计该引脚 所以留空即可</p><p><img src="https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509232103527.png" alt="image-20250923210355410"></p></li></ul></blockquote><h3 id="使用步骤-1"><a href="#使用步骤-1" class="headerlink" title="使用步骤"></a>使用步骤</h3><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SD_Driver.disk_initialize(<span class="number">0</span>); <span class="comment">// SD_Driver已经被声明在FATFS/Target/sd_diskio.c</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> MCU </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式基础 </tag>
            
            <tag> GD32学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TI</title>
      <link href="/2025/05/28/TI/"/>
      <url>/2025/05/28/TI/</url>
      
        <content type="html"><![CDATA[<h2 id="初始化代码"><a href="#初始化代码" class="headerlink" title="初始化代码"></a>初始化代码</h2><h3 id="浮点单元（FPU）相关配置"><a href="#浮点单元（FPU）相关配置" class="headerlink" title="浮点单元（FPU）相关配置"></a>浮点单元（FPU）相关配置</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ROM_FPUEnable(); / 使能浮点单元</span><br><span class="line">ROM_FPULazyStackingEnable(); / 启用浮点延迟堆栈模式，减少中断响应延迟    </span><br></pre></td></tr></table></figure><p><strong>浮点单元（FPU）</strong></p><ul><li><p>浮点单元是 Cortex-M4 芯片（如 Tiva-C）内的硬件模块，用于加速浮点运算（如浮点加法、乘法）。</p></li><li><p>如果你的项目中使用了<code>带小数</code>的计算（如定点PID控制、FFT计算、浮点除法），硬件 FPU 的加速能力远远优于软件模拟。</p></li></ul><p><strong>Lazy Stacking 模式</strong></p><ul><li>启用延迟堆栈推入操作后，在中断期间，只有确实需要使用浮点硬件时，才会将浮点寄存器保存到堆栈，从而减少中断响应时间和堆栈占用空间。</li></ul><h3 id="实际开发中怎么使用和修改"><a href="#实际开发中怎么使用和修改" class="headerlink" title="实际开发中怎么使用和修改"></a><strong>实际开发中怎么使用和修改</strong></h3><h4 id="启用还是禁用-FPU："><a href="#启用还是禁用-FPU：" class="headerlink" title="?  启用还是禁用  FPU："></a>?  启用还是禁用  FPU：</h4><ul><li>如果项目中<code>不涉及浮点运算</code>，可以省略这两个函数的调用以节省资源</li></ul><h4 id="启用延迟堆栈的条件："><a href="#启用延迟堆栈的条件：" class="headerlink" title="启用延迟堆栈的条件："></a>启用延迟堆栈的条件：</h4><ul><li><p>如果中断中涉及浮点运算，建议<code>启用 Lazy Stacking</code> 优化性能。</p></li><li><p>但需要注意堆栈深度：<span style="text-decoration:line-through;">中断嵌套可能导致浮点堆栈溢出</span>，调试时<span style="color:#66FFFF;">增加栈尺寸</span>。</p></li></ul><h2 id="时钟系统配置"><a href="#时钟系统配置" class="headerlink" title="时钟系统配置"></a>时钟系统配置</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROM_SysCtlClockSet(SYSCTL_SYSDIV_2_5 | SYSCTL_USE_PLL | SYSCTL_XTAL_16MHZ | SYSCTL_OSC_MAIN); / 配置系统时钟</span><br></pre></td></tr></table></figure><ul><li><span style="color:#3399FF;">参数说明</span>：</li></ul><ol><li><p><code>SYSCTL_SYSDIV_2_5</code>：</p><ul><li>设置系统分频比， 2.5 是分频因子。</li><li>假设外部晶振频率为 16MHz，PLL 经过倍频后输出为 400MHz， 2.5 分频下得到时钟频率：400 ÷ 2.5 &#x3D; 80MHz 。</li></ul></li><li><p><code>SYSCTL_USE_PLL</code>：</p><ul><li>指定使用 PLL（锁相环）作为系统时钟的倍频源。</li></ul></li><li><p><code>SYSCTL_XTAL_16MHZ</code>：</p><ul><li>配置外部晶振的规格为 16MHz，这需要与硬件实际晶振频率相匹配。</li></ul></li><li><p><code>SYSCTL_OSC_MAIN</code>：</p><ul><li>指定使用外部主振荡器作为系统的时钟输入源。</li></ul></li></ol><h3 id="实际开发中怎么使用和修改-1"><a href="#实际开发中怎么使用和修改-1" class="headerlink" title="实际开发中怎么使用和修改"></a>实际开发中怎么使用和修改</h3><h4 id="如何修改分频比和主频："><a href="#如何修改分频比和主频：" class="headerlink" title="如何修改分频比和主频："></a><strong>如何修改分频比和主频</strong>：</h4><ul><li><p>如果需要更改 MCU 的主频（系统时钟频率），只需调整分频因子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROM_SysCtlClockSet(SYSCTL_SYSDIV_4 | SYSCTL_USE_PLL | SYSCTL_XTAL_16MHZ | SYSCTL_OSC_MAIN);</span><br></pre></td></tr></table></figure><p>示例中，分频比改为 4 ，主频变为 400 ÷ 4 &#x3D; 100MHz 。</p></li></ul><h4 id="如果硬件使用其他晶振"><a href="#如果硬件使用其他晶振" class="headerlink" title="如果硬件使用其他晶振"></a>如果硬件使用其他晶振</h4><ul><li><p>如果使用 8MHz 的晶振，应修改 <code>SYSCTL_XTAL_16MHZ</code> 为 <code>SYSCTL_XTAL_8MHZ</code> ：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROM_SysCtlClockSet(SYSCTL_SYSDIV_2_5 | SYSCTL_USE_PLL | SYSCTL_XTAL_8MHZ | SYSCTL_OSC_MAIN);</span><br></pre></td></tr></table></figure></li></ul><h4 id="切换时钟源"><a href="#切换时钟源" class="headerlink" title="切换时钟源"></a>切换时钟源</h4><ul><li><p>如果不使用外部晶振，可以切换为 <strong>内部振荡器</strong> (Precision Internal Oscillator, PIOSC)：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROM_SysCtlClockSet(SYSCTL_SYSDIV_2_5 | SYSCTL_USE_PLL | SYSCTL_OSC_INT);</span><br></pre></td></tr></table></figure></li></ul><h2 id="外设（GPIO）启用和配置"><a href="#外设（GPIO）启用和配置" class="headerlink" title="外设（GPIO）启用和配置"></a>外设（GPIO）启用和配置</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOF); / 启用 GPIOF 外设</span><br><span class="line">ROM_GPIOPinTypeGPIOOutput(GPIO_PORTF_BASE, GPIO_PIN_5); / 配置 GPIOF <span class="number">5</span> 为推挽输出</span><br><span class="line">ROM_GPIOPinTypeGPIOOutput(GPIO_PORTF_BASE, GPIO_PIN_6); / 配置 GPIOF <span class="number">6</span> 为推挽输出</span><br><span class="line">ROM_GPIOPinTypeGPIOOutput(GPIO_PORTF_BASE, GPIO_PIN_4); / 配置 GPIOF <span class="number">4</span> 为推挽输出</span><br></pre></td></tr></table></figure><h4 id="GPIO-配置解析"><a href="#GPIO-配置解析" class="headerlink" title="GPIO 配置解析"></a><strong>GPIO 配置解析</strong></h4><ol><li><p><strong>使能时钟</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOF);</span><br></pre></td></tr></table></figure></li></ol><ul><li>使能<code>GPIOF</code>外设的时钟</li><li>每个外设模块在使用前都必须先使能其时钟，否则无法访问寄存器</li></ul><ol start="2"><li><p><strong>配置推挽输出</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROM_GPIOPinTypeGPIOOutput(GPIO_PORTF_BASE, GPIO_PIN_X);</span><br></pre></td></tr></table></figure></li></ol><ul><li>将<code>GPIOF</code>的某个引脚配置为<code>推挽输出</code></li></ul><ol start="3"><li><p><strong>配置输入模式</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROM_GPIOPinTypeGPIOInput(GPIO_PORTF_BASE, GPIO_PIN_5);</span><br></pre></td></tr></table></figure></li></ol><ul><li>将<code>PF5</code>引脚配置为输入</li></ul><h3 id="串口代码"><a href="#串口代码" class="headerlink" title="串口代码"></a>串口代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOA); / 启用 GPIOA 外设</span><br><span class="line">ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_UART0); / 启用 UART0 外设</span><br></pre></td></tr></table></figure><h4 id="配置UART引脚模式"><a href="#配置UART引脚模式" class="headerlink" title="配置UART引脚模式"></a>配置UART引脚模式</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ROM_GPIOPinConfigure(GPIO_PA0_U0RX); / 配置 GPIOA 引脚 <span class="number">0</span> 为 UART0 RX</span><br><span class="line"><span class="title function_">ROM_GPIOPinConfigure</span><span class="params">(GPIO_PA1_U0TX)</span>; / 配置 GPIOA 引脚 <span class="number">1</span> 为 UART0 TX</span><br><span class="line"><span class="title function_">ROM_GPIOPinTypeUART</span><span class="params">(GPIO_PORTA_BASE, GPIO_PIN_0 | GPIO_PIN_1)</span>; / 配置 GPIO PA0 和 PA1 为UART 模式</span><br></pre></td></tr></table></figure><ul><li><span style="color:#3399FF;">参数说明</span>：</li></ul><ol><li><p><code>ROM_GPIOPinConfigure(pinConfig)</code>：</p><ul><li>将某个 GPIO 引脚映射为对应外设的功能模式，例如 UART RX（接收）或 UART TX（发送）模式</li><li><code>GPIO_PA0_U0RX</code>和 <code>GPIO_PA1_U0TX</code> 分别表示将 GPIOA 的 0 和 1 引脚映射到 UART0 的 RX 和 TX信号。</li></ul></li><li><p><code>ROM_GPIOPinTypeUART()</code>：</p><ul><li>配置对应引脚为 UART 模式（主功能），指示这些引脚负责 UART 的输入和输出。</li></ul></li><li><p><strong>引脚复用说明</strong>：</p><ul><li><p>某些 GPIO 引脚具备多种功能（如 UART、SPI、I2C 等），可以通过 <code>ROM_GPIOPinConfigure() </code>设置引脚的复用功能。</p></li><li><p>数据手册中会列出默认出厂配置（如 GPIOA0、GPIOA1 默认是普通 I&#x2F;O）以及复用编号</p></li></ul></li></ol><h4 id="配置UART0模块"><a href="#配置UART0模块" class="headerlink" title="配置UART0模块"></a>配置UART0模块</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UARTStdioConfig(<span class="number">0</span>, <span class="number">115200</span>, <span class="number">16000000</span>); / 配置 UART0，设置波特率为 <span class="number">115200</span>，时钟频率为 <span class="number">16</span>MHz</span><br><span class="line"><span class="title function_">UARTClockSourceSet</span><span class="params">(UART0_BASE, UART_CLOCK_PIOSC)</span>; / 将 UART0 的时钟源设为内部精确振荡器PIOSC</span><br></pre></td></tr></table></figure><p><code>UARTStdioConfig() 详解：</code></p><ul><li>用于配置 UART 模块的一些核心参数，例如 UART 通信模块的编号、默认的通信波特率、UART 时钟频率。</li></ul><ol><li><span style="color:#3399FF;">参数说明</span>：</li></ol><ul><li><code>0</code> ：指定 UART 模块编号， 0 对应 UART0。</li><li><code>115200</code> ：波特率，表示每秒传输 115200 个比特。</li><li><code>16000000</code> ：UART 输入时钟频率（以 Hz 为单位），这里指定为 16MHz。</li></ul><ol start="2"><li>作用：<ul><li>根据设置的波特率和时钟频率， <code>UARTStdioConfig</code> 会自动计算并配置 UART 波特率控制寄存器，从而实现正确的通信速率。</li></ul></li><li><strong>默认时钟源（</strong>PIOSC <strong>内部振荡器）</strong></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UARTClockSourceSet(UART0_BASE, UART_CLOCK_PIOSC); / 使用 PIOSC（<span class="number">16</span> MHz）作为时钟源</span><br></pre></td></tr></table></figure><ul><li>PIOSC 是 Tiva-C 系统内置的精确振荡器，频率为 16 MHz。</li><li>替代方案：你可以改用系统主时钟（如 PLL）作为 UART 的时钟源。</li></ul>]]></content>
      
      
      <categories>
          
          <category> MCU </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RT_Thread</title>
      <link href="/2025/05/21/RT-Thread/"/>
      <url>/2025/05/21/RT-Thread/</url>
      
        <content type="html"><![CDATA[<h2 id="时钟管理"><a href="#时钟管理" class="headerlink" title="时钟管理"></a>时钟管理</h2><h3 id="时钟节拍产生与获取"><a href="#时钟节拍产生与获取" class="headerlink" title="时钟节拍产生与获取"></a>时钟节拍产生与获取</h3><p>时钟节拍依赖于硬件中的定时器。你可以把定时器看作是⼀个不停计时的装置，它每隔⼀段时间就会提醒系统“滴答”⼀次。<span style="text-decoration:underline;">每当定时器中断发⽣时，RT-Thread 会调⽤ rt_tick_increase()函数，系统时间增加 1 个节拍</span>。<code>就像家中的闹钟响⼀次，时间就过去了⼀分钟⼀样。</code></p><blockquote><p>其中rt_tick_increase()函数中有rt_tick类似于HAL库中的uwTick，可以直接调用 获取系统时间</p></blockquote><h2 id="定时器管理"><a href="#定时器管理" class="headerlink" title="定时器管理"></a>定时器管理</h2><h3 id="硬件定时器-vs-软件定时器"><a href="#硬件定时器-vs-软件定时器" class="headerlink" title="硬件定时器 vs 软件定时器"></a>硬件定时器 vs 软件定时器</h3><ol><li><span style="color:#FF3399;">硬件定时器</span>：就像厨房⾥的倒计时器，它是由硬件直接提供的。硬件定时器精度⾮常⾼，可以达到纳秒级，适合⼀些对时间要求⾮常严格的任务，⽐如控制电机的旋转时间。</li><li><span style="color:#FF3399;">软件定时器</span>：可以理解为⼿机上的计时 App。它依赖于操作系统的时钟节拍来⼯作，它的时间间隔精度由 OS Tick 决定。例如，如果 OS Tick 是 10ms，那么软件定时器只能精确到 10ms。虽然精度不如硬件定时器⾼，但它更灵活、容易使⽤。</li></ol><h3 id="RTT定时器分类"><a href="#RTT定时器分类" class="headerlink" title="RTT定时器分类"></a>RTT定时器分类</h3><ul><li><span style="color:#FF3399;">单次触发定时器</span>：就像倒计时⼀次的闹钟，响⼀次后就停⽌。例如，设定⼀个 5 秒的倒计时，时间到了闹钟响⼀次就结束了。</li><li><span style="color:#FF3399;">周期触发定时器</span>：就像那些每天早上 7 点重复响起的闹钟。每隔⼀段时间，它会周期性地触发事件，直到你⼿动关闭它。</li></ul><p>根据定时器回调函数执⾏的上下⽂环境，定时器还可以分为两种模式：</p><ul><li><span style="color:#FF3399;">硬件模式 </span>(HARD_TIMER)：定时器的回调函数在<span style="text-decoration:underline;">中断上下⽂</span>中执⾏<code>就像闹钟响起时你⽴刻跳起来⼀样</code>它反应⾮常快，但要求处理时间短。</li><li><span style="color:#FF3399;">软件模式</span> (SOFT_TIMER)：回调函数在<span style="text-decoration:underline;">系统的 timer 线程中</span>执⾏，相当于<code>有⼈提醒你“闹钟响了”</code>，然后你再去执⾏⼀些动作。这个模式可以做更复杂的操作，因为它不是在中断中执⾏。</li></ul><h3 id="控制定时器"><a href="#控制定时器" class="headerlink" title="控制定时器"></a>控制定时器</h3><p><code>通过该函数你可以随时改变定时器触发方式以及定时器时间</code></p><p><img src="https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505212214569.png" alt="image-20250521221429133"></p><h3 id="高精度延时"><a href="#高精度延时" class="headerlink" title="高精度延时"></a>高精度延时</h3><p><code>使用该函数可以实现微妙级的精确延时，适合高精度时间控制场合</code></p><p><img src="https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505212215044.png" alt="image-20250521221525259"></p><h2 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h2><p><img src="https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505212034310.png" alt="image-20250521203425658"></p><ul><li><code>name</code>：线程名字</li><li><code>entry</code>：线程入口函数</li><li><code>parameter</code>：传递给线程的参数</li><li><code>stack_size</code>：线程栈大小</li><li><code>priority</code>：线程优先级</li><li><code>tick</code>：时间片</li></ul><h3 id="详细步骤"><a href="#详细步骤" class="headerlink" title="详细步骤"></a>详细步骤</h3><ol><li>声明一个pcb结构体 <code>static rt_thread_t tid1 = RT_NULL;</code></li><li>编写线程入口函数 <code>static void thread1_entry(void *parameter)</code>，参数为必需，其为传递给线程的参数</li><li>利用<code>rt_thread_create</code>函数赋值给所声明的pcb结构体tid1</li><li>利用<code>rt_thread_startup(tid1)</code>函数启动线程</li></ol><h3 id="实现示例"><a href="#实现示例" class="headerlink" title="实现示例"></a>实现示例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">thread1_proc</span><span class="params">(<span class="type">void</span> *parameter)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*实际功能*/</span></span><br><span class="line">        rt_thread_mdelay(<span class="number">1000</span>);<span class="comment">//休息1秒</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">thread1_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">rt_thread_t</span> tid1 =  rt_thread_create(<span class="string">&quot;thread1_proc&quot;</span>,thread1_proc,RT_NULL,<span class="number">1024</span>,<span class="number">10</span>,<span class="number">20</span>);</span><br><span class="line">    <span class="keyword">if</span>(tid1 != RT_NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        rt_thread_startup(tid1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> RT_EOK;</span><br><span class="line">&#125;</span><br><span class="line">INIT_COMPONENT_EXPORT(thread1_init);   <span class="comment">//用这个宏就不需要另外再去注册</span></span><br></pre></td></tr></table></figure><blockquote><p><span style="font-style:italic;">rt_thread_mdelay(1000)的工作机制：</span></p><p><span style="font-style:italic;">1、当 rt_thread_mdelay 被调⽤时，当前线程会进⼊ RT_THREAD_SUSPEND 状态（<span style="color:#CC00CC;">挂起</span>状态）。</span></p><p><span style="font-style:italic;">2、调度器开始运⾏其他优先级相同或更⾼的线程。</span></p><p><span style="font-style:italic;">3、 <span style="text-decoration:underline;">延时时间结束后，线程从 挂起状态 转变为 就绪状态</span> ，等待系统再次调度该线程。</span></p><p><span style="font-style:italic;">PS：若此时无其他线程，则CPU就处于释放状态</span></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505212056766.png" alt="image-20250521205640868"></p><h2 id="线程间同步"><a href="#线程间同步" class="headerlink" title="线程间同步"></a>线程间同步</h2><h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>信号量可以理解为电影院的座位数（<span style="color:#FF0000;">资源数量</span>）。当所有座位都满了，新的观众（线程）就需要等前⾯的观众离开（释放资源）才能进⼊。当有空位时，观众可以进⼊。<code>信号量通过控制资源的数量来管理多个线程对资源的访问</code></p><h4 id="工作机制"><a href="#工作机制" class="headerlink" title="工作机制"></a>工作机制</h4><ul><li><p><code>获取信号量</code>：当资源可⽤时，线程可以获取信号量，<span style="color:#FF0000;">信号量的值减1</span>。<span style="background:#66FFFF;">如果信号量的值为0，线程就会等待，直到资源释放</span></p></li><li><p><code>释放信号量</code>：使⽤完资源后，线程释放信号量，<span style="color:#FF0000;">信号量的值加1</span>，允许其他线程访问资源</p></li></ul><h5 id="创建信号量"><a href="#创建信号量" class="headerlink" title="创建信号量"></a>创建信号量</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*动态分配内存并创建信号量*/</span></span><br><span class="line"><span class="type">rt_sem_t</span> <span class="title function_">rt_sem_create</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">rt_uint32_t</span> value, <span class="type">rt_uint8_t</span> flag)</span>;</span><br><span class="line"><span class="comment">/*静态分配内存并创建信号量*/</span></span><br><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_sem_init</span><span class="params">(<span class="type">rt_sem_t</span> sem, <span class="type">const</span> <span class="type">char</span> *name, <span class="type">rt_uint32_t</span> value,<span class="type">rt_uint8_t</span> flag)</span>;</span><br></pre></td></tr></table></figure><ul><li><p><span style="color:#3399FF;">参数说明</span>：</p></li><li><p><code>name</code>：信号量的名字（可以为 <code>RT_NULL</code> 表⽰匿名信号量）。</p></li><li><p><code>value</code>：信号量的初始值，表⽰信号量当前持有的资源数量（<code>例如初始值为 0 表⽰等待事件，为 1 表⽰互斥量，或者更⼤值表⽰资源计数</code>）。</p></li><li><p><code>flag</code>：PC 对象的属性标志，常⽤值：</p></li><li><p><code>RT_IPC_FLAG_PRIO</code> ：<span style="color:#FF0000;">优先级</span>等待⽅式，等待线程按照优先级顺序排列。</p></li><li><p><code>RT_IPC_FLAG_FIFO</code> ：<span style="color:#FF0000;">先⼊先出</span>等待⽅式，等待线程按照进⼊顺序排列。</p></li></ul><h5 id="获取信号量"><a href="#获取信号量" class="headerlink" title="获取信号量"></a>获取信号量</h5><p>⽤于获取信号量（P 操作），线程会尝试获取信号量，<code>如果信号量的计数值为 0，线程会进⼊等待状态</code>，直到信号量被释放或超时。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_sem_take</span><span class="params">(<span class="type">rt_sem_t</span> sem, <span class="type">rt_int32_t</span> time)</span>;</span><br></pre></td></tr></table></figure><ul><li><p><span style="color:#3399FF;">参数说明</span>：</p></li><li><p><code>sem</code>：信号量的句柄。</p></li><li><p><code>time</code>：超时时间（单位为系统 tick），表⽰最⼤等待时间。如果设置为 <code>RT_WAITING_FOREVER</code> ，线程会⼀直等待</p></li></ul><h5 id="释放信号量"><a href="#释放信号量" class="headerlink" title="释放信号量"></a>释放信号量</h5><p>⽤于释放信号量（V 操作），<strong>增加</strong>信号量的计数值，<code>并唤醒等待该信号量的线程</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_sem_release</span><span class="params">(<span class="type">rt_sem_t</span> sem)</span>;</span><br></pre></td></tr></table></figure><h4 id="应用示例"><a href="#应用示例" class="headerlink" title="应用示例"></a>应用示例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;rtthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">rt_sem_t</span> sem = RT_NULL;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">thread1</span><span class="params">(<span class="type">void</span> *parameter)</span></span><br><span class="line">&#123;</span><br><span class="line">   rt_kprintf(<span class="string">&quot;线程1：等待线程2发送信号\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">/*等待信号量，超时时间为永久等待*/</span></span><br><span class="line">   rt_sem_take(sem,RT_WAITING_FOREVER);</span><br><span class="line"></span><br><span class="line">   rt_kprintf(<span class="string">&quot;线程1：收到线程2的信号，继续执行....\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">thread2</span><span class="params">(<span class="type">void</span> *parameter)</span></span><br><span class="line">&#123;</span><br><span class="line">   rt_kprintf(<span class="string">&quot;线程2：执行一些操作\n&quot;</span>);</span><br><span class="line">   <span class="comment">/*模拟执行一些动作*/</span></span><br><span class="line">   rt_thread_mdelay(<span class="number">2000</span>);</span><br><span class="line">   rt_kprintf(<span class="string">&quot;线程2：操作完成，发送信号给线程1\n&quot;</span>);</span><br><span class="line">   <span class="comment">/*释放信号量 通知线程1*/</span></span><br><span class="line">   rt_sem_release(sem);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">rt_thread_t</span> tid1 = RT_NULL;</span><br><span class="line">    <span class="type">rt_thread_t</span> tid2 = RT_NULL;</span><br><span class="line"></span><br><span class="line">    sem = rt_sem_create(<span class="string">&quot;sem&quot;</span>, <span class="number">0</span>, RT_IPC_FLAG_PRIO);</span><br><span class="line">    tid1 = rt_thread_create(<span class="string">&quot;tid1&quot;</span>, thread1, RT_NULL, <span class="number">1024</span>, <span class="number">25</span>, <span class="number">100</span>);</span><br><span class="line">    tid2 = rt_thread_create(<span class="string">&quot;tid2&quot;</span>, thread2, RT_NULL, <span class="number">1024</span>, <span class="number">25</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(tid1 != RT_NULL) rt_thread_startup(tid1);</span><br><span class="line">    <span class="keyword">if</span>(tid2 != RT_NULL) rt_thread_startup(tid2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><ol><li>任务同步（多任务协调执行顺序）</li><li>任务互斥(使用<code>互斥量</code> 保证同一时间只有一个线程 访问公共资源)</li><li>事件触发</li><li>限量资源管理</li></ol><h3 id="互斥量（Mutex）"><a href="#互斥量（Mutex）" class="headerlink" title="互斥量（Mutex）"></a><strong>互斥量（Mutex）</strong></h3><h4 id="工作机制-1"><a href="#工作机制-1" class="headerlink" title="工作机制"></a><strong>工作机制</strong></h4><p>互斥量确保同⼀时刻<strong>只有⼀个线程能够访问共享资源</strong>：</p><ul><li><code>获取互斥量</code>：当⼀个线程获取到互斥量时，其他线程不能访问该资源，直到互斥量被释放。</li><li><code>释放互斥量</code>：当线程释放互斥量后，其他等待的线程才能访问资源</li></ul><h5 id="创建互斥量"><a href="#创建互斥量" class="headerlink" title="创建互斥量"></a><strong>创建互斥量</strong></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*动态创建一个互斥量*/</span></span><br><span class="line"><span class="type">rt_mutex_t</span> <span class="title function_">rt_mutex_create</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">rt_uint8_t</span> flag)</span>;</span><br><span class="line"><span class="comment">/*静态创建一个互斥量*/</span></span><br><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_mutex_init</span><span class="params">(<span class="type">rt_mutex_t</span> mutex, <span class="type">const</span> <span class="type">char</span> *name, <span class="type">rt_uint8_t</span> flag)</span>;</span><br></pre></td></tr></table></figure><ul><li><span style="color:#3399FF;">参数说明</span>：</li><li><code>name</code>：互斥量的名字（可以为 <code>RT_NULL</code> 表⽰匿名互斥量）。</li><li><code>flag</code>：IPC 对象的属性标志，通常使⽤ <code>RT_IPC_FLAG_PRIO</code> 表⽰优先级等待。</li></ul><h5 id="获取互斥量"><a href="#获取互斥量" class="headerlink" title="获取互斥量"></a><strong>获取互斥量</strong></h5><p>⽤于获取互斥量，线程通过调⽤此函数进⼊临界区。<code>如果互斥量已经被其他线程获取，当前线程会进⼊等待状态，直到获取成功或超时。</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_mutex_take</span><span class="params">(<span class="type">rt_mutex_t</span> mutex, <span class="type">rt_int32_t</span> time)</span>;</span><br></pre></td></tr></table></figure><ul><li><span style="color:#3399FF;">参数说明</span>：</li><li><code>mutex</code>：互斥量的句柄。</li><li><code>time</code>：超时时间（单位为系统 tick），可以指定等待时⻓或 <code>RT_WAITING_FOREVER</code>表⽰永远等待。</li></ul><h5 id="释放互斥量"><a href="#释放互斥量" class="headerlink" title="释放互斥量"></a>释放互斥量</h5><p>⽤于释放互斥量（V 操作），<strong>增加</strong>互斥量的计数值，并唤醒等待该互斥量的线程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_mutex_release</span><span class="params">(<span class="type">rt_mutex_t</span> mutex)</span>;</span><br></pre></td></tr></table></figure><h4 id="应用示例-1"><a href="#应用示例-1" class="headerlink" title="应用示例"></a><strong>应用示例</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;rtthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">rt_mutex_t</span> mutex = RT_NULL;</span><br><span class="line"><span class="type">rt_uint32_t</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">thread1</span><span class="params">(<span class="type">void</span> *parameter)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">//rt_kprintf(&quot;线程1：等待线程2发送信号\n&quot;);</span></span><br><span class="line">   <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">   &#123;</span><br><span class="line">       rt_mutex_take(mutex,RT_WAITING_FOREVER);</span><br><span class="line">       cnt++;</span><br><span class="line">       rt_thread_mdelay(<span class="number">1000</span>);</span><br><span class="line">       rt_kprintf(<span class="string">&quot;线程1 cnt = %d \n&quot;</span>,cnt);</span><br><span class="line">       rt_mutex_release(mutex);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">thread2</span><span class="params">(<span class="type">void</span> *parameter)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">//rt_kprintf(&quot;线程2：执行一些操作\n&quot;);</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        rt_mutex_take(mutex,RT_WAITING_FOREVER);</span><br><span class="line">        cnt++;</span><br><span class="line">        rt_thread_mdelay(<span class="number">1000</span>);</span><br><span class="line">        rt_kprintf(<span class="string">&quot;线程2 cnt = %d \n&quot;</span>,cnt);</span><br><span class="line">        rt_mutex_release(mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">rt_thread_t</span> tid1 = RT_NULL;</span><br><span class="line">    <span class="type">rt_thread_t</span> tid2 = RT_NULL;</span><br><span class="line"></span><br><span class="line">    mutex = rt_mutex_create(<span class="string">&quot;mutex&quot;</span>, RT_IPC_FLAG_PRIO);</span><br><span class="line">    tid1 = rt_thread_create(<span class="string">&quot;tid1&quot;</span>, thread1, RT_NULL, <span class="number">1024</span>, <span class="number">25</span>, <span class="number">100</span>);</span><br><span class="line">    tid2 = rt_thread_create(<span class="string">&quot;tid2&quot;</span>, thread2, RT_NULL, <span class="number">1024</span>, <span class="number">25</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(tid1 != RT_NULL) rt_thread_startup(tid1);</span><br><span class="line">    <span class="keyword">if</span>(tid2 != RT_NULL) rt_thread_startup(tid2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="任务同步与任务互斥差异"><a href="#任务同步与任务互斥差异" class="headerlink" title="任务同步与任务互斥差异"></a><strong>任务同步与任务互斥差异</strong></h3><p><img src="https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505222030206.png" alt="image-20250522203011255"></p><h3 id="事件集"><a href="#事件集" class="headerlink" title="事件集"></a><strong>事件集</strong></h3><p>事件集可以看作公交⻋站的场景。线程可以等待多个事件发⽣，<code>⽐如等待公交⻋或等待同伴到达。如果满⾜某个或某⼏个条件，线程将被唤醒继续执⾏。</code></p><h4 id="工作机制-2"><a href="#工作机制-2" class="headerlink" title="工作机制"></a><strong>工作机制</strong></h4><p>事件集⽤于线程间的同步，可以让线程等待⼀个或多个事件的触发：</p><ul><li><code>逻辑与（AND)</code>：线程等待多个事件同时发⽣才被唤醒。</li><li><code>逻辑或（OR）</code>：线程只需等待其中⼀个事件发⽣即可被唤醒。</li></ul><h5 id="创建事件对象"><a href="#创建事件对象" class="headerlink" title="创建事件对象"></a><strong>创建事件对象</strong></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*动态创建一个对象*/</span></span><br><span class="line"><span class="type">rt_event_t</span> <span class="title function_">rt_event_create</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">rt_uint8_t</span> flag)</span>;</span><br><span class="line"><span class="comment">/*静态创建一个对象*/</span></span><br><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_event_init</span><span class="params">(<span class="type">rt_event_t</span> event, <span class="type">const</span> <span class="type">char</span> *name, <span class="type">rt_uint8_t</span> flag)</span>; </span><br></pre></td></tr></table></figure><ul><li><span style="color:#3399FF;">参数说明</span>：</li><li><code>name</code>：事件对象的名字（可以为 <code>RT_NULL</code> 表⽰匿名事件对象）。</li><li><code>flag</code>：IPC 对象的属性标志，⼀般使⽤ <code>RT_IPC_FLAG_PRIO</code> 表⽰优先级等待，或<code>RT_IPC_FLAG_FIFO</code> 表⽰先进先出等待。</li></ul><h5 id="发送-触发-事件"><a href="#发送-触发-事件" class="headerlink" title="发送(触发)事件"></a><strong>发送(触发)事件</strong></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_event_send</span><span class="params">(<span class="type">rt_event_t</span> event, <span class="type">rt_uint32_t</span> <span class="built_in">set</span>)</span>;</span><br></pre></td></tr></table></figure><ul><li><span style="color:#3399FF;">参数说明</span>：</li><li><code>event</code>：事件对象的句柄。</li><li><code>set</code>：事件标志，设置哪⼏位事件标志被触发 <code>可以⽤ 1 &lt;&lt; n 来表⽰第 n 位的事件。</code></li></ul><h5 id="接收-等待-事件"><a href="#接收-等待-事件" class="headerlink" title="接收(等待)事件"></a><strong>接收(等待)事件</strong></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_event_recv</span><span class="params">(<span class="type">rt_event_t</span> event, <span class="type">rt_uint32_t</span> <span class="built_in">set</span>, <span class="type">rt_uint8_t</span> option, <span class="type">rt_int32_t</span> timeout, <span class="type">rt_uint32_t</span> *recved)</span>;</span><br></pre></td></tr></table></figure><ul><li><span style="color:#3399FF;">参数说明</span>：</li><li><code>event</code>：事件对象的句柄。</li><li><code>set</code>：需要等待的事件标志 <code>例如 1 &lt;&lt; 3 | 1 &lt;&lt; 5 表⽰同时等待第3位和第5位的事件</code></li><li><code>option</code> ：等待选项，常⻅选项包括：<ul><li><code>RT_EVENT_FLAG_AND</code> ：<span style="color:#3399FF;">所有</span>指定的事件标志都满⾜时才唤醒线程。</li><li><code>RT_EVENT_FLAG_OR</code> ：<span style="color:#3399FF;">只要有⼀个</span>指定的事件标志满⾜就唤醒线程。</li><li><code>RT_EVENT_FLAG_CLEAR</code> ：<span style="color:#3399FF;">收到</span>事件标志后<span style="color:#3399FF;">清除</span>这些事件标志。</li></ul></li><li><code>timeout</code> ：超时时间（单位为系统 tick），可以为 <code>RT_WAITING_FOREVER</code> 表⽰永远等待。</li><li><code>recved</code> ：输出参数，返回实际接收到的事件标志</li></ul><h4 id="应用示例-2"><a href="#应用示例-2" class="headerlink" title="应用示例"></a><strong>应用示例</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;rtthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">rt_event_t</span> event = RT_NULL;</span><br><span class="line"><span class="comment">/*线程1：等待事件*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">thread1</span><span class="params">(<span class="type">void</span> *parameter)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">rt_uint32_t</span> recei;</span><br><span class="line">   rt_kprintf(<span class="string">&quot;线程1：等待公交车3或5到来...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">   rt_event_recv(event, (<span class="number">1</span> &lt;&lt; <span class="number">3</span> | <span class="number">1</span> &lt;&lt; <span class="number">5</span>), RT_EVENT_FLAG_OR | RT_EVENT_FLAG_CLEAR, RT_WAITING_FOREVER, &amp;recei);</span><br><span class="line"></span><br><span class="line">   rt_kprintf(<span class="string">&quot;线程1：公交车 %d 到站，出发！....\n&quot;</span>,recei);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*线程2：发送事件（公交车到站）*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">thread2</span><span class="params">(<span class="type">void</span> *parameter)</span></span><br><span class="line">&#123;</span><br><span class="line">   rt_thread_mdelay(<span class="number">1000</span>);<span class="comment">//模拟公交车到站</span></span><br><span class="line">   rt_kprintf(<span class="string">&quot;线程2：公交车3到站\n&quot;</span>);</span><br><span class="line">   rt_event_send(event, (<span class="number">1</span> &lt;&lt; <span class="number">3</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">rt_thread_t</span> tid1 = RT_NULL;</span><br><span class="line">    <span class="type">rt_thread_t</span> tid2 = RT_NULL;</span><br><span class="line"></span><br><span class="line">    event = rt_event_create(<span class="string">&quot;event&quot;</span>, RT_IPC_FLAG_PRIO);</span><br><span class="line">    tid1 = rt_thread_create(<span class="string">&quot;tid1&quot;</span>, thread1, RT_NULL, <span class="number">1024</span>, <span class="number">25</span>, <span class="number">100</span>);</span><br><span class="line">    tid2 = rt_thread_create(<span class="string">&quot;tid2&quot;</span>, thread2, RT_NULL, <span class="number">1024</span>, <span class="number">25</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(tid1 != RT_NULL) rt_thread_startup(tid1);</span><br><span class="line">    <span class="keyword">if</span>(tid2 != RT_NULL) rt_thread_startup(tid2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a><strong>线程间通信</strong></h2><p>裸机编程中经常使用全局变量进行功能间的通信（标志）：某些功能由于特定的操作改变全局变量的值，另一个功能对此全局变量进行读取，根据读取到的全局变量执行相应的操作来达到通信协作的目的。RTT提供了邮箱、消息队列和信号等工具来完成这样的类似操作</p><h3 id="邮箱"><a href="#邮箱" class="headerlink" title="邮箱"></a><strong>邮箱</strong></h3><h4 id="工作机制-3"><a href="#工作机制-3" class="headerlink" title="工作机制"></a>工作机制</h4><p>邮箱的特点：开销低、效率高、支持一对多</p><p>邮箱中一封邮件<strong>只能容纳固定的4字节信息</strong>（针对32位操作系统，指针大小为4字节，一封邮件恰好能容纳一个指针），所以典型的邮箱也被称为交换消息</p><blockquote><p>一般如果邮箱中<span style="color:#3399FF;">存在邮件</span>且收取邮件时的<span style="color:#3399FF;">超时时间为0</span>，邮件的收取过程是<span style="font-weight:bold;">非阻塞</span>的</p><p>但邮箱中<span style="color:#3399FF;">不存在邮件</span>且<span style="color:#3399FF;">超时时间不为0</span>时，邮件收取过程就是<span style="font-weight:bold;">阻塞</span>的，邮件收取阻塞的情况下只能由线程进行邮件的收取。</p></blockquote><ul><li><p><code>邮件发送阻塞</code>：一个线程向邮箱发送邮件时：</p><ul><li>如果邮箱未满，则把邮件复制到邮箱中</li><li>如果邮箱已满，则<span style="color:#3399FF;">发送线程挂起</span>并等待邮箱有空间时将其唤醒再发送邮件 或 直接返回<code>-RT_EFULL</code></li></ul></li><li><p><code>邮件接收阻塞</code>：一个线程从邮箱中接收邮件时：</p><ul><li>如果邮箱已空，接收线程可以挂起直到收到新的邮件被唤醒 <code>也可以设置超时时间并进行等待</code></li><li>如果达到设置的超时时间<span style="color:#00FFFF;">但邮箱仍未收到邮件</span>时，超时线程将被唤醒并返回<code>-RT_ETIMEOUT</code>；</li><li>如果邮箱中存在邮件，则接收线程赋值邮箱中的邮件到接收缓存</li></ul></li></ul><h5 id="创建邮箱"><a href="#创建邮箱" class="headerlink" title="创建邮箱"></a><strong>创建邮箱</strong></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*创建动态邮箱*/</span></span><br><span class="line"><span class="type">rt_mailbox_t</span> <span class="title function_">rt_mb_create</span> <span class="params">(<span class="type">const</span> <span class="type">char</span>* name, <span class="type">rt_size_t</span> size, <span class="type">rt_uint8_t</span> flag)</span>;</span><br><span class="line"><span class="comment">/*创建静态邮箱*/</span></span><br><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_mb_init</span><span class="params">(<span class="type">rt_mailbox_t</span> mb,<span class="type">const</span> <span class="type">char</span>* name,<span class="type">void</span>* msgpool,<span class="type">rt_size_t</span> size,<span class="type">rt_uint8_t</span> flag)</span></span><br></pre></td></tr></table></figure><ul><li><span style="color:#3399FF;">参数说明</span>：</li><li><code>mb</code>：邮箱对象的句柄。</li><li><code>name</code>：邮箱容量(几封邮件)</li><li><code>size</code> ：邮箱容量(几封邮件)。</li><li><code>flag</code> ：邮箱标志，它可以取如下数值：<code>一般除非应用程序非常在意先来后到，不然都采用PRIO确保线程实时性</code><ul><li><code>RT_IPC_FLAG_FIFO</code> ：非实时调度方式 先来后到</li><li><code>RT_IPC_FLAG_PRIO</code> ：实时调度方式 优先级</li></ul></li><li><code>msgpool</code> ：缓冲区指针。</li><li><code>recved</code> ：输出参数，返回实际接收到的事件标志</li></ul><h5 id="删除或脱离邮箱"><a href="#删除或脱离邮箱" class="headerlink" title="删除或脱离邮箱"></a><strong>删除或脱离邮箱</strong></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*删除动态邮箱create*/</span></span><br><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_mb_delete</span> <span class="params">(<span class="type">rt_mailbox_t</span> mb)</span>;</span><br><span class="line"><span class="comment">/*删除静态邮箱init*/</span></span><br><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_mb_detach</span><span class="params">(<span class="type">rt_mailbox_t</span> mb)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回值：RT_EOK 成功</span></span><br></pre></td></tr></table></figure><ul><li><span style="color:#3399FF;">参数说明</span>：</li><li><code>mb</code>：邮箱对象的句柄。</li></ul><blockquote><p>调用删除函数时，内核会<span style="color:#00FFFF;">先唤醒所有</span>挂在该邮箱上的线程（线程返回值是<code>RT_ERROR</code>），然后<span style="color:#00FFFF;">再释放</span>邮箱使用的<span style="color:#00FFFF;">内存</span>，最后<span style="color:#00FFFF;">删除邮箱对象</span></p></blockquote><h5 id="发送邮件"><a href="#发送邮件" class="headerlink" title="发送邮件"></a><strong>发送邮件</strong></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*1.直接发送邮件*/</span></span><br><span class="line"><span class="comment">/*！！！！！记得value需要强转rt_uint32_t！！！！！*/</span></span><br><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_mb_send</span> <span class="params">(<span class="type">rt_mailbox_t</span> mb, <span class="type">rt_uint32_t</span> value)</span>;</span><br><span class="line"><span class="comment">/**************返回值*****************/</span></span><br><span class="line">RT_EOK        发送成功</span><br><span class="line">-RT_EFULL      邮箱已经满了</span><br><span class="line"></span><br><span class="line"><span class="comment">/*2.等待方式发送邮件*/</span></span><br><span class="line"><span class="comment">/*@note 若邮箱已满，则根据设定的timeout等待邮箱中因为收取邮件而空出空间</span></span><br><span class="line"><span class="comment">/*@note 若超时时间到达依然没有空出时间，此时发送线程被唤醒并返回错误码</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_mb_send_wait</span> <span class="params">(<span class="type">rt_mailbox_t</span> mb,<span class="type">rt_uint32_t</span> value,<span class="type">rt_int32_t</span> timeout)</span>;</span><br><span class="line"><span class="comment">/**************返回值*****************/</span></span><br><span class="line">RT_EOK        发送成功</span><br><span class="line">-RT_ETIMEOUT     超时</span><br><span class="line">-RT_ERROR    失败，返回错误</span><br><span class="line"></span><br><span class="line"><span class="comment">/*3.发送紧急邮件*/</span></span><br><span class="line"><span class="comment">/*@note 发送紧急邮件时，邮件被直接插队放入了邮件队首,这样就能最优先接收到并做出处理</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_mb_urgent</span> <span class="params">(<span class="type">rt_mailbox_t</span> mb, <span class="type">rt_ubase_t</span> value)</span>;</span><br><span class="line"><span class="comment">/**************返回值*****************/</span></span><br><span class="line">RT_EOK       发送成功</span><br><span class="line">-RT_EFULL    邮箱已满</span><br></pre></td></tr></table></figure><ul><li><span style="color:#3399FF;">参数说明</span>：</li><li><code>mb</code>：邮箱对象的句柄。</li><li><code>value</code> ：发送的邮件内容。</li><li><code>timeout</code> ：超时时间。</li></ul><h5 id="接收邮件"><a href="#接收邮件" class="headerlink" title="接收邮件"></a><strong>接收邮件</strong></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*@note 只有当接收者接收的邮箱中有邮件时，接收者才能立即取到邮件并返回 RT_EOK 的返回值</span></span><br><span class="line"><span class="comment">否则接收线程会根据超时时间设置，或挂起在邮箱的等待线程队列上，或直接返回。</span></span><br><span class="line"><span class="comment">！！！！！记得value需要强转rt_uint32_t！！！！！</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_mb_recv</span> <span class="params">(<span class="type">rt_mailbox_t</span> mb, <span class="type">rt_uint32_t</span>* value, <span class="type">rt_int32_t</span> timeout)</span>;</span><br><span class="line"><span class="comment">/**************返回值*****************/</span></span><br><span class="line">RT_EOK        接收成功</span><br><span class="line">-RT_ETIMEOUT     超时</span><br><span class="line">-RT_ERROR    失败，返回错误</span><br></pre></td></tr></table></figure><ul><li><span style="color:#3399FF;">参数说明</span>：</li><li><code>mb</code>：邮箱对象的句柄。</li><li><code>value</code> ：邮件内容<code>(定义一个变量来接收 记得强转)</code></li><li><code>timeout</code> ：超时时间。</li></ul><h4 id="应用示例-3"><a href="#应用示例-3" class="headerlink" title="应用示例"></a><strong>应用示例</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;rtthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*创建邮箱*/</span></span><br><span class="line"><span class="type">rt_mailbox_t</span> mb;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*线程1：发送邮箱*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">thread_entry1</span><span class="params">(<span class="type">void</span> *parameter)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> msg = <span class="string">&#x27;A&#x27;</span>;<span class="comment">//发送&#x27;A&#x27;作为邮件</span></span><br><span class="line">    rt_kprintf(<span class="string">&quot;线程1：发送邮件...\n&quot;</span>);</span><br><span class="line">    <span class="comment">//发送邮件  因为邮箱固定4字节 所以需要强转</span></span><br><span class="line">    rt_mb_send(mb, (<span class="type">rt_uint32_t</span>)msg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*线程2：接收邮件*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">thread_entry2</span><span class="params">(<span class="type">void</span> *parameter)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">char</span> msg;</span><br><span class="line">   rt_kprintf(<span class="string">&quot;线程2：等待接收邮件...\n&quot;</span>);</span><br><span class="line">   <span class="comment">//若邮箱内为空  则执行的是阻塞式的等待接收邮件</span></span><br><span class="line">   rt_mb_recv(mb, (<span class="type">rt_uint32_t</span>)&amp;msg, RT_WAITING_FOREVER);<span class="comment">//接收邮件</span></span><br><span class="line">   rt_kprintf(<span class="string">&quot;线程2：收到邮件：%c\n&quot;</span>,msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*创建一个容量为4的4封邮箱(大小为4*4)) */</span></span><br><span class="line">    mb = rt_mb_create(<span class="string">&quot;mb&quot;</span>, <span class="number">4</span>, RT_IPC_FLAG_PRIO);</span><br><span class="line">    <span class="comment">/*创建两个线程 */</span></span><br><span class="line">    <span class="type">rt_thread_t</span> tid1 = rt_thread_create(<span class="string">&quot;t1&quot;</span>, thread_entry1, RT_NULL, <span class="number">1024</span>, <span class="number">10</span>,</span><br><span class="line">    <span class="number">10</span>);</span><br><span class="line">    <span class="type">rt_thread_t</span> tid2 = rt_thread_create(<span class="string">&quot;t2&quot;</span>, thread_entry2, RT_NULL, <span class="number">1024</span>, <span class="number">10</span>,</span><br><span class="line">    <span class="number">10</span>);</span><br><span class="line">    <span class="comment">/* 启动线程 */</span></span><br><span class="line">    rt_thread_startup(tid1);</span><br><span class="line">    rt_thread_startup(tid2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a><strong>消息队列</strong></h3><p>消息队列是另一种常用的线程间通讯方式，是邮箱的扩展。他可以动态分配内存，对比邮箱局限的4字节存储特性，更适合用来传输复杂大量数据或进行任务队列管理</p><h4 id="工作机制-4"><a href="#工作机制-4" class="headerlink" title="工作机制"></a><strong>工作机制</strong></h4><h5 id="创建消息队列"><a href="#创建消息队列" class="headerlink" title="创建消息队列"></a><strong>创建消息队列</strong></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*创建动态消息队列*/</span></span><br><span class="line"><span class="type">rt_mq_t</span> <span class="title function_">rt_mq_create</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name, <span class="type">rt_size_t</span> msg_size,<span class="type">rt_size_t</span> max_msgs, <span class="type">rt_uint8_t</span> flag)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*创建静态消息队列*/</span></span><br><span class="line"><span class="comment">/*@note 一般放于读数据段或未初始化数据段中。在使用这类静态消息队列对象前，需要进行初始化</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_mq_init</span><span class="params">(<span class="type">rt_mq_t</span> mq, <span class="type">const</span> <span class="type">char</span>* name,<span class="type">void</span> *msgpool,<span class="type">rt_size_t</span> msg_size,<span class="type">rt_size_t</span> pool_size, <span class="type">rt_uint8_t</span> flag)</span>;</span><br></pre></td></tr></table></figure><ul><li><p><span style="color:#3399FF;">参数说明</span>：</p></li><li><p><code>name </code>：消息队列的名称。</p></li><li><p><code>msg_size </code> ：消息队列中一条消息的最大长度，<span style="color:#00FFFF;">单位字节</span>。</p></li><li><p><code>msg_msgs</code>：消息队列的最大个数(消息个数)。</p></li><li><p><code>flag</code> ：消息队列采用的等待方式，它可以取如下数值：<code>一般除非应用程序非常在意先来后到，不然都采用PRIO确保线程实时性</code></p><ul><li><p><code>RT_IPC_FLAG_FIFO</code>：非实时调度方式 先来后到</p></li><li><p><code>RT_IPC_FLAG_PRIO</code>：实时调度方式 优先级</p></li></ul></li><li><p><code>mq</code> ：消息队列对象的句柄。</p></li><li><p><code>msgpool</code>：指向存放消息的缓冲区的指针。</p></li><li><p><code>pool_size</code> ：存放消息的缓冲区大小</p></li></ul><h5 id="删除或脱离消息队列"><a href="#删除或脱离消息队列" class="headerlink" title="删除或脱离消息队列"></a><strong>删除或脱离消息队列</strong></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*删除动态消息队列create*/</span></span><br><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_mq_delete</span><span class="params">(<span class="type">rt_mq_t</span> mq)</span>;</span><br><span class="line"><span class="comment">/*删除静态消息队列init*/</span></span><br><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_mq_detach</span><span class="params">(<span class="type">rt_mq_t</span> mq)</span>;</span><br><span class="line"><span class="comment">//返回值：RT_EOK 成功</span></span><br></pre></td></tr></table></figure><ul><li><span style="color:#3399FF;">参数说明</span>：</li><li><code>mq</code>：消息队列对象的句柄</li></ul><blockquote><p>删除消息队列时，如果<span style="color:#00FFFF;">有线程</span>被挂起在该消息队列等待队列上，则内核<span style="color:#00FFFF;">先唤醒挂起</span>在该消息等待队列上的所有线程（线程返回值是 <code>- RT_ERROR</code>），然后再<span style="color:#00FFFF;">释放</span>消息队列使用的内存，最后<span style="color:#00FFFF;">删除</span>消息队列对象</p></blockquote><h5 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a><strong>发送消息</strong></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*1.直接发送消息*/</span></span><br><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_mq_send</span> <span class="params">(<span class="type">rt_mq_t</span> mq, <span class="type">void</span>* buffer, <span class="type">rt_size_t</span> size)</span>;</span><br><span class="line"><span class="comment">/**************返回值*****************/</span></span><br><span class="line">RT_EOK        发送成功</span><br><span class="line">-RT_EFULL      消息队列已经满了</span><br><span class="line">-RT_ERROR       失败(发送消息长度&gt;队列的最大长度)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*2.等待方式发送消息*/</span></span><br><span class="line"><span class="comment">/*@note 若消息队列已满，则根据设定的timeout等待</span></span><br><span class="line"><span class="comment">/*@note 若超时时间到达依然没有空出时间，此时发送线程被唤醒并返回错误码</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_mq_send_wait</span><span class="params">(<span class="type">rt_mq_t</span> mq,<span class="type">const</span> <span class="type">void</span> *buffer,<span class="type">rt_size_t</span> size,<span class="type">rt_int32_t</span>  timeout)</span>;</span><br><span class="line"><span class="comment">/**************返回值*****************/</span></span><br><span class="line">RT_EOK        发送成功</span><br><span class="line">-RT_ETIMEOUT     超时</span><br><span class="line">-RT_ERROR    失败(发送消息长度&gt;队列的最大长度)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*3.发送紧急消息*/</span></span><br><span class="line"><span class="comment">/*@note 发送紧急消息时，邮件被直接插队放入了消息队列队首,这样就能最优先接收到并做出处理</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_mq_urgent</span><span class="params">(<span class="type">rt_mq_t</span> mq, <span class="type">void</span>* buffer, <span class="type">rt_size_t</span> size)</span>;</span><br><span class="line"><span class="comment">/**************返回值*****************/</span></span><br><span class="line">RT_EOK       发送成功</span><br><span class="line">-RT_EFULL    消息队列已经满了</span><br><span class="line">-RT_ERROR    失败(发送消息长度&gt;队列的最大长度)</span><br></pre></td></tr></table></figure><ul><li><span style="color:#3399FF;">参数说明</span>：</li><li><code>mq</code>：消息队列对象的句柄</li><li><code>buffer</code> ：发送的消息内容。</li><li><code>size</code> ：消息大小。</li><li><code>timeout</code> ：超时时间。</li></ul><h5 id="接收消息"><a href="#接收消息" class="headerlink" title="接收消息"></a><strong>接收消息</strong></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*@note 只有当消息队列中有消息时，接收者才能立即取到邮件并返回 RT_EOK 的返回值</span></span><br><span class="line"><span class="comment">否则接收线程会根据超时时间设置，或挂起在邮箱的等待线程队列上，或直接返回。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">rt_ssize_t</span> <span class="title function_">rt_mq_recv</span> <span class="params">(<span class="type">rt_mq_t</span> mq, <span class="type">void</span>* buffer,<span class="type">rt_size_t</span> size,<span class="type">rt_int32_t</span> timeout)</span>;</span><br><span class="line"><span class="comment">/**************返回值*****************/</span></span><br><span class="line">RT_EOK             成功收到</span><br><span class="line">-RT_ETIMEOUT             超时</span><br><span class="line">-RT_ERROR            失败，返回错误</span><br></pre></td></tr></table></figure><ul><li><span style="color:#3399FF;">参数说明</span>：</li><li><code>mq</code>：消息队列对象的句柄</li><li><code>buffer</code> ：发送的消息内容。</li><li><code>size</code> ：消息大小。</li><li><code>timeout</code> ：超时时间</li></ul><h4 id="应用示例-4"><a href="#应用示例-4" class="headerlink" title="应用示例"></a><strong>应用示例</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;rtthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*创建消息队列*/</span></span><br><span class="line"><span class="type">rt_mq_t</span> mq;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*线程1：发送消息*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">thread_entry1</span><span class="params">(<span class="type">void</span> *parameter)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> msg[] = <span class="string">&quot;Hello, RT-Thread!&quot;</span>;<span class="comment">//发送&#x27;A&#x27;作为邮件</span></span><br><span class="line">    rt_kprintf(<span class="string">&quot;线程1：发送消息...\n&quot;</span>);</span><br><span class="line">    <span class="comment">//发送消息到消息队列</span></span><br><span class="line">    rt_mq_send(mq, msg,<span class="keyword">sizeof</span>(msg));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*线程2：接收邮件*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">thread_entry2</span><span class="params">(<span class="type">void</span> *parameter)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">char</span> buffer[<span class="number">32</span>];</span><br><span class="line">   rt_kprintf(<span class="string">&quot;线程2：等待接收消息...\n&quot;</span>);</span><br><span class="line">   <span class="comment">//若消息队列内无消息  则执行的是阻塞式的等待接收消息</span></span><br><span class="line">   rt_mq_recv(mq, buffer,<span class="keyword">sizeof</span>(buffer), RT_WAITING_FOREVER);<span class="comment">//接收消息</span></span><br><span class="line">   rt_kprintf(<span class="string">&quot;线程2：收到消息：%s\n&quot;</span>,buffer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*创建一个消息队列，容量为4，消息大小为32字节 */</span></span><br><span class="line">    mq = rt_mq_create(<span class="string">&quot;mq&quot;</span>, <span class="number">32</span>, <span class="number">4</span>, RT_IPC_FLAG_PRIO);</span><br><span class="line">    <span class="comment">/*创建两个线程 */</span></span><br><span class="line">    <span class="type">rt_thread_t</span> tid1 = rt_thread_create(<span class="string">&quot;t1&quot;</span>, thread_entry1, RT_NULL, <span class="number">1024</span>, <span class="number">10</span>,</span><br><span class="line">    <span class="number">10</span>);</span><br><span class="line">    <span class="type">rt_thread_t</span> tid2 = rt_thread_create(<span class="string">&quot;t2&quot;</span>, thread_entry2, RT_NULL, <span class="number">1024</span>, <span class="number">10</span>,</span><br><span class="line">    <span class="number">10</span>);</span><br><span class="line">    <span class="comment">/* 启动线程 */</span></span><br><span class="line">    rt_thread_startup(tid1);</span><br><span class="line">    rt_thread_startup(tid2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a><strong>信号</strong></h3><p><code>信号（又称为软中断信号）</code>，在软件层次上是对中断机制的一种模拟。常用于通知线程发生了某个事件。线程收到信号时会根据信号类型执行相应的操作</p><ul><li>与消息队列区别：</li></ul><ol><li><p><span style="color:#00FFFF;">信号仅携带控制信息，不包含数据</span></p></li><li><p>信号不保证顺序性，<span style="color:#00FFFF;">信号发生时立即通知线程</span></p></li><li><p>消息队列则有顺序性（通常是PRIO）</p></li></ol><h4 id="工作机制-5"><a href="#工作机制-5" class="headerlink" title="工作机制"></a><strong>工作机制</strong></h4><h5 id="线程中安装信号"><a href="#线程中安装信号" class="headerlink" title="线程中安装信号"></a><strong>线程中安装信号</strong></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">t_sighandler_t[] 表示一个函数指针数组</span></span><br><span class="line"><span class="comment">t_sighandler_t handler[] 是一个 变量声明</span></span><br><span class="line"><span class="comment">二者是不一样的！</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">rt_sighandler_t</span> <span class="title function_">rt_signal_install</span><span class="params">(<span class="type">int</span> signo, <span class="type">rt_sighandler_t</span>[] handler)</span>;</span><br><span class="line"><span class="comment">/**************返回值*****************/</span></span><br><span class="line">SIG_ERR                错误的信号</span><br><span class="line">安装信号前的handler值    成功</span><br></pre></td></tr></table></figure><ul><li><span style="color:#3399FF;">参数说明</span>：</li><li><code>signo </code>：信号值（只有 <code>SIGUSR1</code> 和 <code>SIGUSR2</code> 是开放给用户使用的）。</li><li><code>buffer</code> ：发送的消息内容。</li><li><code>handler</code> ：设置对信号值的处理方式。</li></ul><blockquote><p> 在信号安装时设定 handler 参数，决定了该信号的不同的处理方法。处理方法可以分为三种：</p><ol><li><p>类似<code>中断</code>的处理方式，参数指向当信号发生时用户<code>自定义的处理函数</code>， 在内部写入处理方式，由该函数来处理。</p></li><li><p>参数设为 <code>SIG_IGN</code>，忽略某个信号，<code>对该信号不做任何处理</code>，就像未发生过一样。</p></li><li><p>参数设为 <code>SIG_DFL</code>，系统会调用默认的处理函数<code>_signal_default_handler()</code>。</p></li></ol></blockquote><h5 id="阻塞信号与解除阻塞"><a href="#阻塞信号与解除阻塞" class="headerlink" title="阻塞信号与解除阻塞"></a><strong>阻塞信号与解除阻塞</strong></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*信号阻塞(屏蔽信号) 该信号不会递答安装此信号的线程*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">rt_signal_mask</span><span class="params">(<span class="type">int</span> signo)</span>;</span><br><span class="line"><span class="comment">/*解除信号阻塞</span></span><br><span class="line"><span class="comment">使用此函数可以对其中一些信号给予 “关注”，那么发送这些信号都会引发该线程的软中断</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">rt_signal_unmask</span><span class="params">(<span class="type">int</span> signo)</span>;</span><br></pre></td></tr></table></figure><ul><li><span style="color:#3399FF;">参数说明</span>：</li><li><code>signo</code>：信号值</li></ul><h5 id="发送信号"><a href="#发送信号" class="headerlink" title="发送信号"></a><strong>发送信号</strong></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*需要异常处理时，可以给安装了信号的线程发送信号*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">rt_thread_kill</span><span class="params">(<span class="type">rt_thread_t</span> tid, <span class="type">int</span> sig)</span>;</span><br><span class="line"><span class="comment">/**************返回值*****************/</span></span><br><span class="line">RT_EOK        发送成功</span><br><span class="line">-RT_EINVAL    参数错误</span><br></pre></td></tr></table></figure><ul><li><span style="color:#3399FF;">参数说明</span>：</li><li><code>tid</code>：接收信号的线程。</li><li><code>sig </code>：信号值。</li></ul><h4 id="应用示例-5"><a href="#应用示例-5" class="headerlink" title="应用示例"></a><strong>应用示例</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;rtthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> THREAD_PRIORITY         25</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> THREAD_STACK_SIZE       512</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> THREAD_TIMESLICE        5</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">rt_thread_t</span> tid1 = RT_NULL;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 线程 1 的信号处理函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">thread1_signal_handler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    rt_kprintf(<span class="string">&quot;thread1 received signal %d\n&quot;</span>, sig);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 线程 1 的入口函数 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">thread1_entry</span><span class="params">(<span class="type">void</span> *parameter)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 安装信号 */</span></span><br><span class="line">    rt_signal_install(SIGUSR1, thread1_signal_handler);</span><br><span class="line">    rt_signal_unmask(SIGUSR1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 运行 10 次 */</span></span><br><span class="line">    <span class="keyword">while</span> (cnt &lt; <span class="number">10</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 线程 1 采用低优先级运行，一直打印计数值 */</span></span><br><span class="line">        rt_kprintf(<span class="string">&quot;thread1 count : %d\n&quot;</span>, cnt);</span><br><span class="line"></span><br><span class="line">        cnt++;</span><br><span class="line">        rt_thread_mdelay(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 信号示例的初始化 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">signal_sample</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 创建线程 1 */</span></span><br><span class="line">    tid1 = rt_thread_create(<span class="string">&quot;thread1&quot;</span>,thread1_entry, RT_NULL,THREAD_STACK_SIZE, THREAD_PRIORITY, THREAD_TIMESLICE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tid1 != RT_NULL)</span><br><span class="line">        rt_thread_startup(tid1);</span><br><span class="line"></span><br><span class="line">    rt_thread_mdelay(<span class="number">300</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 发送信号 SIGUSR1 给线程 1 */</span></span><br><span class="line">    rt_thread_kill(tid1, SIGUSR1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="框架移植"><a href="#框架移植" class="headerlink" title="框架移植"></a><strong>框架移植</strong></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//bsp_system.h中引入以下四个头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;rtthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;rtdevice.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;drv_common.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;board.h&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="系统初始化宏定义"><a href="#系统初始化宏定义" class="headerlink" title="系统初始化宏定义"></a><strong>系统初始化宏定义</strong></h3><p>​    <img src="https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505222143758.png" alt="image-20250522214349807"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*1、板级初始化 fn为函数指针*/</span></span><br><span class="line">INIT_BOARD_EXPORT(fn)</span><br><span class="line"><span class="comment">/*2、纯软件函数初始化 fn为函数指针*/</span></span><br><span class="line">INIT_PREV_EXPORT(fn)</span><br><span class="line"><span class="comment">/*3、设备自动初始化，fn为函数指针*/</span></span><br><span class="line">INIT_DEVICE_EXPORT(fn)</span><br><span class="line"><span class="comment">/*4、组件自动初始化，fn为函数指针*/</span></span><br><span class="line">INIT_COMPONENT_EXPORT(fn)</span><br><span class="line"><span class="comment">/*5、系统环境自动初始化，fn为函数指针*/</span></span><br><span class="line">INIT_ENV_EXPORT(fn) </span><br><span class="line"><span class="comment">/*6、应用自动初始化，fn为函数指针*/</span></span><br><span class="line">INIT_APP_EXPORT(fn)</span><br></pre></td></tr></table></figure><h3 id="ESP8266移植"><a href="#ESP8266移植" class="headerlink" title="ESP8266移植"></a><strong>ESP8266移植</strong></h3><blockquote><p>将<code>uart_app.c</code>与<code>uart_app.h</code>移去 不使用！！！然后RTT打开控制台输出rt_kprintf，选择串口1</p></blockquote><p>   <img src="https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505222145092.png" alt="image-20250522214536841"></p><p><img src="https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505222204947.png" alt="image-20250522220417747"> <img src="https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505222204548.png" alt="image-20250522220447380"></p><p><img src="https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505222147073.png" alt="image-20250522214750185"></p><p><img src="https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505222147664.png" alt="image-20250522214705123"></p><p><img src="https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505222148942.png" alt="image-20250522214840651"></p><p><img src="https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505222149729.png" alt="image-20250522214859546"></p><p><img src="https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505222149203.png" alt="image-20250522214917115"></p><p><img src="https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505222149796.png" alt="image-20250522214947877"></p><p>直接编译开启终端 下载观察现象，出现以下信息则连接成功</p><p>​    <img src="https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505222150747.png" alt="image-20250522215015453"></p><h3 id="DHT11移植"><a href="#DHT11移植" class="headerlink" title="DHT11移植"></a><strong>DHT11移植</strong></h3><h4 id="组件添加"><a href="#组件添加" class="headerlink" title="组件添加"></a><strong>组件添加</strong></h4><p>​    <img src="https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505222151707.png" alt="image-20250522215146162"></p><p><img src="https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505222152193.png" alt="image-20250522215207600"></p><p><img src="https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505222203028.png" alt="image-20250522220342327"></p><h4 id="proc代码构建"><a href="#proc代码构建" class="headerlink" title="proc代码构建"></a><strong>proc代码构建</strong></h4><h5 id="创建sensor-app-c与-h"><a href="#创建sensor-app-c与-h" class="headerlink" title="创建sensor_app.c与.h"></a><strong>创建sensor_app.c与.h</strong></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//引入必要库</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sensor_app.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sensor.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sensor_dallas_dht11.h&quot;</span></span></span><br></pre></td></tr></table></figure><h5 id="注册设备"><a href="#注册设备" class="headerlink" title="注册设备"></a><strong>注册设备</strong></h5><pre><code><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">rt_device_t</span> dev = RT_NULL;</span><br><span class="line"><span class="comment">//创建传感器结构体对象</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rt_sensor_data</span> <span class="title">sensor_data</span>;</span></span><br><span class="line"><span class="type">rt_uint8_t</span> get_data_freq = <span class="number">1</span>;<span class="comment">///默认1hz</span></span><br><span class="line"><span class="type">rt_size_t</span> res;<span class="comment">//返回值 如RT_EOK</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/*注册传感器*/</span></span><br><span class="line">dev =  rt_device_find(<span class="string">&quot;temp_dht11&quot;</span>);<span class="comment">//注意此处注册需要有前缀 如temp_(在sensor.c中)</span></span><br><span class="line"><span class="keyword">if</span>(dev == RT_NULL)</span><br><span class="line">&#123;</span><br><span class="line">    rt_kprintf(<span class="string">&quot;Not Found\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(rt_device_open(dev, RT_DEVICE_FLAG_RDWR) != RT_EOK)</span><br><span class="line">&#123;</span><br><span class="line">    rt_kprintf(<span class="string">&quot;Open Error\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">rt_device_control(dev, RT_SENSOR_CTRL_SET_ODR, (<span class="type">void</span> *)&amp;get_data_freq);</span><br></pre></td></tr></table></figure></code></pre><h5 id="读取传感器数据"><a href="#读取传感器数据" class="headerlink" title="读取传感器数据"></a><strong>读取传感器数据</strong></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*读取传感器*/</span></span><br><span class="line">   <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">   &#123;</span><br><span class="line">       res = rt_device_read(dev, <span class="number">0</span>, &amp;sensor_data, <span class="number">1</span>);<span class="comment">//第0位开始读一个</span></span><br><span class="line">       <span class="comment">//读错了返回0</span></span><br><span class="line">       <span class="keyword">if</span>(res == <span class="number">0</span>)</span><br><span class="line">       &#123;</span><br><span class="line">           rt_kprintf(<span class="string">&quot;Read Error Res:%d&quot;</span>,res);<span class="comment">//返回读取错误编号0</span></span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> <span class="comment">//读取成功</span></span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">if</span>(sensor_data.data.temp &gt;= <span class="number">0</span>) <span class="comment">//数据大于等于0 包括了温度与湿度</span></span><br><span class="line">           &#123;</span><br><span class="line">               <span class="type">uint8_t</span> temp = (sensor_data.data.temp &amp; <span class="number">0xffff</span>);</span><br><span class="line">               <span class="type">uint8_t</span> humi = (sensor_data.data.temp &amp; <span class="number">0xffff0000</span>) &gt;&gt; <span class="number">16</span>;</span><br><span class="line">               rt_kprintf(<span class="string">&quot;temp:%d humi:%d\r\n&quot;</span>,temp,humi);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       rt_thread_delay(<span class="number">1000</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h5 id="init代码构建"><a href="#init代码构建" class="headerlink" title="init代码构建"></a><strong>init代码构建</strong></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sensor_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_sensor_config</span> <span class="title">cfg</span>;</span><span class="comment">//操作集结构体</span></span><br><span class="line">    <span class="comment">/*注册设备 配置接口*/</span></span><br><span class="line">    cfg.intf.user_data = (<span class="type">void</span> *)DHT11_PIN;<span class="comment">//配置接口为IO口</span></span><br><span class="line">    rt_hw_dht11_init(<span class="string">&quot;dht11&quot;</span>, &amp;cfg);</span><br><span class="line"></span><br><span class="line">    <span class="type">rt_thread_t</span> sensor_thread = rt_thread_create(<span class="string">&quot;sensor_proc&quot;</span>, sensor_proc, RT_NULL, <span class="number">1024</span>, <span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">    <span class="keyword">if</span>(sensor_thread != RT_NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        rt_thread_startup(sensor_thread);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> RT_EOK;</span><br><span class="line">&#125;</span><br><span class="line">INIT_COMPONENT_EXPORT(sensor_init);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> MCU </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RTOS </tag>
            
            <tag> 实时操作系统 </tag>
            
            <tag> RT_Thread </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git命令(用于hexo clean之后的处理)</title>
      <link href="/2025/05/20/git/"/>
      <url>/2025/05/20/git/</url>
      
        <content type="html"><![CDATA[<h2 id="连接远程仓库"><a href="#连接远程仓库" class="headerlink" title="连接远程仓库"></a>连接远程仓库</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br><span class="line">git remote add origin [dizhi]</span><br><span class="line">git checkout -b main                  </span><br></pre></td></tr></table></figure><h2 id="推送代码"><a href="#推送代码" class="headerlink" title="推送代码"></a>推送代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;&quot;</span></span><br><span class="line">git push --force origin main #后续可以直接用git push</span><br></pre></td></tr></table></figure><h2 id="如何建立一个多人写作的git仓库？"><a href="#如何建立一个多人写作的git仓库？" class="headerlink" title="如何建立一个多人写作的git仓库？"></a>如何建立一个多人写作的git仓库？</h2><h3 id="1-新建Git仓库"><a href="#1-新建Git仓库" class="headerlink" title="1. 新建Git仓库"></a>1. <strong>新建Git仓库</strong></h3><ul><li><p><strong>在本地创建仓库</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> my_project</span><br><span class="line"><span class="built_in">cd</span> my_project</span><br><span class="line">git init</span><br></pre></td></tr></table></figure></li><li><p><strong>或者在GitHub&#x2F;GitLab等平台创建仓库</strong>：如果你使用的是GitHub、GitLab等托管服务，可以直接在网页端创建仓库，然后克隆到本地：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/your-username/my_project.git</span><br><span class="line"><span class="built_in">cd</span> my_project</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-他人参与协作"><a href="#2-他人参与协作" class="headerlink" title="2. 他人参与协作"></a>2. <strong>他人参与协作</strong></h3><ul><li><p><strong>邀请他人访问仓库</strong>：</p><ul><li>如果是GitHub，可以在仓库设置中添加协作者（Collaborator）。</li><li>如果是GitLab，可以在项目成员管理中添加成员。</li></ul></li><li><p><strong>他人克隆仓库</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/your-username/my_project.git</span><br><span class="line"><span class="built_in">cd</span> my_project</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-他人创建分支并上传代码"><a href="#3-他人创建分支并上传代码" class="headerlink" title="3. 他人创建分支并上传代码"></a>3. <strong>他人创建分支并上传代码</strong></h3><ul><li><p><strong>他人创建分支</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b fenzhiname</span><br></pre></td></tr></table></figure><p><code>fenzhinamme指的是自定义分支名</code></p></li><li><p><strong>他人修改代码并提交</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;Add new feature&quot;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>他人将分支推送到远程仓库</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin fenzhiname</span><br></pre></td></tr></table></figure></li></ul><h3 id="4-你合并分支"><a href="#4-你合并分支" class="headerlink" title="4. 你合并分支"></a>4. <strong>你合并分支</strong></h3><ul><li><p><strong>同步并重置 main</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin</span><br><span class="line">git checkout main</span><br><span class="line">git reset --hard origin/main</span><br></pre></td></tr></table></figure></li><li><p><strong>合并</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge origin/wpy_app --allow-unrelated-histories</span><br></pre></td></tr></table></figure></li><li><p><strong>解决冲突（如果有）并推送</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin main</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>音响实习の学习笔记</title>
      <link href="/2025/05/19/%E9%9F%B3%E5%93%8D%E5%AE%9E%E4%B9%A0/"/>
      <url>/2025/05/19/%E9%9F%B3%E5%93%8D%E5%AE%9E%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="麦克风-话筒"><a href="#麦克风-话筒" class="headerlink" title="麦克风-话筒"></a>麦克风-话筒</h2><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><table><thead><tr><th>类型</th><th>优点</th><th>缺点</th><th>典型用途</th></tr></thead><tbody><tr><td><strong>动圈话筒</strong></td><td>耐用、抗啸叫、便宜</td><td>灵敏度低、高频细节少</td><td>现场演出、演讲、鼓麦克风</td></tr><tr><td><strong>电容话筒</strong></td><td>高解析度、瞬态响应好</td><td>易受潮、需外部供电</td><td>录音棚、人声、乐器收音</td></tr><tr><td><strong>USB 话筒</strong></td><td>即插即用、内置声卡</td><td>延迟较高、不可扩展</td><td>直播、播客、家庭录音</td></tr><tr><td><strong>领夹话筒</strong></td><td>隐蔽、解放双手</td><td>易摩擦衣物产生噪音</td><td>视频拍摄、舞台剧</td></tr><tr><td><strong>枪式话筒</strong></td><td>远距离定向拾音</td><td>环境反射影响音质</td><td>影视同期声、户外采访</td></tr></tbody></table><h3 id="核心参数"><a href="#核心参数" class="headerlink" title="核心参数"></a>核心参数</h3><h4 id="频率响应（麦克风对不同频率声音的灵敏度变化曲线）："><a href="#频率响应（麦克风对不同频率声音的灵敏度变化曲线）：" class="headerlink" title="频率响应（麦克风对不同频率声音的灵敏度变化曲线）："></a><strong>频率响应（麦克风对不同频率声音的灵敏度变化曲线）：</strong></h4><ul><li><strong>理想范围</strong>：人声录制建议 <strong>80Hz-15kHz</strong>，乐器需更宽（如 20Hz-20kHz）。</li><li><strong>曲线特性</strong>：平直曲线适合真实还原，高频提升（如 AKG C414）可增强人声明亮度。</li></ul><h4 id="灵敏度（Sensitivity）"><a href="#灵敏度（Sensitivity）" class="headerlink" title="灵敏度（Sensitivity）"></a><strong>灵敏度（Sensitivity）</strong></h4><ul><li>单位：<strong>mV&#x2F;Pa</strong> 或 <strong>dBV</strong>（如-32dB &gt; -40dB，<span style="color:#FF00FF;">数值越高越灵敏</span>）。</li><li><strong>高灵敏度</strong>：电容麦适合细节捕捉，但易收环境噪音；<code>一般在-30dB到-40dB</code></li><li><strong>低灵敏度</strong>：动圈麦抗噪强，适合现场演出。<code>一般在-54dB到-60dB</code></li><li><strong>重要规律</strong>：<br>▶ 每增加 <strong>6dB</strong>，灵敏度翻倍（-38dB 比-44dB 灵敏 2 倍）</li></ul><h4 id="指向性（Polar-Pattern"><a href="#指向性（Polar-Pattern" class="headerlink" title="指向性（Polar Pattern)"></a><strong>指向性（Polar Pattern)</strong></h4><ul><li><strong>心形（Cardioid）</strong>：最常用，抑制后方噪音，适合独唱&#x2F;演讲。<code>像&quot;手电筒光斑&quot;，正前方收音最强</code></li><li><strong>超心形（Supercardioid）</strong>：定向更强，适合嘈杂环境或远距离拾音。<code>光束更窄，但后方会出现&quot;小耳朵&quot;（微弱拾音区）</code></li><li><strong>全向（Omni）</strong>：360° 拾音，适合会议或合唱，但需安静环境。<code>像&quot;灯泡发光&quot;，360°均匀拾音</code></li></ul><blockquote><p>血泪教训：</p><ul><li>室内直播用 <strong>心形</strong>→ 抑制显示器风扇噪音</li><li>街头采访用 <strong>超心形</strong>→ 对抗环境噪音</li></ul></blockquote><p><img src="https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505201936187.gif" alt="0679D9F9"></p><h4 id="最大声压级（Max-SPL）"><a href="#最大声压级（Max-SPL）" class="headerlink" title="最大声压级（Max SPL）"></a><strong>最大声压级（Max SPL）</strong></h4><ul><li>动圈麦（如 Shure SM58）可承受 <strong>150dB</strong>，适合高音量乐器（如鼓）；电容麦通常 <strong>120-130dB</strong>，需注意过载。</li><li>普通说话&#x2F;弹唱：<strong>100dB</strong> 足够<br><strong>隐藏陷阱</strong>：<br>某些电容麦标称高 SPL，但需要开启-10dB 衰减档（实质是压缩动态）</li></ul><p><img src="https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505201939640.gif" alt="067E4DAE"></p><h4 id="信噪比（SNR）"><a href="#信噪比（SNR）" class="headerlink" title="信噪比（SNR）"></a><strong>信噪比（SNR）</strong></h4><ul><li>假设麦克风输出信号 <strong>-32dB</strong>，底噪 <strong>-82dB</strong></li><li>信噪比 &#x3D; <strong>50dB</strong>（-32 - (-82)）</li><li><strong>&gt;70dB</strong> 为佳，数值越高背景噪音越少。<code>60dB以上：专业级（几乎无底噪）</code> <code>50dB以下：能听到明显&quot;嘶嘶&quot;声</code></li></ul><h4 id="阻抗（Impedance）"><a href="#阻抗（Impedance）" class="headerlink" title="阻抗（Impedance）"></a><strong>阻抗（Impedance）</strong></h4><ul><li>麦克风输出阻抗 <strong>≤200Ω</strong> 为低阻（适合长线缆传输）<code>阻抗越低，音量越小，音质越好。阻抗越高，音量越大，但容易失真</code></li><li>输入设备阻抗需 ≥5 倍麦克风阻抗（如麦克风 200Ω→ 声卡输入要 1kΩ）<br><strong>常见翻车现场</strong>：<br>高阻麦克风（600Ω）接普通声卡 → 声音发闷&#x2F;音量小</li></ul><h3 id="终极避坑口诀"><a href="#终极避坑口诀" class="headerlink" title="终极避坑口诀"></a><strong>终极避坑口诀</strong></h3><blockquote><p>频响看曲线，灵敏看负数<br>指向分角度，声压看极限<br>信噪比 60 起，阻抗要低阻<br>找 U 型麦克风（低频不容易影响）</p></blockquote><h3 id="采购清单"><a href="#采购清单" class="headerlink" title="采购清单"></a>采购清单</h3><ul><li><p>阻抗300Ω      心形         </p><table><thead><tr><th>话筒链接</th><th>频响范围（Hz）</th><th>阻抗（单位Ω）</th><th>指向性</th><th>信噪比(单位dB)</th><th>灵敏度</th><th>续航时长(单位h)</th><th>价格（一拖二）</th></tr></thead><tbody><tr><td><a href="https://detail.1688.com/offer/792895999197.html?spm=a262uh.11734178.favorite-offers-offer-list-offer4.2.52422ef6AHREZ4">2.4g无线麦克风万能防啸叫 舞台k歌充电话筒声卡直播麦克风跨境 - 阿里巴巴</a></td><td>100-20kHz</td><td>300</td><td>心形</td><td>≥75dB</td><td></td><td>12</td><td>102.7+3（109高配好音质）</td></tr><tr><td><a href="https://detail.1688.com/offer/809251918462.html?spm=a262uh.11734178.favorite-offers-offer-list-offer3.2.52422ef6AHREZ4">无线麦克风家用K歌金属U段一拖二音响直播声卡录音高音质充电话筒 - 阿里巴巴</a></td><td>100-20kHz</td><td></td><td>心形</td><td>≥70db</td><td></td><td>6-8h(含)</td><td>95+8</td></tr><tr><td><a href="https://detail.1688.com/offer/910830646473.html?spm=a262uh.11734178.favorite-offers-offer-list-offer5.2.52422ef6AHREZ4">跨境无线麦克风话筒U段直播防啸叫一拖二ktv家用唱歌专用无线话筒 - 阿里巴巴</a></td><td>100-20kHz</td><td>600Ω</td><td>心型</td><td>≥85dB</td><td></td><td>1-3h(含)</td><td>68+5</td></tr><tr><td><a href="https://detail.1688.com/offer/731692801179.html?spm=a262uh.11734178.favorite-offers-offer-list-offer2.2.52422ef6AHREZ4"><span style="color:#33FFFF;">全金属U段无线话筒一拖二KTV家用唱歌声卡直播功放音响通用麦克风 - 阿里巴巴</span></a></td><td>30-20kHz</td><td></td><td>心型</td><td>&gt;95dB</td><td></td><td>3-6h(含)</td><td>145+5</td></tr><tr><td><a href="https://detail.1688.com/offer/683303536027.html?spm=a262uh.11734178.favorite-offers-offer-list-offer1.2.52422ef6AHREZ4">无线麦克风充电防啸叫 户外声卡直播麦克风家用音响k歌舞台话筒 - 阿里巴巴</a></td><td>80Hz-15kHz</td><td></td><td>心型</td><td>&gt;60dB</td><td>-70dB</td><td></td><td>70.2+3（VHF方案）</td></tr></tbody></table></li></ul>]]></content>
      
      
      <categories>
          
          <category> 实习知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 音响 </tag>
            
            <tag> 实习 </tag>
            
            <tag> 音频技术 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
