{"meta":{"title":"Mextraのblog","subtitle":"一个双非的CV工程师","description":"","author":"Mextra","url":"https://mextra.netlify.app","root":"/"},"pages":[{"title":"关于","date":"2025-09-17T03:21:01.487Z","updated":"2025-05-21T04:58:26.220Z","comments":true,"path":"about/index.html","permalink":"https://mextra.netlify.app/about/index.html","excerpt":"","text":"这里是Mextra的博客 一个双非的CV工程师 目前正在修仙嵌入式 该博客如何建立？ 某个平平无奇的中午点开了b站UP主左-岚的视频 【大学生提高课】3 hexo与hugo博客搭建与github自动化推送和服务器推送_哔哩哔哩_bilibili) 通过一个中午的忙碌以及后续的美化 逐渐地诞生了这个博客 再次特别鸣谢两位大大左-岚 以及 拔剑Sketon 有了博客以后会写什么？ 那当然是写一下自己的学习笔记、实习经验什么的(,,•﹏•,,) 以及平时的一些碎碎念"},{"title":"友情链接","date":"2025-09-17T03:21:01.505Z","updated":"2025-05-19T14:43:24.733Z","comments":true,"path":"friend/index.html","permalink":"https://mextra.netlify.app/friend/index.html","excerpt":"","text":"本站信息 站名： Mextra 站长： Mextra 地址： https://mextra.netlify.app/ 申请方法 添加本站后，在本页留言，格式如下 123456```yml- name: #您的名字 url: #您的网址 desc: #简短描述 image: #一张图片``` 小伙伴们 Mextra 一个双非的CV工程师 本站站长 D-Sketon 一个车万人 KingJt 记录生活，分享技术"},{"title":"","date":"2025-05-20T13:48:29.000Z","updated":"2025-05-20T14:22:55.240Z","comments":true,"path":"search/index.html","permalink":"https://mextra.netlify.app/search/index.html","excerpt":"","text":""}],"posts":[{"title":"linux","slug":"linux","date":"2025-09-23T12:17:17.000Z","updated":"2025-09-23T12:17:17.315Z","comments":true,"path":"2025/09/23/linux/","permalink":"https://mextra.netlify.app/2025/09/23/linux/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"ESP32学习","slug":"ESP32学习","date":"2025-09-09T03:04:10.000Z","updated":"2025-09-17T04:11:33.859Z","comments":true,"path":"2025/09/09/ESP32学习/","permalink":"https://mextra.netlify.app/2025/09/09/ESP32%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"ESP32环境搭建WSL2安装与配置推荐查阅官方文档说明：安装 WSL | Microsoft Learn 手动下载安装包 访问 WSL 的 GitHub Releases 页面 https://github.com/microsoft/WSL/releases 查找并下载最新版本的 .msi 安装包（例如 wsl.2.1.5.0.x64.msi） 配置控制面板 有些Windows 11新系统会没有虚拟机平台这个选项 没有关系！！！！ 配置完后重新启动电脑 管理员身份运行Windows PowerShell 安装Ubuntu1wsl --install 如有可选 则选择Uuntu 如 wsl --install -d Ubuntu 等待安装完成后重启电脑打开Ubuntu 输入账号密码 更新软件源1sudo apt update 更新完后输入下方指令，下载espidf依赖库和工具 1sudo apt-get install git wget flex bison gperf python3 python3-pip python3-venv cmake ninja-build ccache libffi-dev libssl-dev dfu-util libusb-1.0-0 输入y VScode配置选择连接到WSL 插件安装 安装Chinese插件 安装C/C++插件 安装ESP-IDF插件 在linux账户新建文件用于存放espidf内容，方便后续管理 ESP-IDF安装 在安装路径中选择自己新建的文件夹 如果出现下图这个情况 那就运行一下下面的指令 12sudo chown -R $USER:$USER /home/你的用户名/你的IDF文件名/chmod -R 755 /home/你的用户名/你的IDF文件名/ 安装完成之后先搞个工程测试一下编译能不能正常 选择文件夹来存放代码 设置环境设置IDF_tools环境（豆包四条命令搞定） 注意下方命令中： ~/ESP_IDF/v5.5.1/esp-idf：你的IDF文件夹路径 要一直引入到esp-idf ~/ESP_IDF/Tools：你的IDF_Tools文件夹路径 1234echo &#x27;export IDF_PATH=~/ESP_IDF/v5.5.1/esp-idf&#x27; &gt;&gt; ~/.bashrcecho &#x27;export IDF_TOOLS_PATH=~/ESP_IDF/Tools&#x27; &gt;&gt; ~/.bashrcecho &#x27;source ~/ESP_IDF/v5.5.1/esp-idf/export.sh&#x27; &gt;&gt; ~/.bashrcsource ~/.bashrc # 立即生效 成功的话 重启vscode就会自动出现idf的命令 若上面还不行 则根据报错情况执行下面场景 1：运行 ./export.sh 时报 “Python 虚拟环境不存在”报错信息 1ERROR: ESP-IDF Python virtual environment &quot;$HOME/ESP_IDF/Tools/python_env/idf5.5_py3.12_env/bin/python&quot; not found. Please run the install script to set it up before proceeding. 原因 未执行 ESP-IDF 安装脚本，Python 虚拟环境未创建。 解决方案 必须先运行安装脚本，自动创建虚拟环境和安装依赖： 123456# 进入 ESP-IDF 根目录（替换为你的实际路径）cd ~/ESP_IDF/v5.5.1/esp-idf# 执行安装脚本（Linux/macOS 用 install.sh，Windows 用 install.bat）./install.sh# 安装完成后再执行 export.sh 导出环境. ./export.sh 场景 2：运行 ./install.sh 时 “下载工具包卡住”报错表现 安装过程中卡在某一工具包下载（如 riscv32-esp-elf-gdb），进度条不动或反复重试。 原因 ESP-IDF 工具包托管在 GitHub，国内网络访问速度慢或不稳定，导致下载中断。 用国内镜像加速（推荐）配置 IDF_GITHUB_ASSETS 环境变量，将下载源切换为 Espressif 国内镜像，无需手动下载： 1234# 临时生效，每次打开终端需重新执行（或写入 shell 配置文件）export IDF_GITHUB_ASSETS=&quot;dl.espressif.com/github_assets&quot;# 重新运行安装脚本./install.sh 烧录文件下载wsl-usb-manager.exe wsl-usb-manager.exe 插上ESP32S3 配置WSL USB管理员身份打开Windows PowerShell 输入winget install usbipd，然后输入y（看情况选择开不开魔法，不开也能20s左右下载安装完） 这个指令是安装usbipd-win工具，用于将windows系统的usb设备共享给wsl环境。 安装好之后 更改权限 输入sudo usermod -aG dialout 你的用户名 然后重启电脑 输入groups验证一下 如果输出中包含 dialout 或 uucp，则表示设置成功，之后就可以正常访问串口了。 进入WSL USB选择端口并烧录 以上环境参考：（二）vscode搭建espidf环境，配置wsl2_wsl 编译idf项目-CSDN博客 感谢QL.ql大博主 ESP32基础知识 使用命令行创建工程1idf.py create-project 工程名 打开vscode 切换到新建的工程1234cd ~/ESP_Code/刚刚的工程名code .按`ctrl+shift+p` 寻找add 添加idf路径 在写代码时候 如果出现宏没定义 则重新设置一下芯片型号 稍等一会就会出现 如果想要删除文件夹 则运行以下命令 12cd ..rm -rf 文件夹 必备头文件 123#include &quot;freertos/FreeRTOS.h&quot;#include &quot;freertos/task.h&quot;#include &quot;esp_log.h&quot; CMakeList.txt使用说明一般CmakeList.txt呈现下面的结构 1234main main.c CMakeList.txtCMakeList.txt 创建自定义文件夹 如 12345678components led led.c led.h CMakeList.txtmain main.c CMakeList.txt 在这个目录下 则components/led文件夹下的CMakeList.txt，可以这么写 1234idf_component_register(SRCS &quot;led.c&quot; INCLUDE_DIRS &quot;.&quot; REQUIRES esp_driver_gpio ) SRCS：.c文件 多个用空格隔开 INCLUDE_DIRS：文件名 多个同样用空格隔开 REQUIRES：引入ESP官方的组件库components ，名字为官方idf下的components文件夹下的文件夹名 如此处的esp_driver_gpio 而若要引用 则main文件夹下的CMakeList.txt 可以这么写 12idf_component_register(SRCS &quot;main.c&quot; &quot;../components/led/led.c&quot; INCLUDE_DIRS &quot;.&quot; &quot;../components&quot;) FreeRTOS-ESP32 基础API任务创建12345678BaseType_t xTaskCreatePinnedToCore( TaskFunction_t pvTaskCode, //任务函数指针，原型是voidfun(void*param) const char *constpcName, //任务的名称，打印调试可能会有用 const uint32_t usStackDepth, //指定的任务堆栈空间大小（字节） void *constpvParameters, //任务参数 UBaseType_t uxPriority, //优先级，数字越大，优先级越大，0到(configMAX_PRIORITIES-1) 即0-24 TaskHandle_t *constpvCreatedTask, //传回来的任务句柄 const BaseType_t xCoreID) //分配在哪个内核上运行 ESP32是双核 所以可以选0或1 ESP32的任务堆栈空间大小usStackDepth与原生FreeRTOS不一样 原生FreeRTOS的任务堆栈空间大小单位是字，即目标平台若是32位 则为4个字节 ESP32的任务堆栈空间大小单位是字节，最小是2048 阻塞函数（少用 可替代）12345678//粗略延时xTicksToDelay个周期 //使用该函数后 任务进入阻塞 等延时结束且调度到来才会再次运行void vTaskDelay(const TickType_t xTicksToDelay) //用于表示精确的解除阻塞时间 //即使任务的执行时间超过了周期时间，它也能自动调整延迟时间，保证任务的周期性运行void vTaskDelayUntil(TickType_t *pxPreviousWakeTime,const TickType_t xTimeIncrement) 打印调试123456789101112131415161718#include &lt;stdio.h&gt;#include &quot;freertos/FreeRTOS.h&quot;#include &quot;freertos/task.h&quot;#include &quot;esp_log.h&quot;void taskA(void *param)&#123; while (1) &#123; ESP_LOGI(&quot;TaskA&quot;, &quot;Hello from Task A%d&quot;, 1);//前面是一个TAG标签，后面是打印内容 他会自动回车换行 vTaskDelay(pdMS_TO_TICKS(500)); &#125;&#125;void app_main(void)&#123; xTaskCreatePinnedToCore(taskA, &quot;TaskA&quot;, 2048, NULL, 5, NULL, 1);&#125; 效果如图 队列 队列特性：先进先出 123456789101112131415161718192021222324252627282930313233343536373839404142434445QueueHandle_t queue_handle = NULL; // 创建队列句柄/** * @brief 创建一个队列 * @param uxQueueLength 队列长度 * @param uxItemSize 每个元素的大小(单位是字节) */QueueHandle_t xQueueCreate(UBaseType_t uxQueueLength, UBaseType_t uxItemSize);/** * @brief 向队列头部发送数据 * @param xQueue 队列句柄 * @param pvItemToQueue 要发送的数据的指针 * @param xTicksToWait 等待的时间(单位是tick) * @return 如果在等待时间内发送成功返回pdTRUE，否则返回errQUEUE_FULL */BaseType_t xQueueSend(QueueHandle_t xQueue, const void *pvItemToQueue, TickType_t xTicksToWait);/** * @brief 向队列尾部发送数据（新数据放在队尾） * @param xQueue 队列句柄 * @param pvItemToQueue 要发送的数据的指针 * @param xTicksToWait 等待的时间 * @return pdTRUE 如果发送成功 * errQUEUE_FULL 如果队列已满，发送失败 */BaseType_t xQueueSendToBack(QueueHandle_t xQueue, const void *pvItemToQueue, TickType_t xTicksToWait);/** * @brief 从队列中接收数据 * @param xQueue 队列句柄 * @param pvBuffer 用于存储接收数据的缓冲区 * @param xTicksToWait 等待数据的最大时间，以系统节拍为单位 * @return pdPASS 表示接收成功，errQUEUE_EMPTY 表示队列为空且等待超时，接收失败。 */BaseType_t xQueueReceive(QueueHandle_t xQueue, void *pvBuffer, TickType_t xTicksToWait);/** * @brief 该函数在中断中使用，从队列发送数据 这个函数的行为和普通的 xQueueSend 有差异，且不允许阻塞（等待） * @param xQueue 队列句柄 * @param pvItemToQueue 要发送的数据 * @param pxHigherPriorityTaskWoken 如果发送数据后，有更高优先级的任务被唤醒，则该参数会被置为pdTRUE * @return 如果发送成功，返回pdTRUE，否则返回errQUEUE_FULL */BaseType_t xQueueSendFromISR(QueueHandle_t xQueue, const void *pvItemToQueue, BaseType_t *pxHigherPriorityTaskWoken); 调用示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &quot;freertos/FreeRTOS.h&quot;#include &quot;freertos/task.h&quot;#include &quot;freertos/queue.h&quot;#include &quot;esp_log.h&quot;QueueHandle_t queue_handle = NULL; // 定义一个队列句柄typedef struct&#123; int value;&#125; queue_date_t;void taskA(void *param)&#123; // 从队列里面接收数据，并打印 queue_date_t data; while (1) &#123; if (xQueueReceive(queue_handle, &amp;data, 100) == pdTRUE) // 从队列中接收数据，阻塞等待 &#123; ESP_LOGI(&quot;re_queue&quot;, &quot;receive queue value:%d&quot;, data.value); // 前面是一个TAG标签，后面是打印内容 他会自动回车换行 &#125; &#125;&#125;void taskB(void *param)&#123; queue_date_t data; memset(&amp;data, 0, sizeof(data)); // 每隔1s向队列里面发送数据 while (1) &#123; xQueueSendToBack(queue_handle, &amp;data, 100); // 向队列中发送数据，阻塞等待 vTaskDelay(pdMS_TO_TICKS(1000)); // 延时1s data.value++; &#125;&#125;void app_main(void)&#123; queue_handle = xQueueCreate(10, sizeof(queue_date_t)); // 创建一个队列，队列长度为10，每个元素的大小为queue_date_t结构体的大小 xTaskCreatePinnedToCore(taskA, &quot;re_queue&quot;, 2048, NULL, 3, NULL, 1); xTaskCreatePinnedToCore(taskB, &quot;se_queue&quot;, 2048, NULL, 3, NULL, 1);&#125; 信号量12345678910111213141516171819202122232425262728293031323334353637383940/** * @brief 创建一个二值信号量 * @return SemaphoreHandle_t 信号量句柄 */SemaphoreHandle_t xSemaphoreCreateBinary(void);/** * @brief 创建一个计数信号量 * @param uxMaxCount 计数信号量的最大值 * @param uxInitialCount 计数信号量的初始值 * */SemaphoreHandle_t xSemaphoreCreateCounting(UBaseType_t uxMaxCount, UBaseType_t uxInitialCount);/** * @brief 创建一个互斥锁 * @return SemaphoreHandle_t 互斥锁句柄 */SemaphoreHandle_t xSemaphoreCreateMutex(void);/** * @brief 取得一个信号量 * @param xSemaphore 信号量句柄 * @param xTicksToWait 等待信号量的时间，单位为ticks * @return 如果成功取得信号量则返回pdTRUE，否则返回pdFALSE */BaseType_t xSemaphoreTake(SemaphoreHandle_t xSemaphore, TickType_t xTicksToWait);/** * @brief 释放一个信号量 * @param xSemaphore 信号量句柄 * @return 如果成功释放信号量则返回pdTRUE，否则返回pdFALSE */BaseType_t xSemaphoreGive(SemaphoreHandle_t xSemaphore);/** * @brief 删除一个信号量 * @param xSemaphore 要删除的信号量句柄 */void vSemaphoreDelete(SemaphoreHandle_t xSemaphore); 调用示例1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;string.h&gt;#include &quot;freertos/FreeRTOS.h&quot;#include &quot;freertos/task.h&quot;#include &quot;freertos/queue.h&quot;#include &quot;freertos/semphr.h&quot;#include &quot;esp_log.h&quot;SemaphoreHandle_t mutex_handle;void taskA(void *param)&#123; while (1) &#123; vTaskDelay(pdMS_TO_TICKS(1000)); xSemaphoreTake(mutex_handle, portMAX_DELAY); ESP_LOGI(&quot;TASK_A&quot;, &quot;Task A is running&quot;); xSemaphoreGive(mutex_handle); vTaskDelay(pdMS_TO_TICKS(10)); // 给其他任务机会 &#125;&#125;void taskB(void *param)&#123; while (1) &#123; vTaskDelay(pdMS_TO_TICKS(500)); xSemaphoreTake(mutex_handle, portMAX_DELAY); ESP_LOGI(&quot;TASK_B&quot;, &quot;Task B is running&quot;); xSemaphoreGive(mutex_handle); vTaskDelay(pdMS_TO_TICKS(10)); // 给其他任务机会 &#125;&#125;void app_main(void)&#123; mutex_handle = xSemaphoreCreateMutex(); xTaskCreatePinnedToCore(taskA, &quot;taskA&quot;, 2048, NULL, 6, NULL, 1); xTaskCreatePinnedToCore(taskB, &quot;taskB&quot;, 2048, NULL, 4, NULL, 1);&#125; 注意释放信号量的时候 一般会给个延时 不加的话任务会马上回到while(1)初始的时候 反应出来的现象就是一直是A任务运行 原因：RTOS任务调度需要时间 并且最少只能是10ms 已测试 事件组1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/** * @brief 创建事件组 * @return EventGroupHandle_t 事件组句柄 */EventGroupHandle_t xEventGroupCreate(void);/** * @brief 设置事件位 * @param xEventGroup 事件组句柄 * @param uxBitsToSet 要设置的事件位 * @return 设置后事件组的值 */EventBits_t xEventGroupSetBits(EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet);/** * @brief 事件组等待位函数 * @param xEventGroup 事件组句柄 * @param uxBitsToWaitFor 等待的事件位 * @param xClearOnExit 退出时是否清除事件位 pdTRUE or pdFALSE * @param xWaitForAllBits 是否等待所有位 pdTRUE or pdFALSE * @param xTicksToWait 等待的最大时间 * @return 返回实际获得的事件位 */EventBits_t xEventGroupWaitBits(const EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait);/** * @brief 清除事件组指定事件位 * @param xEventGroup 事件组句柄 * @param uxBitsToClear 要清除的事件位 * @return 清除前的事件组位值 */EventBits_t xEventGroupClearBits(EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear);/* 以下使用消息直达机制*//** * @brief 任务通知函数 * @param xTaskToNotify 任务句柄 * @param ulValue 发送的值 * @param eAction 发送的动作 * eNoAction 不改变任务的通知值(即不更新 会一直发送初始值) * eSetBits 将ulValue的值按位或 到任务的通知值中 * eIncrement 将任务的通知值加1 * eSetValueWithOverwrite 将任务的通知值设置为ulValue * eSetValueWithoutOverwrite 如果任务的通知值为0，则将其设置为ulValue，否则不改变任务的通知值 * @return 如果通知成功返回pdPASS，否则返回errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY */BaseType_t xTaskNotify(TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction);/** * @brief 将任务设置为等待接收通知 * @param ulBitsToClearOnEntry 进入等待前要清除的位 * @param ulBitsToClearOnExit 退出等待后要清除的位 * @param pulNotificationValue 指向接收通知值的指针 * @param xTicksToWait 等待通知的最大时间（以滴答为单位） * @return 如果在指定的等待时间内收到通知，则返回pdTRUE；否则返回 */BaseType_t xTaskNotifyWait(uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait); 调用示例事件组设置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;string.h&gt;#include &quot;freertos/FreeRTOS.h&quot;#include &quot;freertos/task.h&quot;#include &quot;freertos/queue.h&quot;#include &quot;freertos/semphr.h&quot;#include &quot;freertos/event_groups.h&quot;#include &quot;esp_log.h&quot;#define EVENT_BIT_0 BIT0#define EVENT_BIT_1 BIT1EventGroupHandle_t event_handle;void taskA(void *param)&#123; // 定时1s向任务B发送事件消息 while (1) &#123; xEventGroupSetBits(event_handle, EVENT_BIT_0); vTaskDelay(pdMS_TO_TICKS(1000)); xEventGroupSetBits(event_handle, EVENT_BIT_1); vTaskDelay(pdMS_TO_TICKS(1000)); &#125;&#125;void taskB(void *param)&#123; EventBits_t ev; while (1) &#123; ev = xEventGroupWaitBits(event_handle, EVENT_BIT_0 | EVENT_BIT_1, pdTRUE, pdFALSE, pdMS_TO_TICKS(5000)); if (ev &amp; EVENT_BIT_0) &#123; ESP_LOGI(&quot;ev&quot;, &quot;ev get event0&quot;); &#125; if (ev &amp; EVENT_BIT_1) &#123; ESP_LOGI(&quot;ev&quot;, &quot;ev get event1&quot;); &#125; &#125;&#125;void app_main(void)&#123; event_handle = xEventGroupCreate(); xTaskCreatePinnedToCore(taskA, &quot;taskA&quot;, 2048, NULL, 3, NULL, 1); xTaskCreatePinnedToCore(taskB, &quot;taskB&quot;, 2048, NULL, 3, NULL, 1);&#125; 消息直达123456789101112131415161718192021222324252627282930313233343536373839#include &lt;string.h&gt;#include &quot;freertos/FreeRTOS.h&quot;#include &quot;freertos/task.h&quot;#include &quot;freertos/queue.h&quot;#include &quot;freertos/semphr.h&quot;#include &quot;freertos/event_groups.h&quot;#include &quot;esp_log.h&quot;static TaskHandle_t taskA_handle;static TaskHandle_t taskB_handle;void taskA(void *param)&#123; // 定时1s向任务B发送事件消息 uint32_t count = 0; vTaskDelay(pdMS_TO_TICKS(100)); while (1) &#123; xTaskNotify(taskB_handle, count, eSetValueWithoutOverwrite); count++; vTaskDelay(pdMS_TO_TICKS(1000)); &#125;&#125;void taskB(void *param)&#123; uint32_t count = 0; while (1) &#123; xTaskNotifyWait(0, 0, &amp;count, portMAX_DELAY); ESP_LOGI(&quot;taskB&quot;, &quot;Notify count: %lu&quot;, count); &#125;&#125;void app_main(void)&#123; xTaskCreatePinnedToCore(taskA, &quot;taskA&quot;, 2048, NULL, 3, &amp;taskA_handle, 1); xTaskCreatePinnedToCore(taskB, &quot;taskB&quot;, 2048, NULL, 3, &amp;taskB_handle, 1);&#125; ESP-IDF中的FreeRTOS与原生区别 ESP32是多核的 所以可以完全实现程序并发执行 即不是单核那种 低优先级的任务因为高优先级任务存在而执行不了 esp-idf自动创建五个任务 空闲任务（每个核都会创建一个，优先级为0） FreeRTOS定时器任务（优先级为1） app_main任务（我们的应用入口，优先级为1） IPC任务（每个核创建一个，用于多核协调，优先级为24） ESP定时器任务（负责ESP32定时器回调，优先级为22） esp-idf不使用原生FreeRTOS的内存堆管理，实现了自己的堆 创建任务使用xTaskCreatePinnedToCore() 可以指定用哪个核创建任务 负责处理无线网络的任务（如WiFi蓝牙）将被固定到CPU0，即PRO_CPU 处理应用程序其余部分任务将被固定到CPU1，即APP_CPU 如果任务中用到浮点运算，则创建任务的时候必须指定具体运行在哪个核上，不能由系统自动安排 GPIO配置引脚基础配置gpio_config()：批量配置 GPIO（核心入口） 函数原型 1esp_err_t gpio_config(const gpio_config_t *pGPIOConfig); 作用：一次性配置一组 GPIO 的模式、上下拉、中断类型（覆盖该引脚当前所有配置）。 参数：pGPIOConfig：指向 gpio_config_t 结构体的指针（需提前初始化）。 返回值：ESP_OK（成功）、ESP_ERR_INVALID_ARG（参数错误，如引脚无效）。 示例：配置 GPIO2、GPIO3 为输出模式，禁用上下拉和中断： 12345678gpio_config_t io_conf = &#123; .pin_bit_mask = (1ULL &lt;&lt; GPIO_NUM_2) | (1ULL &lt;&lt; GPIO_NUM_3), // 仅配置 GPIO2 .mode = GPIO_MODE_OUTPUT, .pull_up_en = GPIO_PULLUP_DISABLE, .pull_down_en = GPIO_PULLDOWN_DISABLE, .intr_type = GPIO_INTR_DISABLE&#125;;gpio_config(&amp;io_conf); // 执行配置 intr_type : GPIO_INTR_DISABLE：禁用中断 GPIO_INTR_POSEDGE：上升沿触发 GPIO_INTR_NEGEDGE：下降沿触发 GPIO_INTR_ANYEDGE：双边沿触发 GPIO_INTR_LOW_LEVEL：低电平触发 GPIO_INTR_HIGH_LEVEL：高电平触发 gpio_reset_pin()：重置引脚为默认状态 函数原型 1esp_err_t gpio_reset_pin(gpio_num_t gpio_num); 作用：将指定 GPIO 重置为默认状态（输入模式、禁用上下拉、禁用中断、选择 GPIO 功能）。 参数：gpio_num：要重置的 GPIO 编号（如 GPIO_NUM_4）。 示例：重置 GPIO4，恢复初始状态： 1gpio_reset_pin(GPIO_NUM_4); gpio_set_direction()：单独设置引脚方向 函数原型 1esp_err_t gpio_set_direction(gpio_num_t gpio_num, gpio_mode_t mode); 作用：单独修改某个 GPIO 的模式（输入 &#x2F; 输出 &#x2F; 输入输出），覆盖当前模式。 参数 gpio_num：目标 GPIO 编号。 mode：目标模式（如 GPIO_MODE_INPUT）。 示例：将已配置的 GPIO2 改为输入模式 1gpio_set_direction(GPIO_NUM_2, GPIO_MODE_INPUT); 配置上下拉函数（gpio_pullup_en&#x2F;gpio_pulldown_en） 函数原型 1234esp_err_t gpio_pullup_en(gpio_num_t gpio_num); // 启用上拉esp_err_t gpio_pullup_dis(gpio_num_t gpio_num); // 禁用上拉esp_err_t gpio_pulldown_en(gpio_num_t gpio_num); // 启用下拉esp_err_t gpio_pulldown_dis(gpio_num_t gpio_num); // 禁用下拉 作用：比 gpio_set_pull_mode 更直观，单独控制上拉 &#x2F; 下拉的启用 &#x2F; 禁用。 示例：启用 GPIO0 下拉，禁用上拉： 12gpio_pulldown_en(GPIO_NUM_0);gpio_pullup_dis(GPIO_NUM_0); 引脚电平控制函数gpio_set_level()：设置输出电平 函数原型 1esp_err_t gpio_set_level(gpio_num_t gpio_num, uint32_t level); 作用：给输出模式的 GPIO 设置高 &#x2F; 低电平（仅输出模式有效）。 参数： level：0（低电平）、1（高电平）。 gpio_get_level()：读取输入电平 函数原型 1int gpio_get_level(gpio_num_t gpio_num); 作用：读取 GPIO 的当前输入电平（需引脚为输入 &#x2F; 输入输出模式，否则返回 0）。 返回值：0（低电平）、1（高电平）。 LEDC库学习笔记 定义：LEDC（Light Emitting Diode Controller）是 ESP32 内置的 LED 控制器，核心功能是生成 PWM（脉冲宽度调制）信号，不仅用于 LED 亮度调节，还可驱动电机、舵机等需 PWM 信号的设备。 核心优势：无需手动编写定时器中断逻辑，ESP-IDF 提供完整库接口，配置简单、信号稳定 注意：LEDC 控制器有自己专属的 4 个定时器（LEDC_TIMER_0 ~ LEDC_TIMER_3），这些定时器是 LEDC 模块内部集成的，专门用于生成 PWM 信号。 与通用定时器（TIMER_0 ~ TIMER_3）完全分离 LEDC关键概念 概念 说明 通道（Channel） ESP32 有 16 个独立通道，每个通道可独立配置 PWM 参数（频率、占空比），并映射到 1 个 GPIO 引脚输出信号。 定时器（Timer） 每个通道需绑定定时器，定时器决定 PWM 频率（由预分频和计数范围计算），多个通道可共享同一定时器（频率相同）。 频率（Frequency） PWM 信号周期的倒数（单位：Hz），如 50Hz（舵机常用，对应 20ms 周期）、1000Hz（LED 常用，避免人眼闪烁）。 占空比（Duty Cycle） PWM 高电平持续时间与周期的比值（0100%），LEDC 中用数值表示（如 12 位分辨率对应 04095）。 分辨率（Duty Resolution） 占空比的可调精度，范围 LEDC_TIMER_1_BITLEDC_TIMER_20_BIT，如 12 位表示占空比可设为 04095（共 4096 级）。 速度模式 分 LEDC_LOW_SPEED_MODE（低速模式）和 LEDC_HIGH_SPEED_MODE（高速模式），高速模式支持更高 PWM 频率。 常用API（需包含头文件 driver/ledc.h）定时器初始化 作用：初始化 LEDC 定时器，设置频率、分辨率等核心参数。 函数原型 1esp_err_t ledc_timer_config(const ledc_timer_config_t *timer_conf); 参数结构体 ledc_timer_config_t 说明： 参数 取值 &#x2F; 说明 speed_mode 速度模式：LEDC_LOW_SPEED_MODE 或 LEDC_HIGH_SPEED_MODE duty_resolution 占空比分辨率：LEDC_TIMER_1_BIT ~ LEDC_TIMER_20_BIT（如 12 位选 LEDC_TIMER_12_BIT） timer_num 定时器编号：LEDC_TIMER_0 ~ LEDC_TIMER_3（共 4 个定时器） freq_hz PWM 频率（如 50、1000，单位：Hz） clk_cfg 时钟源：通常用 LEDC_AUTO_CLK（自动选择最优时钟） 示例：配置 1000Hz、12 位分辨率的定时器 0（低速模式） 12345678ledc_timer_config_t timer_conf = &#123; .speed_mode = LEDC_LOW_SPEED_MODE, .duty_resolution = LEDC_TIMER_12_BIT, // 0~4095 级占空比 .timer_num = LEDC_TIMER_0, .freq_hz = 1000, // 1000Hz 频率 .clk_cfg = LEDC_AUTO_CLK&#125;;ledc_timer_config(&amp;timer_conf); // 执行配置 通道配置：ledc_channel_config()通道配置：ledc_channel_config() 作用：将 LEDC 通道绑定到定时器和 GPIO 引脚，设置初始占空比。 函数原型 1esp_err_t ledc_channel_config(const ledc_channel_config_t *channel_conf); 参数结构体 ledc_channel_config_t 说明 参数 取值 &#x2F; 说明 speed_mode 需与绑定的定时器速度模式一致（如 LEDC_LOW_SPEED_MODE） channel 通道编号：LEDC_CHANNEL_0 ~ LEDC_CHANNEL_15（共 16 个通道） timer_sel 绑定的定时器编号（如 LEDC_TIMER_0） intr_type 中断类型：通常设 LEDC_INTR_DISABLE（禁用中断） gpio_num 输出 PWM 的 GPIO 引脚（如 GPIO_NUM_2、GPIO_NUM_4） duty 初始占空比（0 ~ 分辨率最大值，如 12 位初始为 0 表示 LED 灭） hpoint 脉冲起点偏移：通常设 0（无偏移） 示例 12345678910ledc_channel_config_t channel_conf = &#123; .speed_mode = LEDC_LOW_SPEED_MODE, .channel = LEDC_CHANNEL_0, .timer_sel = LEDC_TIMER_0, // 绑定定时器 0 .intr_type = LEDC_INTR_DISABLE, .gpio_num = GPIO_NUM_2, // GPIO2 输出 PWM .duty = 0, // 初始占空比 0（LED 不亮） .hpoint = 0&#125;;ledc_channel_config(&amp;channel_conf); // 执行配置 3. 占空比修改：ledc_set_duty() + ledc_update_duty() 作用：动态调整通道的 PWM 占空比（ledc_set_duty 仅修改寄存器，ledc_update_duty 使修改生效）。 函数原型 1234// 1. 设置占空比（不立即生效）esp_err_t ledc_set_duty(ledc_mode_t speed_mode, ledc_channel_t channel, uint32_t duty);// 2. 使占空比生效esp_err_t ledc_update_duty(ledc_mode_t speed_mode, ledc_channel_t channel); 参数说明 speed_mode：速度模式（与通道一致） channel：目标通道编号 duty：目标占空比（0 ~ 分辨率最大值） 示例：将通道 0 占空比设为 50%（12 位分辨率对应 2048） 123// 12 位分辨率下，50% 占空比 = 4096 / 2 = 2048ledc_set_duty(LEDC_LOW_SPEED_MODE, LEDC_CHANNEL_0, 2048);ledc_update_duty(LEDC_LOW_SPEED_MODE, LEDC_CHANNEL_0); // 占空比生效 4. 硬件渐变：ledc_fade_* 系列函数 作用：实现硬件自动渐变（无需软件循环），适合 LED 呼吸灯、平滑调光等场景。 核心函数： 函数 作用 ledc_fade_func_install() 初始化渐变功能（需开启中断，参数 0 表示不使用中断回调） ledc_set_fade_with_time() 配置渐变参数（目标占空比、渐变时间） ledc_fade_start() 启动渐变（可选择阻塞 &#x2F; 非阻塞模式） ledc_cb_register() 注册 LEDC 回调函数 函数原型 123456// 1. 初始化渐变功能esp_err_t ledc_fade_func_install(int intr_alloc_flags);// 2. 配置渐变：在指定时间内从当前占空比渐变到目标占空比esp_err_t ledc_set_fade_with_time(ledc_mode_t speed_mode, ledc_channel_t channel, uint32_t target_duty, uint32_t fade_time_ms);// 3. 启动渐变esp_err_t ledc_fade_start(ledc_mode_t speed_mode, ledc_channel_t channel, ledc_fade_mode_t fade_mode); 参数说明： intr_alloc_flags：中断分配标志（设 0 即可） target_duty：渐变目标占空比 fade_time_ms：渐变总时间（单位：ms） fade_mode：渐变模式：LEDC_FADE_WAIT_DONE（阻塞，等待渐变完成返回）&#x2F; LEDC_FADE_NO_WAIT（非阻塞） 示例：2 秒内从当前占空比渐变到最大亮度（12 位对应 4095） 1234567891011// 1. 初始化渐变功能ledc_fade_func_install(0); // 不使用中断回调// 2. 配置渐变：2000ms（2秒）内渐变到 4095（最大亮度）ledc_set_fade_with_time(LEDC_LOW_SPEED_MODE, LEDC_CHANNEL_0, 4095, // 目标占空比（最大） 2000); // 渐变时间（ms）// 3. 启动渐变（阻塞模式，等待渐变完成后再执行后续代码）ledc_fade_start(LEDC_LOW_SPEED_MODE, LEDC_CHANNEL_0, LEDC_FADE_WAIT_DONE); 启用中断模式 函数原型 1esp_err_t ledc_cb_register(ledc_mode_t speed_mode, ledc_channel_t channel, ledc_cbs_t *cbs, void *user_arg) 参数结构体 ledc_cbs_t 说明 fade_cb：需要注册的中断回调函数 示例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;stdio.h&gt;#include &quot;freertos/FreeRTOS.h&quot;#include &quot;freertos/task.h&quot;#include &quot;driver/gpio.h&quot;#include &quot;driver/ledc.h&quot;#define LED_GPIO GPIO_NUM_18#define FULL_EV_BIT BIT0#define EMPTY_EV_BIT BIT1static EventGroupHandle_t led_fade_handle;/** * @brief 重写LEDC完成回调函数 * @note IRAM_ATTR 修饰符表示该函数在IRAM中执行，中断服务程序中不能调用RAM中的函数 */bool IRAM_ATTR ledc_finish_cb(const ledc_cb_param_t *param, void *user_arg)&#123; BaseType_t taskWoken; if (param-&gt;duty) &#123; xEventGroupSetBitsFromISR(led_fade_handle, FULL_EV_BIT, &amp;taskWoken); &#125; else &#123; xEventGroupSetBitsFromISR(led_fade_handle, EMPTY_EV_BIT, &amp;taskWoken); &#125; return taskWoken;&#125;void led_run_task(void *param)&#123; EventBits_t ev; while (1) &#123; ev = xEventGroupWaitBits(led_fade_handle, FULL_EV_BIT | EMPTY_EV_BIT, pdTRUE, pdFALSE, pdMS_TO_TICKS(5000)); if (ev &amp; FULL_EV_BIT) &#123; ledc_set_fade_with_time(LEDC_LOW_SPEED_MODE, LEDC_CHANNEL_0, 0, 2000); ledc_fade_start(LEDC_LOW_SPEED_MODE, LEDC_CHANNEL_0, LEDC_FADE_NO_WAIT); &#125; if (ev &amp; EMPTY_EV_BIT) &#123; ledc_set_fade_with_time(LEDC_LOW_SPEED_MODE, LEDC_CHANNEL_0, 8191, 2000); ledc_fade_start(LEDC_LOW_SPEED_MODE, LEDC_CHANNEL_0, LEDC_FADE_NO_WAIT); &#125; ledc_cbs_t ledc_cbs = &#123; .fade_cb = ledc_finish_cb, &#125;; ledc_cb_register(LEDC_LOW_SPEED_MODE, LEDC_CHANNEL_0, &amp;ledc_cbs, NULL); &#125;&#125;void app_main(void)&#123; // gpio_config_t led_cfg = &#123; // .pin_bit_mask = (1 &lt;&lt; LED_GPIO), // .pull_down_en = GPIO_PULLDOWN_DISABLE, // .pull_up_en = GPIO_PULLUP_DISABLE, // .intr_type = GPIO_INTR_DISABLE, // .mode = GPIO_MODE_OUTPUT, // &#125;; // gpio_config(&amp;led_cfg); ledc_timer_config_t ledc_timer = &#123; .speed_mode = LEDC_LOW_SPEED_MODE, .timer_num = LEDC_TIMER_0, .clk_cfg = LEDC_AUTO_CLK, .freq_hz = 5000, .duty_resolution = LEDC_TIMER_13_BIT, // 占空比分辨率 0-8191 &#125;; ledc_timer_config(&amp;ledc_timer); ledc_channel_config_t ledc_channel = &#123; .gpio_num = LED_GPIO, .channel = LEDC_CHANNEL_0, .duty = 0, .speed_mode = LEDC_LOW_SPEED_MODE, .timer_sel = LEDC_TIMER_0, .intr_type = LEDC_INTR_DISABLE, &#125;; ledc_channel_config(&amp;ledc_channel); ledc_fade_func_install(0); // 使能渐变 不需要自己手动调节占空比 ledc_set_fade_with_time(LEDC_LOW_SPEED_MODE, LEDC_CHANNEL_0, 8191, 2000); ledc_fade_start(LEDC_LOW_SPEED_MODE, LEDC_CHANNEL_0, LEDC_FADE_NO_WAIT); led_fade_handle = xEventGroupCreate(); ledc_cbs_t ledc_cbs = &#123; .fade_cb = ledc_finish_cb, &#125;; ledc_cb_register(LEDC_LOW_SPEED_MODE, LEDC_CHANNEL_0, &amp;ledc_cbs, NULL); xTaskCreatePinnedToCore(led_run_task, &quot;led_run_task&quot;, 2048, NULL, 3, NULL, 1);&#125; UART配置ESP32 UART 硬件特性 硬件资源：ESP32 内置 3 个 UART 接口（UART0、UART1、UART2），支持不同引脚映射 通信参数：可配置波特率（1200 ~ 5000000bps）、数据位（5 ~ 8 位）、校验位（无 &#x2F; 奇 &#x2F; 偶）、停止位（1&#x2F;1.5&#x2F;2 位） 缓冲区：每个 UART 支持硬件 FIFO 缓冲区，可通过软件配置环形缓冲区大小 事件驱动：支持通过 FreeRTOS 队列触发 UART 事件（数据接收、缓冲区满、溢出等） 关键API API 函数 功能描述 核心参数说明 uart_param_config() 配置 UART 通信参数（波特率、数据位等） 端口号、uart_config_t 结构体 uart_set_pin() 绑定 UART 信号到物理引脚 端口号、TX 引脚、RX 引脚、RTS 引脚、CTS 引脚 uart_driver_install() 安装 UART 驱动并创建事件队列 端口号、接收缓冲区大小、发送缓冲区大小、队列容量、队列句柄、标志 uart_read_bytes() 读取 UART 接收数据 端口号、接收缓冲区、读取长度、超时时间 uart_write_bytes() 发送 UART 数据 端口号、发送缓冲区、发送长度 uart_flush_input() 清空 UART 接收缓冲区 端口号 xQueueReceive() 从事件队列接收 UART 事件 队列句柄、事件存储变量地址、超时时间 xTaskCreate() 创建独立任务处理 UART 事件 任务函数、任务名称、栈大小、优先级等 基础配置步骤 1：定义核心参数（宏定义）123456789101112131415161718// 1. 定义 UART 端口号#define USER_UART_NUM UART_NUM_1 // 避免 UART0 冲突（默认用于串口打印）#define USER_UART_BAUD 115200 // 串口波特率设置// 2. 定义引脚（需根据硬件接线调整）#define UART_TX_PIN 17 // TX 发送引脚#define UART_RX_PIN 16 // RX 接收引脚// 3. 定义缓冲区和队列参数#define UART_BUFFER_SIZE 1024 // 数据缓冲区大小#define UART_QUEUE_SIZE 10 // 事件队列容量（最多缓存 10 个事件）#define UART_TASK_STACK_SIZE 4096// UART 处理任务栈大小#define UART_TASK_PRIORITY 5 // UART 任务优先级（1~24，数值越大优先级越高）// 4. 全局变量声明static QueueHandle_t uart_event_queue; // UART 事件队列句柄static uint8_t uart_rx_buffer[UART_BUFFER_SIZE]; // 接收数据缓冲区static const char *TAG = &quot;UART_DEV&quot;; // 日志标签 步骤 2：配置 UART 硬件参数通过 uart_config_t 结构体配置通信参数，再调用 uart_param_config() 生效： 1234567891011// 配置 UART 通信参数uart_config_t uart_config = &#123; .baud_rate = USER_UART_BAUD, // 波特率（常用：9600、115200、1000000） .data_bits = UART_DATA_8_BITS,// 数据位：8 位 .parity = UART_PARITY_DISABLE,// 校验位：禁用 .stop_bits = UART_STOP_BITS_1,// 停止位：1 位 .flow_ctrl = UART_HW_FLOWCTRL_DISABLE, // 硬件流控：禁用（无需 RTS/CTS 引脚） .source_clk = UART_SCLK_DEFAULT, // 时钟源：默认&#125;;// 应用配置到指定 UART 端口ESP_ERROR_CHECK(uart_param_config(USER_UART_NUM, &amp;uart_config)); 步骤 3：绑定引脚并安装驱动 （如果用默认串口的话 则不需要绑定引脚） 引脚绑定：通过 uart_set_pin() 将 UART 信号映射到 ESP32 物理引脚 驱动安装：调用 uart_driver_install() 初始化 UART 驱动，创建事件队列（可选） 1234567891011121314// 1. 绑定 UART 引脚（TX/RX，流控引脚填 UART_PIN_NO_CHANGE 表示禁用）ESP_ERROR_CHECK(uart_set_pin(USER_UART_NUM, UART_TX_PIN, // TX 引脚 UART_RX_PIN, // RX 引脚 UART_PIN_NO_CHANGE, // RTS 引脚（禁用） UART_PIN_NO_CHANGE)); // CTS 引脚（禁用）// 2. 安装 UART 驱动（参数依次：端口号、接收缓冲区大小、发送缓冲区大小、事件队列容量、队列句柄、标志）ESP_ERROR_CHECK(uart_driver_install(USER_UART_NUM, UART_BUFFER_SIZE * 2, // 接收缓冲区（建议比单次接收大） UART_BUFFER_SIZE * 2, // 发送缓冲区 UART_QUEUE_SIZE, // 事件队列容量 &amp;uart_event_queue, // 事件队列句柄（传出） 0)); // 标志：0（默认） ESP32 UART 数据处理方式 特性 轮询方式（简单场景） 事件驱动方式（高效场景） 核心函数 uart_read_bytes()、uart_write_bytes() xQueueReceive()（监听事件队列） 适用场景 简单回显、低频率数据交互 高频率数据、多事件处理（如溢出） CPU 占用率 较高（循环查询） 较低（事件触发，无轮询） 代码复杂度 低 中（需处理多事件类型） 看门狗风险 高（需避免长阻塞） 低（事件队列超时释放 CPU） 实战代码示例事件驱动方式 通过 FreeRTOS 队列接收 UART 事件，按需处理数据接收、缓冲区满、溢出等场景： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#include &lt;stdio.h&gt;#include &quot;freertos/FreeRTOS.h&quot;#include &quot;freertos/task.h&quot;#include &quot;driver/uart.h&quot;#include &quot;esp_log.h&quot;#include &quot;driver/gpio.h&quot;// -------------- 1. 宏定义参数 --------------#define USER_UART_NUM UART_NUM_1#define USER_UART_BAUD 115200#define UART_TX_PIN 17#define UART_RX_PIN 16#define UART_BUFFER_SIZE 1024#define UART_QUEUE_SIZE 10#define UART_TASK_STACK_SIZE 4096#define UART_TASK_PRIORITY 5// -------------- 2. 全局变量 --------------static QueueHandle_t uart_event_queue;static uint8_t uart_rx_buffer[UART_BUFFER_SIZE];static const char *TAG = &quot;UART_DEV&quot;;// -------------- 3. UART 事件处理任务 --------------void uart_event_task(void *arg) &#123; uart_event_t event; // 存储 UART 事件的结构体 while (1) &#123; // 从事件队列接收事件（超时 100ms，避免阻塞触发看门狗） if (xQueueReceive(uart_event_queue, &amp;event, pdMS_TO_TICKS(100)) == pdTRUE) &#123; switch (event.type) &#123; // 1. 接收数据事件 case UART_DATA: ESP_LOGI(TAG, &quot;收到数据，长度：%d 字节&quot;, event.size); // 读取数据到缓冲区（超时 50ms，确保数据完整性） int read_len = uart_read_bytes(USER_UART_NUM, uart_rx_buffer, event.size, pdMS_TO_TICKS(50)); if (read_len &gt; 0) &#123; // 示例1：回显数据（发送收到的数据） uart_write_bytes(USER_UART_NUM, uart_rx_buffer, read_len); // 示例2：打印接收的数据（十六进制） ESP_LOGI(TAG, &quot;接收数据（hex）：&quot;); for (int i = 0; i &lt; read_len; i++) &#123; printf(&quot;%02X &quot;, uart_rx_buffer[i]); &#125; printf(&quot;\\n&quot;); &#125; break; // 2. 接收缓冲区满事件 case UART_BUFFER_FULL: ESP_LOGI(TAG, &quot;接收缓冲区满，清空缓冲区&quot;); uart_flush_input(USER_UART_NUM); // 清空接收缓冲区 xQueueReset(uart_event_queue); // 重置事件队列 break; // 3. FIFO 溢出事件（硬件缓冲区溢出） case UART_FIFO_OVF: ESP_LOGI(TAG, &quot;UART FIFO 溢出，清空缓冲区&quot;); uart_flush_input(USER_UART_NUM); xQueueReset(uart_event_queue); break; // 4. 帧错误事件（数据格式错误） case UART_FRAME_ERR: ESP_LOGI(TAG, &quot;帧错误（数据格式异常）&quot;); break; // 5. 校验错误事件（启用校验时生效） case UART_PARITY_ERR: ESP_LOGI(TAG, &quot;校验错误（数据校验不匹配）&quot;); break; // 其他未处理事件 default: ESP_LOGI(TAG, &quot;未处理事件类型：%d&quot;, event.type); break; &#125; &#125; &#125;&#125;// -------------- 4. 主函数初始化 --------------void app_main(void) &#123; // 1. 配置 UART 硬件参数 uart_config_t uart_config = &#123; .baud_rate = USER_UART_BAUD, .data_bits = UART_DATA_8_BITS, .parity = UART_PARITY_DISABLE, .stop_bits = UART_STOP_BITS_1, .flow_ctrl = UART_HW_FLOWCTRL_DISABLE, .source_clk = UART_SCLK_DEFAULT, &#125;; ESP_ERROR_CHECK(uart_param_config(USER_UART_NUM, &amp;uart_config)); // 2. 绑定引脚 ESP_ERROR_CHECK(uart_set_pin(USER_UART_NUM, UART_TX_PIN, UART_RX_PIN, UART_PIN_NO_CHANGE, UART_PIN_NO_CHANGE)); // 3. 安装 UART 驱动并创建事件队列 ESP_ERROR_CHECK(uart_driver_install(USER_UART_NUM, UART_BUFFER_SIZE * 2, UART_BUFFER_SIZE * 2, UART_QUEUE_SIZE, &amp;uart_event_queue, 0)); // 4. 创建 UART 事件处理任务（独立任务，避免阻塞 main 任务） xTaskCreate(uart_event_task, // 任务函数 &quot;uart_event_task&quot;, // 任务名称 UART_TASK_STACK_SIZE, // 栈大小 NULL, // 任务参数 UART_TASK_PRIORITY, // 优先级 NULL); // 任务句柄（无需则填 NULL）&#125; 轮询方式（简单场景，如回显） 适用于数据量小、交互频率低的场景，代码更简洁： 1234567891011121314151617181920212223242526void app_main(void) &#123; // 1. 配置 UART 参数（同事件驱动方式） uart_config_t uart_config = &#123; .baud_rate = 115200, .data_bits = UART_DATA_8_BITS, .parity = UART_PARITY_DISABLE, .stop_bits = UART_STOP_BITS_1, .flow_ctrl = UART_HW_FLOWCTRL_DISABLE, &#125;; ESP_ERROR_CHECK(uart_param_config(USER_UART_NUM, &amp;uart_config)); ESP_ERROR_CHECK(uart_set_pin(USER_UART_NUM, 17, 16, UART_PIN_NO_CHANGE, UART_PIN_NO_CHANGE)); ESP_ERROR_CHECK(uart_driver_install(USER_UART_NUM, 1024, 1024, 0, NULL, 0)); // 2. 轮询读取数据并回显 while (1) &#123; // 读取数据（超时 50ms，无数据则返回 0） int read_len = uart_read_bytes(USER_UART_NUM, uart_rx_buffer, 1024, pdMS_TO_TICKS(50)); if (read_len &gt; 0) &#123; // 回显数据 uart_write_bytes(USER_UART_NUM, uart_rx_buffer, read_len); ESP_LOGI(TAG, &quot;轮询接收数据长度：%d&quot;, read_len); &#125; // 短暂延迟，释放 CPU（避免触发看门狗） vTaskDelay(pdMS_TO_TICKS(10)); &#125;&#125; 常见问题与解决方案触发 Task Watchdog（任务看门狗） 原因： 轮询方式中 uart_read_bytes() 超时过长，或无 vTaskDelay() 释放 CPU； 事件驱动方式中 xQueueReceive() 使用 portMAX_DELAY 永久阻塞。 解决方案： 轮询方式：在循环中添加 vTaskDelay(pdMS_TO_TICKS(10))； 事件驱动方式：xQueueReceive() 超时设为有限值（如 pdMS_TO_TICKS(100)）。 数据接收不完整或丢失 原因： 接收缓冲区过小，无法容纳单次接收的数据； uart_read_bytes() 超时过短，数据未完全接收； 波特率不匹配（发送端与接收端波特率必须一致）。 解决方案： 增大接收缓冲区（如 UART_BUFFER_SIZE * 2）； 延长 uart_read_bytes() 超时时间（如 50~100ms）； 确保发送端与 ESP32 UART 波特率、数据位、校验位完全一致。 UART0 与串口打印冲突 原因：ESP32 默认将 printf() 映射到 UART0（引脚 TX&#x3D;1，RX&#x3D;3），若使用 UART0 通信会导致打印乱码。 解决方案： 优先使用 UART1 或 UART2 作为通信端口； 若必须使用 UART0，需重新映射 printf() 到其他 UART（需修改 ESP-IDF 配置）。 WIFIESP32下WIFI组件三种模式 AP 模式：ESP32 自身作为接入点，其他设备（如手机、电脑）可连接 ESP32 创建的 WiFi 热点，适用于 “本地设备直连 ESP32” 场景（如配置 ESP32 参数）； AP+STA 混合模式：ESP32 同时作为接入点和客户端，既允许其他设备连接自身，又能接入外部路由器，适用于 “本地控制 + 远程联网” 复合场景（如智能家居设备）； STA 模式：仅作为客户端，专注于接入外部网络，是 ESP32 实现联网功能的最常用模式（如传感器数据上传云端、远程控制指令接收）。 STA模式核心工作原理ESP32 的 STA 模式连接 WiFi 的过程遵循 IEEE 802.11 协议，核心流程可分为 4 个阶段，各阶段依赖 ESP-IDF 提供的 WiFi 驱动接口实现： 初始化阶段： 初始化 WiFi 组件（调用esp_wifi_init()），配置 WiFi 工作模式为 STA（通过wifi_init_config_t结构体设置mode &#x3D; WIFI_MODE_STA）； 配置 TCP&#x2F;IP 协议栈（ESP-IDF 默认自动初始化，无需手动操作，支持 DHCP 自动获取 IP 或静态 IP 配置）。 配置连接参数阶段： 定义wifi_config_t结构体，填入目标 AP 的SSID（WiFi 名称） 和Password（WiFi 密码），确保参数与 AP 一致（区分 SSID 大小写，密码长度需符合 AP 要求，如 WPA2-PSK 密码通常为 8-63 位）； 通过esp_wifi_set_config(WIFI_IF_STA, &amp;wifi_config)将配置参数写入 ESP32 的 WiFi 接口。 启动与连接阶段： 启动 STA 接口（esp_wifi_start()），ESP32 开始扫描周围 WiFi 信号； 自动匹配目标 AP 的 SSID，发起连接请求，与 AP 进行认证（如 WPA2-PSK 认证） 和关联； 若认证通过，ESP32 通过 DHCP 向 AP 请求 IP 地址（默认开启 DHCP 客户端），获取到 IP、子网掩码、网关后，完成 “物理连接→网络层连接” 的全流程。 状态监测阶段： ESP32 通过事件回调机制（esp_event_loop_create_default()创建事件循环，esp_event_handler_instance_register()注册事件处理函数）反馈连接状态； 关键事件包括：WIFI_EVENT_STA_START（STA 接口启动成功）、WIFI_EVENT_STA_CONNECTED（与 AP 物理连接成功）、IP_EVENT_STA_GOT_IP（获取 IP 地址，联网完成）、WIFI_EVENT_STA_DISCONNECTED（与 AP 断开连接）。 实现步骤重写事件处理函数（核心）12345678910/** * @brief WiFi事件与IP事件处理回调函数（核心逻辑） * @param arg：用户自定义参数，本代码未使用，传入NULL即可 * @param event_base：事件基础类型，用于区分是WiFi相关事件（WIFI_EVENT）还是IP相关事件（IP_EVENT） * @param event_id：具体事件ID，标识当前触发的是该事件类型下的哪一种具体事件 * @param event_data：事件关联的数据指针，如IP事件中可获取分配的IP地址信息 * 功能：响应ESP32 WiFi模块的关键事件，更新连接状态、触发重连逻辑、通知外部状态变化 */static void event_handler(void *arg, esp_event_base_t event_base, int32_t event_id, void *event_data) 实现 STA 模式初始化函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154// 引入所需头文件：自定义WiFi管理模块头文件、ESP32 WiFi驱动库、事件处理库// 日志打印库、FreeRTOS实时操作系统任务调度库、标准输入输出库#include &quot;wifi_manager.h&quot;#include &quot;esp_wifi.h&quot;#include &quot;esp_event.h&quot;#include &quot;esp_log.h&quot;#include &quot;nvs_flash.h&quot;#include &quot;freertos/FreeRTOS.h&quot;#include &quot;freertos/task.h&quot;#include &lt;stdio.h&gt;#define WIFI_SSID &quot;2078&quot;#define WIFI_PASSWORD &quot;12345678&quot;// 静态全局变量：WiFi状态回调函数指针，用于将WiFi连接/断开状态通知给外部调用者// 外部需通过wifi_manager_init函数传入自定义回调，接收WIFI_STATE_CONNECTED/WIFI_STATE_DISCONNECTED状态static p_wifi_state_cb wifi_state_cb = NULL;// 宏定义：STA模式下最大重连次数，限制重连次数避免无限循环占用CPU资源#define MAX_CONNECT_RETRY 10// 宏定义：日志标签，串口打印时用于区分该模块的日志，方便调试定位#define TAG &quot;wifi_manager&quot;// 静态全局变量：记录STA模式当前的重连尝试次数，初始值为0，每次重连失败自增1static int sta_connect_cnt = 0; // 重连次数// 静态全局变量：标记STA模式是否已成功连接到目标AP，true表示已连接，false表示未连接/已断开static bool is_sta_connected = false;/** * @brief WiFi事件与IP事件处理回调函数（核心逻辑） * @param arg：用户自定义参数，本代码未使用，传入NULL即可 * @param event_base：事件基础类型，用于区分是WiFi相关事件（WIFI_EVENT）还是IP相关事件（IP_EVENT） * @param event_id：具体事件ID，标识当前触发的是该事件类型下的哪一种具体事件 * @param event_data：事件关联的数据指针，如IP事件中可获取分配的IP地址信息 * 功能：响应ESP32 WiFi模块的关键事件，更新连接状态、触发重连逻辑、通知外部状态变化 */static void event_handler(void *arg, esp_event_base_t event_base, int32_t event_id, void *event_data)&#123; // 判断事件类型为WiFi相关事件（WIFI_EVENT） if (event_base == WIFI_EVENT) &#123; // 根据具体事件ID处理不同场景 switch (event_id) &#123; // 事件：STA接口启动成功（调用esp_wifi_start()后触发此事件） case WIFI_EVENT_STA_START: // 启动成功后，主动调用esp_wifi_connect()发起WiFi连接请求 esp_wifi_connect(); break; // 事件：STA与已连接的AP断开连接（如信号弱、密码错误、路由器重启等） case WIFI_EVENT_STA_DISCONNECTED: // 若之前处于已连接状态，先更新连接状态并通知外部 if (is_sta_connected) &#123; is_sta_connected = false; // 将连接状态标记为未连接 if (wifi_state_cb) // 若外部注册了回调函数，触发&quot;断开连接&quot;状态通知 wifi_state_cb(WIFI_STATE_DISCONNECTED); &#125; // 检查当前重连次数是否小于最大重连次数，若未达到则继续重试 if (sta_connect_cnt &lt; MAX_CONNECT_RETRY) &#123; sta_connect_cnt++; // 重连次数自增1 esp_wifi_connect(); // 发起新一轮连接请求 &#125; // 若已达到最大重连次数，不再重试（避免无限重连） wifi_state_cb(WIFI_STATE_DISCONNECTED); break; // 其他未定义的WiFi事件，暂不处理，直接break default: break; &#125; &#125; // 判断事件类型为IP相关事件（IP_EVENT） else if (event_base == IP_EVENT) &#123; // 事件：STA成功从DHCP服务器获取到IP地址（标志网络层连接完成） if (event_id == IP_EVENT_STA_GOT_IP) &#123; // 打印日志提示已获取IP地址，便于调试确认 ESP_LOGI(TAG, &quot;Got IP address&quot;); sta_connect_cnt = 0; // 重置重连次数 is_sta_connected = true; // 将连接状态标记为已连接 if (wifi_state_cb) // 若外部注册了回调函数，触发&quot;连接成功&quot;状态通知 wifi_state_cb(WIFI_STATE_CONNECTED); &#125; &#125;&#125;/** * @brief WiFi管理器初始化函数（STA模式初始化入口） * @param f：外部传入的WiFi状态回调函数，用于接收连接/断开状态通知 * 功能：初始化ESP32网络接口、事件循环、WiFi驱动，配置STA模式并启动WiFi模块 * 注意：使用WiFi功能前必须先调用此函数完成初始化，建议在app_main()中优先执行 */void wifi_manager_init(p_wifi_state_cb f)&#123; // 1. 初始化NVS（ESP32存储WiFi配置的依赖组件，必须先初始化） esp_err_t ret = nvs_flash_init(); if (ret == ESP_ERR_NVS_NO_FREE_PAGES || ret == ESP_ERR_NVS_NEW_VERSION_FOUND) &#123; ESP_ERROR_CHECK(nvs_flash_erase()); // 若NVS有问题，先擦除再初始化 ret = nvs_flash_init(); &#125; // 2. 初始化ESP32网络接口（TCP/IP协议栈初始化，必须在WiFi初始化前执行） ESP_ERROR_CHECK(esp_netif_init()); // 3. 创建默认的事件循环（用于处理WiFi和IP事件） ESP_ERROR_CHECK(esp_event_loop_create_default()); esp_netif_create_default_wifi_sta(); // 使用默认的STA模式网络接口 // 4. 初始化WiFi驱动：使用WIFI_INIT_CONFIG_DEFAULT()获取默认配置（包含时钟、中断等参数） wifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT(); ESP_ERROR_CHECK(esp_wifi_init(&amp;cfg)); // 执行WiFi驱动初始化，若失败则触发错误检查 // 5. 注册事件处理函数：监听WiFi事件和IP事件 // 5.1注册WiFi事件监听器：监听所有WiFi事件（ESP_EVENT_ANY_ID），触发时调用event_handler处理 ESP_ERROR_CHECK(esp_event_handler_instance_register(WIFI_EVENT, ESP_EVENT_ANY_ID, &amp;event_handler, NULL, NULL)); // 5.2注册IP事件监听器：仅监听&quot;STA获取IP&quot;事件（IP_EVENT_STA_GOT_IP） ESP_ERROR_CHECK(esp_event_handler_instance_register(IP_EVENT, IP_EVENT_STA_GOT_IP, &amp;event_handler, NULL, NULL)); // 6. 保存外部传入的状态回调函数，后续状态变化时通过此函数通知外部 wifi_state_cb = f; wifi_config_t wifi_config = &#123; .sta = &#123; // 配置STA的认证模式为WPA2-PSK（主流家用/工业路由器默认加密方式） .threshold.authmode = WIFI_AUTH_WPA2_PSK, .ssid = WIFI_SSID, .password = WIFI_PASSWORD, &#125;, &#125;; // 7. 配置WiFi工作模式为纯STA模式（仅作为客户端连接外部AP，不开启AP模式） ESP_ERROR_CHECK(esp_wifi_set_mode(WIFI_MODE_STA)); ESP_ERROR_CHECK(esp_wifi_set_config(WIFI_IF_STA, &amp;wifi_config)); // 写入配置 // 8. 启动WiFi模块（启动后会触发WIFI_EVENT_STA_START事件，进而发起连接） ESP_ERROR_CHECK(esp_wifi_start()); ESP_LOGI(TAG, &quot;STA initialization done&quot;);&#125;","categories":[{"name":"MCU","slug":"MCU","permalink":"https://mextra.netlify.app/categories/MCU/"}],"tags":[{"name":"RTOS","slug":"RTOS","permalink":"https://mextra.netlify.app/tags/RTOS/"},{"name":"ESP32","slug":"ESP32","permalink":"https://mextra.netlify.app/tags/ESP32/"}]},{"title":"LVGL学习之旅（基于正点原子STM32F407探索者）","slug":"LVGL学习之旅","date":"2025-09-07T06:58:25.000Z","updated":"2025-09-17T04:12:11.178Z","comments":true,"path":"2025/09/07/LVGL学习之旅/","permalink":"https://mextra.netlify.app/2025/09/07/LVGL%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/","excerpt":"","text":"LVGL 基础 LVGL（Light and Versatile Graphics Library）轻量级通用型图形库，是一个免费的开源图形库，提供了创建嵌入式 GUI 所需的一切，具有易于使用的组件，美观的视觉效果和低内存占用等特点。支持触摸屏操作，移植简单方便，开发者一直在不断完善更新。 特点： 丰富且强大的模块化图形组件：按钮 (buttons)、图表 (charts)、列表 (lists)、滑动条 (sliders)、图片 (images) 等 高级的图形引擎：动画、抗锯齿、透明度、平滑滚动、图层混合等效果 不依赖特定的硬件平台，可以在任何显示屏上运行 配置可裁剪（最低资源占用：64 kB Flash，16 kB RAM） 基于UTF-8的多语种支持，例如中文、日文、韩文、阿拉伯文等 可以通过类CSS的方式来设计、布局图形界面（例如：Flexbox、Grid） 支持操作系统、外置内存、以及硬件加速（LVGL已内建支持STM32 DMA2D、NXP PXP和VGLite） 即便仅有单缓冲区(frame buffer)的情况下，也可保证渲染如丝般顺滑 全部由C编写完成，并支持C++调用 支持Micropython编程，参见：LVGL API in Micropython 支持模拟器仿真，可以无硬件依托进行开发 TFT-LCD配置——移植正点原子官方LCD例程点亮LCD——FSMC配置先根据原理图配置FSMC 详细FSMC参数配置 这里根据正点原子官方lcd_init 来设置 如下图 背光引脚配置 生成代码并将LCD、sys、delay文件夹添加到工程中 首先将HAL_SRAM_MspInit函数整个屏蔽 将lcd_init中有关fsmc部分屏蔽 屏蔽部分如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849void LCD_Init(void)&#123; // GPIO_InitTypeDef GPIO_Initure;// FSMC_NORSRAM_TimingTypeDef FSMC_ReadWriteTim;// FSMC_NORSRAM_TimingTypeDef FSMC_WriteTim;// // __HAL_RCC_GPIOB_CLK_ENABLE(); //开启GPIOB时钟// GPIO_Initure.Pin=GPIO_PIN_15; //PB15,背光控制// GPIO_Initure.Mode=GPIO_MODE_OUTPUT_PP; //推挽输出// GPIO_Initure.Pull=GPIO_PULLUP; //上拉// GPIO_Initure.Speed=GPIO_SPEED_HIGH; //高速// HAL_GPIO_Init(GPIOB,&amp;GPIO_Initure); // // TFTSRAM_Handler.Instance=FSMC_NORSRAM_DEVICE; // TFTSRAM_Handler.Extended=FSMC_NORSRAM_EXTENDED_DEVICE; // // TFTSRAM_Handler.Init.NSBank=FSMC_NORSRAM_BANK4; //使用NE4// TFTSRAM_Handler.Init.DataAddressMux=FSMC_DATA_ADDRESS_MUX_DISABLE; //地址/数据线不复用// TFTSRAM_Handler.Init.MemoryType=FSMC_MEMORY_TYPE_SRAM; //SRAM// TFTSRAM_Handler.Init.MemoryDataWidth=FSMC_NORSRAM_MEM_BUS_WIDTH_16; //16位数据宽度// TFTSRAM_Handler.Init.BurstAccessMode=FSMC_BURST_ACCESS_MODE_DISABLE; //是否使能突发访问,仅对同步突发存储器有效,此处未用到// TFTSRAM_Handler.Init.WaitSignalPolarity=FSMC_WAIT_SIGNAL_POLARITY_LOW;//等待信号的极性,仅在突发模式访问下有用// TFTSRAM_Handler.Init.WaitSignalActive=FSMC_WAIT_TIMING_BEFORE_WS; //存储器是在等待周期之前的一个时钟周期还是等待周期期间使能NWAIT// TFTSRAM_Handler.Init.WriteOperation=FSMC_WRITE_OPERATION_ENABLE; //存储器写使能// TFTSRAM_Handler.Init.WaitSignal=FSMC_WAIT_SIGNAL_DISABLE; //等待使能位,此处未用到// TFTSRAM_Handler.Init.ExtendedMode=FSMC_EXTENDED_MODE_ENABLE; //读写使用不同的时序// TFTSRAM_Handler.Init.AsynchronousWait=FSMC_ASYNCHRONOUS_WAIT_DISABLE;//是否使能同步传输模式下的等待信号,此处未用到// TFTSRAM_Handler.Init.WriteBurst=FSMC_WRITE_BURST_DISABLE; //禁止突发写// TFTSRAM_Handler.Init.ContinuousClock=FSMC_CONTINUOUS_CLOCK_SYNC_ASYNC;// // //FMC读时序控制寄存器// FSMC_ReadWriteTim.AddressSetupTime=0x0F; //地址建立时间（ADDSET）为16个HCLK 1/168M=6ns*16=96ns// FSMC_ReadWriteTim.AddressHoldTime=0;// FSMC_ReadWriteTim.DataSetupTime=60; //数据保存时间为60个HCLK =6*60=360ns// FSMC_ReadWriteTim.AccessMode=FSMC_ACCESS_MODE_A;//模式A// //FMC写时序控制寄存器// FSMC_WriteTim.BusTurnAroundDuration=0; //总线周转阶段持续时间为0，此变量不赋值的话会莫名其妙的自动修改为4。导致程序运行正常// FSMC_WriteTim.AddressSetupTime=9; //地址建立时间（ADDSET）为9个HCLK =54ns // FSMC_WriteTim.AddressHoldTime=0;// FSMC_WriteTim.DataSetupTime=8; //数据保存时间为6ns*9个HCLK=54n// FSMC_WriteTim.AccessMode=FSMC_ACCESS_MODE_A; //模式A// HAL_SRAM_Init(&amp;TFTSRAM_Handler,&amp;FSMC_ReadWriteTim,&amp;FSMC_WriteTim); // HAL_Delay(50); // delay 50 ms //尝试9341 ID的读取 LCD_WR_REG(0XD3); .........&#125; 注意有个坑！！！！ 正点原子官方的lcd_init函数中有个 printf(&quot; LCD ID:%x\\r\\n&quot;,lcddev.id);，所以在此之前需先进行串口重定向 替换官方的delay函数123456789101112131415void delay_us(u32 nus)&#123; uint32_t Delay = nus * 168 / 4; do &#123; __NOP(); &#125; while (Delay--);&#125;// 延时nms// nms:要延时的ms数void delay_ms(u16 nms)&#123; HAL_Delay(nms);&#125; 修改点亮背光函数 在lcd_init函数最后 将LCD_BL(1)替换为HAL_GPIO_WritePin(LCD_BL_GPIO_Port, LCD_BL_Pin, GPIO_PIN_SET); 触摸屏TOUCH移植将BSP文件夹下的24CXX、IIC与TOUCH文件夹添加到项目中 LVGL移植国内码云仓库：https://gitee.com/mirrors/lvgl 注意不要直接克隆 直接克隆下载的是最新的 可以选择右上角下载zip 就可以选中当前分支 裁剪LVGL源码根目录 仅保留 demos、examples、src文件夹以及两个.h文件 如下图 进入examples文件夹 删去除porting文件夹 更改lv_conf_template.h 将lv_conf_template.h更名为lv_conf.h 进入该文件 将里面的#if 0 改为#if 1 按以下结构创建文件夹123456Project----Middlewares--------LVGL------------GUI----------------lvgl------------GUI_APP 将裁剪后的LVGL库文件复制到Middlewares/LVGL/GUI/lvgl文件夹下 Keil配置创建如下管理 添加路径 注意一定要开启C99模式 可以屏蔽MDK警告 –diag_suppress&#x3D;68 –diag_suppress&#x3D;111 –diag_suppress&#x3D;188 –diag_suppress&#x3D;223 –diag_suppress&#x3D;546 –diag_suppress&#x3D;1295 添加文件到项目 LVGL文件修改配置LCD屏幕显示 包含输出设备驱动头文件 在lv_port_disp_template.c引入lcd.h 如#include &quot;../BSP/LCD/lcd.h&quot; 在disp_init函数中初始化123456static void disp_init(void)&#123; /*You code here*/ LCD_Init(); LCD_Display_Dir(1); // 横屏&#125; 配置图形数据缓冲方式 进入lv_port_disp_init函数 选择缓冲方式 另外两个将其屏蔽 修改disp_flush函数123456789101112131415161718192021static void disp_flush(lv_disp_drv_t *disp_drv, const lv_area_t *area, lv_color_t *color_p)&#123; /*The most simple case (but also the slowest) to put all pixels to the screen one-by-one*/ /*官方打点函数 */ // int32_t x; // int32_t y; // for (y = area-&gt;y1; y &lt;= area-&gt;y2; y++) // &#123; // for (x = area-&gt;x1; x &lt;= area-&gt;x2; x++) // &#123; // /*Put a pixel to the display. For example:*/ // /*put_px(x, y, *color_p)*/ // color_p++; // &#125; // &#125; LCD_Color_Fill(area-&gt;x1, area-&gt;y1, area-&gt;x2, area-&gt;y2, (uint16_t *)color_p); /*IMPORTANT!!! *Inform the graphics library that you are ready with the flushing*/ lv_disp_flush_ready(disp_drv);&#125; 配置输入（触摸） 按需裁剪输入设备 打开lv_port_indev_template.c 此处我们只需要触摸输入 所以把除了touchpad 其他都屏蔽或删去 注意：一定要把其他无关的屏蔽掉 否则会无法触摸 在touchpad_init函数中初始化触摸屏12345static void touchpad_init(void)&#123; /*Your code comes here*/ tp_dev.init();&#125; 修改touchpad_is_pressed函数12345678910static bool touchpad_is_pressed(void)&#123; /*Your code comes here*/ tp_dev.scan(0); // É¨ÃèÎïÀí×ø±ê if (tp_dev.sta &amp; TP_PRES_DOWN) &#123; return true; &#125; return false;&#125; 配置坐标获取函数1234567static void touchpad_get_xy(lv_coord_t *x, lv_coord_t *y)&#123; /*Your code comes here*/ (*x) = tp_dev.x[0]; (*y) = tp_dev.y[0];&#125; 提供时基 使用CubeMX生成一个定时1ms的定时器 在tim.c中引用#include &quot;lvgl.h&quot; 在定时器中断回调函数中lv_tick_inc(1); main函数部分 1234567891011121314151617#include &quot;lvgl.h&quot;#include &quot;lv_port_disp_template.h&quot;#include &quot;lv_port_indev_template.h&quot;....int main(void)&#123; ..... HAL_TIM_Base_Start_IT(&amp;htim3); // 启动定时器3中断 为lvgl提供时基 lv_init(); // 初始化LVGL lv_port_disp_init(); // 初始化显示接口 lv_port_indev_init(); // 初始化输入接口 while (1) &#123; lv_timer_handler(); // 处理LVGL任务 delay_ms(5); &#125;&#125;","categories":[{"name":"MCU","slug":"MCU","permalink":"https://mextra.netlify.app/categories/MCU/"}],"tags":[{"name":"LVGL v8.2","slug":"LVGL-v8-2","permalink":"https://mextra.netlify.app/tags/LVGL-v8-2/"},{"name":"RTOS","slug":"RTOS","permalink":"https://mextra.netlify.app/tags/RTOS/"},{"name":"嵌入式基础","slug":"嵌入式基础","permalink":"https://mextra.netlify.app/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%9F%BA%E7%A1%80/"}]},{"title":"freertos","slug":"freertos","date":"2025-09-05T07:48:39.000Z","updated":"2025-09-19T03:20:58.365Z","comments":true,"path":"2025/09/05/freertos/","permalink":"https://mextra.netlify.app/2025/09/05/freertos/","excerpt":"","text":"FreeRTOS基础获取系统时间123456TickType_t currentTicks;while(1)&#123; currentTicks = xTaskGetTickCount(); printf(&quot;[%lu]dev:%u,name:%s\\r\\n&quot;, currentTicks, data-&gt;dev, data-&gt;data);&#125; 堆和栈堆：一块空闲的内存 可以使用malloc申请内存 使用完后用free释放内存 堆也可以理解为就是定义了一个堆大小的数组 然后定义一个长度 每次动态改变长度来申请空间（链表） 在FreeRTOSConfig.h中就有定义堆大小的宏configTOTAL_HEAP_SIZE 他被引用到 heap.c中的 static uint8_t ucHeap[configTOTAL_HEAP_SIZE]; 栈：一块内存空间，CPU的SP寄存器指向它，它可以用于函数调用、局部变量、多任务系统里保存现场 栈是FreeRTOS中非常重要的概念，每个任务都有自己的栈 FreeRTOS源码概述目录结构 主要涉及3个目录： ra\\aws\\FreeRTOS\\FreeRTOS\\Source：存放的是FreeRTOS的核心文件 ra_gen：从main.c可以看到创建任务的函数调用过程 src：使用RASC创建任务时，在src目录下生成任务的入口函数 核心文件 FreeRTOS的最核心文件只有2个： FreeRTOS/Source/tasks.c FreeRTOS/Source/list.c 其他文件的作用也一起列表如下： FreeRTOS/Source/下的文件 作用 tasks.c 必需，任务操作 list.c 必须，列表 queue.c 基本必需，提供队列操作、信号量(semaphore)操作 timer.c 可选，software timer event_groups.c 可选，提供event group功能 头文件相关头文件目录 FreeRTOS需要3个头文件目录： FreeRTOS本身的头文件：ra\\aws\\FreeRTOS\\FreeRTOS\\Source\\include 移植时用到的头文件：ra\\fsp\\src\\rm_freertos_port\\portmacro.h 含有配置文件FreeRTOSConfig.h的目录：ra_cfg\\aws 头文件列表如下： 头文件 作用 FreeRTOSConfig.h FreeRTOS的配置文件，比如选择调度算法：configUSE_PREEMPTION 每个工程都必定含有FreeRTOSConfig.h FreeRTOS.h 使用FreeRTOS API函数时，必须包含此文件。 在FreeRTOS.h之后，再去包含其他头文件，比如： task.h、queue.h、semphr.h、event_group.h 独属于FreeRTOS的数据类型和编程规范数据类型每个移植的版本都含有自己的 portmacro.h 头文件，里面定义了2个数据类型： TickType_t： 时钟计数单位 （可以是uint16_t 也可以是uint32_t）当FreeRTOSConfig.h中定义configUSE_16_BIT_TICKS时 TickType_t则为uint16_t 对于32位架构，建议把TickType_t配置为uint32_t BaseType_t:这是该架构最高效的数据类型(取决于CPU是多少位的架构) BaseType_t通常用作简单的返回值的类型，还有逻辑值，比如 pdTRUE&#x2F;pdFALSE 变量名变量名的前缀 对应其类型 如：pcName (代表着他是一个指向char类型的指针p) 变量名前缀 含义 c char s int16_t，short l int32_t，long x BaseType_t， 其他非标准的类型：结构体、task handle、queue handle等 u unsigned p 指针 uc uint8_t，unsigned char pc char指针 函数名函数名的前缀有2部分：返回值类型、在哪个文件定义。 函数名前缀 含义 vTaskPrioritySet 返回值类型：void 在task.c中定义 xQueueReceive 返回值类型：BaseType_t 在queue.c中定义 pvTimerGetTimerID 返回值类型：pointer to void 在tmer.c中定义 宏的名宏的名字是大小，可以添加小写的前缀。前缀是用来表示：宏在哪个文件中定义。 宏的前缀 含义：在哪个文件里定义 port (比如portMAX_DELAY) portable.h或portmacro.h task (比如taskENTER_CRITICAL()) task.h pd (比如pdTRUE) projdefs.h config (比如configUSE_PREEMPTION) FreeRTOSConfig.h err (比如errQUEUE_FULL) projdefs.h 通用的宏定义如下： 宏 值 pdTRUE 1 pdFALSE 0 pdPASS 1 pdFAIL 0 内存管理 FreeRTOS中内存管理的接口函数为：pvPortMalloc 、vPortFree，对应于C库的malloc、free。 文件在FreeRTOS/Source/portable/MemMang下，它也是放在portable目录下，表示你可以提供自己的函数。 源码中默认提供了5个文件，对应内存管理的5种方法。 文件 优点 缺点 heap_1.c 分配简单，时间确定 只分配、不回收 heap_2.c 动态分配、最佳匹配 碎片、时间不定 heap_3.c 调用标准库函数 速度慢、时间不定 heap_4.c(常用) 相邻空闲内存可合并 可解决碎片问题、时间不定 heap_5.c 在heap_4基础上支持分隔的内存块 可解决碎片问题、时间不定 Heap相关的函数分配、释放内存函数原型： 12void * pvPortMalloc( size_t xWantedSize );void vPortFree( void * pv ); 作用：分配内存、释放内存。 如果分配内存不成功，则返回值为NULL。 检测剩余多少空闲内存函数原型： 1size_t xPortGetFreeHeapSize( void ); 当前还有多少空闲内存，这函数可以用来优化内存的使用情况。比如当所有内核对象都分配好后，执行此函数返回2000，那么configTOTAL_HEAP_SIZE就可减小2000。 注意：在heap_3中无法使用。 获取空闲内存容量的最小值函数原型： 1size_t xPortGetMinimumEverFreeHeapSize( void ); 返回：程序运行过程中，空闲内存容量的最小值。 注意：只有heap_4、heap_5支持此函数。 malloc失败的钩子函数在pvPortMalloc函数内部： 123456789101112131415void * pvPortMalloc( size_t xWantedSize )vPortDefineHeapRegions&#123; ...... #if ( configUSE_MALLOC_FAILED_HOOK == 1 ) &#123; if( pvReturn == NULL ) &#123; extern void vApplicationMallocFailedHook( void ); vApplicationMallocFailedHook(); &#125; &#125; #endif return pvReturn; &#125; 所以，如果想使用这个钩子函数： 在FreeRTOSConfig.h中，把configUSE_MALLOC_FAILED_HOOK定义为1 提供vApplicationMallocFailedHook函数 pvPortMalloc失败时，才会调用此函数 任务管理任务创建与删除什么是任务在FreeRTOS中，任务就是一个函数，原型如下： 1void ATaskFunction( void *pvParameters ); 要注意的是： 这个函数不能返回 同一个函数，可以用来创建多个任务；换句话说，多个任务可以运行同一个函数 函数内部，尽量使用局部变量： 每个任务都有自己的栈 每个任务运行这个函数时 任务A的局部变量放在任务A的栈里、任务B的局部变量放在任务B的栈里 不同任务的局部变量，有自己的副本 函数使用全局变量、静态变量的话 只有一个副本：多个任务使用的是同一个副本 要防止冲突(后续会讲) 下面是一个示例： 123456789101112131415161718void ATaskFunction( void *pvParameters )&#123; /* 对于不同的任务，局部变量放在任务的栈里，有各自的副本 */ int32_t lVariableExample = 0; /* 任务函数通常实现为一个无限循环 */ for( ;; ) &#123; /* 任务的代码 */ &#125; /* 如果程序从循环中退出，一定要使用vTaskDelete删除自己 * NULL表示删除的是自己 */ vTaskDelete( NULL ); /* 程序不会执行到这里, 如果执行到这里就出错了 */&#125; 创建任务创建任务时使用的函数如下： 123456BaseType_t xTaskCreate( TaskFunction_t pxTaskCode, // 函数指针, 任务函数 const char * const pcName, // 任务的名字 const configSTACK_DEPTH_TYPE usStackDepth, // 栈大小,单位为word,10表示40字节 void * const pvParameters, // 调用任务函数时传入的参数 UBaseType_t uxPriority, // 优先级 TaskHandle_t * const pxCreatedTask ); // 任务句柄, 以后使用它来操作这个任务 参数说明： 参数 描述 pvTaskCode 函数指针，任务对应的 C 函数。任务应该永远不退出，或者在退出时调用 “vTaskDelete(NULL)“。 pcName 任务的名称，仅用于调试目的，FreeRTOS 内部不使用。pcName 的长度为 configMAX_TASK_NAME_LEN。 usStackDepth 每个任务都有自己的栈，usStackDepth 指定了栈的大小，单位为 word。例如，如果传入 100，表示栈的大小为 100 word，即 400 字节。最大值为 uint16_t 的最大值。确定栈的大小并不容易，通常是根据估计来设定。精确的办法是查看反汇编代码。 pvParameters 调用 pvTaskCode 函数指针时使用的参数：pvTaskCode(pvParameters)。 uxPriority 任务的优先级范围为 0~(configMAX_PRIORITIES – 1)。数值越小，优先级越低。如果传入的值过大，xTaskCreate 会将其调整为 (configMAX_PRIORITIES – 1)。 pxCreatedTask 用于保存 xTaskCreate 的输出结果，即任务的句柄（task handle）。如果以后需要对该任务进行操作，如修改优先级，则需要使用此句柄。如果不需要使用该句柄，可以传入 NULL。 返回值 成功时返回 pdPASS，失败时返回 errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY（失败原因是内存不足）。请注意，文档中提到的失败返回值是 pdFAIL 是不正确的。pdFAIL 的值为 0，而 errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY 的值为 -1。 使用静态分配内存的函数如下： 123456789TaskHandle_t xTaskCreateStatic ( TaskFunction_t pxTaskCode, // 函数指针, 任务函数 const char * const pcName, // 任务的名字 const uint32_t ulStackDepth, // 栈大小,单位为word,10表示40字节 void * const pvParameters, // 调用任务函数时传入的参数 UBaseType_t uxPriority, // 优先级 StackType_t * const puxStackBuffer, // 静态分配的栈，就是一个buffer StaticTask_t * const pxTaskBuffer // 静态分配的任务结构体的指针，用它来操作这个任务); 相比于使用动态分配内存创建任务的函数，最后2个参数不一样： 参数 描述 pvTaskCode 函数指针，可以简单地认为任务就是一个C函数。 它稍微特殊一点：永远不退出，或者退出时要调用”vTaskDelete(NULL)“ pcName 任务的名字，FreeRTOS内部不使用它，仅仅起调试作用。 长度为：configMAX_TASK_NAME_LEN usStackDepth 每个任务都有自己的栈，这里指定栈大小。 单位是word，比如传入100，表示栈大小为100 word，也就是400字节。 最大值为uint16_t的最大值。 怎么确定栈的大小，并不容易，很多时候是估计。 精确的办法是看反汇编码。 pvParameters 调用pvTaskCode函数指针时用到：pvTaskCode(pvParameters) uxPriority 优先级范围：0~(configMAX_PRIORITIES – 1) 数值越小优先级越低， 如果传入过大的值，xTaskCreate会把它调整为(configMAX_PRIORITIES – 1) puxStackBuffer 静态分配的栈内存，比如可以传入一个数组， 它的大小是usStackDepth*4。 pxTaskBuffer 静态分配的StaticTask_t结构体的指针 返回值 成功：返回任务句柄； 失败：NULL 任务栈大小估算任务栈空间包含 返回地址LR与其他寄存器：可以理解为函数调用深度 局部变量：如char buff[1000] 直接看类型 此处则可以算1个 保留现场：可以理解为固定16个寄存器 即16 * 4 &#x3D; 64b 公式如下： （n层调用 * 36） + 局部变量 + 64b 例如： 使用任务参数我们说过，多个任务可以使用同一个函数，怎么体现它们的差别？ 栈不同 创建任务时可以传入不同的参数 我们创建2个任务，使用同一个函数，但是在LCD上打印不一样的信息。 123456789101112131415161718192021typedef struct&#123; int x; int y; const char *str;&#125;DisplayInfo;void vTaskFunction( void *pvParameters )&#123; DisplayInfo *info = pvParameters; uint32_t cnt = 0;uint32_t len; /* 任务函数的主体一般都是无限循环 */ for( ;; ) &#123; /* 打印任务的信息 */ len = LCD_PrintString(info-&gt;x, info-&gt;y, info-&gt;str); LCD_PrintSignedVal(len+1, info-&gt;y, cnt++); mdelay(500); &#125;&#125; 上述代码中的info来自参数pvParameters，pvParameters来自哪里？创建任务时传入的。 代码如下： 使用xTaskCreate创建任务时，第4个参数就是pvParameters 不同的任务，pvParameters不一样 12345678DisplayInfo g_Task1Info =&#123;0,0,&quot;task1&quot;&#125;;DisplayInfo g_Task2Info =&#123;3,0,&quot;task2&quot;&#125;;DisplayInfo g_Task3Info =&#123;6,0,&quot;task3&quot;&#125;;/* 使用同一个函数创建不同的任务 */ xTaskCreate(LcdPrintTask, &quot;task1&quot;, 128, &amp;g_Task1Info, osPriorityNormal, NULL); xTaskCreate(LcdPrintTask, &quot;task2&quot;, 128, &amp;g_Task2Info, osPriorityNormal, NULL); xTaskCreate(LcdPrintTask, &quot;task3&quot;, 128, &amp;g_Task3Info, osPriorityNormal, NULL); 任务的删除删除任务时使用的函数如下： 1void vTaskDelete( TaskHandle_t xTaskToDelete ); 参数说明： 参数 描述 pvTaskCode 任务句柄，使用xTaskCreate创建任务时可以得到一个句柄。 也可传入NULL，这表示删除自己。 怎么删除任务？举个不好的例子： 自杀：vTaskDelete(NULL) 被杀：别的任务执行vTaskDelete(pvTaskCode)，pvTaskCode是自己的句柄 杀人：执行vTaskDelete(pvTaskCode)，pvTaskCode是别的任务的句柄 任务管理与调度机制调度机制 同等优先级的任务 轮流运行 最高优先级的任务先运行 高优先级的任务未运行完，低优先级任务无法运行 一旦高优先级任务就绪 马上运行 最高优先级的任务有多个 他们轮流运行 任务管理任务的切换通过链表操作进行切换 RTOS会创建3个链表 分别是就绪链表ReadyList、阻塞链表DelayTaskList、挂起链表 先在优先级数组中按下标从大到小遍历，使用任务创建函数本质其实是在对应优先级数组中创建TCB结构体，并且会有一个全局指针——当前执行TCB结构体pxCurrentTCB，这就说明了为什么同等优先级下，最后创建的任务先运行（因为指针最终指向了最后一个任务链表，启动调度器后，开始运行） 当调用vTaskDelay后会将当前任务链表丢到阻塞链表上，并根据vTaskDelay的参数等待Tick中断判断到达时间后，该任务链表才能再次回到原先链表上 当任务调用vTaskSuspend后 当前任务会被丢到挂起链表，此任务只有调用vTaskResume才能回到原先链表，不能通过Tick中断回归 Tick中断是什么？他又做些什么？ Tick中断来源于 Tick中断做什么？ 有个计数器count，count一直执行++ 判断DelayTaskList里任务是否可以恢复（可恢复则将其丢到ReadyList） 发起调度（遍历优先级数组，改变pxCurrentTCB指针指向） 空闲任务空闲任务是Freertos启动调度器时 会自动创建的一个最低优先级的任务prvIdleTask 负责清理用户的自杀任务 如vTaskDelete(NULL)的内存释放 由于优先级最低 所以当用户任务不释放CPU时，就会导致空闲任务不会运行，因而vTaskDelete(NULL)得不到释放 因此尽量不要使用死延时，改用vTaskDelay释放CPU 或者不使用自杀函数vTaskDelete(NULL) 此外 空闲任务中还有提供钩子函数 可以方便我们在里面打印调试信息 注意每个任务都要使用while(1)进行死循环 如果有一个任务没有则会触发任务退出错误中断prvTaskExitError 同步与互斥同步与互斥的概念一句话理解同步与互斥：我等你用完厕所，我再用厕所。 什么叫同步？就是：哎哎哎，我正在用厕所，你等会。 什么叫互斥？就是：哎哎哎，我正在用厕所，你不能进来。 同步与互斥经常放在一起讲，是因为它们之的关系很大，“互斥”操作可以使用“同步”来实现。我“等”你用完厕所，我再用厕所。这不就是用“同步”来实现“互斥”吗？ 再举一个例子。在团队活动里，同事A先写完报表，经理B才能拿去向领导汇报。经理B必须等同事A完成报表，AB之间有依赖，B必须放慢脚步，被称为同步。在团队活动中，同事A已经使用会议室了，经理B也想使用，即使经理B是领导，他也得等着，这就叫互斥。经理B跟同事A说：你用完会议室就提醒我。这就是使用”同步”来实现”互斥”。 有时候看代码更容易理解，伪代码如下： 123456void 抢厕所(void)&#123; if (有人在用) 我眯一会; 用厕所; 喂，醒醒，有人要用厕所吗;&#125; 假设有A、B两人早起抢厕所，A先行一步占用了；B慢了一步，于是就眯一会；当A用完后叫醒B，B也就愉快地上厕所了。 在这个过程中，A、B是互斥地访问“厕所”，“厕所”被称之为临界资源。我们使用了“休眠-唤醒”的同步机制实现了“临界资源”的“互斥访问”。 同一时间只能有一个人使用的资源，被称为临界资源。比如任务A、B都要使用串口来打印，串口就是临界资源。如果A、B同时使用串口，那么打印出来的信息就是A、B混杂，无法分辨。所以使用串口时，应该是这样：A用完，B再用；B用完，A再用 各类方法的对比能实现同步、互斥的内核方法有：任务通知(task notification)、队列(queue)、事件组(event group)、信号量(semaphoe)、互斥量(mutex)。 它们都有类似的操作方法：获取&#x2F;释放、阻塞&#x2F;唤醒、超时。比如： 任务A获取资源，用完后任务A释放资源 任务A获取不到资源则阻塞，任务B释放资源并把任务A唤醒 任务A获取不到资源则阻塞，并定个闹钟；A要么超时返回，要么在这段时间内因为任务B释放资源而被唤醒。 这些内核对象五花八门，记不住怎么办？我也记不住，通过对比的方法来区分它们。 能否传信息？还是只能传递状态？ 为众生（所有任务都可以使用）？只为你（只能指定任务使用）？ 我生产，你们消费？ 我上锁，只能由我开锁 内核对象 生产者 消费者 数据&#x2F;状态 说明 队列 ALL ALL 数据：若干个数据 谁都可以往队列里扔数据， 谁都可以从队列里读数据 用来传递数据， 发送者、接收者无限制， 一个数据只能唤醒一个接收者 事件组 ALL ALL 多个位：或、与 谁都可以设置(生产)多个位， 谁都可以等待某个位、若干个位 用来传递事件， 可以是N个事件， 发送者、接受者无限制， 可以唤醒多个接收者：像广播 信号量 ALL ALL 数量：0~n 谁都可以增加一个数量， 谁都可消耗一个数量 用来维持资源的个数， 生产者、消费者无限制， 1个资源只能唤醒1个接收者 任务通知 ALL 只有我 数据、状态都可以传输， 使用任务通知时， 必须指定接受者 N对1的关系： 发送者无限制， 接收者只能是这个任务 互斥量 只能A开锁 A上锁 位：0、1 我上锁：1变为0， 只能由我开锁：0变为1 就像一个空厕所， 谁使用谁上锁， 也只能由他开锁 使用图形对比如下： 队列： 里面可以放任意数据，可以放多个数据 任务、ISR都可以放入数据；任务、ISR都可以从中读出数据 事件组： 一个事件用一bit表示，1表示事件发生了，0表示事件没发生 可以用来表示事件、事件的组合发生了，不能传递数据 有广播效果：事件或事件的组合发生了，等待它的多个任务都会被唤醒 信号量： 核心是”计数值” 任务、ISR释放信号量时让计数值加1 任务、ISR获得信号量时，让计数值减1 任务通知： 核心是任务的TCB里的数值 会被覆盖 发通知给谁？必须指定接收任务 只能由接收任务本身获取该通知 互斥量： 数值只有0或1 谁获得互斥量，就必须由谁释放同一个互斥量 为何要引用这些机制呢？ 原本逻辑可以采用全局变量来进行传递信息，但在RTOS下，可能还未来得及改变全局变量的值就被切换到其他任务，这样就会发生全局变量未及时更新的问题 引入事件阻塞与唤醒大大提高了CPU的利用率 当任务A计数1s，任务B负责打印任务A的最终计数值，就不会出现A运行，B也运行，而是等待A运行完后通知任务B，或大概估算任务A结束的时间，让B阻塞这么多的时间，这样就实现了整个时间轴都是任务A在运行 队列队列的本质队列中，数据的读写就是环形缓冲区，在这个基础上增加了互斥措施、阻塞-唤醒机制 如果这个队列不传输数据，只调整“数据个数”，他就是信号量（semaphore） 如果信号量中，限定“数据个数”最大值为1，他就是互斥量（mutex） 传输数据的两种方法使用队列传输数据时有两种方法： 拷贝：把数据、把变量的值复制进队列里 引用：把数据、把变量的地址复制进队列里 FreeRTOS使用拷贝值的方法，这更简单： 局部变量的值可以发送到队列中，后续即使函数退出、局部变量被回收，也不会影响队列中的数据 无需分配buffer来保存数据，队列中有buffer 局部变量可以马上再次使用 发送任务、接收任务解耦：接收任务不需要知道这数据是谁的、也不需要发送任务来释放数据 如果数据实在太大，你还是可以使用队列传输它的地址 队列的空间有FreeRTOS内核分配，无需任务操心 对于有内存保护功能的系统，如果队列使用引用方法，也就是使用地址，必须确保双方任务对这个地址都有访问权限。使用拷贝方法时，则无此限制：内核有足够的权限，把数据复制进队列、再把数据复制出队列。 队列的阻塞访问只要知道队列的句柄，谁都可以读、写该队列。任务、ISR都可读、写队列。可以多个任务读写队列。 任务读写队列时，简单地说：如果读写不成功，则阻塞；可以指定超时时间。口语化地说，就是可以定个闹钟：如果能读写了就马上进入就绪态，否则就阻塞直到超时。 某个任务读队列时，如果队列没有数据，则该任务可以进入阻塞状态：还可以指定阻塞的时间。如果队列有数据了，则该阻塞的任务会变为就绪态。如果一直都没有数据，则时间到之后它也会进入就绪态。 既然读取队列的任务个数没有限制，那么当多个任务读取空队列时，这些任务都会进入阻塞状态：有多个任务在等待同一个队列的数据。当队列中有数据时，哪个任务会进入就绪态？ 优先级最高的任务 如果大家的优先级相同，那等待时间最久的任务会进入就绪态 跟读队列类似，一个任务要写队列时，如果队列满了，该任务也可以进入阻塞状态：还可以指定阻塞的时间。如果队列有空间了，则该阻塞的任务会变为就绪态。如果一直都没有空间，则时间到之后它也会进入就绪态。 既然写队列的任务个数没有限制，那么当多个任务写”满队列”时，这些任务都会进入阻塞状态：有多个任务在等待同一个队列的空间。当队列中有空间时，哪个任务会进入就绪态？ 优先级最高的任务 如果大家的优先级相同，那等待时间最久的任务会进入就绪态 队列函数创建队列的创建有两种方法：动态分配内存、静态分配内存， 动态分配内存：xQueueCreate，队列的内存在函数内部动态分配 函数原型如下： 1QueueHandle_t xQueueCreate( UBaseType_t uxQueueLength, UBaseType_t uxItemSize ); 参数 说明 uxQueueLength 队列长度，最多能存放多少个数据(item) uxItemSize 每个数据(item)的大小：以字节为单位（可以定义一个结构体存放，然后sizeof(结构体)） 返回值 非0：成功，返回句柄，以后使用句柄来操作队列 NULL：失败，因为内存不足 静态分配内存：xQueueCreateStatic，队列的内存要事先分配好 函数原型如下： 123456QueueHandle_t xQueueCreateStatic(* UBaseType_t uxQueueLength,* UBaseType_t uxItemSize,* uint8_t *pucQueueStorageBuffer,* StaticQueue_t *pxQueueBuffer* ); 参数 说明 uxQueueLength 队列长度，最多能存放多少个数据(item) uxItemSize 每个数据(item)的大小：以字节为单位 pucQueueStorageBuffer 如果uxItemSize非0，pucQueueStorageBuffer必须指向一个uint8_t数组， 此数组大小至少为”uxQueueLength * uxItemSize” pxQueueBuffer 必须执行一个StaticQueue_t结构体，用来保存队列的数据结构 返回值 非0：成功，返回句柄，以后使用句柄来操作队列 NULL：失败，因为pxQueueBuffer为NULL 复位队列刚被创建时，里面没有数据；使用过程中可以调用 xQueueReset() 把队列恢复为初始状态，此函数原型为： 1234/* pxQueue : 复位哪个队列; * 返回值: pdPASS(必定成功)*/BaseType_t xQueueReset( QueueHandle_t pxQueue); 删除删除队列的函数为 vQueueDelete() ，只能删除使用动态方法创建的队列，它会释放内存。原型如下： 1void vQueueDelete( QueueHandle_t xQueue ); 写队列可以把数据写到队列头部，也可以写到尾部，这些函数有两个版本：在任务中使用、在ISR中使用。函数原型如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445/* 等同于xQueueSendToBack * 往队列尾部写入数据，如果没有空间，阻塞时间为xTicksToWait */BaseType_t xQueueSend( QueueHandle_t xQueue, const void *pvItemToQueue, TickType_t xTicksToWait );/* * 往队列尾部写入数据，如果没有空间，阻塞时间为xTicksToWait */BaseType_t xQueueSendToBack( QueueHandle_t xQueue, const void *pvItemToQueue, TickType_t xTicksToWait );/* * 往队列尾部写入数据，此函数可以在中断函数中使用，不可阻塞 */BaseType_t xQueueSendToBackFromISR( QueueHandle_t xQueue, const void *pvItemToQueue, BaseType_t *pxHigherPriorityTaskWoken );/* * 往队列头部写入数据，如果没有空间，阻塞时间为xTicksToWait */BaseType_t xQueueSendToFront( QueueHandle_t xQueue, const void *pvItemToQueue, TickType_t xTicksToWait );/* * 往队列头部写入数据，此函数可以在中断函数中使用，不可阻塞 */BaseType_t xQueueSendFromISR( QueueHandle_t xQueue, const void *pvItemToQueue, BaseType_t *pxHigherPriorityTaskWoken ); 这些函数用到的参数是类似的，统一说明如下： 参数 说明 xQueue 队列句柄，要写哪个队列 pvItemToQueue 数据指针，这个数据的值会被复制进队列， 复制多大的数据？在创建队列时已经指定了数据大小 xTicksToWait 如果队列满则无法写入新数据，可以让任务进入阻塞状态， xTicksToWait表示阻塞的最大时间(Tick Count)。 如果被设为0，无法写入数据时函数会立刻返回； 如果被设为portMAX_DELAY，则会一直阻塞直到有空间可写 返回值 pdPASS：数据成功写入了队列 errQUEUE_FULL：写入失败，因为队列满了。 读队列使用 xQueueReceive() 函数读队列，读到一个数据后，队列中该数据会被移除。这个函数有两个版本：在任务中使用、在ISR中使用。函数原型如下： 123456789BaseType_t xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait );BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void *pvBuffer, BaseType_t *pxTaskWoken ); 参数说明如下： 参数 说明 xQueue 队列句柄，要读哪个队列 pvBuffer buffer指针，队列的数据会被复制到这个buffer 复制多大的数据？在创建队列时已经指定了数据大小 xTicksToWait 果队列空则无法读出数据，可以让任务进入阻塞状态， xTicksToWait表示阻塞的最大时间(Tick Count)。 如果被设为0，无法读出数据时函数会立刻返回； 如果被设为portMAX_DELAY，则会一直阻塞直到有数据可写 返回值 pdPASS：从队列读出数据入 errQUEUE_EMPTY：读取失败，因为队列空了。 查询可以查询队列中有多少个数据、有多少空余空间。函数原型如下： 123456789/* * 返回队列中可用数据的个数 */UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue );/* * 返回队列中可用空间的个数 */UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue ); 覆盖&#x2F;偷看当队列长度为1时，可以使用 xQueueOverwrite() 或 xQueueOverwriteFromISR() 来覆盖数据。 注意，队列长度必须为1。当队列满时，这些函数会覆盖里面的数据，这也以为着这些函数不会被阻塞。 函数原型如下： 123456789101112131415/* 覆盖队列 * xQueue: 写哪个队列 * pvItemToQueue: 数据地址 * 返回值: pdTRUE表示成功, pdFALSE表示失败 */BaseType_t xQueueOverwrite( QueueHandle_t xQueue, const void * pvItemToQueue );BaseType_t xQueueOverwriteFromISR( QueueHandle_t xQueue, const void * pvItemToQueue, BaseType_t *pxHigherPriorityTaskWoken ); 如果想让队列中的数据供多方读取，也就是说读取时不要移除数据，要留给后来人。那么可以使用”窥视”，也就是**xQueuePeek()**或**xQueuePeekFromISR()**。这些函数会从队列中复制出数据，但是不移除数据。这也意味着，如果队列中没有数据，那么”偷看”时会导致阻塞；一旦队列中有数据，以后每次”偷看”都会成功。 函数原型如下： 12345678910111213141516/* 偷看队列 * xQueue: 偷看哪个队列 * pvItemToQueue: 数据地址, 用来保存复制出来的数据 * xTicksToWait: 没有数据的话阻塞一会 * 返回值: pdTRUE表示成功, pdFALSE表示失败 */BaseType_t xQueuePeek( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait );BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue, void *pvBuffer, ); 使用队列时注意 写队列与读队列 所传入的buffer一定要严格按照初始创建时的类型，否则就会出现死机 情况一：创建时类型为指针（常用，可以接收多种类型） 123456789101112131415typedef struct&#123; uint8_t data[128]; uint8_t index;&#125;Uart_RxTypeDef;Uart_RxTypeDef UartRx = &#123;&#123;0&#125;,0&#125;;void task(void *arg)&#123; Uart_RxTypeDef *data = &amp;UartRx; debug_TX_QueueHandle = osMessageQueueNew(5, sizeof(void *), &amp;debug_TX_Queue_attributes); xQueueSend(debug_TX_QueueHandle,&amp;data,NULL);//此处一定要&amp;data 因为创建队列的时候是指针 直接写data 相当于&amp;UartRx 他并不是一个指针&#125; 情况二：创建时类型为数据 1234567891011121314typedef struct&#123; uint8_t data[128]; uint8_t index;&#125;Uart_RxTypeDef;Uart_RxTypeDef UartRx = &#123;&#123;0&#125;,0&#125;;void task(void *arg)&#123; Uart_RxTypeDef data = &#123;&#123;0&#125;,0&#125;; debug_TX_QueueHandle = osMessageQueueNew(5, sizeof(Uart_RxTypeDef), &amp;debug_TX_Queue_attributes); xQueueSend(debug_TX_QueueHandle,&amp;data,NULL);//此处的&amp;data与情况一不一样 这个是参数要求要地址 所以需要将结构体的地址赋值过去&#125; 队列集 当多个队列需要上报到同一个处理任务时，队列集可以实现统合多个队列，再往上传递到同一个任务 创建队列集 注意要使用队列集 需要先在Core/inc/FreeRTOSConfig.h 定义 1#define configUSE_QUEUE_SETS 1 函数原型如下： 1QueueSetHandle_t xQueueCreateSet( const UBaseType_t uxEventQueueLength ) 参数 说明 uxQueueLength 队列集长度，最多能存放多少个数据(队列句柄) 返回值 非0：成功，返回句柄，以后使用句柄来操作队列NULL：失败，因为内存不足 把队列加入队列集函数原型如下： 12345BaseType_t xQueueAddToSet( QueueSetMemberHandle_t xQueueOrSemaphore, QueueSetHandle_t xQueueSet ); 参数 说明 xQueueOrSemaphore 队列句柄，这个队列要加入队列集 xQueueSet 队列集句柄 返回值 pdTRUE：成功pdFALSE：失败 读取队列集函数原型如下： 123QueueSetMemberHandle_t xQueueSelectFromSet( QueueSetHandle_t xQueueSet, TickType_t const xTicksToWait ); 参数 说明 xQueueSet 队列集句柄 xTicksToWait 如果队列集空则无法读出数据，可以让任务进入阻塞状态，xTicksToWait表示阻塞的最大时间(Tick Count)。如果被设为0，无法读出数据时函数会立刻返回；如果被设为portMAX_DELAY，则会一直阻塞直到有数据可写 返回值 NULL：失败，队列句柄：成功 信号量前面介绍的队列(queue)可以用于传输数据：在任务之间、任务和中断之间。 消息队列用于传输多个数据，但是有时候我们只需要传递状态，这个状态值需要用一个数值表示，比如： 卖家：做好了1个包子！做好了2个包子！做好了3个包子！ 买家：买了1个包子，包子数量减1 这个停车位我占了，停车位减1 我开车走了，停车位加1 在这种情况下我们只需要维护一个数值，使用信号量效率更高、更节省内存 本章涉及如下内容： 怎么创建、删除信号量 怎么发送、获得信号量 什么是计数型信号量？什么是二进制信号量？ 信号量的特性信号量的常规操作信号量这个名字很恰当： 信号：起通知作用 量：还可以用来表示资源的数量 当”量”没有限制时，它就是”计数型信号量”(Counting Semaphores) 当”量”只有0、1两个取值时，它就是”二进制信号量”(Binary Semaphores) 支持的动作：”give”给出资源，计数值加1；”take”获得资源，计数值减1 计数型信号量的典型场景是： 计数：事件产生时”give”信号量，让计数值加1；处理事件时要先”take”信号量，就是获得信号量，让计数值减1。 资源管理：要想访问资源需要先”take”信号量，让计数值减1；用完资源后”give”信号量，让计数值加1。 信号量的”give”、”take”双方并不需要相同，可以用于生产者-消费者场合： 生产者为任务A、B，消费者为任务C、D 一开始信号量的计数值为0，如果任务C、D想获得信号量，会有两种结果： 阻塞：买不到东西咱就等等吧，可以定个闹钟(超时时间) 即刻返回失败：不等 任务A、B可以生产资源，就是让信号量的计数值增加1，并且把等待这个资源的顾客唤醒 唤醒谁？谁优先级高就唤醒谁，如果大家优先级一样就唤醒等待时间最长的人 二进制信号量跟计数型的唯一差别，就是计数值的最大值被限定为1。 信号量跟队列的对比差异列表如下： 队列 信号量 可以容纳多个数据， 创建队列时有2部分内存: 队列结构体、存储数据的空间 只有计数值，无法容纳其他数据。 创建信号量时，只需要分配信号量结构体 生产者：没有空间存入数据时可以阻塞 生产者：用于不阻塞，计数值已经达到最大时返回失败 消费者：没有数据时可以阻塞 消费者：没有资源时可以阻塞 两种信号量的对比信号量的计数值都有限制：限定了最大值。如果最大值被限定为1，那么它就是二进制信号量；如果最大值不是1，它就是计数型信号量。 差别列表如下： 二进制信号量 计数型信号量 被创建时初始值为0 被创建时初始值可以设定 其他操作是一样的 其他操作是一样的 信号量函数使用信号量时，先创建、然后去添加资源、获得资源。使用句柄来表示一个信号量。 创建使用信号量之前，要先创建，得到一个句柄；使用信号量时，要使用句柄来表明使用哪个信号量。 对于二进制信号量、计数型信号量，它们的创建函数不一样： 二进制信号量 计数型信号量 动态创建 xSemaphoreCreateBinary 计数值初始值为0 xSemaphoreCreateCounting vSemaphoreCreateBinary(过时了) 计数值初始值为1 静态创建 xSemaphoreCreateBinaryStatic xSemaphoreCreateCountingStatic 创建二进制信号量的函数原型如下： 1234567891011/* 创建一个二进制信号量，返回它的句柄。 * 此函数内部会分配信号量结构体 * 返回值: 返回句柄，非NULL表示成功 */SemaphoreHandle_t xSemaphoreCreateBinary( void );/* 创建一个二进制信号量，返回它的句柄。 * 此函数无需动态分配内存，所以需要先有一个StaticSemaphore_t结构体，并传入它的指针 * 返回值: 返回句柄，非NULL表示成功 */SemaphoreHandle_t xSemaphoreCreateBinaryStatic( StaticSemaphore_t *pxSemaphoreBuffer ); 创建计数型信号量的函数原型如下： 123456789101112131415161718/* 创建一个计数型信号量，返回它的句柄。 * 此函数内部会分配信号量结构体 * uxMaxCount: 最大计数值 * uxInitialCount: 初始计数值 * 返回值: 返回句柄，非NULL表示成功 */SemaphoreHandle_t xSemaphoreCreateCounting(UBaseType_t uxMaxCount, UBaseType_t uxInitialCount);/* 创建一个计数型信号量，返回它的句柄。 * 此函数无需动态分配内存，所以需要先有一个StaticSemaphore_t结构体，并传入它的指针 * uxMaxCount: 最大计数值 * uxInitialCount: 初始计数值 * pxSemaphoreBuffer: StaticSemaphore_t结构体指针 * 返回值: 返回句柄，非NULL表示成功 */SemaphoreHandle_t xSemaphoreCreateCountingStatic( UBaseType_t uxMaxCount, UBaseType_t uxInitialCount, StaticSemaphore_t *pxSemaphoreBuffer ); 删除对于动态创建的信号量，不再需要它们时，可以删除它们以回收内存。 vSemaphoreDelete可以用来删除二进制信号量、计数型信号量，函数原型如下： 1234/* * xSemaphore: 信号量句柄，你要删除哪个信号量 */void vSemaphoreDelete( SemaphoreHandle_t xSemaphore ); 释放&#x2F;获取信号量二进制信号量、计数型信号量的give、take操作函数是一样的。这些函数也分为2个版本：给任务使用，给ISR使用。列表如下： 在任务中使用 在ISR中使用 give xSemaphoreGive xSemaphoreGiveFromISR take xSemaphoreTake xSemaphoreTakeFromISR xSemaphoreGive的函数原型如下： 1BaseType_t xSemaphoreGive( SemaphoreHandle_t xSemaphore ); xSemaphoreGive函数的参数与返回值列表如下： 参数 说明 xSemaphore 信号量句柄，释放哪个信号量 返回值 pdTRUE表示成功, 如果二进制信号量的计数值已经是1，再次调用此函数则返回失败； 如果计数型信号量的计数值已经是最大值，再次调用此函数则返回失败 pxHigherPriorityTaskWoken的函数原型如下： 1234BaseType_t xSemaphoreGiveFromISR( SemaphoreHandle_t xSemaphore, BaseType_t *pxHigherPriorityTaskWoken ); xSemaphoreGiveFromISR函数的参数与返回值列表如下： 参数 说明 xSemaphore 信号量句柄，释放哪个信号量 pxHigherPriorityTaskWoken 如果释放信号量导致更高优先级的任务变为了就绪态， 则*pxHigherPriorityTaskWoken &#x3D; pdTRUE 返回值 pdTRUE表示成功, 如果二进制信号量的计数值已经是1，再次调用此函数则返回失败； 如果计数型信号量的计数值已经是最大值，再次调用此函数则返回失败 xSemaphoreTake的函数原型如下： 1234BaseType_t xSemaphoreTake( SemaphoreHandle_t xSemaphore, TickType_t xTicksToWait ); xSemaphoreTake函数的参数与返回值列表如下： 参数 说明 xSemaphore 信号量句柄，获取哪个信号量 xTicksToWait 如果无法马上获得信号量，阻塞一会： 0：不阻塞，马上返回 portMAX_DELAY: 一直阻塞直到成功 其他值: 阻塞的Tick个数，可以使用*pdMS_TO_TICKS()*来指定阻塞时间为若干ms 返回值 pdTRUE表示成功 xSemaphoreTakeFromISR的函数原型如下： 1234BaseType_t xSemaphoreTakeFromISR( SemaphoreHandle_t xSemaphore, BaseType_t *pxHigherPriorityTaskWoken ); xSemaphoreTakeFromISR函数的参数与返回值列表如下： 参数 说明 xSemaphore 信号量句柄，获取哪个信号量 pxHigherPriorityTaskWoken 如果获取信号量导致更高优先级的任务变为了就绪态， 则*pxHigherPriorityTaskWoken = pdTRUE 返回值 pdTRUE表示成功 优先级反转信号量使用不当 就会出现优先级反转的问题——任务执行顺序：任务1、任务2、任务1、任务3 即最高优先级的任务最后运行 优先级反转：假设信号量值为1，同时创建了低、中等、高优先级任务 低优先级任务获取信号量，中等优先级先阻塞一段时间，确保低优先级任务先成功获取到信号量 高优先级任务先阻塞一段时间，确保低优先级、中等优先级先完成任务，然后尝试获取信号量 此时由于低优先级获取了信号量，高优先级任务就会被阻塞 中等优先级不释放信号量，那么就会发生高优先级任务无法运行 示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &quot;uart.h&quot;typedef struct __FILE FILE;static SemaphoreHandle_t task_mutex = NULL;typedef struct&#123; uint8_t dev; uint8_t *data;&#125; uart_info_t;uart_info_t task1_data = &#123;1, &quot;task1&quot;&#125;;uart_info_t task2_data = &#123;2, &quot;task2&quot;&#125;;uart_info_t task3_data = &#123;3, &quot;task3&quot;&#125;;int fputc(int ch, FILE *f)&#123; HAL_UART_Transmit(&amp;huart1, (uint8_t *)&amp;ch, 1, 0xFFFF); return ch;&#125;void task1(void *param)&#123; uint8_t cnt = 0; xSemaphoreTake(task_mutex, portMAX_DELAY); uart_info_t *data = param; while (1) &#123; printf(&quot;dev:%u,name:%s\\r\\n&quot;, data-&gt;dev, data-&gt;data); if (++cnt == 5) &#123; xSemaphoreGive(task_mutex); &#125; vTaskDelay(50); &#125;&#125;void task2(void *param)&#123; uint8_t cnt = 0; vTaskDelay(300);//先阻塞一段时间 确保任务1成功获取信号量且能够被切换为任务2 uart_info_t *data = param; while (1) &#123; printf(&quot;dev:%u,name:%s\\r\\n&quot;, data-&gt;dev, data-&gt;data); if (++cnt == 5) &#123; vTaskDelete(NULL); &#125; HAL_Delay(50); &#125;&#125;void task3(void *param)&#123; uint8_t cnt = 0; vTaskDelay(500); //先阻塞一段时间 确保任务1先成功获取信号量且能够被切换为任务2 xSemaphoreTake(task_mutex, portMAX_DELAY); uart_info_t *data = param; while (1) &#123; printf(&quot;dev:%u,name:%s\\r\\n&quot;, data-&gt;dev, data-&gt;data); if (++cnt == 5) &#123; vTaskDelete(NULL); &#125; &#125;&#125;void uart_init(void)&#123; task_mutex = xSemaphoreCreateBinary(); xSemaphoreGive(task_mutex); xTaskCreate(task1, &quot;task1&quot;, 128, &amp;task1_data, osPriorityNormal, NULL); //低优先级任务 xTaskCreate(task2, &quot;task2&quot;, 128, &amp;task2_data, osPriorityNormal1, NULL); //中等优先级任务 xTaskCreate(task3, &quot;task3&quot;, 128, &amp;task3_data, osPriorityNormal2, NULL); //高优先级任务&#125; 解决优先级反转 使用互斥量 （实现优先级继承），当最高优先级任务等待互斥量时，可以将低优先级任务继承最高优先级，使得最高优先级任务也可以先运行 现象：任务1执行一小段时间被任务2抢占，当任务3时间到来，任务1继承任务3优先级，所以任务1运行释放后，任务1恢复原先优先级，任务3启动 事件组 上述任务同步与互斥的方法都是一对一通知，难以实现一对多通知（广播），因此引入了事件组 事件组的概念事件组可以简单地认为就是一个整数： 的每一位表示一个事件 每一位事件的含义由程序员决定，比如：Bit0表示用来串口是否就绪，Bit1表示按键是否被按下 这些位，值为1表示事件发生了，值为0表示事件没发生 一个或多个任务、ISR都可以去写这些位；一个或多个任务、ISR都可以去读这些位 可以等待某一位、某些位中的任意一个，也可以等待多位 事件组用一个整数来表示，其中的高8位留给内核使用，只能用其他的位来表示事件。那么这个整数是多少位的？ 如果configUSE_16_BIT_TICKS是1，那么这个整数就是16位的，低8位用来表示事件 如果configUSE_16_BIT_TICKS是0，那么这个整数就是32位的，低24位用来表示事件 configUSE_16_BIT_TICKS是用来表示Tick Count的，怎么会影响事件组？这只是基于效率来考虑 如果configUSE_16_BIT_TICKS是1，就表示该处理器使用16位更高效，所以事件组也使用16位 如果configUSE_16_BIT_TICKS是0，就表示该处理器使用32位更高效，所以事件组也使用32位 事件组的操作事件组和队列、信号量等不太一样，主要集中在2个地方： 唤醒谁？ 队列、信号量：事件发生时，只会唤醒一个任务 事件组：事件发生时，会唤醒所有符号条件的任务，简单地说它有”广播”的作用 是否清除事件？ 队列、信号量：是消耗型的资源，队列的数据被读走就没了；信号量被获取后就减少了 事件组：被唤醒的任务有两个选择，可以让事件保留不动，也可以清除事件 以上图为列，事件组的常规操作如下： 先创建事件组 任务C、D等待事件： 等待什么事件？可以等待某一位、某些位中的任意一个，也可以等待多位。简单地说就是”或”、”与”的关系。 得到事件时，要不要清除？可选择清除、不清除。 任务A、B产生事件：设置事件组里的某一位、某些位 事件组函数创建使用事件组之前，要先创建，得到一个句柄；使用事件组时，要使用句柄来表明使用哪个事件组。 有两种创建方法：动态分配内存、静态分配内存。函数原型如下： 1234567891011/* 创建一个事件组，返回它的句柄。 * 此函数内部会分配事件组结构体 * 返回值: 返回句柄，非NULL表示成功 */EventGroupHandle_t xEventGroupCreate( void );/* 创建一个事件组，返回它的句柄。 * 此函数无需动态分配内存，所以需要先有一个StaticEventGroup_t结构体，并传入它的指针 * 返回值: 返回句柄，非NULL表示成功 */EventGroupHandle_t xEventGroupCreateStatic( StaticEventGroup_t * pxEventGroupBuffer ); 删除对于动态创建的事件组，不再需要它们时，可以删除它们以回收内存。 vEventGroupDelete可以用来删除事件组，函数原型如下： 1234/* * xEventGroup: 事件组句柄，你要删除哪个事件组 */void vEventGroupDelete( EventGroupHandle_t xEventGroup ) 设置事件可以设置事件组的某个位、某些位，使用的函数有2个： 在任务中使用xEventGroupSetBits() 在ISR中使用xEventGroupSetBitsFromISR() 有一个或多个任务在等待事件，如果这些事件符合这些任务的期望，那么任务还会被唤醒。 函数原型如下： 123456789101112131415161718192021/* 设置事件组中的位 * xEventGroup: 哪个事件组 * uxBitsToSet: 设置哪些位? * 如果uxBitsToSet的bitX, bitY为1, 那么事件组中的bitX, bitY被设置为1 * 可以用来设置多个位，比如 0x15 就表示设置bit4, bit2, bit0 * 返回值: 返回原来的事件值(没什么意义, 因为很可能已经被其他任务修改了) */EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet );/* 设置事件组中的位 * xEventGroup: 哪个事件组 * uxBitsToSet: 设置哪些位? * 如果uxBitsToSet的bitX, bitY为1, 那么事件组中的bitX, bitY被设置为1 * 可以用来设置多个位，比如 0x15 就表示设置bit4, bit2, bit0 * pxHigherPriorityTaskWoken: 有没有导致更高优先级的任务进入就绪态? pdTRUE-有, pdFALSE-没有 * 返回值: pdPASS-成功, pdFALSE-失败 */BaseType_t xEventGroupSetBitsFromISR( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, BaseType_t * pxHigherPriorityTaskWoken ); 值得注意的是，ISR中的函数，比如队列函数xQueueSendToBackFromISR、信号量函数xSemaphoreGiveFromISR，它们会唤醒某个任务，最多只会唤醒1个任务。 但是设置事件组时，有可能导致多个任务被唤醒，这会带来很大的不确定性。所以xEventGroupSetBitsFromISR函数不是直接去设置事件组，而是给一个FreeRTOS后台任务(daemon task)发送队列数据，由这个任务来设置事件组。 如果后台任务的优先级比当前被中断的任务优先级高，xEventGroupSetBitsFromISR会设置pxHigherPriorityTaskWoken为pdTRUE。 如果daemon task成功地把队列数据发送给了后台任务，那么xEventGroupSetBitsFromISR的返回值就是pdPASS。 等待事件使用xEventGroupWaitBits来等待事件，可以等待某一位、某些位中的任意一个，也可以等待多位；等到期望的事件后，还可以清除某些位。 函数原型如下： 12345EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait ); 先引入一个概念：unblock condition。一个任务在等待事件发生时，它处于阻塞状态；当期望的时间发生时，这个状态就叫”unblock condition”，非阻塞条件，或称为”非阻塞条件成立”；当”非阻塞条件成立”后，该任务就可以变为就绪态。 函数参数说明列表如下： 参数 说明 xEventGroup 等待哪个事件组？ uxBitsToWaitFor 等待哪些位？哪些位要被测试？ xWaitForAllBits 怎么测试？是”AND”还是”OR”？ pdTRUE: 等待的位，全部为1; pdFALSE: 等待的位，某一个为1即可 xClearOnExit 函数提出前是否要清除事件？ pdTRUE: 清除uxBitsToWaitFor指定的位 pdFALSE: 不清除 xTicksToWait 如果期待的事件未发生，阻塞多久。 可以设置为0：判断后即刻返回； 可设置为portMAX_DELAY：一定等到成功才返回； 可以设置为期望的Tick Count，一般用*pdMS_TO_TICKS()*把ms转换为Tick Count 返回值 返回的是事件值， 如果期待的事件发生了，返回的是”非阻塞条件成立”时的事件值； 如果是超时退出，返回的是超时时刻的事件值。 举例如下： 事件组的值 uxBitsToWaitFor xWaitForAllBits 说明 0100 0101 pdTRUE 任务期望bit0,bit2都为1， 当前值只有bit2满足，任务进入阻塞态； 当事件组中bit0,bit2都为1时退出阻塞态 0100 0110 pdFALSE 任务期望bit0,bit2某一个为1， 当前值满足，所以任务成功退出 0100 0110 pdTRUE 任务期望bit1,bit2都为1， 当前值不满足，任务进入阻塞态； 当事件组中bit1,bit2都为1时退出阻塞态 你可以使用*xEventGroupWaitBits()等待期望的事件，它发生之后再使用xEventGroupClearBits()*来清除。但是这两个函数之间，有可能被其他任务或中断抢占，它们可能会修改事件组。 可以使用设置xClearOnExit为pdTRUE，使得对事件组的测试、清零都在*xEventGroupWaitBits()*函数内部完成，这是一个原子操作。 同步点有一个事情需要多个任务协同，比如： 任务A：炒菜 任务B：买酒 任务C：摆台 A、B、C做好自己的事后，还要等别人做完；大家一起做完，才可开饭 使用 xEventGroupSync() 函数可以同步多个任务： 可以设置某位、某些位，表示自己做了什么事 可以等待某位、某些位，表示要等等其他任务 期望的时间发生后， xEventGroupSync() 才会成功返回。 xEventGroupSync成功返回后，会清除事件 xEventGroupSync 函数原型如下： 1234EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, const EventBits_t uxBitsToWaitFor, TickType_t xTicksToWait ); 参数列表如下： 参数 说明 xEventGroup 哪个事件组？ uxBitsToSet 要设置哪些事件？我完成了哪些事件？ 比如0x05(二进制为0101)会导致事件组的bit0,bit2被设置为1 uxBitsToWaitFor 等待那个位、哪些位？ 比如0x15(二级制10101)，表示要等待bit0,bit2,bit4都为1 xTicksToWait 如果期待的事件未发生，阻塞多久。 可以设置为0：判断后即刻返回； 可设置为portMAX_DELAY：一定等到成功才返回； 可以设置为期望的Tick Count，一般用*pdMS_TO_TICKS()*把ms转换为Tick Count 返回值 返回的是事件值， 如果期待的事件发生了，返回的是”非阻塞条件成立”时的事件值； 如果是超时退出，返回的是超时时刻的事件值。 参数列表如下： 参数 说明 xEventGroup 哪个事件组？ uxBitsToSet 要设置哪些事件？我完成了哪些事件？ 比如0x05(二进制为0101)会导致事件组的bit0,bit2被设置为1 uxBitsToWaitFor 等待那个位、哪些位？ 比如0x15(二级制10101)，表示要等待bit0,bit2,bit4都为1 xTicksToWait 如果期待的事件未发生，阻塞多久。 可以设置为0：判断后即刻返回； 可设置为portMAX_DELAY：一定等到成功才返回； 可以设置为期望的Tick Count，一般用*pdMS_TO_TICKS()*把ms转换为Tick Count 返回值 返回的是事件值， 如果期待的事件发生了，返回的是”非阻塞条件成立”时的事件值； 如果是超时退出，返回的是超时时刻的事件值。 任务通知所谓”任务通知”，你可以反过来读”通知任务”。 我们使用队列、信号量、事件组等等方法时，并不知道对方是谁。使用任务通知时，可以明确指定：通知哪个任务。 使用队列、信号量、事件组时，我们都要事先创建对应的结构体，双方通过中间的结构体通信： 使用任务通知时，任务结构体TCB中就包含了内部对象，可以直接接收别人发过来的”通知”： 任务通知的特性优势及限制任务通知的优势： 效率更高：使用任务通知来发送事件、数据给某个任务时，效率更高。比队列、信号量、事件组都有大的优势。 更节省内存：使用其他方法时都要先创建对应的结构体，使用任务通知时无需额外创建结构体。 任务通知的限制： 不能发送数据给ISR： ISR并没有任务结构体，所以无法使用任务通知的功能给ISR发送数据。但是ISR可以使用任务通知的功能，发数据给任务。 数据只能给该任务独享 使用队列、信号量、事件组时，数据保存在这些结构体中，其他任务、ISR都可以访问这些数据。使用任务通知时，数据存放入目标任务中，只有它可以访问这些数据。 在日常工作中，这个限制影响不大。因为很多场合是从多个数据源把数据发给某个任务，而不是把一个数据源的数据发给多个任务。 无法缓冲数据 使用队列时，假设队列深度为N，那么它可以保持N个数据。 使用任务通知时，任务结构体中只有一个任务通知值，只能保持一个数据。 无法广播给多个任务 使用事件组可以同时给多个任务发送事件。 使用任务通知，只能发个一个任务。 如果发送受阻，发送方无法进入阻塞状态等待 假设队列已经满了，使用 xQueueSendToBack() 给队列发送数据时，任务可以进入阻塞状态等待发送完成。 使用任务通知时，即使对方无法接收数据，发送方也无法阻塞等待，只能即刻返回错误。 通知状态和通知值每个任务都有一个结构体：TCB(Task Control Block)，里面有2个成员： 一个是uint8_t类型，用来表示通知状态 一个是uint32_t类型，用来表示通知值 12345678typedef struct tskTaskControlBlock&#123; ...... /* configTASK_NOTIFICATION_ARRAY_ENTRIES = 1 */ volatile uint32_t ulNotifiedValue[ configTASK_NOTIFICATION_ARRAY_ENTRIES ]; volatile uint8_t ucNotifyState[ configTASK_NOTIFICATION_ARRAY_ENTRIES ]; ......&#125; tskTCB; 通知状态有3种取值： taskNOT_WAITING_NOTIFICATION：任务没有在等待通知 taskWAITING_NOTIFICATION：任务在等待通知 taskNOTIFICATION_RECEIVED：任务接收到了通知，也被称为pending(有数据了，待处理) 123##define taskNOT_WAITING_NOTIFICATION ( ( uint8_t ) 0 ) /* 也是初始状态 */##define taskWAITING_NOTIFICATION ( ( uint8_t ) 1 )##define taskNOTIFICATION_RECEIVED ( ( uint8_t ) 2 ) 通知值可以有很多种类型： 计数值 位(类似事件组) 任意数值 任务通知的使用使用任务通知，可以实现轻量级的队列(长度为1)、邮箱(覆盖的队列)、计数型信号量、二进制信号量、事件组。 两类函数任务通知有2套函数，简化版、专业版，列表如下： 简化版函数的使用比较简单，它实际上也是使用专业版函数实现的 专业版函数支持很多参数，可以实现很多功能 简化版 专业版 发出通知 xTaskNotifyGive vTaskNotifyGiveFromISR xTaskNotify xTaskNotifyFromISR 取出通知 ulTaskNotifyTake xTaskNotifyWait 简化版任务通知在任务中使用xTaskNotifyGive函数，在ISR中使用vTaskNotifyGiveFromISR函数，都是直接给其他任务发送通知： 使得通知值加一 并使得通知状态变为”pending”，也就是taskNOTIFICATION_RECEIVED，表示有数据了、待处理 可以使用ulTaskNotifyTake函数来取出通知值： 如果通知值等于0，则阻塞(可以指定超时时间) 当通知值大于0时，任务从阻塞态进入就绪态 在ulTaskNotifyTake返回之前，还可以做些清理工作：把通知值减一，或者把通知值清零 使用ulTaskNotifyTake函数可以实现轻量级的、高效的二进制信号量、计数型信号量。 这几个函数的原型如下： 12345BaseType_t xTaskNotifyGive( TaskHandle_t xTaskToNotify );void vTaskNotifyGiveFromISR( TaskHandle_t xTaskHandle, BaseType_t *pxHigherPriorityTaskWoken );uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait ); xTaskNotifyGive函数的参数说明如下： 参数 说明 xTaskToNotify 任务句柄(创建任务时得到)，给哪个任务发通知 返回值 必定返回pdPASS vTaskNotifyGiveFromISR函数的参数说明如下： 参数 说明 xTaskHandle 任务句柄(创建任务时得到)，给哪个任务发通知 pxHigherPriorityTaskWoken 被通知的任务，可能正处于阻塞状态。 此函数发出通知后，会把它从阻塞状态切换为就绪态。 如果被唤醒的任务的优先级，高于当前任务的优先级， 则”*pxHigherPriorityTaskWoken”被设置为pdTRUE， 这表示在中断返回之前要进行任务切换。 ulTaskNotifyTake函数的参数说明如下： 参数 说明 xClearCountOnExit 函数返回前是否清零： pdTRUE：把通知值清零 pdFALSE：如果通知值大于0，则把通知值减一 xTicksToWait 任务进入阻塞态的超时时间，它在等待通知值大于0。 0：不等待，即刻返回； portMAX_DELAY：一直等待，直到通知值大于0； 其他值：Tick Count，可以用*pdMS_TO_TICKS()*把ms转换为Tick Count 返回值 函数返回之前，在清零或减一之前的通知值。 如果xTicksToWait非0，则返回值有2种情况： 1. 大于0：在超时前，通知值被增加了 2. 等于0：一直没有其他任务增加通知值，最后超时返回0 专业版任务通知xTaskNotify 函数功能更强大，可以使用不同参数实现各类功能，比如： 让接收任务的通知值加一：这时 xTaskNotify() 等同于 xTaskNotifyGive() 设置接收任务的通知值的某一位、某些位，这就是一个轻量级的、更高效的事件组 把一个新值写入接收任务的通知值：上一次的通知值被读走后，写入才成功。这就是轻量级的、长度为1的队列 用一个新值覆盖接收任务的通知值：无论上一次的通知值是否被读走，覆盖都成功。类似 xQueueOverwrite() 函数，这就是轻量级的邮箱。 xTaskNotify() 比 xTaskNotifyGive() 更灵活、强大，使用上也就更复杂。xTaskNotifyFromISR() 是它对应的ISR版本。 这两个函数用来发出任务通知，使用哪个函数来取出任务通知呢？ 使用 xTaskNotifyWait() 函数！它比 ulTaskNotifyTake() 更复杂： 可以让任务等待(可以加上超时时间)，等到任务状态为”pending”(也就是有数据) 还可以在函数进入、退出时，清除通知值的指定位 这几个函数的原型如下： 1234567891011BaseType_t xTaskNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction );BaseType_t xTaskNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, BaseType_t *pxHigherPriorityTaskWoken );BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait ); xTaskNotify函数的参数说明如下： 参数 说明 xTaskToNotify 任务句柄(创建任务时得到)，给哪个任务发通知 ulValue 怎么使用ulValue，由eAction参数决定 eAction 见下表 返回值 pdPASS：成功，大部分调用都会成功 pdFAIL：只有一种情况会失败，当eAction为eSetValueWithoutOverwrite， 并且通知状态为”pending”(表示有新数据未读)，这时就会失败。 eNotifyAction参数说明： eNotifyAction取值 说明 eNoAction 仅仅是更新通知状态为”pending”，未使用ulValue。 这个选项相当于轻量级的、更高效的二进制信号量。 eSetBits 通知值 &#x3D; 原来的通知值 | ulValue，按位或。 相当于轻量级的、更高效的事件组。 eIncrement 通知值 &#x3D; 原来的通知值 + 1，未使用ulValue。 相当于轻量级的、更高效的二进制信号量、计数型信号量。 相当于**xTaskNotifyGive()**函数。 eSetValueWithoutOverwrite 不覆盖。 如果通知状态为”pending”(表示有数据未读)， 则此次调用xTaskNotify不做任何事，返回pdFAIL。 如果通知状态不是”pending”(表示没有新数据)， 则：通知值 &#x3D; ulValue。 eSetValueWithOverwrite 覆盖。 无论如何，不管通知状态是否为”pendng”， 通知值 &#x3D; ulValue。 xTaskNotifyFromISR函数跟xTaskNotify很类似，就多了最后一个参数pxHigherPriorityTaskWoken。在很多ISR函数中，这个参数的作用都是类似的，使用场景如下： 被通知的任务，可能正处于阻塞状态 xTaskNotifyFromISR函数发出通知后，会把接收任务从阻塞状态切换为就绪态 如果被唤醒的任务的优先级，高于当前任务的优先级，则”*pxHigherPriorityTaskWoken”被设置为pdTRUE，这表示在中断返回之前要进行任务切换。 xTaskNotifyWait函数列表如下： 参数 说明 ulBitsToClearOnEntry 在xTaskNotifyWait入口处，要清除通知值的哪些位？ 通知状态不是”pending”的情况下，才会清除。 它的本意是：我想等待某些事件发生，所以先把”旧数据”的某些位清零。 能清零的话：通知值 &#x3D; 通知值 &amp; ~(ulBitsToClearOnEntry)。 比如传入0x01，表示清除通知值的bit0； 传入0xffffffff即ULONG_MAX，表示清除所有位，即把值设置为0 ulBitsToClearOnExit 在xTaskNotifyWait出口处，如果不是因为超时推出，而是因为得到了数据而退出时： 通知值 &#x3D; 通知值 &amp; ~(ulBitsToClearOnExit)。 在清除某些位之前，通知值先被赋给”*pulNotificationValue”。 比如入0x03，表示清除通知值的bit0、bit1； 传入0xffffffff即ULONG_MAX，表示清除所有位，即把值设置为0 pulNotificationValue 用来取出通知值。 在函数退出时，使用ulBitsToClearOnExit清除之前，把通知值赋给”*pulNotificationValue”。 如果不需要取出通知值，可以设为NULL。 xTicksToWait 任务进入阻塞态的超时时间，它在等待通知状态变为”pending”。 0：不等待，即刻返回； portMAX_DELAY：一直等待，直到通知状态变为”pending”； 其他值：Tick Count，可以用*pdMS_TO_TICKS()*把ms转换为Tick Count 返回值 1. pdPASS：成功 这表示xTaskNotifyWait成功获得了通知： 可能是调用函数之前，通知状态就是”pending”； 也可能是在阻塞期间，通知状态变为了”pending”。 2. pdFAIL：没有得到通知。","categories":[{"name":"MCU","slug":"MCU","permalink":"https://mextra.netlify.app/categories/MCU/"}],"tags":[{"name":"RTOS","slug":"RTOS","permalink":"https://mextra.netlify.app/tags/RTOS/"},{"name":"实时操作系统","slug":"实时操作系统","permalink":"https://mextra.netlify.app/tags/%E5%AE%9E%E6%97%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"FreeRTOS","slug":"FreeRTOS","permalink":"https://mextra.netlify.app/tags/FreeRTOS/"}]},{"title":"C语言高级","slug":"C语言高级","date":"2025-09-02T03:36:37.000Z","updated":"2025-09-28T13:17:03.567Z","comments":true,"path":"2025/09/02/C语言高级/","permalink":"https://mextra.netlify.app/2025/09/02/C%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7/","excerpt":"","text":"关于const的进一步思考 背景：在进行宿舍精灵项目的代码编写时， 我使用了映射表来表现楼栋，我使用了const来修饰 以稳定内容 但是在我尝试将楼栋的内容分离出来时（例如中1C 在oled上需把中文提取出来 然后剩下用oled_print来显示在oled上） 但却出现了指针错误 分析了一下：const是将对应的字符数组存放在只读存储区中 而我因为想要分离 从而修改了指针的内容 故造成指针错误 解决措施：通过malloc来申请内存，然后使用strcpy或者sprintf来存放在新申请的内存中 123456789101112131415161718192021222324252627282930char *get_building_map_remain(void)&#123; char *map = get_building_map(); if (map == NULL) &#123; return NULL; &#125; size_t len = strlen(map); if (len &lt;= 3) &#123; // 返回空字符串 char *result = malloc(1); if (result) &#123; result[0] = &#x27;\\0&#x27;; &#125; return result; &#125; // 分配新内存并复制跳过前3字节的内容 char *result = malloc(len - 3 + 1); if (result == NULL) &#123; return NULL; &#125; strcpy(result, map + 3); return result;&#125; freertos https://mextra.netlify.app/2025/09/05/freertos/ 二维数组高级应用 背景：在进一步封装MP3_Test项目的时候，本身有个二维数组mp3Files用来存放MP3文件路径，在修饰为static保护变量时，遇到了不会返回的难题 []优先级高于* 解决措施：通过询问AI后，得出可以将其封装为一个返回值为数组指针的函数，然后定义一个数组指针来接收原型为指针，但指向的是数组 函数封装12345678910111213static char mp3Files[100][64]; // 假设最多有100个MP3文件char (*get_mp3_files(void)) [64]&#123; return mp3Files;&#125;void task(void)&#123; char (*files)[64] = get_mp3_files(); for(int i = 0; i &lt; 100 ;i++) printf(&quot;file[%d]:%s\\r\\n&quot;,i,files[i]);&#125; 指针访问12345678910static char mp3Files[100][64]; // 假设最多有100个MP3文件void task(void)&#123; /*（1）指向数组的指针（按行访问） 即指针数组*/ char (*p)[64] = mp3Files; /*（2）指向数组的指针（逐个访问）*/ char *p = &amp;mp3Files[0][0]; //或 char *p = mp3Files[0];&#125;","categories":[],"tags":[{"name":"嵌入式基础","slug":"嵌入式基础","permalink":"https://mextra.netlify.app/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%9F%BA%E7%A1%80/"},{"name":"C语言高级","slug":"C语言高级","permalink":"https://mextra.netlify.app/tags/C%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7/"}]},{"title":"电赛","slug":"电赛","date":"2025-06-08T05:22:05.000Z","updated":"2025-06-12T14:17:36.622Z","comments":true,"path":"2025/06/08/电赛/","permalink":"https://mextra.netlify.app/2025/06/08/%E7%94%B5%E8%B5%9B/","excerpt":"","text":"PID 其中 e 为误差 P：正比 即控制摆动 I：积分 积累误差，可用来消除稳定误差 （比如无人机中，向下吹的风刚好是1米，但p中最后上升也是1米 即形成一种稳态） D：微分 速度控制 可用来让系统快速停下来 编码器CubeMX配置 参数解析 Encoder Mode Encoder Mode TI1 ：只保留A相，滤除B相数据 Encoder Mode TI2 ：只保留B相，滤除A相数据 Encoder Mode TI1 and TI2：A、B相都保留，数据波长会是第一、二模式的两倍 一般用于高精度场合 如小车 代码编写初始化12HAL_TIM_Encoder_Start(&amp;htim3, TIM_CHANNEL_1); // 开启编码器AHAL_TIM_Encoder_Start(&amp;htim3, TIM_CHANNEL_2); // 开启编码器A 获取编码器值 记得先接上编码器的电源 他与电机是分开的电源 工作电压为3.3V~5V 12g_nMotor_Lef_Pulse = (short)(__HAL_TIM_GET_COUNTER(&amp;htim3)); // 获取计数器值__HAL_TIM_SET_COUNTER(&amp;htim3, 0); // 左编码器TIM3计数器清零 超声波CubeMX配置 初始化1Hcsr04Init(&amp;htim11, TIM_CHANNEL_1); // 超声波模块初始化 注册回调函数与绑定定时器溢出回调函数12345678910111213void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim)&#123; if (htim-&gt;Instance == TIM11) Hcsr04TimIcIsr(&amp;htim11);&#125;void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)&#123; if (htim-&gt;Instance == TIM11) &#123; Hcsr04TimOverflowIsr(&amp;htim11); &#125;&#125; 获取距离值123Hcsr04Start();printf(&quot;distance:%.1f cm\\r\\n&quot;, Hcsr04Read());HAL_Delay(300); // 可适当加些延时 JY60陀螺仪CubeMX配置 初始化 引入官方sdk wit_c_sdk.h与wit_c_sdk.c 新建驱动文件 jy60.c与 jy60.h 1234567891011jy60_init();/*void jy60_init(void)&#123; WitInit(WIT_PROTOCOL_NORMAL, 0x50); WitSerialWriteRegister(SensorUartSend); WitRegisterCallBack(SensorDataUpdata); WitDelayMsRegister(Delayms); HAL_Delay(100);&#125;*/ 获取加速度、角速度、姿态角1234567891011121314151617181920212223242526272829303132333435363738394041jy60_read();/*void jy60_read(void)&#123; if(s_cDataUpdate) &#123; for(uint8_t i = 0; i &lt; 3; i++) &#123; fAcc[i] = sReg[AX+i] / 32768.0f * 16.0f; fGyro[i] = sReg[GX+i] / 32768.0f * 2000.0f; fAngle[i] = sReg[Roll+i] / 32768.0f * 180.0f; &#125;// uint8_t strff[21];// // sprintf(strff,&quot;%.2f&quot;,fAngle[2]);// // OLED_ShowStr(0,3,strff,1); if(s_cDataUpdate &amp; ACC_UPDATE) &#123;// printf(&quot;acc:%.3f %.3f %.3f\\r\\n&quot;, fAcc[0], fAcc[1], fAcc[2]); s_cDataUpdate &amp;= ~ACC_UPDATE; &#125; if(s_cDataUpdate &amp; GYRO_UPDATE) &#123;// printf(&quot;gyro:%.3f %.3f %.3f\\r\\n&quot;, fGyro[0], fGyro[1], fGyro[2]); s_cDataUpdate &amp;= ~GYRO_UPDATE; &#125; if(s_cDataUpdate &amp; ANGLE_UPDATE) &#123; printf(&quot;angle:%.3f %.3f %.3f\\r\\n&quot;, fAngle[0], fAngle[1], fAngle[2]); s_cDataUpdate &amp;= ~ANGLE_UPDATE; &#125; if(s_cDataUpdate &amp; MAG_UPDATE) &#123; //printf(&quot;mag:%d %d %d\\r\\n&quot;, sReg[HX], sReg[HY], sReg[HZ]); s_cDataUpdate &amp;= ~MAG_UPDATE; &#125; &#125; &#125;*/ 变量名 含义 单位 来源寄存器 fAcc 加速度（Accelerometer） M&#x2F;s² AX、AY、AZ fGyro 角速度（Gyroscope） °&#x2F;s（角度每秒） GX、GY、GZ fAngle 姿态角（Angle） °（角度） Roll、Pitch、Yaw 下标 fAcc fGyro fAngle [0] X 轴加速度 X 轴角速度 横滚角（Roll） [1] Y 轴加速度 Y 轴角速度 俯仰角（Pitch） [2] Z 轴加速度 Z 轴角速度 偏航角（Yaw） 数据分析12345fAcc[i] = sReg[AX+i] / 32768.0f * 16.0f;fGyro[i] = sReg[GX+i] / 32768.0f * 2000.0f;fAngle[i] = sReg[Roll+i] / 32768.0f * 180.0f;/*以上数据均来源于这里*///后面的 * 16.0f 表示限幅 即 加速度范围为 ± 16M/s²","categories":[],"tags":[{"name":"电赛准备","slug":"电赛准备","permalink":"https://mextra.netlify.app/tags/%E7%94%B5%E8%B5%9B%E5%87%86%E5%A4%87/"}]},{"title":"西门子嵌入式学习","slug":"西门子","date":"2025-06-02T08:00:53.000Z","updated":"2025-09-28T03:44:57.994Z","comments":true,"path":"2025/06/02/西门子/","permalink":"https://mextra.netlify.app/2025/06/02/%E8%A5%BF%E9%97%A8%E5%AD%90/","excerpt":"","text":"调度器模板123456789101112131415161718192021222324252627282930313233#include &quot;scheduler.h&quot;// clang-format offtypedef struct&#123; void (*task_func)(void); uint32_t rate_ms; uint32_t last_ms;&#125; task_t;task_t tasks[] = &#123;&#125;;uint8_t task_count;void scheduler_init(void)&#123; task_count = sizeof(tasks) / sizeof(task_t);&#125;void scheduler_run(void)&#123; uint8_t i; for (i = 0; i &lt; task_count; i++) &#123; uint32_t now_time = HAL_GetTick(); if ((uint32_t)(now_time - tasks[i].last_ms) &gt;= tasks[i].rate_ms) &#123; tasks[i].last_ms = now_time; tasks[i].task_func(); &#125; &#125;&#125; 时钟配置栏模式设置 高速时钟HSE Disable：不启用外部时钟（默认使用内部时钟） 内部时钟（内部RC（电阻-电容）振荡器）提供了此便捷性 但精度不如外部时钟（外部低速晶振或陶瓷振荡器） BYPASS Clock Source：旁路模式，允许直接从外部导入时钟信号，而不使用外部晶体。这种模式适用于需要从外部系统或其他设备接收时钟信号的情况。 Crystal/Ceramic Resonator：将外部低速晶振或陶瓷谐振器作为时钟源，一般则是板载上的外部晶振 低速时钟LSE 参数同上 通常用于实时时钟（RTC）等需要低频稳定时钟的应用。LSE的典型频率为32.768kHz Master Clock Output 配置是否使能主时钟输出到MCO引脚，即可以通过MCO引脚将时钟信号输出到外部，供其他设备使用 **Audio Clock Input (I2S_CKIN)**： 此选项用于配置是否从特定的引脚（如I2S_CKIN）输入音频时钟。这对于需要精确音频时钟的音频应用非常重要，例如I2S音频接口。 参数设置 TIM Prescaler Selection：定时器预分频选择，禁用时使用最大分频值。 HSE Startup Timeout Value (ms)：HSE（高速外部时钟）启动超时时间，设置为100ms。这是外部晶振启动的最长等待时间，如果超出这个时间晶振还未启动，微控制器会认为启动失败。 LSE Startup Timeout Value (ms)：LSE（低速外部时钟）启动超时时间，设置为5000ms。这通常用于RTC的时钟源，如果超出这个时间晶振还未启动，微控制器会认为启动失败。 Power Regulator Voltage Scale：电源调节器电压等级，设置为Power Regulator Voltage Scale 3。这通常与微控制器的性能和功耗有关，不同的电压等级可以提供不同的性能和功耗平衡。 Power Over Drive：电源过驱，禁用。这通常用于在需要更高性能时临时提高微控制器的电压，以支持更高的时钟频率。 在何处选择了HSI以及HSE 第一个框一定一定要看硬件上的晶振是多少频率，一定要严格按照硬件资源给的 （不要无脑用默认的） 否则可能会出现串口数据接收乱码 第二个框选择了用&#96;相位锁定环（PLL） 调整外部高速时钟（HSE）还是内部高速时钟（HSI） 第三个框框则直接选择是否选择 经过PLL调整后的时钟，也可以选择不经过PLL的原生外部高速时钟（HSE），以及内部高速时钟（HSI）。 SYS调试接口选择 Serial Wire (SW-DP) 串口烧录 仅需要两个引脚 SWCLK：主机到从机的时钟信号 SWDIO：双向数据信号 这种模式下，ST-Link工作最稳定，占用引脚少，是日常开发的首选。 JTAG(JTAG-DP) J-Link烧录 需要4或5个引脚： TCK：测试时钟 TMS：测试模式选择 TDI：测试数据输入 TDO：测试数据输出 TRST：测试复位（可选，5pin模式才有） JTAG适合复杂的调试场景，尤其是在使用J-Link调试器时。 LED驱动代码1234567891011121314151617181920212223242526272829#include &quot;led_app.h&quot;uint8_t ucLed[6] = &#123;0, 0, 1, 0, 1, 1&#125;;void Led_disp(uint8_t *ucLed)&#123; uint8_t temp = 0x00, i; static uint8_t temp_old = 0xff; for (i = 0; i &lt; 6; i++) &#123; if (ucLed[i]) temp |= (1 &lt;&lt; i); &#125; if (temp != temp_old) &#123; HAL_GPIO_WritePin(LED1_GPIO_Port, LED1_Pin, (temp &amp; 0x01) ? GPIO_PIN_SET : GPIO_PIN_RESET); HAL_GPIO_WritePin(LED2_GPIO_Port, LED2_Pin, (temp &amp; 0x02) ? GPIO_PIN_SET : GPIO_PIN_RESET); HAL_GPIO_WritePin(LED3_GPIO_Port, LED3_Pin, (temp &amp; 0x04) ? GPIO_PIN_SET : GPIO_PIN_RESET); HAL_GPIO_WritePin(LED4_GPIO_Port, LED4_Pin, (temp &amp; 0x08) ? GPIO_PIN_SET : GPIO_PIN_RESET); HAL_GPIO_WritePin(LED5_GPIO_Port, LED5_Pin, (temp &amp; 0x10) ? GPIO_PIN_SET : GPIO_PIN_RESET); HAL_GPIO_WritePin(LED6_GPIO_Port, LED6_Pin, (temp &amp; 0x20) ? GPIO_PIN_SET : GPIO_PIN_RESET); temp_old = temp; &#125;&#125;void led_task(void)&#123; Led_disp(ucLed);&#125; 软件PWM呼吸灯12345678910111213141516171819void led_task(void)&#123; static uint32_t breath_counter = 0; // 呼吸效果内部计时器，模拟时间流逝 static uint8_t pwm_counter = 0; // PWM内部计时器，用于生成PWM波形 static uint8_t brightness = 0; // 当前的亮度值 static const uint16_t breath_period = 2000; // 呼吸效果周期，单位ms 调小可增加速度 static const uint16_t pwm_max = 10; // PWM最大计数值 调大会降低pwm频率 breath_counter = (++breath_counter) % breath_period; //(2.0f * 3.14159f * breath_counter / breath_period) 将结果映射为0到2π //sin(2.0f * 3.14159f * breath_counter / breath_period) 将结果映射为-1到1 //sin(2.0f * 3.14159f * breath_counter / breath_period) + 1.0f 将结果映射为0到2 //(sin(2.0f * 3.14159f * breath_counter / breath_period) + 1.0f) * pwm_max / 2.0f 将实际亮度计算出来 通过(uint8_t)强制类型转换 brightness = (uint8_t)((sin(2.0f * 3.14159f * breath_counter / breath_period) + 1.0f) * pwm_max / 2.0f); pwm_counter = (++pwm_counter) % pwm_max; for (uint8_t i = 0; i &lt; 6; i++) ucLed[i] = (pwm_counter &lt; brightness) ? 1 : 0; //将所有LED置为呼吸灯效果 Led_disp(ucLed);&#125; 如果是要实时调光，则直接赋值brightness即可 （即不需要breath_counter和breath_period） 按键 常用工程上所用按键对比 github仓库地址：bobwenstudy&#x2F;easy_button: 嵌入式按键处理驱动（Button Driver），支持单击、双击、多击、自动消抖、长按、长长按、超长按 | 低功耗支持 | 组合按键支持 | 静态&#x2F;动态注册支持 整体框架：easy_button ├── ebtn │ ├── bit_array.h │ ├── ebtn.c │ └── ebtn.h ├── build.mk ├── example_user.c └── example_test.c ├── main.c ├── Makefile └── README.md 使用步骤第一步：新建button_app.c并包含头文件123#include &quot;ebtn.h&quot; // 包含 ebtn 库头文件// ... 可能还需要包含你的 HAL 库头文件 ...// #include &quot;stm32xxx_hal.h&quot; 第二步：定义参数与按键列表 定义按键参数 (ebtn_btn_param_t): 使用 EBTN_PARAMS_INIT 宏设定按键的各种时间阈值和行为。这些参数可以被多个按键共用。可用默认参数 即如下default_param_normal 定义按键实例数组 (ebtn_btn_t): 使用 EBTN_BUTTON_INIT 宏创建每个物理按键的实例，并指定它的唯一 key_id 和使用的参数。 （可不加）定义组合按键实例数组 (ebtn_btn_combo_t, 可选): 使用 EBTN_BUTTON_COMBO_INIT 创建组合键实例，同样指定 key_id 和参数。 1234567891011121314151617181920212223242526272829303132/* 1. 定义按键参数实例 */// 参数宏: EBTN_PARAMS_INIT(// 按下消抖时间ms, 释放消抖时间ms,// 单击有效最短按下时间ms, 单击有效最长按下时间ms,// 多次单击最大间隔时间ms,// 长按(KeepAlive)事件周期ms (0禁用),// 最大连续有效点击次数 (e.g., 1=单击, 2=双击, ...)// )const ebtn_btn_param_t default_param_normal = EBTN_PARAMS_INIT( 20, // time_debounce: 按下稳定 20ms(消抖) 20, // time_debounce_release: 释放稳定 20ms 50, // time_click_pressed_min: 最短单击按下 50ms 500, // time_click_pressed_max: 最长单击按下 500ms (超过则不算单击) 300, // time_click_multi_max: 多次单击最大间隔 300ms (两次点击间隔超过则重新计数) 500, // time_keepalive_period: 长按事件周期 500ms (按下超过 500ms 后，每 500ms 触发一次) 5 // max_consecutive: 最多支持 5 连击);/* 2. 定义静态按键列表 */// 宏: EBTN_BUTTON_INIT(按键ID, 参数指针)ebtn_btn_t static_buttons[] = &#123; EBTN_BUTTON_INIT(1, &amp;default_param_normal), // KEY1, ID=1, 使用 &#x27;default_param_normal&#x27; 参数 EBTN_BUTTON_INIT(2, &amp;default_param_normal), // KEY2, ID=2, 也使用 &#x27;default_param_normal&#x27; 参数&#125;;/* 3. 定义静态组合按键列表 (可选) */// 宏: EBTN_BUTTON_COMBO_INIT(按键ID, 参数指针)ebtn_btn_combo_t static_combos[] = &#123; // 假设 KEY1+KEY2 组合键 EBTN_BUTTON_COMBO_INIT(101, &amp;default_param_normal), // 组合键, ID=101 (必须与普通按键ID不同)&#125;; 第三步：编写回调函数你需要提供两个函数给 ebtn 库，告诉它如何与你的硬件交互以及如何通知你事件： get_state_fn (状态获取): 这个函数被 ebtn 调用，用于读取指定按键当前的物理电平。 evt_fn (事件处理): 当 ebtn 检测到一个有效的按键事件（按下、释放、单击、长按）时，会调用这个函数，并传入触发事件的按键信息和事件类型。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182/* 1. 实现获取按键状态的回调函数 */// 函数原型: uint8_t (*ebtn_get_state_fn)(struct ebtn_btn *btn);uint8_t my_get_key_state(struct ebtn_btn *btn) &#123; // 根据传入的按钮实例中的 key_id 判断是哪个物理按键 switch (btn-&gt;key_id) &#123; case 1: // 请求读取 KEY1 的状态 // 假设 KEY1 接在 PB0，按下为低电平 (返回 1 代表按下) return (HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_0) == GPIO_PIN_RESET); case 2: // 请求读取 KEY2 的状态 // 假设 KEY2 接在 PB1，按下为低电平 return (HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_1) == GPIO_PIN_RESET); // ... 可以添加更多按键的读取逻辑 ... default: // 对于库内部处理组合键等情况，或者未知的 key_id，安全起见返回 0 (未按下) return 0; &#125; // 注意：返回值 1 表示 &quot;活动/按下&quot;，0 表示 &quot;非活动/释放&quot;&#125;/* 2. 实现处理按键事件的回调函数 */// 函数原型: void (*ebtn_evt_fn)(struct ebtn_btn *btn, ebtn_evt_t evt);void my_handle_key_event(struct ebtn_btn *btn, ebtn_evt_t evt) &#123; uint16_t key_id = btn-&gt;key_id; // 获取触发事件的按键 ID uint16_t click_cnt = ebtn_click_get_count(btn); // 获取连击次数 (仅在 ONCLICK 事件时有意义) // uint16_t kalive_cnt = ebtn_keepalive_get_count(btn); // 获取长按计数 (仅在 KEEPALIVE 事件时有意义) // 调试打印 (可选) // printf(&quot;Key ID: %d, Event: %d&quot;, key_id, evt); // 根据事件类型进行处理 switch (evt) &#123; case EBTN_EVT_ONPRESS: // 按下事件 (消抖成功后触发一次) // printf(&quot; - Pressed\\n&quot;); // 可以在这里处理按下即触发的操作，比如点亮提示灯 if (key_id == 1) &#123; /* Do something for KEY1 press */ &#125; break; case EBTN_EVT_ONRELEASE: // 释放事件 (消抖成功后触发一次) // printf(&quot; - Released\\n&quot;); // 可以在这里处理释放时触发的操作 if (key_id == 1) &#123; /* Do something for KEY1 release */ &#125; break; case EBTN_EVT_ONCLICK: // 单击/连击事件 (在释放后，或达到最大连击数，或超时后触发) // printf(&quot; - Clicked (%d times)\\n&quot;, click_cnt); // --- 根据 key_id 和 click_cnt 执行不同操作 --- if (key_id == 1) &#123; // 如果是 KEY1 触发的 CLICK if (click_cnt == 1) &#123; // KEY1 单击 // printf(&quot; Action: KEY1 Single Click - Toggle LED1\\n&quot;); // HAL_GPIO_TogglePin(LED1_GPIO_Port, LED1_Pin); &#125; else if (click_cnt == 2) &#123; // KEY1 双击 // printf(&quot; Action: KEY1 Double Click - Switch Mode\\n&quot;); &#125; // ... 可以继续判断 3击, 4击 ... &#125; else if (key_id == 2) &#123; // 如果是 KEY2 触发的 CLICK if (click_cnt == 1) &#123; // KEY2 单击 // printf(&quot; Action: KEY2 Single Click - Toggle LED2\\n&quot;); &#125; &#125; else if (key_id == 101) &#123; // 如果是组合键 (KEY1+KEY2) 触发的 CLICK if (click_cnt == 1) &#123; // 组合键单击 // printf(&quot; Action: Combo Key 101 Single Click - Reset System\\n&quot;); &#125; &#125; break; case EBTN_EVT_KEEPALIVE: // 保持活动/长按事件 (按下持续时间超过阈值后，按周期触发) // printf(&quot; - Keep Alive (Long Press, Count: %d)\\n&quot;, kalive_cnt); if (key_id == 1) &#123; // KEY1 长按 // printf(&quot; Action: KEY1 Long Press - Increase Volume\\n&quot;); &#125; break; default: // 未知事件 (理论上不应发生) // printf(&quot; - Unknown Event\\n&quot;); break; &#125;&#125; 第四步：初始化 ebtn 库在系统启动的初始化阶段（例如 main 函数开始处，或专门的初始化函数中），调用 ebtn_init 函数，将之前准备好的按键列表和回调函数”注册”给 ebtn 库。 如果使用了组合按键，还需要在 ebtn_init 之后，调用相关函数将普通按键绑定到组合键上。 12345678910111213141516void button_init(void)&#123; ebtn_init( static_buttons, // 静态按键数组的指针 EBTN_ARRAY_SIZE(static_buttons), // 静态按键数量 (用宏计算) static_combos, // 静态组合按键数组的指针 (如果没有，传 NULL, 0) EBTN_ARRAY_SIZE(static_combos), // 静态组合按键数量 (如果没有，传 0) my_get_key_state, // 你的状态获取回调函数 my_handle_key_event // 你的事件处理回调函数 );&#125;//下面这个函数可以在调度器中每5秒调用void button_task(void)&#123; ebtn_process(uwTick);&#125; SD+FATFSCubeMX配置 注意：如果TF-CARD上的CD引脚有接入gpio的话 可以将platform设置为该引脚 即检测SD卡引脚 当该引脚为低电平时，则检测到sd卡 没有接gpio的话，platform不要设置 不然会读取不到卡 正点原子探索者v3没有设计该引脚 所以留空即可 使用步骤初始化1SD_Driver.disk_initialize(0); // SD_Driver已经被声明在FATFS/Target/sd_diskio.c","categories":[{"name":"MCU","slug":"MCU","permalink":"https://mextra.netlify.app/categories/MCU/"}],"tags":[{"name":"嵌入式基础","slug":"嵌入式基础","permalink":"https://mextra.netlify.app/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%9F%BA%E7%A1%80/"},{"name":"GD32学习","slug":"GD32学习","permalink":"https://mextra.netlify.app/tags/GD32%E5%AD%A6%E4%B9%A0/"}]},{"title":"TI","slug":"TI","date":"2025-05-28T12:40:37.000Z","updated":"2025-09-17T04:12:23.191Z","comments":true,"path":"2025/05/28/TI/","permalink":"https://mextra.netlify.app/2025/05/28/TI/","excerpt":"","text":"初始化代码浮点单元（FPU）相关配置12ROM_FPUEnable(); / 使能浮点单元ROM_FPULazyStackingEnable(); / 启用浮点延迟堆栈模式，减少中断响应延迟 浮点单元（FPU） 浮点单元是 Cortex-M4 芯片（如 Tiva-C）内的硬件模块，用于加速浮点运算（如浮点加法、乘法）。 如果你的项目中使用了带小数的计算（如定点PID控制、FFT计算、浮点除法），硬件 FPU 的加速能力远远优于软件模拟。 Lazy Stacking 模式 启用延迟堆栈推入操作后，在中断期间，只有确实需要使用浮点硬件时，才会将浮点寄存器保存到堆栈，从而减少中断响应时间和堆栈占用空间。 实际开发中怎么使用和修改? 启用还是禁用 FPU： 如果项目中不涉及浮点运算，可以省略这两个函数的调用以节省资源 启用延迟堆栈的条件： 如果中断中涉及浮点运算，建议启用 Lazy Stacking 优化性能。 但需要注意堆栈深度：中断嵌套可能导致浮点堆栈溢出，调试时增加栈尺寸。 时钟系统配置1ROM_SysCtlClockSet(SYSCTL_SYSDIV_2_5 | SYSCTL_USE_PLL | SYSCTL_XTAL_16MHZ | SYSCTL_OSC_MAIN); / 配置系统时钟 参数说明： SYSCTL_SYSDIV_2_5： 设置系统分频比， 2.5 是分频因子。 假设外部晶振频率为 16MHz，PLL 经过倍频后输出为 400MHz， 2.5 分频下得到时钟频率：400 ÷ 2.5 &#x3D; 80MHz 。 SYSCTL_USE_PLL： 指定使用 PLL（锁相环）作为系统时钟的倍频源。 SYSCTL_XTAL_16MHZ： 配置外部晶振的规格为 16MHz，这需要与硬件实际晶振频率相匹配。 SYSCTL_OSC_MAIN： 指定使用外部主振荡器作为系统的时钟输入源。 实际开发中怎么使用和修改如何修改分频比和主频： 如果需要更改 MCU 的主频（系统时钟频率），只需调整分频因子： 1ROM_SysCtlClockSet(SYSCTL_SYSDIV_4 | SYSCTL_USE_PLL | SYSCTL_XTAL_16MHZ | SYSCTL_OSC_MAIN); 示例中，分频比改为 4 ，主频变为 400 ÷ 4 &#x3D; 100MHz 。 如果硬件使用其他晶振 如果使用 8MHz 的晶振，应修改 SYSCTL_XTAL_16MHZ 为 SYSCTL_XTAL_8MHZ ： 1ROM_SysCtlClockSet(SYSCTL_SYSDIV_2_5 | SYSCTL_USE_PLL | SYSCTL_XTAL_8MHZ | SYSCTL_OSC_MAIN); 切换时钟源 如果不使用外部晶振，可以切换为 内部振荡器 (Precision Internal Oscillator, PIOSC)： 1ROM_SysCtlClockSet(SYSCTL_SYSDIV_2_5 | SYSCTL_USE_PLL | SYSCTL_OSC_INT); 外设（GPIO）启用和配置1234ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOF); / 启用 GPIOF 外设ROM_GPIOPinTypeGPIOOutput(GPIO_PORTF_BASE, GPIO_PIN_5); / 配置 GPIOF 5 为推挽输出ROM_GPIOPinTypeGPIOOutput(GPIO_PORTF_BASE, GPIO_PIN_6); / 配置 GPIOF 6 为推挽输出ROM_GPIOPinTypeGPIOOutput(GPIO_PORTF_BASE, GPIO_PIN_4); / 配置 GPIOF 4 为推挽输出 GPIO 配置解析 使能时钟： 1ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOF); 使能GPIOF外设的时钟 每个外设模块在使用前都必须先使能其时钟，否则无法访问寄存器 配置推挽输出： 1ROM_GPIOPinTypeGPIOOutput(GPIO_PORTF_BASE, GPIO_PIN_X); 将GPIOF的某个引脚配置为推挽输出 配置输入模式 1ROM_GPIOPinTypeGPIOInput(GPIO_PORTF_BASE, GPIO_PIN_5); 将PF5引脚配置为输入 串口代码12ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOA); / 启用 GPIOA 外设ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_UART0); / 启用 UART0 外设 配置UART引脚模式123ROM_GPIOPinConfigure(GPIO_PA0_U0RX); / 配置 GPIOA 引脚 0 为 UART0 RXROM_GPIOPinConfigure(GPIO_PA1_U0TX); / 配置 GPIOA 引脚 1 为 UART0 TXROM_GPIOPinTypeUART(GPIO_PORTA_BASE, GPIO_PIN_0 | GPIO_PIN_1); / 配置 GPIO PA0 和 PA1 为UART 模式 参数说明： ROM_GPIOPinConfigure(pinConfig)： 将某个 GPIO 引脚映射为对应外设的功能模式，例如 UART RX（接收）或 UART TX（发送）模式 GPIO_PA0_U0RX和 GPIO_PA1_U0TX 分别表示将 GPIOA 的 0 和 1 引脚映射到 UART0 的 RX 和 TX信号。 ROM_GPIOPinTypeUART()： 配置对应引脚为 UART 模式（主功能），指示这些引脚负责 UART 的输入和输出。 引脚复用说明： 某些 GPIO 引脚具备多种功能（如 UART、SPI、I2C 等），可以通过 ROM_GPIOPinConfigure() 设置引脚的复用功能。 数据手册中会列出默认出厂配置（如 GPIOA0、GPIOA1 默认是普通 I&#x2F;O）以及复用编号 配置UART0模块12UARTStdioConfig(0, 115200, 16000000); / 配置 UART0，设置波特率为 115200，时钟频率为 16MHzUARTClockSourceSet(UART0_BASE, UART_CLOCK_PIOSC); / 将 UART0 的时钟源设为内部精确振荡器PIOSC UARTStdioConfig() 详解： 用于配置 UART 模块的一些核心参数，例如 UART 通信模块的编号、默认的通信波特率、UART 时钟频率。 参数说明： 0 ：指定 UART 模块编号， 0 对应 UART0。 115200 ：波特率，表示每秒传输 115200 个比特。 16000000 ：UART 输入时钟频率（以 Hz 为单位），这里指定为 16MHz。 作用： 根据设置的波特率和时钟频率， UARTStdioConfig 会自动计算并配置 UART 波特率控制寄存器，从而实现正确的通信速率。 默认时钟源（PIOSC 内部振荡器） 1UARTClockSourceSet(UART0_BASE, UART_CLOCK_PIOSC); / 使用 PIOSC（16 MHz）作为时钟源 PIOSC 是 Tiva-C 系统内置的精确振荡器，频率为 16 MHz。 替代方案：你可以改用系统主时钟（如 PLL）作为 UART 的时钟源。","categories":[{"name":"MCU","slug":"MCU","permalink":"https://mextra.netlify.app/categories/MCU/"}],"tags":[{"name":"TI","slug":"TI","permalink":"https://mextra.netlify.app/tags/TI/"}]},{"title":"RT_Thread","slug":"RT-Thread","date":"2025-05-21T12:26:03.000Z","updated":"2025-09-17T04:12:16.658Z","comments":true,"path":"2025/05/21/RT-Thread/","permalink":"https://mextra.netlify.app/2025/05/21/RT-Thread/","excerpt":"","text":"时钟管理时钟节拍产生与获取时钟节拍依赖于硬件中的定时器。你可以把定时器看作是⼀个不停计时的装置，它每隔⼀段时间就会提醒系统“滴答”⼀次。每当定时器中断发⽣时，RT-Thread 会调⽤ rt_tick_increase()函数，系统时间增加 1 个节拍。就像家中的闹钟响⼀次，时间就过去了⼀分钟⼀样。 其中rt_tick_increase()函数中有rt_tick类似于HAL库中的uwTick，可以直接调用 获取系统时间 定时器管理硬件定时器 vs 软件定时器 硬件定时器：就像厨房⾥的倒计时器，它是由硬件直接提供的。硬件定时器精度⾮常⾼，可以达到纳秒级，适合⼀些对时间要求⾮常严格的任务，⽐如控制电机的旋转时间。 软件定时器：可以理解为⼿机上的计时 App。它依赖于操作系统的时钟节拍来⼯作，它的时间间隔精度由 OS Tick 决定。例如，如果 OS Tick 是 10ms，那么软件定时器只能精确到 10ms。虽然精度不如硬件定时器⾼，但它更灵活、容易使⽤。 RTT定时器分类 单次触发定时器：就像倒计时⼀次的闹钟，响⼀次后就停⽌。例如，设定⼀个 5 秒的倒计时，时间到了闹钟响⼀次就结束了。 周期触发定时器：就像那些每天早上 7 点重复响起的闹钟。每隔⼀段时间，它会周期性地触发事件，直到你⼿动关闭它。 根据定时器回调函数执⾏的上下⽂环境，定时器还可以分为两种模式： 硬件模式 (HARD_TIMER)：定时器的回调函数在中断上下⽂中执⾏就像闹钟响起时你⽴刻跳起来⼀样它反应⾮常快，但要求处理时间短。 软件模式 (SOFT_TIMER)：回调函数在系统的 timer 线程中执⾏，相当于有⼈提醒你“闹钟响了”，然后你再去执⾏⼀些动作。这个模式可以做更复杂的操作，因为它不是在中断中执⾏。 控制定时器通过该函数你可以随时改变定时器触发方式以及定时器时间 高精度延时使用该函数可以实现微妙级的精确延时，适合高精度时间控制场合 线程创建 name：线程名字 entry：线程入口函数 parameter：传递给线程的参数 stack_size：线程栈大小 priority：线程优先级 tick：时间片 详细步骤 声明一个pcb结构体 static rt_thread_t tid1 = RT_NULL; 编写线程入口函数 static void thread1_entry(void *parameter)，参数为必需，其为传递给线程的参数 利用rt_thread_create函数赋值给所声明的pcb结构体tid1 利用rt_thread_startup(tid1)函数启动线程 实现示例123456789101112131415161718static void thread1_proc(void *parameter)&#123; while(1) &#123; /*实际功能*/ rt_thread_mdelay(1000);//休息1秒 &#125;&#125;int thread1_init(void)&#123; rt_thread_t tid1 = rt_thread_create(&quot;thread1_proc&quot;,thread1_proc,RT_NULL,1024,10,20); if(tid1 != RT_NULL) &#123; rt_thread_startup(tid1); &#125; return RT_EOK;&#125;INIT_COMPONENT_EXPORT(thread1_init); //用这个宏就不需要另外再去注册 rt_thread_mdelay(1000)的工作机制： 1、当 rt_thread_mdelay 被调⽤时，当前线程会进⼊ RT_THREAD_SUSPEND 状态（挂起状态）。 2、调度器开始运⾏其他优先级相同或更⾼的线程。 3、 延时时间结束后，线程从 挂起状态 转变为 就绪状态 ，等待系统再次调度该线程。 PS：若此时无其他线程，则CPU就处于释放状态 线程间同步信号量信号量可以理解为电影院的座位数（资源数量）。当所有座位都满了，新的观众（线程）就需要等前⾯的观众离开（释放资源）才能进⼊。当有空位时，观众可以进⼊。信号量通过控制资源的数量来管理多个线程对资源的访问 工作机制 获取信号量：当资源可⽤时，线程可以获取信号量，信号量的值减1。如果信号量的值为0，线程就会等待，直到资源释放 释放信号量：使⽤完资源后，线程释放信号量，信号量的值加1，允许其他线程访问资源 创建信号量1234/*动态分配内存并创建信号量*/rt_sem_t rt_sem_create(const char *name, rt_uint32_t value, rt_uint8_t flag);/*静态分配内存并创建信号量*/rt_err_t rt_sem_init(rt_sem_t sem, const char *name, rt_uint32_t value,rt_uint8_t flag); 参数说明： name：信号量的名字（可以为 RT_NULL 表⽰匿名信号量）。 value：信号量的初始值，表⽰信号量当前持有的资源数量（例如初始值为 0 表⽰等待事件，为 1 表⽰互斥量，或者更⼤值表⽰资源计数）。 flag：PC 对象的属性标志，常⽤值： RT_IPC_FLAG_PRIO ：优先级等待⽅式，等待线程按照优先级顺序排列。 RT_IPC_FLAG_FIFO ：先⼊先出等待⽅式，等待线程按照进⼊顺序排列。 获取信号量⽤于获取信号量（P 操作），线程会尝试获取信号量，如果信号量的计数值为 0，线程会进⼊等待状态，直到信号量被释放或超时。 1rt_err_t rt_sem_take(rt_sem_t sem, rt_int32_t time); 参数说明： sem：信号量的句柄。 time：超时时间（单位为系统 tick），表⽰最⼤等待时间。如果设置为 RT_WAITING_FOREVER ，线程会⼀直等待 释放信号量⽤于释放信号量（V 操作），增加信号量的计数值，并唤醒等待该信号量的线程。 1rt_err_t rt_sem_release(rt_sem_t sem); 应用示例12345678910111213141516171819202122232425262728293031323334353637#include &lt;rtthread.h&gt;rt_sem_t sem = RT_NULL;void thread1(void *parameter)&#123; rt_kprintf(&quot;线程1：等待线程2发送信号\\n&quot;); /*等待信号量，超时时间为永久等待*/ rt_sem_take(sem,RT_WAITING_FOREVER); rt_kprintf(&quot;线程1：收到线程2的信号，继续执行....\\n&quot;);&#125;void thread2(void *parameter)&#123; rt_kprintf(&quot;线程2：执行一些操作\\n&quot;); /*模拟执行一些动作*/ rt_thread_mdelay(2000); rt_kprintf(&quot;线程2：操作完成，发送信号给线程1\\n&quot;); /*释放信号量 通知线程1*/ rt_sem_release(sem);&#125;int main(void)&#123; rt_thread_t tid1 = RT_NULL; rt_thread_t tid2 = RT_NULL; sem = rt_sem_create(&quot;sem&quot;, 0, RT_IPC_FLAG_PRIO); tid1 = rt_thread_create(&quot;tid1&quot;, thread1, RT_NULL, 1024, 25, 100); tid2 = rt_thread_create(&quot;tid2&quot;, thread2, RT_NULL, 1024, 25, 100); if(tid1 != RT_NULL) rt_thread_startup(tid1); if(tid2 != RT_NULL) rt_thread_startup(tid2); return 0;&#125; 使用场景 任务同步（多任务协调执行顺序） 任务互斥(使用互斥量 保证同一时间只有一个线程 访问公共资源) 事件触发 限量资源管理 互斥量（Mutex）工作机制互斥量确保同⼀时刻只有⼀个线程能够访问共享资源： 获取互斥量：当⼀个线程获取到互斥量时，其他线程不能访问该资源，直到互斥量被释放。 释放互斥量：当线程释放互斥量后，其他等待的线程才能访问资源 创建互斥量1234/*动态创建一个互斥量*/rt_mutex_t rt_mutex_create(const char *name, rt_uint8_t flag);/*静态创建一个互斥量*/rt_err_t rt_mutex_init(rt_mutex_t mutex, const char *name, rt_uint8_t flag); 参数说明： name：互斥量的名字（可以为 RT_NULL 表⽰匿名互斥量）。 flag：IPC 对象的属性标志，通常使⽤ RT_IPC_FLAG_PRIO 表⽰优先级等待。 获取互斥量⽤于获取互斥量，线程通过调⽤此函数进⼊临界区。如果互斥量已经被其他线程获取，当前线程会进⼊等待状态，直到获取成功或超时。 1rt_err_t rt_mutex_take(rt_mutex_t mutex, rt_int32_t time); 参数说明： mutex：互斥量的句柄。 time：超时时间（单位为系统 tick），可以指定等待时⻓或 RT_WAITING_FOREVER表⽰永远等待。 释放互斥量⽤于释放互斥量（V 操作），增加互斥量的计数值，并唤醒等待该互斥量的线程。 1rt_err_t rt_mutex_release(rt_mutex_t mutex); 应用示例123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;rtthread.h&gt;rt_mutex_t mutex = RT_NULL;rt_uint32_t cnt = 0;void thread1(void *parameter)&#123; //rt_kprintf(&quot;线程1：等待线程2发送信号\\n&quot;); while(1) &#123; rt_mutex_take(mutex,RT_WAITING_FOREVER); cnt++; rt_thread_mdelay(1000); rt_kprintf(&quot;线程1 cnt = %d \\n&quot;,cnt); rt_mutex_release(mutex); &#125;&#125;void thread2(void *parameter)&#123; //rt_kprintf(&quot;线程2：执行一些操作\\n&quot;); while(1) &#123; rt_mutex_take(mutex,RT_WAITING_FOREVER); cnt++; rt_thread_mdelay(1000); rt_kprintf(&quot;线程2 cnt = %d \\n&quot;,cnt); rt_mutex_release(mutex); &#125;&#125;int main(void)&#123; rt_thread_t tid1 = RT_NULL; rt_thread_t tid2 = RT_NULL; mutex = rt_mutex_create(&quot;mutex&quot;, RT_IPC_FLAG_PRIO); tid1 = rt_thread_create(&quot;tid1&quot;, thread1, RT_NULL, 1024, 25, 100); tid2 = rt_thread_create(&quot;tid2&quot;, thread2, RT_NULL, 1024, 25, 100); if(tid1 != RT_NULL) rt_thread_startup(tid1); if(tid2 != RT_NULL) rt_thread_startup(tid2); return 0;&#125; 任务同步与任务互斥差异 事件集事件集可以看作公交⻋站的场景。线程可以等待多个事件发⽣，⽐如等待公交⻋或等待同伴到达。如果满⾜某个或某⼏个条件，线程将被唤醒继续执⾏。 工作机制事件集⽤于线程间的同步，可以让线程等待⼀个或多个事件的触发： 逻辑与（AND)：线程等待多个事件同时发⽣才被唤醒。 逻辑或（OR）：线程只需等待其中⼀个事件发⽣即可被唤醒。 创建事件对象1234/*动态创建一个对象*/rt_event_t rt_event_create(const char *name, rt_uint8_t flag);/*静态创建一个对象*/rt_err_t rt_event_init(rt_event_t event, const char *name, rt_uint8_t flag); 参数说明： name：事件对象的名字（可以为 RT_NULL 表⽰匿名事件对象）。 flag：IPC 对象的属性标志，⼀般使⽤ RT_IPC_FLAG_PRIO 表⽰优先级等待，或RT_IPC_FLAG_FIFO 表⽰先进先出等待。 发送(触发)事件1rt_err_t rt_event_send(rt_event_t event, rt_uint32_t set); 参数说明： event：事件对象的句柄。 set：事件标志，设置哪⼏位事件标志被触发 可以⽤ 1 &lt;&lt; n 来表⽰第 n 位的事件。 接收(等待)事件1rt_err_t rt_event_recv(rt_event_t event, rt_uint32_t set, rt_uint8_t option, rt_int32_t timeout, rt_uint32_t *recved); 参数说明： event：事件对象的句柄。 set：需要等待的事件标志 例如 1 &lt;&lt; 3 | 1 &lt;&lt; 5 表⽰同时等待第3位和第5位的事件 option ：等待选项，常⻅选项包括： RT_EVENT_FLAG_AND ：所有指定的事件标志都满⾜时才唤醒线程。 RT_EVENT_FLAG_OR ：只要有⼀个指定的事件标志满⾜就唤醒线程。 RT_EVENT_FLAG_CLEAR ：收到事件标志后清除这些事件标志。 timeout ：超时时间（单位为系统 tick），可以为 RT_WAITING_FOREVER 表⽰永远等待。 recved ：输出参数，返回实际接收到的事件标志 应用示例12345678910111213141516171819202122232425262728293031323334#include &lt;rtthread.h&gt;rt_event_t event = RT_NULL;/*线程1：等待事件*/void thread1(void *parameter)&#123; rt_uint32_t recei; rt_kprintf(&quot;线程1：等待公交车3或5到来...\\n&quot;); rt_event_recv(event, (1 &lt;&lt; 3 | 1 &lt;&lt; 5), RT_EVENT_FLAG_OR | RT_EVENT_FLAG_CLEAR, RT_WAITING_FOREVER, &amp;recei); rt_kprintf(&quot;线程1：公交车 %d 到站，出发！....\\n&quot;,recei);&#125;/*线程2：发送事件（公交车到站）*/void thread2(void *parameter)&#123; rt_thread_mdelay(1000);//模拟公交车到站 rt_kprintf(&quot;线程2：公交车3到站\\n&quot;); rt_event_send(event, (1 &lt;&lt; 3));&#125;int main(void)&#123; rt_thread_t tid1 = RT_NULL; rt_thread_t tid2 = RT_NULL; event = rt_event_create(&quot;event&quot;, RT_IPC_FLAG_PRIO); tid1 = rt_thread_create(&quot;tid1&quot;, thread1, RT_NULL, 1024, 25, 100); tid2 = rt_thread_create(&quot;tid2&quot;, thread2, RT_NULL, 1024, 25, 100); if(tid1 != RT_NULL) rt_thread_startup(tid1); if(tid2 != RT_NULL) rt_thread_startup(tid2); return 0;&#125; 线程间通信裸机编程中经常使用全局变量进行功能间的通信（标志）：某些功能由于特定的操作改变全局变量的值，另一个功能对此全局变量进行读取，根据读取到的全局变量执行相应的操作来达到通信协作的目的。RTT提供了邮箱、消息队列和信号等工具来完成这样的类似操作 邮箱工作机制邮箱的特点：开销低、效率高、支持一对多 邮箱中一封邮件只能容纳固定的4字节信息（针对32位操作系统，指针大小为4字节，一封邮件恰好能容纳一个指针），所以典型的邮箱也被称为交换消息 一般如果邮箱中存在邮件且收取邮件时的超时时间为0，邮件的收取过程是非阻塞的 但邮箱中不存在邮件且超时时间不为0时，邮件收取过程就是阻塞的，邮件收取阻塞的情况下只能由线程进行邮件的收取。 邮件发送阻塞：一个线程向邮箱发送邮件时： 如果邮箱未满，则把邮件复制到邮箱中 如果邮箱已满，则发送线程挂起并等待邮箱有空间时将其唤醒再发送邮件 或 直接返回-RT_EFULL 邮件接收阻塞：一个线程从邮箱中接收邮件时： 如果邮箱已空，接收线程可以挂起直到收到新的邮件被唤醒 也可以设置超时时间并进行等待 如果达到设置的超时时间但邮箱仍未收到邮件时，超时线程将被唤醒并返回-RT_ETIMEOUT； 如果邮箱中存在邮件，则接收线程赋值邮箱中的邮件到接收缓存 创建邮箱1234/*创建动态邮箱*/rt_mailbox_t rt_mb_create (const char* name, rt_size_t size, rt_uint8_t flag);/*创建静态邮箱*/rt_err_t rt_mb_init(rt_mailbox_t mb,const char* name,void* msgpool,rt_size_t size,rt_uint8_t flag) 参数说明： mb：邮箱对象的句柄。 name：邮箱容量(几封邮件) size ：邮箱容量(几封邮件)。 flag ：邮箱标志，它可以取如下数值：一般除非应用程序非常在意先来后到，不然都采用PRIO确保线程实时性 RT_IPC_FLAG_FIFO ：非实时调度方式 先来后到 RT_IPC_FLAG_PRIO ：实时调度方式 优先级 msgpool ：缓冲区指针。 recved ：输出参数，返回实际接收到的事件标志 删除或脱离邮箱123456/*删除动态邮箱create*/rt_err_t rt_mb_delete (rt_mailbox_t mb);/*删除静态邮箱init*/rt_err_t rt_mb_detach(rt_mailbox_t mb);//返回值：RT_EOK 成功 参数说明： mb：邮箱对象的句柄。 调用删除函数时，内核会先唤醒所有挂在该邮箱上的线程（线程返回值是RT_ERROR），然后再释放邮箱使用的内存，最后删除邮箱对象 发送邮件123456789101112131415161718192021222324/*1.直接发送邮件*//*！！！！！记得value需要强转rt_uint32_t！！！！！*/rt_err_t rt_mb_send (rt_mailbox_t mb, rt_uint32_t value);/**************返回值*****************/RT_EOK 发送成功-RT_EFULL 邮箱已经满了/*2.等待方式发送邮件*//*@note 若邮箱已满，则根据设定的timeout等待邮箱中因为收取邮件而空出空间/*@note 若超时时间到达依然没有空出时间，此时发送线程被唤醒并返回错误码*/rt_err_t rt_mb_send_wait (rt_mailbox_t mb,rt_uint32_t value,rt_int32_t timeout);/**************返回值*****************/RT_EOK 发送成功-RT_ETIMEOUT 超时-RT_ERROR 失败，返回错误/*3.发送紧急邮件*//*@note 发送紧急邮件时，邮件被直接插队放入了邮件队首,这样就能最优先接收到并做出处理*/rt_err_t rt_mb_urgent (rt_mailbox_t mb, rt_ubase_t value);/**************返回值*****************/RT_EOK 发送成功-RT_EFULL 邮箱已满 参数说明： mb：邮箱对象的句柄。 value ：发送的邮件内容。 timeout ：超时时间。 接收邮件123456789/*@note 只有当接收者接收的邮箱中有邮件时，接收者才能立即取到邮件并返回 RT_EOK 的返回值否则接收线程会根据超时时间设置，或挂起在邮箱的等待线程队列上，或直接返回。！！！！！记得value需要强转rt_uint32_t！！！！！*/rt_err_t rt_mb_recv (rt_mailbox_t mb, rt_uint32_t* value, rt_int32_t timeout);/**************返回值*****************/RT_EOK 接收成功-RT_ETIMEOUT 超时-RT_ERROR 失败，返回错误 参数说明： mb：邮箱对象的句柄。 value ：邮件内容(定义一个变量来接收 记得强转) timeout ：超时时间。 应用示例12345678910111213141516171819202122232425262728293031323334353637#include &lt;rtthread.h&gt;/*创建邮箱*/rt_mailbox_t mb;/*线程1：发送邮箱*/void thread_entry1(void *parameter)&#123; char msg = &#x27;A&#x27;;//发送&#x27;A&#x27;作为邮件 rt_kprintf(&quot;线程1：发送邮件...\\n&quot;); //发送邮件 因为邮箱固定4字节 所以需要强转 rt_mb_send(mb, (rt_uint32_t)msg);&#125;/*线程2：接收邮件*/void thread_entry2(void *parameter)&#123; char msg; rt_kprintf(&quot;线程2：等待接收邮件...\\n&quot;); //若邮箱内为空 则执行的是阻塞式的等待接收邮件 rt_mb_recv(mb, (rt_uint32_t)&amp;msg, RT_WAITING_FOREVER);//接收邮件 rt_kprintf(&quot;线程2：收到邮件：%c\\n&quot;,msg);&#125;int main(void)&#123; /*创建一个容量为4的4封邮箱(大小为4*4)) */ mb = rt_mb_create(&quot;mb&quot;, 4, RT_IPC_FLAG_PRIO); /*创建两个线程 */ rt_thread_t tid1 = rt_thread_create(&quot;t1&quot;, thread_entry1, RT_NULL, 1024, 10, 10); rt_thread_t tid2 = rt_thread_create(&quot;t2&quot;, thread_entry2, RT_NULL, 1024, 10, 10); /* 启动线程 */ rt_thread_startup(tid1); rt_thread_startup(tid2); return 0;&#125; 消息队列消息队列是另一种常用的线程间通讯方式，是邮箱的扩展。他可以动态分配内存，对比邮箱局限的4字节存储特性，更适合用来传输复杂大量数据或进行任务队列管理 工作机制创建消息队列1234567/*创建动态消息队列*/rt_mq_t rt_mq_create(const char* name, rt_size_t msg_size,rt_size_t max_msgs, rt_uint8_t flag);/*创建静态消息队列*//*@note 一般放于读数据段或未初始化数据段中。在使用这类静态消息队列对象前，需要进行初始化*/rt_err_t rt_mq_init(rt_mq_t mq, const char* name,void *msgpool,rt_size_t msg_size,rt_size_t pool_size, rt_uint8_t flag); 参数说明： name ：消息队列的名称。 msg_size ：消息队列中一条消息的最大长度，单位字节。 msg_msgs：消息队列的最大个数(消息个数)。 flag ：消息队列采用的等待方式，它可以取如下数值：一般除非应用程序非常在意先来后到，不然都采用PRIO确保线程实时性 RT_IPC_FLAG_FIFO：非实时调度方式 先来后到 RT_IPC_FLAG_PRIO：实时调度方式 优先级 mq ：消息队列对象的句柄。 msgpool：指向存放消息的缓冲区的指针。 pool_size ：存放消息的缓冲区大小 删除或脱离消息队列12345/*删除动态消息队列create*/rt_err_t rt_mq_delete(rt_mq_t mq);/*删除静态消息队列init*/rt_err_t rt_mq_detach(rt_mq_t mq);//返回值：RT_EOK 成功 参数说明： mq：消息队列对象的句柄 删除消息队列时，如果有线程被挂起在该消息队列等待队列上，则内核先唤醒挂起在该消息等待队列上的所有线程（线程返回值是 - RT_ERROR），然后再释放消息队列使用的内存，最后删除消息队列对象 发送消息12345678910111213141516171819202122232425/*1.直接发送消息*/rt_err_t rt_mq_send (rt_mq_t mq, void* buffer, rt_size_t size);/**************返回值*****************/RT_EOK 发送成功-RT_EFULL 消息队列已经满了-RT_ERROR 失败(发送消息长度&gt;队列的最大长度)/*2.等待方式发送消息*//*@note 若消息队列已满，则根据设定的timeout等待/*@note 若超时时间到达依然没有空出时间，此时发送线程被唤醒并返回错误码*/rt_err_t rt_mq_send_wait(rt_mq_t mq,const void *buffer,rt_size_t size,rt_int32_t timeout);/**************返回值*****************/RT_EOK 发送成功-RT_ETIMEOUT 超时-RT_ERROR 失败(发送消息长度&gt;队列的最大长度)/*3.发送紧急消息*//*@note 发送紧急消息时，邮件被直接插队放入了消息队列队首,这样就能最优先接收到并做出处理*/rt_err_t rt_mq_urgent(rt_mq_t mq, void* buffer, rt_size_t size);/**************返回值*****************/RT_EOK 发送成功-RT_EFULL 消息队列已经满了-RT_ERROR 失败(发送消息长度&gt;队列的最大长度) 参数说明： mq：消息队列对象的句柄 buffer ：发送的消息内容。 size ：消息大小。 timeout ：超时时间。 接收消息12345678/*@note 只有当消息队列中有消息时，接收者才能立即取到邮件并返回 RT_EOK 的返回值否则接收线程会根据超时时间设置，或挂起在邮箱的等待线程队列上，或直接返回。*/rt_ssize_t rt_mq_recv (rt_mq_t mq, void* buffer,rt_size_t size,rt_int32_t timeout);/**************返回值*****************/RT_EOK 成功收到-RT_ETIMEOUT 超时-RT_ERROR 失败，返回错误 参数说明： mq：消息队列对象的句柄 buffer ：发送的消息内容。 size ：消息大小。 timeout ：超时时间 应用示例1234567891011121314151617181920212223242526272829303132333435363738#include &lt;rtthread.h&gt;/*创建消息队列*/rt_mq_t mq;/*线程1：发送消息*/void thread_entry1(void *parameter)&#123; char msg[] = &quot;Hello, RT-Thread!&quot;;//发送&#x27;A&#x27;作为邮件 rt_kprintf(&quot;线程1：发送消息...\\n&quot;); //发送消息到消息队列 rt_mq_send(mq, msg,sizeof(msg));&#125;/*线程2：接收邮件*/void thread_entry2(void *parameter)&#123; char buffer[32]; rt_kprintf(&quot;线程2：等待接收消息...\\n&quot;); //若消息队列内无消息 则执行的是阻塞式的等待接收消息 rt_mq_recv(mq, buffer,sizeof(buffer), RT_WAITING_FOREVER);//接收消息 rt_kprintf(&quot;线程2：收到消息：%s\\n&quot;,buffer);&#125;int main(void)&#123; /*创建一个消息队列，容量为4，消息大小为32字节 */ mq = rt_mq_create(&quot;mq&quot;, 32, 4, RT_IPC_FLAG_PRIO); /*创建两个线程 */ rt_thread_t tid1 = rt_thread_create(&quot;t1&quot;, thread_entry1, RT_NULL, 1024, 10, 10); rt_thread_t tid2 = rt_thread_create(&quot;t2&quot;, thread_entry2, RT_NULL, 1024, 10, 10); /* 启动线程 */ rt_thread_startup(tid1); rt_thread_startup(tid2); return 0;&#125; 信号信号（又称为软中断信号），在软件层次上是对中断机制的一种模拟。常用于通知线程发生了某个事件。线程收到信号时会根据信号类型执行相应的操作 与消息队列区别： 信号仅携带控制信息，不包含数据 信号不保证顺序性，信号发生时立即通知线程 消息队列则有顺序性（通常是PRIO） 工作机制线程中安装信号123456789/*t_sighandler_t[] 表示一个函数指针数组t_sighandler_t handler[] 是一个 变量声明二者是不一样的！*/rt_sighandler_t rt_signal_install(int signo, rt_sighandler_t[] handler);/**************返回值*****************/SIG_ERR 错误的信号安装信号前的handler值 成功 参数说明： signo ：信号值（只有 SIGUSR1 和 SIGUSR2 是开放给用户使用的）。 buffer ：发送的消息内容。 handler ：设置对信号值的处理方式。 在信号安装时设定 handler 参数，决定了该信号的不同的处理方法。处理方法可以分为三种： 类似中断的处理方式，参数指向当信号发生时用户自定义的处理函数， 在内部写入处理方式，由该函数来处理。 参数设为 SIG_IGN，忽略某个信号，对该信号不做任何处理，就像未发生过一样。 参数设为 SIG_DFL，系统会调用默认的处理函数_signal_default_handler()。 阻塞信号与解除阻塞123456/*信号阻塞(屏蔽信号) 该信号不会递答安装此信号的线程*/void rt_signal_mask(int signo);/*解除信号阻塞使用此函数可以对其中一些信号给予 “关注”，那么发送这些信号都会引发该线程的软中断*/void rt_signal_unmask(int signo); 参数说明： signo：信号值 发送信号12345/*需要异常处理时，可以给安装了信号的线程发送信号*/int rt_thread_kill(rt_thread_t tid, int sig);/**************返回值*****************/RT_EOK 发送成功-RT_EINVAL 参数错误 参数说明： tid：接收信号的线程。 sig ：信号值。 应用示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;rtthread.h&gt;#define THREAD_PRIORITY 25#define THREAD_STACK_SIZE 512#define THREAD_TIMESLICE 5static rt_thread_t tid1 = RT_NULL;/* 线程 1 的信号处理函数 */void thread1_signal_handler(int sig)&#123; rt_kprintf(&quot;thread1 received signal %d\\n&quot;, sig);&#125;/* 线程 1 的入口函数 */static void thread1_entry(void *parameter)&#123; int cnt = 0; /* 安装信号 */ rt_signal_install(SIGUSR1, thread1_signal_handler); rt_signal_unmask(SIGUSR1); /* 运行 10 次 */ while (cnt &lt; 10) &#123; /* 线程 1 采用低优先级运行，一直打印计数值 */ rt_kprintf(&quot;thread1 count : %d\\n&quot;, cnt); cnt++; rt_thread_mdelay(100); &#125;&#125;/* 信号示例的初始化 */int signal_sample(void)&#123; /* 创建线程 1 */ tid1 = rt_thread_create(&quot;thread1&quot;,thread1_entry, RT_NULL,THREAD_STACK_SIZE, THREAD_PRIORITY, THREAD_TIMESLICE); if (tid1 != RT_NULL) rt_thread_startup(tid1); rt_thread_mdelay(300); /* 发送信号 SIGUSR1 给线程 1 */ rt_thread_kill(tid1, SIGUSR1); return 0;&#125; 框架移植12345//bsp_system.h中引入以下四个头文件#include &lt;rtthread.h&gt;#include &lt;rtdevice.h&gt;#include &lt;drv_common.h&gt;#include &lt;board.h&gt; 系统初始化宏定义​ 123456789101112/*1、板级初始化 fn为函数指针*/INIT_BOARD_EXPORT(fn)/*2、纯软件函数初始化 fn为函数指针*/INIT_PREV_EXPORT(fn)/*3、设备自动初始化，fn为函数指针*/INIT_DEVICE_EXPORT(fn)/*4、组件自动初始化，fn为函数指针*/INIT_COMPONENT_EXPORT(fn)/*5、系统环境自动初始化，fn为函数指针*/INIT_ENV_EXPORT(fn) /*6、应用自动初始化，fn为函数指针*/INIT_APP_EXPORT(fn) ESP8266移植 将uart_app.c与uart_app.h移去 不使用！！！然后RTT打开控制台输出rt_kprintf，选择串口1 直接编译开启终端 下载观察现象，出现以下信息则连接成功 ​ DHT11移植组件添加​ proc代码构建创建sensor_app.c与.h1234//引入必要库#include &lt;sensor_app.h&gt;#include &lt;sensor.h&gt;#include &quot;sensor_dallas_dht11.h&quot; 注册设备1234567891011121314151617181920rt_device_t dev = RT_NULL;//创建传感器结构体对象struct rt_sensor_data sensor_data;rt_uint8_t get_data_freq = 1;///默认1hzrt_size_t res;//返回值 如RT_EOK /*注册传感器*/dev = rt_device_find(&quot;temp_dht11&quot;);//注意此处注册需要有前缀 如temp_(在sensor.c中)if(dev == RT_NULL)&#123; rt_kprintf(&quot;Not Found\\r\\n&quot;); return;&#125;if(rt_device_open(dev, RT_DEVICE_FLAG_RDWR) != RT_EOK)&#123; rt_kprintf(&quot;Open Error\\r\\n&quot;); return;&#125; rt_device_control(dev, RT_SENSOR_CTRL_SET_ODR, (void *)&amp;get_data_freq); 读取传感器数据123456789101112131415161718192021/*读取传感器*/ while(1) &#123; res = rt_device_read(dev, 0, &amp;sensor_data, 1);//第0位开始读一个 //读错了返回0 if(res == 0) &#123; rt_kprintf(&quot;Read Error Res:%d&quot;,res);//返回读取错误编号0 return; &#125; else //读取成功 &#123; if(sensor_data.data.temp &gt;= 0) //数据大于等于0 包括了温度与湿度 &#123; uint8_t temp = (sensor_data.data.temp &amp; 0xffff); uint8_t humi = (sensor_data.data.temp &amp; 0xffff0000) &gt;&gt; 16; rt_kprintf(&quot;temp:%d humi:%d\\r\\n&quot;,temp,humi); &#125; &#125; rt_thread_delay(1000); &#125; init代码构建123456789101112131415int sensor_init(void)&#123; struct rt_sensor_config cfg;//操作集结构体 /*注册设备 配置接口*/ cfg.intf.user_data = (void *)DHT11_PIN;//配置接口为IO口 rt_hw_dht11_init(&quot;dht11&quot;, &amp;cfg); rt_thread_t sensor_thread = rt_thread_create(&quot;sensor_proc&quot;, sensor_proc, RT_NULL, 1024, 10, 20); if(sensor_thread != RT_NULL) &#123; rt_thread_startup(sensor_thread); &#125; return RT_EOK;&#125;INIT_COMPONENT_EXPORT(sensor_init);","categories":[{"name":"MCU","slug":"MCU","permalink":"https://mextra.netlify.app/categories/MCU/"}],"tags":[{"name":"RTOS","slug":"RTOS","permalink":"https://mextra.netlify.app/tags/RTOS/"},{"name":"实时操作系统","slug":"实时操作系统","permalink":"https://mextra.netlify.app/tags/%E5%AE%9E%E6%97%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"RT_Thread","slug":"RT-Thread","permalink":"https://mextra.netlify.app/tags/RT-Thread/"}]},{"title":"git命令(用于hexo clean之后的处理)","slug":"git","date":"2025-05-20T14:18:09.000Z","updated":"2025-07-09T03:45:36.978Z","comments":true,"path":"2025/05/20/git/","permalink":"https://mextra.netlify.app/2025/05/20/git/","excerpt":"","text":"连接远程仓库123git initgit remote add origin [dizhi]git checkout -b main 推送代码123git add .git commit -m &quot;&quot;git push --force origin main #后续可以直接用git push 如何建立一个多人写作的git仓库？1. 新建Git仓库 在本地创建仓库： 123mkdir my_projectcd my_projectgit init 或者在GitHub&#x2F;GitLab等平台创建仓库：如果你使用的是GitHub、GitLab等托管服务，可以直接在网页端创建仓库，然后克隆到本地： 12git clone https://github.com/your-username/my_project.gitcd my_project 2. 他人参与协作 邀请他人访问仓库： 如果是GitHub，可以在仓库设置中添加协作者（Collaborator）。 如果是GitLab，可以在项目成员管理中添加成员。 他人克隆仓库： 12git clone https://github.com/your-username/my_project.gitcd my_project 3. 他人创建分支并上传代码 他人创建分支： 1git checkout -b fenzhiname fenzhinamme指的是自定义分支名 他人修改代码并提交： 12git add .git commit -m &quot;Add new feature&quot; 他人将分支推送到远程仓库： 1git push origin fenzhiname 4. 你合并分支 同步并重置 main： 123git fetch origingit checkout maingit reset --hard origin/main 合并： 1git merge origin/wpy_app --allow-unrelated-histories 解决冲突（如果有）并推送： 1git push origin main","categories":[],"tags":[{"name":"git","slug":"git","permalink":"https://mextra.netlify.app/tags/git/"}]},{"title":"音响实习の学习笔记","slug":"音响实习","date":"2025-05-19T04:08:26.000Z","updated":"2025-09-17T04:21:55.058Z","comments":true,"path":"2025/05/19/音响实习/","permalink":"https://mextra.netlify.app/2025/05/19/%E9%9F%B3%E5%93%8D%E5%AE%9E%E4%B9%A0/","excerpt":"","text":"麦克风-话筒分类 类型 优点 缺点 典型用途 动圈话筒 耐用、抗啸叫、便宜 灵敏度低、高频细节少 现场演出、演讲、鼓麦克风 电容话筒 高解析度、瞬态响应好 易受潮、需外部供电 录音棚、人声、乐器收音 USB 话筒 即插即用、内置声卡 延迟较高、不可扩展 直播、播客、家庭录音 领夹话筒 隐蔽、解放双手 易摩擦衣物产生噪音 视频拍摄、舞台剧 枪式话筒 远距离定向拾音 环境反射影响音质 影视同期声、户外采访 核心参数频率响应（麦克风对不同频率声音的灵敏度变化曲线）： 理想范围：人声录制建议 80Hz-15kHz，乐器需更宽（如 20Hz-20kHz）。 曲线特性：平直曲线适合真实还原，高频提升（如 AKG C414）可增强人声明亮度。 灵敏度（Sensitivity） 单位：mV&#x2F;Pa 或 dBV（如-32dB &gt; -40dB，数值越高越灵敏）。 高灵敏度：电容麦适合细节捕捉，但易收环境噪音；一般在-30dB到-40dB 低灵敏度：动圈麦抗噪强，适合现场演出。一般在-54dB到-60dB 重要规律：▶ 每增加 6dB，灵敏度翻倍（-38dB 比-44dB 灵敏 2 倍） 指向性（Polar Pattern) 心形（Cardioid）：最常用，抑制后方噪音，适合独唱&#x2F;演讲。像&quot;手电筒光斑&quot;，正前方收音最强 超心形（Supercardioid）：定向更强，适合嘈杂环境或远距离拾音。光束更窄，但后方会出现&quot;小耳朵&quot;（微弱拾音区） 全向（Omni）：360° 拾音，适合会议或合唱，但需安静环境。像&quot;灯泡发光&quot;，360°均匀拾音 血泪教训： 室内直播用 心形→ 抑制显示器风扇噪音 街头采访用 超心形→ 对抗环境噪音 最大声压级（Max SPL） 动圈麦（如 Shure SM58）可承受 150dB，适合高音量乐器（如鼓）；电容麦通常 120-130dB，需注意过载。 普通说话&#x2F;弹唱：100dB 足够隐藏陷阱：某些电容麦标称高 SPL，但需要开启-10dB 衰减档（实质是压缩动态） 信噪比（SNR） 假设麦克风输出信号 -32dB，底噪 -82dB 信噪比 &#x3D; 50dB（-32 - (-82)） &gt;70dB 为佳，数值越高背景噪音越少。60dB以上：专业级（几乎无底噪） 50dB以下：能听到明显&quot;嘶嘶&quot;声 阻抗（Impedance） 麦克风输出阻抗 ≤200Ω 为低阻（适合长线缆传输）阻抗越低，音量越小，音质越好。阻抗越高，音量越大，但容易失真 输入设备阻抗需 ≥5 倍麦克风阻抗（如麦克风 200Ω→ 声卡输入要 1kΩ）常见翻车现场：高阻麦克风（600Ω）接普通声卡 → 声音发闷&#x2F;音量小 终极避坑口诀 频响看曲线，灵敏看负数指向分角度，声压看极限信噪比 60 起，阻抗要低阻找 U 型麦克风（低频不容易影响） 采购清单 阻抗300Ω 心形 话筒链接 频响范围（Hz） 阻抗（单位Ω） 指向性 信噪比(单位dB) 灵敏度 续航时长(单位h) 价格（一拖二） 2.4g无线麦克风万能防啸叫 舞台k歌充电话筒声卡直播麦克风跨境 - 阿里巴巴 100-20kHz 300 心形 ≥75dB 12 102.7+3（109高配好音质） 无线麦克风家用K歌金属U段一拖二音响直播声卡录音高音质充电话筒 - 阿里巴巴 100-20kHz 心形 ≥70db 6-8h(含) 95+8 跨境无线麦克风话筒U段直播防啸叫一拖二ktv家用唱歌专用无线话筒 - 阿里巴巴 100-20kHz 600Ω 心型 ≥85dB 1-3h(含) 68+5 全金属U段无线话筒一拖二KTV家用唱歌声卡直播功放音响通用麦克风 - 阿里巴巴 30-20kHz 心型 &gt;95dB 3-6h(含) 145+5 无线麦克风充电防啸叫 户外声卡直播麦克风家用音响k歌舞台话筒 - 阿里巴巴 80Hz-15kHz 心型 &gt;60dB -70dB 70.2+3（VHF方案）","categories":[{"name":"实习知识","slug":"实习知识","permalink":"https://mextra.netlify.app/categories/%E5%AE%9E%E4%B9%A0%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"音响","slug":"音响","permalink":"https://mextra.netlify.app/tags/%E9%9F%B3%E5%93%8D/"},{"name":"实习","slug":"实习","permalink":"https://mextra.netlify.app/tags/%E5%AE%9E%E4%B9%A0/"},{"name":"音频技术","slug":"音频技术","permalink":"https://mextra.netlify.app/tags/%E9%9F%B3%E9%A2%91%E6%8A%80%E6%9C%AF/"}]}],"categories":[{"name":"MCU","slug":"MCU","permalink":"https://mextra.netlify.app/categories/MCU/"},{"name":"实习知识","slug":"实习知识","permalink":"https://mextra.netlify.app/categories/%E5%AE%9E%E4%B9%A0%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"RTOS","slug":"RTOS","permalink":"https://mextra.netlify.app/tags/RTOS/"},{"name":"ESP32","slug":"ESP32","permalink":"https://mextra.netlify.app/tags/ESP32/"},{"name":"LVGL v8.2","slug":"LVGL-v8-2","permalink":"https://mextra.netlify.app/tags/LVGL-v8-2/"},{"name":"嵌入式基础","slug":"嵌入式基础","permalink":"https://mextra.netlify.app/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%9F%BA%E7%A1%80/"},{"name":"实时操作系统","slug":"实时操作系统","permalink":"https://mextra.netlify.app/tags/%E5%AE%9E%E6%97%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"FreeRTOS","slug":"FreeRTOS","permalink":"https://mextra.netlify.app/tags/FreeRTOS/"},{"name":"C语言高级","slug":"C语言高级","permalink":"https://mextra.netlify.app/tags/C%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7/"},{"name":"电赛准备","slug":"电赛准备","permalink":"https://mextra.netlify.app/tags/%E7%94%B5%E8%B5%9B%E5%87%86%E5%A4%87/"},{"name":"GD32学习","slug":"GD32学习","permalink":"https://mextra.netlify.app/tags/GD32%E5%AD%A6%E4%B9%A0/"},{"name":"TI","slug":"TI","permalink":"https://mextra.netlify.app/tags/TI/"},{"name":"RT_Thread","slug":"RT-Thread","permalink":"https://mextra.netlify.app/tags/RT-Thread/"},{"name":"git","slug":"git","permalink":"https://mextra.netlify.app/tags/git/"},{"name":"音响","slug":"音响","permalink":"https://mextra.netlify.app/tags/%E9%9F%B3%E5%93%8D/"},{"name":"实习","slug":"实习","permalink":"https://mextra.netlify.app/tags/%E5%AE%9E%E4%B9%A0/"},{"name":"音频技术","slug":"音频技术","permalink":"https://mextra.netlify.app/tags/%E9%9F%B3%E9%A2%91%E6%8A%80%E6%9C%AF/"}]}