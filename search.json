[{"title":"linux","url":"/2025/09/23/linux/"},{"title":"ESP32学习","url":"/2025/09/09/ESP32学习/","content":"\n## ESP32环境搭建\n\n### WSL2安装与配置\n\n推荐查阅官方文档说明：[安装 WSL | Microsoft Learn](https://learn.microsoft.com/zh-cn/windows/wsl/install)\n\n#### 手动下载安装包\n\n1. 访问 WSL 的 GitHub Releases 页面 https://github.com/microsoft/WSL/releases\n\n2. 查找并下载最新版本的 .msi 安装包（例如 wsl.2.1.5.0.x64.msi）\n\n![image-20250909111242531](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091112594.png)\n\n#### 配置控制面板\n\n![image-20250909111552848](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091115919.png)\n\n![image-20250909111621317](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091116357.png)\n\n> 有些Windows 11新系统会没有`虚拟机平台`这个选项 没有关系！！！！\n>\n> 配置完后重新启动电脑\n\n#### 管理员身份运行Windows PowerShell\n\n![img](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091108898.png)\n\n#### 安装Ubuntu\n\n```bash\nwsl --install\n```\n\n![img](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091108464.png)\n\n> 如有可选 则选择Uuntu 如 `wsl --install -d Ubuntu`\n\n#### 等待安装完成后重启电脑打开Ubuntu\n\n![image-20250909112101810](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091121963.png)\n\n#### 输入账号密码\n\n![img](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091121306.png)\n\n#### 更新软件源\n\n```bash\nsudo apt update\n```\n\n![img](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091124279.png)\n\n#### 更新完后输入下方指令，下载espidf依赖库和工具\n\n> ```bash\n> sudo apt-get install git wget flex bison gperf python3 python3-pip python3-venv cmake ninja-build ccache libffi-dev libssl-dev dfu-util libusb-1.0-0\n> ```\n\n![img](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091126525.png)\n\n#### 输入y\n\n![image-20250909112720315](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091127364.png)\n\n### VScode配置\n\n#### 选择连接到WSL\n\n![img](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091129218.png)\n\n#### 插件安装\n\n> - 安装`Chinese`插件\n> - 安装`C/C++`插件\n> - 安装`ESP-IDF`插件\n\n#### 在linux账户新建文件用于存放espidf内容，方便后续管理\n\n![image-20250909113527188](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091135250.png)\n\n#### ESP-IDF安装\n\n![img](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091131190.png)\n\n#### 在安装路径中选择自己新建的文件夹\n\n![img](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091135132.png)\n\n> 如果出现下图这个情况\n>\n> ![img](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091137839.png)\n>\n> 那就运行一下下面的指令 \n>\n> ```bash\n> sudo chown -R $USER:$USER /home/你的用户名/你的IDF文件名/\n> chmod -R 755 /home/你的用户名/你的IDF文件名/\n> ```\n\n#### 安装完成之后先搞个工程测试一下编译能不能正常\n\n![img](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091140479.png)\n\n#### 选择文件夹来存放代码\n\n![img](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091143918.png)\n\n![img](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091143292.png)\n\n#### 设置环境\n\n##### 设置IDF_tools环境（豆包四条命令搞定）\n\n> 注意下方命令中：\n>\n> `~/ESP_IDF/v5.5.1/esp-idf`：你的IDF文件夹路径 要一直引入到`esp-idf`\n>\n> `~/ESP_IDF/Tools`：你的IDF_Tools文件夹路径\n\n```bash\necho 'export IDF_PATH=~/ESP_IDF/v5.5.1/esp-idf' >> ~/.bashrc\necho 'export IDF_TOOLS_PATH=~/ESP_IDF/Tools' >> ~/.bashrc\necho 'source ~/ESP_IDF/v5.5.1/esp-idf/export.sh' >> ~/.bashrc\nsource ~/.bashrc  # 立即生效\n```\n\n> 成功的话 重启`vscode`就会自动出现`idf`的命令\n>\n> ![image-20250909221836025](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509092218229.png)\n\n##### 若上面还不行 则根据报错情况执行下面\n\n###### 场景 1：运行 `./export.sh` 时报 “Python 虚拟环境不存在”\n\n`报错信息`\n\n```bash\nERROR: ESP-IDF Python virtual environment \"$HOME/ESP_IDF/Tools/python_env/idf5.5_py3.12_env/bin/python\" not found. Please run the install script to set it up before proceeding.\n```\n\n`原因`\n\n未执行 ESP-IDF 安装脚本，Python 虚拟环境未创建。\n\n`解决方案`\n\n必须先运行安装脚本，自动创建虚拟环境和安装依赖：\n\n```bash\n# 进入 ESP-IDF 根目录（替换为你的实际路径）\ncd ~/ESP_IDF/v5.5.1/esp-idf\n# 执行安装脚本（Linux/macOS 用 install.sh，Windows 用 install.bat）\n./install.sh\n# 安装完成后再执行 export.sh 导出环境\n. ./export.sh\n```\n\n###### 场景 2：运行 `./install.sh` 时 “下载工具包卡住”\n\n`报错表现`\n\n安装过程中卡在某一工具包下载（如 `riscv32-esp-elf-gdb`），进度条不动或反复重试。\n\n`原因`\n\nESP-IDF 工具包托管在 GitHub，国内网络访问速度慢或不稳定，导致下载中断。\n\n1. **用国内镜像加速（推荐）**\n   配置 `IDF_GITHUB_ASSETS` 环境变量，将下载源切换为 Espressif 国内镜像，无需手动下载：\n\n   ```bash\n   # 临时生效，每次打开终端需重新执行（或写入 shell 配置文件）\n   export IDF_GITHUB_ASSETS=\"dl.espressif.com/github_assets\"\n   # 重新运行安装脚本\n   ./install.sh\n   ```\n\n#### 烧录文件\n\n##### 下载wsl-usb-manager.exe\n\n> <a href=\"https://mextra.netlify.app/download/ESP32/wsl-usb-manager.exe\">wsl-usb-manager.exe </a>\n\n##### 插上ESP32S3\n\n![059f326e4709ef71f539677c5da784c2](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091454477.jpg)\n\n##### 配置WSL USB\n\n###### 管理员身份打开Windows PowerShell\n\n> 输入`winget install usbipd`，然后输入`y`（`看情况选择开不开魔法`，不开也能20s左右下载安装完）\n\n这个指令是安装usbipd-win工具，用于将windows系统的usb设备共享给wsl环境。\n\n![img](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509092343890.png)\n\n安装好之后 更改权限\n\n> - 输入`sudo usermod -aG dialout 你的用户名`\n>\n> - 然后`重启电脑`\n> - 输入`groups`验证一下\n>   - 如果输出中包含 `dialout` 或 `uucp`，则表示设置成功，之后就可以正常访问串口了。\n\n##### 进入WSL USB选择端口并烧录\n\n![image-20250909145724459](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091457549.png)\n\n![image-20250909150034639](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091500732.png)\n\n以上环境参考：[（二）vscode搭建espidf环境，配置wsl2_wsl 编译idf项目-CSDN博客](https://blog.csdn.net/QL_SD/article/details/150216599?spm=1001.2014.3001.5502)\n\n感谢[QL.ql](https://blog.csdn.net/QL_SD)大博主\n\n## ESP32基础知识\n\n![image-20250909173749995](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091737219.png)\n\n![image-20250909173836126](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509091738212.png)\n\n### 使用命令行创建工程\n\n```bash\nidf.py create-project 工程名\n```\n\n#### 打开vscode 切换到新建的工程\n\n```bash\ncd ~/ESP_Code/刚刚的工程名\ncode .\n\n按`ctrl+shift+p` 寻找add 添加idf路径\n```\n\n> 在写代码时候 如果出现宏没定义 则重新设置一下芯片型号 稍等一会就会出现\n>\n> ![image-20250910100948617](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509101009919.png)\n>\n> ![image-20250910102600612](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509101026730.png)\n>\n> 如果想要删除文件夹 则运行以下命令\n>\n> ```bash\n> cd ..\n> rm -rf 文件夹\n> ```\n>\n> 必备头文件\n>\n> ```C\n> #include \"freertos/FreeRTOS.h\"\n> #include \"freertos/task.h\"\n> #include \"esp_log.h\"\n> ```\n>\n\n### CMakeList.txt使用说明\n\n一般CmakeList.txt呈现下面的结构\n\n```C\nmain\n    main.c\n    CMakeList.txt\nCMakeList.txt\n```\n\n#### 创建自定义文件夹\n\n> 如\n>\n> ```C\n> components\n>     led\n>     \tled.c\n>     \tled.h\n>     \tCMakeList.txt\n> main\n>     main.c\n>     CMakeList.txt\n> ```\n>\n> 在这个目录下 则`components/led`文件夹下的`CMakeList.txt`，可以这么写\n>\n> ```cmake\n> idf_component_register(SRCS \"led.c\"\n>                     INCLUDE_DIRS \".\"\n>                     REQUIRES esp_driver_gpio\n>                     )\n> ```\n>\n> - `SRCS`：`.c`文件 多个用空格隔开\n>\n> - `INCLUDE_DIRS`：文件名 多个同样用空格隔开\n>\n> - `REQUIRES`：引入ESP官方的组件库`components` ，名字为官方`idf`下的`components`文件夹下的文件夹名 如此处的`esp_driver_gpio`\n>\n>   ![image-20250912184005520](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509121840992.png)\n>\n> 而若要引用 则`main`文件夹下的`CMakeList.txt` 可以这么写\n>\n> ```cmake\n> idf_component_register(SRCS \"main.c\" \"../components/led/led.c\"\n>                     INCLUDE_DIRS \".\" \"../components\")\n> ```\n\n### FreeRTOS-ESP32 基础API\n\n#### 任务创建\n\n```C\nBaseType_t xTaskCreatePinnedToCore(\n\tTaskFunction_t pvTaskCode,\t\t\t\t//任务函数指针，原型是voidfun(void*param)\n\tconst char *constpcName,\t\t\t\t//任务的名称，打印调试可能会有用\n\tconst uint32_t usStackDepth,\t\t\t//指定的任务堆栈空间大小（字节）\n\tvoid *constpvParameters,\t\t\t\t//任务参数\n\tUBaseType_t uxPriority,\t\t\t\t\t//优先级，数字越大，优先级越大，0到(configMAX_PRIORITIES-1) 即0-24\n\tTaskHandle_t *constpvCreatedTask,\t\t //传回来的任务句柄\n\tconst BaseType_t xCoreID)\t\t\t\t//分配在哪个内核上运行 ESP32是双核 所以可以选0或1\n```\n\n> ESP32的任务堆栈空间大小`usStackDepth`与原生FreeRTOS不一样\n>\n> - 原生FreeRTOS的任务堆栈空间大小单位是`字`，即目标平台若是32位 则为4个字节\n> - ESP32的任务堆栈空间大小单位是`字节`，最小是`2048`\n\n#### 阻塞函数（少用 可替代）\n\n```C\n//粗略延时xTicksToDelay个周期 \n//使用该函数后 任务进入阻塞 等延时结束且调度到来才会再次运行\nvoid vTaskDelay(const TickType_t xTicksToDelay)\t\n\n//用于表示精确的解除阻塞时间    \n//即使任务的执行时间超过了周期时间，它也能自动调整延迟时间，保证任务的周期性运行\nvoid vTaskDelayUntil(TickType_t *pxPreviousWakeTime,const TickType_t xTimeIncrement)\n\n```\n\n#### 打印调试\n\n```C\n#include <stdio.h>\n#include \"freertos/FreeRTOS.h\"\n#include \"freertos/task.h\"\n#include \"esp_log.h\"\nvoid taskA(void *param)\n{\n    while (1)\n    {\n        ESP_LOGI(\"TaskA\", \"Hello from Task A%d\", 1);//前面是一个TAG标签，后面是打印内容 他会自动回车换行\n        vTaskDelay(pdMS_TO_TICKS(500));\n    }\n}\n\nvoid app_main(void)\n{\n    xTaskCreatePinnedToCore(taskA, \"TaskA\", 2048, NULL, 5, NULL, 1);\n}\n\t\n```\n\n效果如图\n\n![image-20250910101607354](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509101016442.png)\n\n#### 队列\n\n> 队列特性：先进先出\n\n```C\nQueueHandle_t queue_handle = NULL; // 创建队列句柄\n\n/**\n * @brief 创建一个队列\n * @param uxQueueLength 队列长度\n * @param uxItemSize 每个元素的大小(单位是字节)\n */\nQueueHandle_t xQueueCreate(UBaseType_t uxQueueLength, UBaseType_t uxItemSize);\n\n/**\n * @brief 向队列头部发送数据\n * @param xQueue 队列句柄\n * @param pvItemToQueue 要发送的数据的指针\n * @param xTicksToWait 等待的时间(单位是tick)\n * @return 如果在等待时间内发送成功返回pdTRUE，否则返回errQUEUE_FULL\n */\nBaseType_t xQueueSend(QueueHandle_t xQueue, const void *pvItemToQueue, TickType_t xTicksToWait);\n\n/**\n * @brief 向队列尾部发送数据（新数据放在队尾）\n * @param xQueue 队列句柄\n * @param pvItemToQueue 要发送的数据的指针\n * @param xTicksToWait 等待的时间\n * @return pdTRUE 如果发送成功\n *         errQUEUE_FULL 如果队列已满，发送失败\n */\nBaseType_t xQueueSendToBack(QueueHandle_t xQueue, const void *pvItemToQueue, TickType_t xTicksToWait);\n\n/**\n * @brief 从队列中接收数据\n * @param xQueue 队列句柄\n * @param pvBuffer 用于存储接收数据的缓冲区\n * @param xTicksToWait 等待数据的最大时间，以系统节拍为单位\n * @return pdPASS 表示接收成功，errQUEUE_EMPTY 表示队列为空且等待超时，接收失败。\n */\nBaseType_t xQueueReceive(QueueHandle_t xQueue, void *pvBuffer, TickType_t xTicksToWait);\n\n/**\n * @brief 该函数在中断中使用，从队列发送数据 这个函数的行为和普通的 xQueueSend 有差异，且不允许阻塞（等待）\n * @param xQueue 队列句柄\n * @param pvItemToQueue 要发送的数据\n * @param pxHigherPriorityTaskWoken 如果发送数据后，有更高优先级的任务被唤醒，则该参数会被置为pdTRUE\n * @return 如果发送成功，返回pdTRUE，否则返回errQUEUE_FULL\n */\nBaseType_t xQueueSendFromISR(QueueHandle_t xQueue, const void *pvItemToQueue, BaseType_t *pxHigherPriorityTaskWoken);\n```\n\n##### 调用示例\n\n```C\n#include <stdio.h>\n#include <string.h>\n#include \"freertos/FreeRTOS.h\"\n#include \"freertos/task.h\"\n#include \"freertos/queue.h\"\n#include \"esp_log.h\"\n\nQueueHandle_t queue_handle = NULL; // 定义一个队列句柄\n\ntypedef struct\n{\n    int value;\n} queue_date_t;\n\nvoid taskA(void *param)\n{\n    // 从队列里面接收数据，并打印\n    queue_date_t data;\n    while (1)\n    {\n        if (xQueueReceive(queue_handle, &data, 100) == pdTRUE) // 从队列中接收数据，阻塞等待\n        {\n            ESP_LOGI(\"re_queue\", \"receive queue value:%d\", data.value); // 前面是一个TAG标签，后面是打印内容 他会自动回车换行\n        }\n    }\n}\n\nvoid taskB(void *param)\n{\n    queue_date_t data;\n    memset(&data, 0, sizeof(data));\n    // 每隔1s向队列里面发送数据\n    while (1)\n    {\n        xQueueSendToBack(queue_handle, &data, 100); // 向队列中发送数据，阻塞等待\n        vTaskDelay(pdMS_TO_TICKS(1000));            // 延时1s\n        data.value++;\n    }\n}\n\nvoid app_main(void)\n{\n    queue_handle = xQueueCreate(10, sizeof(queue_date_t)); // 创建一个队列，队列长度为10，每个元素的大小为queue_date_t结构体的大小\n    xTaskCreatePinnedToCore(taskA, \"re_queue\", 2048, NULL, 3, NULL, 1);\n    xTaskCreatePinnedToCore(taskB, \"se_queue\", 2048, NULL, 3, NULL, 1);\n}\n```\n\n> ![image-20250910110704875](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509101107988.png)\n\n#### 信号量\n\n```C\n/**\n * @brief 创建一个二值信号量\n * @return SemaphoreHandle_t 信号量句柄\n */\nSemaphoreHandle_t xSemaphoreCreateBinary(void);\n\n/**\n * @brief 创建一个计数信号量\n * @param uxMaxCount 计数信号量的最大值\n * @param uxInitialCount 计数信号量的初始值\n * \n */\nSemaphoreHandle_t xSemaphoreCreateCounting(UBaseType_t uxMaxCount, UBaseType_t uxInitialCount);\n\n/**\n * @brief 创建一个互斥锁\n * @return SemaphoreHandle_t 互斥锁句柄\n */\nSemaphoreHandle_t xSemaphoreCreateMutex(void);\n\n/**\n * @brief 取得一个信号量\n * @param xSemaphore 信号量句柄\n * @param xTicksToWait 等待信号量的时间，单位为ticks\n * @return 如果成功取得信号量则返回pdTRUE，否则返回pdFALSE\n */\nBaseType_t xSemaphoreTake(SemaphoreHandle_t xSemaphore, TickType_t xTicksToWait);\n\n/**\n * @brief 释放一个信号量\n * @param xSemaphore 信号量句柄\n * @return 如果成功释放信号量则返回pdTRUE，否则返回pdFALSE\n */\nBaseType_t xSemaphoreGive(SemaphoreHandle_t xSemaphore);\n\n/**\n * @brief 删除一个信号量\n * @param xSemaphore 要删除的信号量句柄\n */\nvoid vSemaphoreDelete(SemaphoreHandle_t xSemaphore);\n```\n\n##### 调用示例\n\n```C\n#include <string.h>\n#include \"freertos/FreeRTOS.h\"\n#include \"freertos/task.h\"\n#include \"freertos/queue.h\"\n#include \"freertos/semphr.h\"\n#include \"esp_log.h\"\n\nSemaphoreHandle_t mutex_handle;\n\nvoid taskA(void *param)\n{\n    while (1)\n    {\n        vTaskDelay(pdMS_TO_TICKS(1000));\n        xSemaphoreTake(mutex_handle, portMAX_DELAY);\n        ESP_LOGI(\"TASK_A\", \"Task A is running\");\n\n        xSemaphoreGive(mutex_handle);\n        vTaskDelay(pdMS_TO_TICKS(10)); // 给其他任务机会\n    }\n}\n\nvoid taskB(void *param)\n{\n    while (1)\n    {\n        vTaskDelay(pdMS_TO_TICKS(500));\n        xSemaphoreTake(mutex_handle, portMAX_DELAY);\n        ESP_LOGI(\"TASK_B\", \"Task B is running\");\n\n        xSemaphoreGive(mutex_handle);\n        vTaskDelay(pdMS_TO_TICKS(10)); // 给其他任务机会\n    }\n}\n\nvoid app_main(void)\n{\n    mutex_handle = xSemaphoreCreateMutex();\n    xTaskCreatePinnedToCore(taskA, \"taskA\", 2048, NULL, 6, NULL, 1);\n    xTaskCreatePinnedToCore(taskB, \"taskB\", 2048, NULL, 4, NULL, 1);\n}\n```\n\n> 注意释放信号量的时候 一般会给个延时 不加的话任务会马上回到`while(1)`初始的时候 反应出来的现象就是一直是A任务运行\n>\n> 原因：RTOS任务调度需要时间 并且最少只能是10ms 已测试\n\n#### 事件组\n\n```C\n/**\n * @brief 创建事件组\n * @return EventGroupHandle_t 事件组句柄\n */\nEventGroupHandle_t xEventGroupCreate(void);\n\n/**\n * @brief 设置事件位\n * @param xEventGroup 事件组句柄\n * @param uxBitsToSet 要设置的事件位\n * @return 设置后事件组的值\n */\nEventBits_t xEventGroupSetBits(EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet);\n\n/**\n * @brief 事件组等待位函数\n * @param xEventGroup 事件组句柄\n * @param uxBitsToWaitFor 等待的事件位\n * @param xClearOnExit 退出时是否清除事件位 pdTRUE or pdFALSE\n * @param xWaitForAllBits 是否等待所有位 pdTRUE or pdFALSE\n * @param xTicksToWait 等待的最大时间\n * @return 返回实际获得的事件位\n */\nEventBits_t xEventGroupWaitBits(const EventGroupHandle_t xEventGroup,\n                                const EventBits_t uxBitsToWaitFor,\n                                const BaseType_t xClearOnExit,\n                                const BaseType_t xWaitForAllBits,\n                                TickType_t xTicksToWait);\n\n\n/**\n * @brief 清除事件组指定事件位\n * @param xEventGroup 事件组句柄\n * @param uxBitsToClear 要清除的事件位\n * @return 清除前的事件组位值\n */\nEventBits_t xEventGroupClearBits(EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear);\n\n/* 以下使用消息直达机制*/\n\n/**\n * @brief 任务通知函数\n * @param xTaskToNotify 任务句柄\n * @param ulValue 发送的值\n * @param eAction 发送的动作 \n *                eNoAction 不改变任务的通知值(即不更新 会一直发送初始值)\n *                eSetBits 将ulValue的值按位或 到任务的通知值中 \n *                eIncrement 将任务的通知值加1\n *                eSetValueWithOverwrite 将任务的通知值设置为ulValue\n *                eSetValueWithoutOverwrite 如果任务的通知值为0，则将其设置为ulValue，否则不改变任务的通知值\n * @return 如果通知成功返回pdPASS，否则返回errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY\n */\nBaseType_t xTaskNotify(TaskHandle_t xTaskToNotify,\n                       uint32_t ulValue,\n                       eNotifyAction eAction);\n\n/**\n * @brief 将任务设置为等待接收通知\n * @param ulBitsToClearOnEntry 进入等待前要清除的位\n * @param ulBitsToClearOnExit 退出等待后要清除的位\n * @param pulNotificationValue 指向接收通知值的指针\n * @param xTicksToWait 等待通知的最大时间（以滴答为单位）\n * @return 如果在指定的等待时间内收到通知，则返回pdTRUE；否则返回\n */\nBaseType_t xTaskNotifyWait(uint32_t ulBitsToClearOnEntry,\n                           uint32_t ulBitsToClearOnExit,\n                           uint32_t *pulNotificationValue,\n                           TickType_t xTicksToWait);\n```\n\n##### 调用示例\n\n###### 事件组设置\n\n```C\n#include <string.h>\n#include \"freertos/FreeRTOS.h\"\n#include \"freertos/task.h\"\n#include \"freertos/queue.h\"\n#include \"freertos/semphr.h\"\n#include \"freertos/event_groups.h\"\n#include \"esp_log.h\"\n\n#define EVENT_BIT_0 BIT0\n#define EVENT_BIT_1 BIT1\n\nEventGroupHandle_t event_handle;\n\nvoid taskA(void *param)\n{\n    // 定时1s向任务B发送事件消息\n    while (1)\n    {\n        xEventGroupSetBits(event_handle, EVENT_BIT_0);\n        vTaskDelay(pdMS_TO_TICKS(1000));\n        xEventGroupSetBits(event_handle, EVENT_BIT_1);\n        vTaskDelay(pdMS_TO_TICKS(1000));\n    }\n}\n\nvoid taskB(void *param)\n{\n    EventBits_t ev;\n    while (1)\n    {\n        ev = xEventGroupWaitBits(event_handle, EVENT_BIT_0 | EVENT_BIT_1, pdTRUE, pdFALSE, pdMS_TO_TICKS(5000));\n        if (ev & EVENT_BIT_0)\n        {\n            ESP_LOGI(\"ev\", \"ev get event0\");\n        }\n        if (ev & EVENT_BIT_1)\n        {\n            ESP_LOGI(\"ev\", \"ev get event1\");\n        }\n    }\n}\n\nvoid app_main(void)\n{\n    event_handle = xEventGroupCreate();\n    xTaskCreatePinnedToCore(taskA, \"taskA\", 2048, NULL, 3, NULL, 1);\n    xTaskCreatePinnedToCore(taskB, \"taskB\", 2048, NULL, 3, NULL, 1);\n}\n```\n\n###### 消息直达\n\n```C\n#include <string.h>\n#include \"freertos/FreeRTOS.h\"\n#include \"freertos/task.h\"\n#include \"freertos/queue.h\"\n#include \"freertos/semphr.h\"\n#include \"freertos/event_groups.h\"\n#include \"esp_log.h\"\n\nstatic TaskHandle_t taskA_handle;\nstatic TaskHandle_t taskB_handle;\n\nvoid taskA(void *param)\n{\n    // 定时1s向任务B发送事件消息\n    uint32_t count = 0;\n    vTaskDelay(pdMS_TO_TICKS(100));\n    while (1)\n    {\n        xTaskNotify(taskB_handle, count, eSetValueWithoutOverwrite);\n        count++;\n        vTaskDelay(pdMS_TO_TICKS(1000));\n    }\n}\n\nvoid taskB(void *param)\n{\n    uint32_t count = 0;\n    while (1)\n    {\n        xTaskNotifyWait(0, 0, &count, portMAX_DELAY);\n        ESP_LOGI(\"taskB\", \"Notify count: %lu\", count);\n    }\n}\n\nvoid app_main(void)\n{\n    xTaskCreatePinnedToCore(taskA, \"taskA\", 2048, NULL, 3, &taskA_handle, 1);\n    xTaskCreatePinnedToCore(taskB, \"taskB\", 2048, NULL, 3, &taskB_handle, 1);\n}\n```\n\n#### ESP-IDF中的FreeRTOS与原生区别\n\n> 1. ESP32是多核的 所以可以完全实现程序并发执行 即不是单核那种 低优先级的任务因为高优先级任务存在而执行不了\n> 2. esp-idf自动创建五个任务\n>    - 空闲任务（每个核都会创建一个，`优先级为0`）\n>    - FreeRTOS定时器任务（`优先级为1`）\n>    - app_main任务（我们的应用入口，`优先级为1`）\n>    - IPC任务（每个核创建一个，用于多核协调，`优先级为24`）\n>    - ESP定时器任务（负责ESP32定时器回调，`优先级为22`）\n> 3. esp-idf不使用原生FreeRTOS的内存堆管理，实现了自己的堆\n> 4. 创建任务使用`xTaskCreatePinnedToCore()` 可以指定用哪个核创建任务\n>    - 负责处理`无线网络的任务（如WiFi蓝牙）`将被固定到`CPU0`，即`PRO_CPU`\n>    - 处理`应用程序`其余部分任务将被固定到`CPU1`，即`APP_CPU`\n> 5. 如果任务中用到浮点运算，则创建任务的时候必须指定具体运行在哪个核上，不能由系统自动安排\n\n## GPIO配置\n\n### 引脚基础配置\n\n#### `gpio_config()`：批量配置 GPIO（核心入口）\n\n- **函数原型**\n\n  ```c\n  esp_err_t gpio_config(const gpio_config_t *pGPIOConfig);\n  ```\n\n- **作用**：一次性配置一组 GPIO 的模式、上下拉、中断类型（覆盖该引脚当前所有配置）。\n\n- **参数**：`pGPIOConfig`：指向 `gpio_config_t` 结构体的指针（需提前初始化）。\n\n- **返回值**：`ESP_OK`（成功）、`ESP_ERR_INVALID_ARG`（参数错误，如引脚无效）。\n\n- **示例**：配置 GPIO2、GPIO3 为输出模式，禁用上下拉和中断：\n\n  ```c\n  gpio_config_t io_conf = {\n      .pin_bit_mask = (1ULL << GPIO_NUM_2) | (1ULL << GPIO_NUM_3),  // 仅配置 GPIO2\n      .mode = GPIO_MODE_OUTPUT,\n      .pull_up_en = GPIO_PULLUP_DISABLE,\n      .pull_down_en = GPIO_PULLDOWN_DISABLE,\n      .intr_type = GPIO_INTR_DISABLE\n  };\n  gpio_config(&io_conf);  // 执行配置\n  ```\n\n> `intr_type` :\n>\n> - `GPIO_INTR_DISABLE`：禁用中断\n> -  `GPIO_INTR_POSEDGE`：上升沿触发\n> - `GPIO_INTR_NEGEDGE`：下降沿触发\n> - `GPIO_INTR_ANYEDGE`：双边沿触发\n> - `GPIO_INTR_LOW_LEVEL`：低电平触发\n> - `GPIO_INTR_HIGH_LEVEL`：高电平触发\n\n#### `gpio_reset_pin()`：重置引脚为默认状态\n\n- **函数原型**\n\n  ```c\n  esp_err_t gpio_reset_pin(gpio_num_t gpio_num);\n  ```\n\n- **作用**：将指定 GPIO 重置为默认状态（输入模式、禁用上下拉、禁用中断、选择 GPIO 功能）。\n\n- **参数**：`gpio_num`：要重置的 GPIO 编号（如 `GPIO_NUM_4`）。\n\n- **示例**：重置 GPIO4，恢复初始状态：\n\n  ```c\n  gpio_reset_pin(GPIO_NUM_4);\n  ```\n\n#### `gpio_set_direction()`：单独设置引脚方向\n\n- **函数原型**\n\n  ```c\n  esp_err_t gpio_set_direction(gpio_num_t gpio_num, gpio_mode_t mode);\n  ```\n\n- **作用**：单独修改某个 GPIO 的模式（输入 / 输出 / 输入输出），覆盖当前模式。\n\n- **参数**\n\n  - `gpio_num`：目标 GPIO 编号。\n  - `mode`：目标模式（如 `GPIO_MODE_INPUT`）。\n\n- **示例**：将已配置的 GPIO2 改为输入模式\n\n  ```c\n  gpio_set_direction(GPIO_NUM_2, GPIO_MODE_INPUT);\n  ```\n\n#### 配置上下拉函数（`gpio_pullup_en`/`gpio_pulldown_en`）\n\n- **函数原型**\n\n  ```c\n  esp_err_t gpio_pullup_en(gpio_num_t gpio_num);    // 启用上拉\n  esp_err_t gpio_pullup_dis(gpio_num_t gpio_num);   // 禁用上拉\n  esp_err_t gpio_pulldown_en(gpio_num_t gpio_num);  // 启用下拉\n  esp_err_t gpio_pulldown_dis(gpio_num_t gpio_num); // 禁用下拉\n  ```\n\n- **作用**：比 `gpio_set_pull_mode` 更直观，单独控制上拉 / 下拉的启用 / 禁用。\n\n- **示例**：启用 GPIO0 下拉，禁用上拉：\n\n  ```c\n  gpio_pulldown_en(GPIO_NUM_0);\n  gpio_pullup_dis(GPIO_NUM_0);\n  ```\n\n### 引脚电平控制函数\n\n#### `gpio_set_level()`：设置输出电平\n\n- **函数原型**\n\n  ```c\n  esp_err_t gpio_set_level(gpio_num_t gpio_num, uint32_t level);\n  ```\n\n- **作用**：给输出模式的 GPIO 设置高 / 低电平（仅输出模式有效）。\n\n- **参数**：\n\n  - `level`：`0`（低电平）、`1`（高电平）。\n\n#### `gpio_get_level()`：读取输入电平\n\n- **函数原型**\n\n  ```c\n  int gpio_get_level(gpio_num_t gpio_num);\n  ```\n\n- **作用**：读取 GPIO 的当前输入电平（需引脚为输入 / 输入输出模式，否则返回 0）。\n\n- **返回值**：`0`（低电平）、`1`（高电平）。\n\n## LEDC库学习笔记\n\n> **定义**：LEDC（Light Emitting Diode Controller）是 ESP32 内置的 LED 控制器，核心功能是生成 PWM（脉冲宽度调制）信号，不仅用于 LED 亮度调节，还可驱动电机、舵机等需 PWM 信号的设备。\n>\n> **核心优势**：无需手动编写定时器中断逻辑，ESP-IDF 提供完整库接口，配置简单、信号稳定\n>\n> **注意**：LEDC 控制器有自己`专属的 4 个定时器`（`LEDC_TIMER_0` ~ `LEDC_TIMER_3`），这些定时器是 LEDC 模块内部集成的，专门用于生成 PWM 信号。\n>\n> 与`通用定时器（TIMER_0 ~ TIMER_3）`完全分离\n\n### LEDC关键概念\n\n| 概念                      | 说明                                                         |\n| ------------------------- | ------------------------------------------------------------ |\n| 通道（Channel）           | ESP32 有 16 个独立通道，每个通道可独立配置 PWM 参数（频率、占空比），并映射到 1 个 GPIO 引脚输出信号。 |\n| 定时器（Timer）           | 每个通道需绑定定时器，定时器决定 PWM 频率（由预分频和计数范围计算），多个通道可共享同一定时器（频率相同）。 |\n| 频率（Frequency）         | PWM 信号周期的倒数（单位：Hz），如 50Hz（舵机常用，对应 20ms 周期）、1000Hz（LED 常用，避免人眼闪烁）。 |\n| 占空比（Duty Cycle）      | PWM 高电平持续时间与周期的比值（0~100%），LEDC 中用数值表示（如 12 位分辨率对应 0~4095）。 |\n| 分辨率（Duty Resolution） | 占空比的可调精度，范围 `LEDC_TIMER_1_BIT`~`LEDC_TIMER_20_BIT`，如 12 位表示占空比可设为 0~4095（共 4096 级）。 |\n| 速度模式                  | 分 `LEDC_LOW_SPEED_MODE`（低速模式）和 `LEDC_HIGH_SPEED_MODE`（高速模式），高速模式支持更高 PWM 频率。 |\n\n### 常用API（需包含头文件 `driver/ledc.h`）\n\n#### 定时器初始化\n\n- **作用**：初始化 LEDC 定时器，设置频率、分辨率等核心参数。\n\n- 函数原型\n\n  ```c\n  esp_err_t ledc_timer_config(const ledc_timer_config_t *timer_conf);\n  ```\n\n- **参数结构体 `ledc_timer_config_t` 说明**：\n\n  | 参数              | 取值 / 说明                                                  |\n  | ----------------- | ------------------------------------------------------------ |\n  | `speed_mode`      | 速度模式：`LEDC_LOW_SPEED_MODE` 或 `LEDC_HIGH_SPEED_MODE`    |\n  | `duty_resolution` | 占空比分辨率：`LEDC_TIMER_1_BIT` ~ `LEDC_TIMER_20_BIT`（如 12 位选 `LEDC_TIMER_12_BIT`） |\n  | `timer_num`       | 定时器编号：`LEDC_TIMER_0` ~ `LEDC_TIMER_3`（共 4 个定时器） |\n  | `freq_hz`         | PWM 频率（如 50、1000，单位：Hz）                            |\n  | `clk_cfg`         | 时钟源：通常用 `LEDC_AUTO_CLK`（自动选择最优时钟）           |\n\n- **示例**：配置 1000Hz、12 位分辨率的定时器 0（低速模式）\n\n  ```c\n  ledc_timer_config_t timer_conf = {\n      .speed_mode = LEDC_LOW_SPEED_MODE,\n      .duty_resolution = LEDC_TIMER_12_BIT,  // 0~4095 级占空比\n      .timer_num = LEDC_TIMER_0,\n      .freq_hz = 1000,                       // 1000Hz 频率\n      .clk_cfg = LEDC_AUTO_CLK\n  };\n  ledc_timer_config(&timer_conf);  // 执行配置\n  ```\n\n####  通道配置：`ledc_channel_config()`\n\n#### 通道配置：`ledc_channel_config()`\n\n- **作用**：将 LEDC 通道绑定到定时器和 GPIO 引脚，设置初始占空比。\n\n- **函数原型**\n\n  ```c\n  esp_err_t ledc_channel_config(const ledc_channel_config_t *channel_conf);\n  ```\n\n- **参数结构体** `ledc_channel_config_t` **说明**\n\n  | 参数         | 取值 / 说明                                                  |\n  | ------------ | ------------------------------------------------------------ |\n  | `speed_mode` | 需与绑定的定时器速度模式一致（如 `LEDC_LOW_SPEED_MODE`）     |\n  | `channel`    | 通道编号：`LEDC_CHANNEL_0` ~ `LEDC_CHANNEL_15`（共 16 个通道） |\n  | `timer_sel`  | 绑定的定时器编号（如 `LEDC_TIMER_0`）                        |\n  | `intr_type`  | 中断类型：通常设 `LEDC_INTR_DISABLE`（禁用中断）             |\n  | `gpio_num`   | 输出 PWM 的 GPIO 引脚（如 `GPIO_NUM_2`、`GPIO_NUM_4`）       |\n  | `duty`       | 初始占空比（0 ~ 分辨率最大值，如 12 位初始为 0 表示 LED 灭） |\n  | `hpoint`     | 脉冲起点偏移：通常设 0（无偏移）                             |\n\n- 示例\n\n  ```c\n  ledc_channel_config_t channel_conf = {\n      .speed_mode = LEDC_LOW_SPEED_MODE,\n      .channel = LEDC_CHANNEL_0,\n      .timer_sel = LEDC_TIMER_0,  // 绑定定时器 0\n      .intr_type = LEDC_INTR_DISABLE,\n      .gpio_num = GPIO_NUM_2,     // GPIO2 输出 PWM\n      .duty = 0,                  // 初始占空比 0（LED 不亮）\n      .hpoint = 0\n  };\n  ledc_channel_config(&channel_conf);  // 执行配置\n  ```\n\n#### 3. 占空比修改：`ledc_set_duty()` + `ledc_update_duty()`\n\n- **作用**：动态调整通道的 PWM 占空比（`ledc_set_duty` 仅修改寄存器，`ledc_update_duty` 使修改生效）。\n\n- **函数原型**\n\n  ```c\n  // 1. 设置占空比（不立即生效）\n  esp_err_t ledc_set_duty(ledc_mode_t speed_mode, ledc_channel_t channel, uint32_t duty);\n  // 2. 使占空比生效\n  esp_err_t ledc_update_duty(ledc_mode_t speed_mode, ledc_channel_t channel);\n  ```\n\n- **参数说明**\n\n  - `speed_mode`：速度模式（与通道一致）\n  - `channel`：目标通道编号\n  - `duty`：目标占空比（0 ~ 分辨率最大值）\n\n- **示例**：将通道 0 占空比设为 50%（12 位分辨率对应 2048）\n\n  ```c\n  // 12 位分辨率下，50% 占空比 = 4096 / 2 = 2048\n  ledc_set_duty(LEDC_LOW_SPEED_MODE, LEDC_CHANNEL_0, 2048);\n  ledc_update_duty(LEDC_LOW_SPEED_MODE, LEDC_CHANNEL_0);  // 占空比生效\n  ```\n\n#### 4. 硬件渐变：`ledc_fade_*` 系列函数\n\n- **作用**：实现硬件自动渐变（无需软件循环），适合 LED 呼吸灯、平滑调光等场景。\n\n- **核心函数**：\n\n  | 函数                        | 作用                                                    |\n  | --------------------------- | ------------------------------------------------------- |\n  | `ledc_fade_func_install()`  | 初始化渐变功能（需开启中断，参数 0 表示不使用中断回调） |\n  | `ledc_set_fade_with_time()` | 配置渐变参数（目标占空比、渐变时间）                    |\n  | `ledc_fade_start()`         | 启动渐变（可选择阻塞 / 非阻塞模式）                     |\n  | `ledc_cb_register()`        | 注册 LEDC 回调函数                                      |\n\n- **函数原型**\n\n  ```c\n  // 1. 初始化渐变功能\n  esp_err_t ledc_fade_func_install(int intr_alloc_flags);\n  // 2. 配置渐变：在指定时间内从当前占空比渐变到目标占空比\n  esp_err_t ledc_set_fade_with_time(ledc_mode_t speed_mode, ledc_channel_t channel, uint32_t target_duty, uint32_t fade_time_ms);\n  // 3. 启动渐变\n  esp_err_t ledc_fade_start(ledc_mode_t speed_mode, ledc_channel_t channel, ledc_fade_mode_t fade_mode);\n  ```\n\n- **参数说明**：\n\n  - `intr_alloc_flags`：中断分配标志（设 0 即可）\n  - `target_duty`：渐变目标占空比\n  - `fade_time_ms`：渐变总时间（单位：ms）\n  - `fade_mode`：渐变模式：`LEDC_FADE_WAIT_DONE`（阻塞，等待渐变完成返回）/ `LEDC_FADE_NO_WAIT`（非阻塞）\n\n- **示例**：2 秒内从当前占空比渐变到最大亮度（12 位对应 4095）\n\n  ```c\n  // 1. 初始化渐变功能\n  ledc_fade_func_install(0);  // 不使用中断回调\n  \n  // 2. 配置渐变：2000ms（2秒）内渐变到 4095（最大亮度）\n  ledc_set_fade_with_time(LEDC_LOW_SPEED_MODE, \n                          LEDC_CHANNEL_0, \n                          4095,        // 目标占空比（最大）\n                          2000);       // 渐变时间（ms）\n  \n  // 3. 启动渐变（阻塞模式，等待渐变完成后再执行后续代码）\n  ledc_fade_start(LEDC_LOW_SPEED_MODE, LEDC_CHANNEL_0, LEDC_FADE_WAIT_DONE);\n  ```\n\n##### 启用中断模式\n\n- **函数原型**\n\n  ```C\n  esp_err_t ledc_cb_register(ledc_mode_t speed_mode, ledc_channel_t channel, ledc_cbs_t *cbs, void *user_arg)\n  ```\n\n- **参数结构体** `ledc_cbs_t` **说明**\n\n  - `fade_cb`：需要注册的中断回调函数\n\n- **示例**\n\n  ```C\n  #include <stdio.h>\n  #include \"freertos/FreeRTOS.h\"\n  #include \"freertos/task.h\"\n  #include \"driver/gpio.h\"\n  #include \"driver/ledc.h\"\n  \n  #define LED_GPIO GPIO_NUM_18\n  \n  #define FULL_EV_BIT BIT0\n  #define EMPTY_EV_BIT BIT1\n  \n  static EventGroupHandle_t led_fade_handle;\n  \n  /**\n   * @brief 重写LEDC完成回调函数\n   * @note IRAM_ATTR 修饰符表示该函数在IRAM中执行，中断服务程序中不能调用RAM中的函数\n   */\n  bool IRAM_ATTR ledc_finish_cb(const ledc_cb_param_t *param, void *user_arg)\n  {\n      BaseType_t taskWoken;\n      if (param->duty)\n      {\n          xEventGroupSetBitsFromISR(led_fade_handle, FULL_EV_BIT, &taskWoken);\n      }\n      else\n      {\n          xEventGroupSetBitsFromISR(led_fade_handle, EMPTY_EV_BIT, &taskWoken);\n      }\n      return taskWoken;\n  }\n  \n  void led_run_task(void *param)\n  {\n      EventBits_t ev;\n      while (1)\n      {\n          ev = xEventGroupWaitBits(led_fade_handle, FULL_EV_BIT | EMPTY_EV_BIT, pdTRUE, pdFALSE, pdMS_TO_TICKS(5000));\n          if (ev & FULL_EV_BIT)\n          {\n              ledc_set_fade_with_time(LEDC_LOW_SPEED_MODE, LEDC_CHANNEL_0, 0, 2000);\n              ledc_fade_start(LEDC_LOW_SPEED_MODE, LEDC_CHANNEL_0, LEDC_FADE_NO_WAIT);\n          }\n          if (ev & EMPTY_EV_BIT)\n          {\n              ledc_set_fade_with_time(LEDC_LOW_SPEED_MODE, LEDC_CHANNEL_0, 8191, 2000);\n              ledc_fade_start(LEDC_LOW_SPEED_MODE, LEDC_CHANNEL_0, LEDC_FADE_NO_WAIT);\n          }\n  \n          ledc_cbs_t ledc_cbs = {\n              .fade_cb = ledc_finish_cb,\n          };\n  \n          ledc_cb_register(LEDC_LOW_SPEED_MODE, LEDC_CHANNEL_0, &ledc_cbs, NULL);\n      }\n  }\n  \n  void app_main(void)\n  {\n      // gpio_config_t led_cfg = {\n      //     .pin_bit_mask = (1 << LED_GPIO),\n      //     .pull_down_en = GPIO_PULLDOWN_DISABLE,\n      //     .pull_up_en = GPIO_PULLUP_DISABLE,\n      //     .intr_type = GPIO_INTR_DISABLE,\n      //     .mode = GPIO_MODE_OUTPUT,\n      // };\n      // gpio_config(&led_cfg);\n  \n      ledc_timer_config_t ledc_timer = {\n          .speed_mode = LEDC_LOW_SPEED_MODE,\n          .timer_num = LEDC_TIMER_0,\n          .clk_cfg = LEDC_AUTO_CLK,\n          .freq_hz = 5000,\n          .duty_resolution = LEDC_TIMER_13_BIT, // 占空比分辨率 0-8191\n      };\n      ledc_timer_config(&ledc_timer);\n  \n      ledc_channel_config_t ledc_channel = {\n          .gpio_num = LED_GPIO,\n          .channel = LEDC_CHANNEL_0,\n          .duty = 0,\n          .speed_mode = LEDC_LOW_SPEED_MODE,\n          .timer_sel = LEDC_TIMER_0,\n          .intr_type = LEDC_INTR_DISABLE,\n      };\n      ledc_channel_config(&ledc_channel);\n  \n      ledc_fade_func_install(0); // 使能渐变 不需要自己手动调节占空比\n      ledc_set_fade_with_time(LEDC_LOW_SPEED_MODE, LEDC_CHANNEL_0, 8191, 2000);\n      ledc_fade_start(LEDC_LOW_SPEED_MODE, LEDC_CHANNEL_0, LEDC_FADE_NO_WAIT);\n  \n      led_fade_handle = xEventGroupCreate();\n  \n      ledc_cbs_t ledc_cbs = {\n          .fade_cb = ledc_finish_cb,\n      };\n  \n      ledc_cb_register(LEDC_LOW_SPEED_MODE, LEDC_CHANNEL_0, &ledc_cbs, NULL);\n  \n      xTaskCreatePinnedToCore(led_run_task, \"led_run_task\", 2048, NULL, 3, NULL, 1);\n  }\n  ```\n\n\n## UART配置\n\n### ESP32 UART 硬件特性\n\n- **硬件资源**：ESP32 内置 3 个 UART 接口（UART0、UART1、UART2），支持不同引脚映射\n- **通信参数**：可配置波特率（1200 ~ 5000000bps）、数据位（5 ~ 8 位）、校验位（无 / 奇 / 偶）、停止位（1/1.5/2 位）\n- **缓冲区**：每个 UART 支持硬件 FIFO 缓冲区，可通过软件配置环形缓冲区大小\n- **事件驱动**：支持通过 FreeRTOS 队列触发 UART 事件（数据接收、缓冲区满、溢出等）\n\n### 关键API\n\n| API 函数                | 功能描述                               | 核心参数说明                                                 |\n| ----------------------- | -------------------------------------- | ------------------------------------------------------------ |\n| `uart_param_config()`   | 配置 UART 通信参数（波特率、数据位等） | 端口号、`uart_config_t` 结构体                               |\n| `uart_set_pin()`        | 绑定 UART 信号到物理引脚               | 端口号、TX 引脚、RX 引脚、RTS 引脚、CTS 引脚                 |\n| `uart_driver_install()` | 安装 UART 驱动并创建事件队列           | 端口号、接收缓冲区大小、发送缓冲区大小、队列容量、队列句柄、标志 |\n| `uart_read_bytes()`     | 读取 UART 接收数据                     | 端口号、接收缓冲区、读取长度、超时时间                       |\n| `uart_write_bytes()`    | 发送 UART 数据                         | 端口号、发送缓冲区、发送长度                                 |\n| `uart_flush_input()`    | 清空 UART 接收缓冲区                   | 端口号                                                       |\n| `xQueueReceive()`       | 从事件队列接收 UART 事件               | 队列句柄、事件存储变量地址、超时时间                         |\n| `xTaskCreate()`         | 创建独立任务处理 UART 事件             | 任务函数、任务名称、栈大小、优先级等                         |\n\n### 基础配置\n\n#### 步骤 1：定义核心参数（宏定义）\n\n```c\n// 1. 定义 UART 端口号\n#define USER_UART_NUM UART_NUM_1  // 避免 UART0 冲突（默认用于串口打印）\n#define USER_UART_BAUD 115200  // 串口波特率设置\n\n// 2. 定义引脚（需根据硬件接线调整）\n#define UART_TX_PIN 17  // TX 发送引脚\n#define UART_RX_PIN 16  // RX 接收引脚\n\n// 3. 定义缓冲区和队列参数\n#define UART_BUFFER_SIZE 1024    // 数据缓冲区大小\n#define UART_QUEUE_SIZE 10       // 事件队列容量（最多缓存 10 个事件）\n#define UART_TASK_STACK_SIZE 4096// UART 处理任务栈大小\n#define UART_TASK_PRIORITY 5     // UART 任务优先级（1~24，数值越大优先级越高）\n\n// 4. 全局变量声明\nstatic QueueHandle_t uart_event_queue;  // UART 事件队列句柄\nstatic uint8_t uart_rx_buffer[UART_BUFFER_SIZE];  // 接收数据缓冲区\nstatic const char *TAG = \"UART_DEV\";    // 日志标签\n```\n\n#### 步骤 2：配置 UART 硬件参数\n\n通过 `uart_config_t` 结构体配置通信参数，再调用 `uart_param_config()` 生效：\n\n```c\n// 配置 UART 通信参数\nuart_config_t uart_config = {\n    .baud_rate = USER_UART_BAUD,          // 波特率（常用：9600、115200、1000000）\n    .data_bits = UART_DATA_8_BITS,// 数据位：8 位\n    .parity = UART_PARITY_DISABLE,// 校验位：禁用\n    .stop_bits = UART_STOP_BITS_1,// 停止位：1 位\n    .flow_ctrl = UART_HW_FLOWCTRL_DISABLE,  // 硬件流控：禁用（无需 RTS/CTS 引脚）\n    .source_clk = UART_SCLK_DEFAULT,         // 时钟源：默认\n};\n// 应用配置到指定 UART 端口\nESP_ERROR_CHECK(uart_param_config(USER_UART_NUM, &uart_config));\n```\n\n#### 步骤 3：绑定引脚并安装驱动 （如果用默认串口的话 则不需要绑定引脚）\n\n- **引脚绑定**：通过 `uart_set_pin()` 将 UART 信号映射到 ESP32 物理引脚\n- **驱动安装**：调用 `uart_driver_install()` 初始化 UART 驱动，创建事件队列（可选）\n\n```c\n// 1. 绑定 UART 引脚（TX/RX，流控引脚填 UART_PIN_NO_CHANGE 表示禁用）\nESP_ERROR_CHECK(uart_set_pin(USER_UART_NUM, \n                            UART_TX_PIN,  // TX 引脚\n                            UART_RX_PIN,  // RX 引脚\n                            UART_PIN_NO_CHANGE,  // RTS 引脚（禁用）\n                            UART_PIN_NO_CHANGE)); // CTS 引脚（禁用）\n\n// 2. 安装 UART 驱动（参数依次：端口号、接收缓冲区大小、发送缓冲区大小、事件队列容量、队列句柄、标志）\nESP_ERROR_CHECK(uart_driver_install(USER_UART_NUM, \n                                    UART_BUFFER_SIZE * 2,  // 接收缓冲区（建议比单次接收大）\n                                    UART_BUFFER_SIZE * 2,  // 发送缓冲区\n                                    UART_QUEUE_SIZE,       // 事件队列容量\n                                    &uart_event_queue,     // 事件队列句柄（传出）\n                                    0));                   // 标志：0（默认）\n```\n\n### ESP32 UART 数据处理方式\n\n| 特性       | 轮询方式（简单场景）                      | 事件驱动方式（高效场景）          |\n| ---------- | ----------------------------------------- | --------------------------------- |\n| 核心函数   | `uart_read_bytes()`、`uart_write_bytes()` | `xQueueReceive()`（监听事件队列） |\n| 适用场景   | 简单回显、低频率数据交互                  | 高频率数据、多事件处理（如溢出）  |\n| CPU 占用率 | 较高（循环查询）                          | 较低（事件触发，无轮询）          |\n| 代码复杂度 | 低                                        | 中（需处理多事件类型）            |\n| 看门狗风险 | 高（需避免长阻塞）                        | 低（事件队列超时释放 CPU）        |\n\n### 实战代码示例\n\n#### 事件驱动方式\n\n- 通过 FreeRTOS 队列接收 UART 事件，按需处理数据接收、缓冲区满、溢出等场景：\n\n  ```C\n  #include <stdio.h>\n  #include \"freertos/FreeRTOS.h\"\n  #include \"freertos/task.h\"\n  #include \"driver/uart.h\"\n  #include \"esp_log.h\"\n  #include \"driver/gpio.h\"\n  \n  // -------------- 1. 宏定义参数 --------------\n  #define USER_UART_NUM UART_NUM_1\n  #define USER_UART_BAUD 115200\n  #define UART_TX_PIN 17\n  #define UART_RX_PIN 16\n  #define UART_BUFFER_SIZE 1024\n  #define UART_QUEUE_SIZE 10\n  #define UART_TASK_STACK_SIZE 4096\n  #define UART_TASK_PRIORITY 5\n  \n  // -------------- 2. 全局变量 --------------\n  static QueueHandle_t uart_event_queue;\n  static uint8_t uart_rx_buffer[UART_BUFFER_SIZE];\n  static const char *TAG = \"UART_DEV\";\n  \n  // -------------- 3. UART 事件处理任务 --------------\n  void uart_event_task(void *arg) {\n      uart_event_t event;  // 存储 UART 事件的结构体\n  \n      while (1) {\n          // 从事件队列接收事件（超时 100ms，避免阻塞触发看门狗）\n          if (xQueueReceive(uart_event_queue, &event, pdMS_TO_TICKS(100)) == pdTRUE) {\n              switch (event.type) {\n                  // 1. 接收数据事件\n                  case UART_DATA:\n                      ESP_LOGI(TAG, \"收到数据，长度：%d 字节\", event.size);\n                      // 读取数据到缓冲区（超时 50ms，确保数据完整性）\n                      int read_len = uart_read_bytes(USER_UART_NUM, \n                                                    uart_rx_buffer, \n                                                    event.size, \n                                                    pdMS_TO_TICKS(50));\n                      if (read_len > 0) {\n                          // 示例1：回显数据（发送收到的数据）\n                          uart_write_bytes(USER_UART_NUM, uart_rx_buffer, read_len);\n                          // 示例2：打印接收的数据（十六进制）\n                          ESP_LOGI(TAG, \"接收数据（hex）：\");\n                          for (int i = 0; i < read_len; i++) {\n                              printf(\"%02X \", uart_rx_buffer[i]);\n                          }\n                          printf(\"\\n\");\n                      }\n                      break;\n  \n                  // 2. 接收缓冲区满事件\n                  case UART_BUFFER_FULL:\n                      ESP_LOGI(TAG, \"接收缓冲区满，清空缓冲区\");\n                      uart_flush_input(USER_UART_NUM);  // 清空接收缓冲区\n                      xQueueReset(uart_event_queue);    // 重置事件队列\n                      break;\n  \n                  // 3. FIFO 溢出事件（硬件缓冲区溢出）\n                  case UART_FIFO_OVF:\n                      ESP_LOGI(TAG, \"UART FIFO 溢出，清空缓冲区\");\n                      uart_flush_input(USER_UART_NUM);\n                      xQueueReset(uart_event_queue);\n                      break;\n  \n                  // 4. 帧错误事件（数据格式错误）\n                  case UART_FRAME_ERR:\n                      ESP_LOGI(TAG, \"帧错误（数据格式异常）\");\n                      break;\n  \n                  // 5. 校验错误事件（启用校验时生效）\n                  case UART_PARITY_ERR:\n                      ESP_LOGI(TAG, \"校验错误（数据校验不匹配）\");\n                      break;\n  \n                  // 其他未处理事件\n                  default:\n                      ESP_LOGI(TAG, \"未处理事件类型：%d\", event.type);\n                      break;\n              }\n          }\n      }\n  }\n  \n  // -------------- 4. 主函数初始化 --------------\n  void app_main(void) {\n      // 1. 配置 UART 硬件参数\n      uart_config_t uart_config = {\n          .baud_rate = USER_UART_BAUD,\n          .data_bits = UART_DATA_8_BITS,\n          .parity = UART_PARITY_DISABLE,\n          .stop_bits = UART_STOP_BITS_1,\n          .flow_ctrl = UART_HW_FLOWCTRL_DISABLE,\n          .source_clk = UART_SCLK_DEFAULT,\n      };\n      ESP_ERROR_CHECK(uart_param_config(USER_UART_NUM, &uart_config));\n  \n      // 2. 绑定引脚\n      ESP_ERROR_CHECK(uart_set_pin(USER_UART_NUM, \n                                  UART_TX_PIN, \n                                  UART_RX_PIN, \n                                  UART_PIN_NO_CHANGE, \n                                  UART_PIN_NO_CHANGE));\n  \n      // 3. 安装 UART 驱动并创建事件队列\n      ESP_ERROR_CHECK(uart_driver_install(USER_UART_NUM, \n                                          UART_BUFFER_SIZE * 2, \n                                          UART_BUFFER_SIZE * 2, \n                                          UART_QUEUE_SIZE, \n                                          &uart_event_queue, \n                                          0));\n  \n      // 4. 创建 UART 事件处理任务（独立任务，避免阻塞 main 任务）\n      xTaskCreate(uart_event_task,          // 任务函数\n                  \"uart_event_task\",        // 任务名称\n                  UART_TASK_STACK_SIZE,     // 栈大小\n                  NULL,                     // 任务参数\n                  UART_TASK_PRIORITY,       // 优先级\n                  NULL);                    // 任务句柄（无需则填 NULL）\n  }\n  ```\n\n#### 轮询方式（简单场景，如回显）\n\n- 适用于数据量小、交互频率低的场景，代码更简洁：\n\n  ```C\n  void app_main(void) {\n      // 1. 配置 UART 参数（同事件驱动方式）\n      uart_config_t uart_config = {\n          .baud_rate = 115200,\n          .data_bits = UART_DATA_8_BITS,\n          .parity = UART_PARITY_DISABLE,\n          .stop_bits = UART_STOP_BITS_1,\n          .flow_ctrl = UART_HW_FLOWCTRL_DISABLE,\n      };\n      ESP_ERROR_CHECK(uart_param_config(USER_UART_NUM, &uart_config));\n      ESP_ERROR_CHECK(uart_set_pin(USER_UART_NUM, 17, 16, UART_PIN_NO_CHANGE, UART_PIN_NO_CHANGE));\n      ESP_ERROR_CHECK(uart_driver_install(USER_UART_NUM, 1024, 1024, 0, NULL, 0));\n  \n      // 2. 轮询读取数据并回显\n      while (1) {\n          // 读取数据（超时 50ms，无数据则返回 0）\n          int read_len = uart_read_bytes(USER_UART_NUM, uart_rx_buffer, 1024, pdMS_TO_TICKS(50));\n          if (read_len > 0) {\n              // 回显数据\n              uart_write_bytes(USER_UART_NUM, uart_rx_buffer, read_len);\n              ESP_LOGI(TAG, \"轮询接收数据长度：%d\", read_len);\n          }\n          // 短暂延迟，释放 CPU（避免触发看门狗）\n          vTaskDelay(pdMS_TO_TICKS(10));\n      }\n  }\n  ```\n\n### 常见问题与解决方案\n\n#### 触发 Task Watchdog（任务看门狗）\n\n- **原因**：\n  1. 轮询方式中 `uart_read_bytes()` 超时过长，或无 `vTaskDelay()` 释放 CPU；\n  2. 事件驱动方式中 `xQueueReceive()` 使用 `portMAX_DELAY` 永久阻塞。\n- **解决方案**：\n  - 轮询方式：在循环中添加 `vTaskDelay(pdMS_TO_TICKS(10))`；\n  - 事件驱动方式：`xQueueReceive()` 超时设为有限值（如 `pdMS_TO_TICKS(100)`）。\n\n#### 数据接收不完整或丢失\n\n- **原因**：\n  1. 接收缓冲区过小，无法容纳单次接收的数据；\n  2. `uart_read_bytes()` 超时过短，数据未完全接收；\n  3. 波特率不匹配（发送端与接收端波特率必须一致）。\n- **解决方案**：\n  - 增大接收缓冲区（如 `UART_BUFFER_SIZE * 2`）；\n  - 延长 `uart_read_bytes()` 超时时间（如 50~100ms）；\n  - 确保发送端与 ESP32 UART 波特率、数据位、校验位完全一致。\n\n#### UART0 与串口打印冲突\n\n- **原因**：ESP32 默认将 `printf()` 映射到 UART0（引脚 TX=1，RX=3），若使用 UART0 通信会导致打印乱码。\n- **解决方案**：\n  - 优先使用 UART1 或 UART2 作为通信端口；\n  - 若必须使用 UART0，需重新映射 `printf()` 到其他 UART（需修改 ESP-IDF 配置）。\n\n## WIFI\n\n### ESP32下WIFI组件三种模式\n\n- **AP 模式**：ESP32 自身作为接入点，其他设备（如手机、电脑）可连接 ESP32 创建的 WiFi 热点，适用于 “本地设备直连 ESP32” 场景（如配置 ESP32 参数）；\n\n- **AP+STA 混合模式**：ESP32 同时作为接入点和客户端，既允许其他设备连接自身，又能接入外部路由器，适用于 “本地控制 + 远程联网” 复合场景（如智能家居设备）；\n\n- **STA 模式**：仅作为客户端，专注于接入外部网络，是 ESP32 实现联网功能的最常用模式（如传感器数据上传云端、远程控制指令接收）。\n\n### STA模式核心工作原理\n\nESP32 的 STA 模式连接 WiFi 的过程遵循 IEEE 802.11 协议，核心流程可分为 4 个阶段，各阶段依赖 ESP-IDF 提供的 WiFi 驱动接口实现：\n\n1. **初始化阶段**：\n\n   - 初始化 WiFi 组件（调用esp_wifi_init()），配置 WiFi 工作模式为 STA（通过wifi_init_config_t结构体设置mode = WIFI_MODE_STA）；\n\n   - 配置 TCP/IP 协议栈（ESP-IDF 默认自动初始化，无需手动操作，支持 DHCP 自动获取 IP 或静态 IP 配置）。\n\n2. **配置连接参数阶段**：\n\n   - 定义wifi_config_t结构体，填入目标 AP 的**SSID（WiFi 名称）** 和**Password（WiFi 密码）**，确保参数与 AP 一致（区分 SSID 大小写，密码长度需符合 AP 要求，如 WPA2-PSK 密码通常为 8-63 位）；\n\n   - 通过esp_wifi_set_config(WIFI_IF_STA, &wifi_config)将配置参数写入 ESP32 的 WiFi 接口。\n\n3. **启动与连接阶段**：\n\n   - 启动 STA 接口（esp_wifi_start()），ESP32 开始扫描周围 WiFi 信号；\n\n   - 自动匹配目标 AP 的 SSID，发起连接请求，与 AP 进行**认证（如 WPA2-PSK 认证）** 和**关联**；\n\n   - 若认证通过，ESP32 通过 DHCP 向 AP 请求 IP 地址（默认开启 DHCP 客户端），获取到 IP、子网掩码、网关后，完成 “物理连接→网络层连接” 的全流程。\n\n4. **状态监测阶段**：\n\n   - ESP32 通过**事件回调机制**（esp_event_loop_create_default()创建事件循环，esp_event_handler_instance_register()注册事件处理函数）反馈连接状态；\n\n   - 关键事件包括：WIFI_EVENT_STA_START（STA 接口启动成功）、WIFI_EVENT_STA_CONNECTED（与 AP 物理连接成功）、IP_EVENT_STA_GOT_IP（获取 IP 地址，联网完成）、WIFI_EVENT_STA_DISCONNECTED（与 AP 断开连接）。\n\n#### 实现步骤\n\n##### 重写事件处理函数（核心）\n\n```C\n/**\n * @brief WiFi事件与IP事件处理回调函数（核心逻辑）\n * @param arg：用户自定义参数，本代码未使用，传入NULL即可\n * @param event_base：事件基础类型，用于区分是WiFi相关事件（WIFI_EVENT）还是IP相关事件（IP_EVENT）\n * @param event_id：具体事件ID，标识当前触发的是该事件类型下的哪一种具体事件\n * @param event_data：事件关联的数据指针，如IP事件中可获取分配的IP地址信息\n * 功能：响应ESP32 WiFi模块的关键事件，更新连接状态、触发重连逻辑、通知外部状态变化\n */\nstatic void event_handler(void *arg, esp_event_base_t event_base,\n                          int32_t event_id, void *event_data)\n```\n\n##### 实现 STA 模式初始化函数\n\n```C\n// 引入所需头文件：自定义WiFi管理模块头文件、ESP32 WiFi驱动库、事件处理库\n// 日志打印库、FreeRTOS实时操作系统任务调度库、标准输入输出库\n#include \"wifi_manager.h\"\n#include \"esp_wifi.h\"\n#include \"esp_event.h\"\n#include \"esp_log.h\"\n#include \"nvs_flash.h\"\n#include \"freertos/FreeRTOS.h\"\n#include \"freertos/task.h\"\n#include <stdio.h>\n\n#define WIFI_SSID \"2078\"\n#define WIFI_PASSWORD \"12345678\"\n\n// 静态全局变量：WiFi状态回调函数指针，用于将WiFi连接/断开状态通知给外部调用者\n// 外部需通过wifi_manager_init函数传入自定义回调，接收WIFI_STATE_CONNECTED/WIFI_STATE_DISCONNECTED状态\nstatic p_wifi_state_cb wifi_state_cb = NULL;\n\n// 宏定义：STA模式下最大重连次数，限制重连次数避免无限循环占用CPU资源\n#define MAX_CONNECT_RETRY 10\n// 宏定义：日志标签，串口打印时用于区分该模块的日志，方便调试定位\n#define TAG \"wifi_manager\"\n\n// 静态全局变量：记录STA模式当前的重连尝试次数，初始值为0，每次重连失败自增1\nstatic int sta_connect_cnt = 0; // 重连次数\n\n// 静态全局变量：标记STA模式是否已成功连接到目标AP，true表示已连接，false表示未连接/已断开\nstatic bool is_sta_connected = false;\n\n/**\n * @brief WiFi事件与IP事件处理回调函数（核心逻辑）\n * @param arg：用户自定义参数，本代码未使用，传入NULL即可\n * @param event_base：事件基础类型，用于区分是WiFi相关事件（WIFI_EVENT）还是IP相关事件（IP_EVENT）\n * @param event_id：具体事件ID，标识当前触发的是该事件类型下的哪一种具体事件\n * @param event_data：事件关联的数据指针，如IP事件中可获取分配的IP地址信息\n * 功能：响应ESP32 WiFi模块的关键事件，更新连接状态、触发重连逻辑、通知外部状态变化\n */\nstatic void event_handler(void *arg, esp_event_base_t event_base,\n                          int32_t event_id, void *event_data)\n{\n    // 判断事件类型为WiFi相关事件（WIFI_EVENT）\n    if (event_base == WIFI_EVENT)\n    {\n        // 根据具体事件ID处理不同场景\n        switch (event_id)\n        {\n        // 事件：STA接口启动成功（调用esp_wifi_start()后触发此事件）\n        case WIFI_EVENT_STA_START:\n            // 启动成功后，主动调用esp_wifi_connect()发起WiFi连接请求\n            esp_wifi_connect();\n            break;\n\n        // 事件：STA与已连接的AP断开连接（如信号弱、密码错误、路由器重启等）\n        case WIFI_EVENT_STA_DISCONNECTED:\n            // 若之前处于已连接状态，先更新连接状态并通知外部\n            if (is_sta_connected)\n            {\n                is_sta_connected = false; // 将连接状态标记为未连接\n                if (wifi_state_cb)        // 若外部注册了回调函数，触发\"断开连接\"状态通知\n                    wifi_state_cb(WIFI_STATE_DISCONNECTED);\n            }\n\n            // 检查当前重连次数是否小于最大重连次数，若未达到则继续重试\n            if (sta_connect_cnt < MAX_CONNECT_RETRY)\n            {\n                sta_connect_cnt++;  // 重连次数自增1\n                esp_wifi_connect(); // 发起新一轮连接请求\n            }\n            // 若已达到最大重连次数，不再重试（避免无限重连）\n            wifi_state_cb(WIFI_STATE_DISCONNECTED);\n            break;\n\n        // 其他未定义的WiFi事件，暂不处理，直接break\n        default:\n            break;\n        }\n    }\n    // 判断事件类型为IP相关事件（IP_EVENT）\n    else if (event_base == IP_EVENT)\n    {\n        // 事件：STA成功从DHCP服务器获取到IP地址（标志网络层连接完成）\n        if (event_id == IP_EVENT_STA_GOT_IP)\n        {\n            // 打印日志提示已获取IP地址，便于调试确认\n            ESP_LOGI(TAG, \"Got IP address\");\n            sta_connect_cnt = 0;     // 重置重连次数\n            is_sta_connected = true; // 将连接状态标记为已连接\n            if (wifi_state_cb)       // 若外部注册了回调函数，触发\"连接成功\"状态通知\n                wifi_state_cb(WIFI_STATE_CONNECTED);\n        }\n    }\n}\n\n/**\n * @brief WiFi管理器初始化函数（STA模式初始化入口）\n * @param f：外部传入的WiFi状态回调函数，用于接收连接/断开状态通知\n * 功能：初始化ESP32网络接口、事件循环、WiFi驱动，配置STA模式并启动WiFi模块\n * 注意：使用WiFi功能前必须先调用此函数完成初始化，建议在app_main()中优先执行\n */\nvoid wifi_manager_init(p_wifi_state_cb f)\n{\n    // 1. 初始化NVS（ESP32存储WiFi配置的依赖组件，必须先初始化）\n    esp_err_t ret = nvs_flash_init();\n    if (ret == ESP_ERR_NVS_NO_FREE_PAGES || ret == ESP_ERR_NVS_NEW_VERSION_FOUND)\n    {\n        ESP_ERROR_CHECK(nvs_flash_erase()); // 若NVS有问题，先擦除再初始化\n        ret = nvs_flash_init();\n    }\n\n    // 2. 初始化ESP32网络接口（TCP/IP协议栈初始化，必须在WiFi初始化前执行）\n    ESP_ERROR_CHECK(esp_netif_init());\n\n    // 3. 创建默认的事件循环（用于处理WiFi和IP事件）\n    ESP_ERROR_CHECK(esp_event_loop_create_default());\n    esp_netif_create_default_wifi_sta(); // 使用默认的STA模式网络接口\n\n    // 4. 初始化WiFi驱动：使用WIFI_INIT_CONFIG_DEFAULT()获取默认配置（包含时钟、中断等参数）\n    wifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT();\n    ESP_ERROR_CHECK(esp_wifi_init(&cfg)); // 执行WiFi驱动初始化，若失败则触发错误检查\n\n    // 5. 注册事件处理函数：监听WiFi事件和IP事件\n    // 5.1注册WiFi事件监听器：监听所有WiFi事件（ESP_EVENT_ANY_ID），触发时调用event_handler处理\n    ESP_ERROR_CHECK(esp_event_handler_instance_register(WIFI_EVENT,\n                                                        ESP_EVENT_ANY_ID,\n                                                        &event_handler,\n                                                        NULL,\n                                                        NULL));\n    // 5.2注册IP事件监听器：仅监听\"STA获取IP\"事件（IP_EVENT_STA_GOT_IP）\n    ESP_ERROR_CHECK(esp_event_handler_instance_register(IP_EVENT,\n                                                        IP_EVENT_STA_GOT_IP,\n                                                        &event_handler,\n                                                        NULL,\n                                                        NULL));\n\n    // 6. 保存外部传入的状态回调函数，后续状态变化时通过此函数通知外部\n    wifi_state_cb = f;\n\n    wifi_config_t wifi_config = {\n        .sta = {\n            // 配置STA的认证模式为WPA2-PSK（主流家用/工业路由器默认加密方式）\n            .threshold.authmode = WIFI_AUTH_WPA2_PSK,\n            .ssid = WIFI_SSID,\n            .password = WIFI_PASSWORD,\n        },\n    };\n\n    // 7. 配置WiFi工作模式为纯STA模式（仅作为客户端连接外部AP，不开启AP模式）\n    ESP_ERROR_CHECK(esp_wifi_set_mode(WIFI_MODE_STA));\n    ESP_ERROR_CHECK(esp_wifi_set_config(WIFI_IF_STA, &wifi_config)); // 写入配置\n    // 8. 启动WiFi模块（启动后会触发WIFI_EVENT_STA_START事件，进而发起连接）\n    ESP_ERROR_CHECK(esp_wifi_start());\n    ESP_LOGI(TAG, \"STA initialization done\");\n}\n\n```\n\n\n\n\n\n\n\n","tags":["RTOS","ESP32"],"categories":["MCU"]},{"title":"LVGL学习之旅（基于正点原子STM32F407探索者）","url":"/2025/09/07/LVGL学习之旅/","content":"\n## LVGL 基础\n\n> LVGL（Light and Versatile Graphics Library）轻量级通用型图形库，是一个免费的开源图形库，提供了创建嵌入式 GUI 所需的一切，具有易于使用的组件，美观的视觉效果和低内存占用等特点。支持触摸屏操作，移植简单方便，开发者一直在不断完善更新。\n>\n> 特点：\n>\n> - 丰富且强大的模块化图形组件：按钮 (buttons)、图表 (charts)、列表 (lists)、滑动条 (sliders)、图片 (images) 等\n> - 高级的图形引擎：动画、抗锯齿、透明度、平滑滚动、图层混合等效果\n> - 不依赖特定的硬件平台，可以在任何显示屏上运行\n> - 配置可裁剪（最低资源占用：<span style=\"color:#FF0000;\">64 kB Flash，16 kB RAM</span>）\n> - 基于<span style=\"color:#FF0000;\">UTF-8</span>的多语种支持，例如中文、日文、韩文、阿拉伯文等\n> - 可以通过类CSS的方式来设计、布局图形界面（例如：Flexbox、Grid）\n> - 支持操作系统、外置内存、以及硬件加速（LVGL已内建支持STM32 DMA2D、NXP PXP和VGLite）\n> - 即便仅有单缓冲区(frame buffer)的情况下，也可保证渲染如丝般顺滑\n> - 全部由C编写完成，并支持C++调用\n> - 支持Micropython编程，参见：LVGL API in Micropython\n> - 支持模拟器仿真，可以无硬件依托进行开发\n\n## TFT-LCD配置——移植正点原子官方LCD例程\n\n### 点亮LCD——FSMC配置\n\n#### 先根据原理图配置`FSMC`\n\n![image-20250907155616208](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071556284.png)\n\n![image-20250907160758201](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071607256.png)\n\n#### 详细FSMC参数配置\n\n> 这里根据正点原子官方`lcd_init` 来设置 如下图\n\n![image-20250907164335816](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071643877.png)\n\n![img](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071724936.png)\n\n![img](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071725408.png)\n\n\n\n#### 背光引脚配置\n\n![img](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071725075.png)\n\n#### 生成代码并将LCD、sys、delay文件夹添加到工程中\n\n![image-20250907234315989](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509072343199.png)\n\n##### 首先将*HAL_SRAM_MspInit*函数整个屏蔽\n\n![image-20250907171842072](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071718133.png)\n\n##### 将lcd_init中有关fsmc部分屏蔽\n\n> 屏蔽部分如下\n\n```C\nvoid LCD_Init(void)\n{ \t  \n//\tGPIO_InitTypeDef GPIO_Initure;\n//\tFSMC_NORSRAM_TimingTypeDef FSMC_ReadWriteTim;\n//\tFSMC_NORSRAM_TimingTypeDef FSMC_WriteTim;\n//    \n//\t__HAL_RCC_GPIOB_CLK_ENABLE();\t\t\t//开启GPIOB时钟\n//\tGPIO_Initure.Pin=GPIO_PIN_15;          \t//PB15,背光控制\n//\tGPIO_Initure.Mode=GPIO_MODE_OUTPUT_PP;  //推挽输出\n//\tGPIO_Initure.Pull=GPIO_PULLUP;          //上拉\n//\tGPIO_Initure.Speed=GPIO_SPEED_HIGH;     //高速\n//\tHAL_GPIO_Init(GPIOB,&GPIO_Initure); \n//\t\n//\tTFTSRAM_Handler.Instance=FSMC_NORSRAM_DEVICE;                \n//\tTFTSRAM_Handler.Extended=FSMC_NORSRAM_EXTENDED_DEVICE;    \n//    \n//\tTFTSRAM_Handler.Init.NSBank=FSMC_NORSRAM_BANK4;     \t\t\t\t//使用NE4\n//\tTFTSRAM_Handler.Init.DataAddressMux=FSMC_DATA_ADDRESS_MUX_DISABLE; \t//地址/数据线不复用\n//\tTFTSRAM_Handler.Init.MemoryType=FSMC_MEMORY_TYPE_SRAM;   \t\t\t//SRAM\n//\tTFTSRAM_Handler.Init.MemoryDataWidth=FSMC_NORSRAM_MEM_BUS_WIDTH_16; //16位数据宽度\n//\tTFTSRAM_Handler.Init.BurstAccessMode=FSMC_BURST_ACCESS_MODE_DISABLE; //是否使能突发访问,仅对同步突发存储器有效,此处未用到\n//\tTFTSRAM_Handler.Init.WaitSignalPolarity=FSMC_WAIT_SIGNAL_POLARITY_LOW;//等待信号的极性,仅在突发模式访问下有用\n//\tTFTSRAM_Handler.Init.WaitSignalActive=FSMC_WAIT_TIMING_BEFORE_WS;   //存储器是在等待周期之前的一个时钟周期还是等待周期期间使能NWAIT\n//\tTFTSRAM_Handler.Init.WriteOperation=FSMC_WRITE_OPERATION_ENABLE;    //存储器写使能\n//\tTFTSRAM_Handler.Init.WaitSignal=FSMC_WAIT_SIGNAL_DISABLE;           //等待使能位,此处未用到\n//\tTFTSRAM_Handler.Init.ExtendedMode=FSMC_EXTENDED_MODE_ENABLE;        //读写使用不同的时序\n//\tTFTSRAM_Handler.Init.AsynchronousWait=FSMC_ASYNCHRONOUS_WAIT_DISABLE;//是否使能同步传输模式下的等待信号,此处未用到\n//\tTFTSRAM_Handler.Init.WriteBurst=FSMC_WRITE_BURST_DISABLE;           //禁止突发写\n//\tTFTSRAM_Handler.Init.ContinuousClock=FSMC_CONTINUOUS_CLOCK_SYNC_ASYNC;\n//    \n//\t//FMC读时序控制寄存器\n//\tFSMC_ReadWriteTim.AddressSetupTime=0x0F;       \t//地址建立时间（ADDSET）为16个HCLK 1/168M=6ns*16=96ns\n//\tFSMC_ReadWriteTim.AddressHoldTime=0;\n//\tFSMC_ReadWriteTim.DataSetupTime=60;\t\t\t\t//数据保存时间为60个HCLK\t=6*60=360ns\n//\tFSMC_ReadWriteTim.AccessMode=FSMC_ACCESS_MODE_A;//模式A\n//\t//FMC写时序控制寄存器\n//\tFSMC_WriteTim.BusTurnAroundDuration=0;\t\t\t//总线周转阶段持续时间为0，此变量不赋值的话会莫名其妙的自动修改为4。导致程序运行正常\n//\tFSMC_WriteTim.AddressSetupTime=9;          \t\t//地址建立时间（ADDSET）为9个HCLK =54ns \n//\tFSMC_WriteTim.AddressHoldTime=0;\n//\tFSMC_WriteTim.DataSetupTime=8;              \t//数据保存时间为6ns*9个HCLK=54n\n//\tFSMC_WriteTim.AccessMode=FSMC_ACCESS_MODE_A;    //模式A\n//\tHAL_SRAM_Init(&TFTSRAM_Handler,&FSMC_ReadWriteTim,&FSMC_WriteTim);\t\n\n//\tHAL_Delay(50); // delay 50 ms \n\t\n\t//尝试9341 ID的读取\t\t\n\tLCD_WR_REG(0XD3);\t\t\n    .........\n}\n```\n\n> 注意有个坑！！！！\n>\n> 正点原子官方的`lcd_init`函数中有个 `printf(\" LCD ID:%x\\r\\n\",lcddev.id);`，所以在此之前需先进行串口重定向  \n\n##### 替换官方的delay函数\n\n```C\nvoid delay_us(u32 nus)\n{\n\tuint32_t Delay = nus * 168 / 4;\n\tdo\n\t{\n\t\t__NOP();\n\t} while (Delay--);\n}\n\n// 延时nms\n// nms:要延时的ms数\nvoid delay_ms(u16 nms)\n{\n\tHAL_Delay(nms);\n}\n```\n\n\n\n##### 修改点亮背光函数\n\n> 在`lcd_init`函数最后 将`LCD_BL(1)`替换为`HAL_GPIO_WritePin(LCD_BL_GPIO_Port, LCD_BL_Pin, GPIO_PIN_SET);`\n\n### 触摸屏TOUCH移植\n\n#### 将BSP文件夹下的24CXX、IIC与TOUCH文件夹添加到项目中\n\n![image-20250907180027576](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071800663.png)\n\n## LVGL移植国内码云仓库：https://gitee.com/mirrors/lvgl\n\n![image-20250907180958855](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071809967.png)\n\n![image-20250907181022271](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071810376.png)\n\n> 注意不要直接克隆 直接克隆下载的是最新的 可以选择右上角下载zip 就可以选中当前分支\n\n### 裁剪LVGL源码\n\n#### 根目录\n\n> 仅保留 demos、examples、src文件夹以及两个.h文件 如下图\n\n![image-20250907181309155](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071813234.png)\n\n#### 进入`examples`文件夹 删去除`porting`文件夹\n\n![image-20250907181406209](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071814287.png)\n\n#### 更改`lv_conf_template.h`\n\n> 1. 将`lv_conf_template.h`更名为`lv_conf.h`\n> 2. 进入该文件 将里面的#if 0 改为#if 1\n>\n> ![image-20250907182017202](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071820299.png)\n\n### 按以下结构创建文件夹\n\n```C\nProject\n----Middlewares\n--------LVGL\n------------GUI\n----------------lvgl\n------------GUI_APP\n```\n\n> 将裁剪后的LVGL库文件复制到`Middlewares/LVGL/GUI/lvgl`文件夹下\n\n### Keil配置\n\n#### 创建如下管理\n\n![image-20250907194802955](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071948050.png)\n\n#### 添加路径\n\n![image-20250907194859063](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071948156.png)\n\n> - 注意一定要开启C99模式\n>\n> ![image-20250907195152454](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071951544.png)\n>\n> - 可以屏蔽MDK警告\n>\n>   --diag_suppress=68 --diag_suppress=111 --diag_suppress=188 --diag_suppress=223 --diag_suppress=546  --diag_suppress=1295\n>\n> \n\n#### 添加文件到项目\n\n![image-20250907195111490](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071951610.png)\n\n### LVGL文件修改\n\n#### 配置LCD屏幕显示\n\n![image-20250907195420988](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071954102.png)\n\n##### 包含输出设备驱动头文件\n\n> 在`lv_port_disp_template.c`引入`lcd.h` 如`#include \"../BSP/LCD/lcd.h\"`\n\n##### 在`disp_init`函数中初始化\n\n```C\nstatic void disp_init(void)\n{\n    /*You code here*/\n    LCD_Init();\n    LCD_Display_Dir(1); // 横屏\n}\n```\n\n##### 配置图形数据缓冲方式\n\n> 进入`lv_port_disp_init`函数\n>\n> 选择缓冲方式 另外两个将其屏蔽\n>\n> ![image-20250907195842896](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071958994.png)\n\n##### 修改`disp_flush`函数\n\n```C\nstatic void disp_flush(lv_disp_drv_t *disp_drv, const lv_area_t *area, lv_color_t *color_p)\n{\n    /*The most simple case (but also the slowest) to put all pixels to the screen one-by-one*/\n    /*官方打点函数 */\n    // int32_t x;\n    // int32_t y;\n    // for (y = area->y1; y <= area->y2; y++)\n    // {\n    //     for (x = area->x1; x <= area->x2; x++)\n    //     {\n    //         /*Put a pixel to the display. For example:*/\n    //         /*put_px(x, y, *color_p)*/\n    //         color_p++;\n    //     }\n    // }\n\n    LCD_Color_Fill(area->x1, area->y1, area->x2, area->y2, (uint16_t *)color_p);\n    /*IMPORTANT!!!\n     *Inform the graphics library that you are ready with the flushing*/\n    lv_disp_flush_ready(disp_drv);\n}\n```\n\n#### 配置输入（触摸）\n\n![image-20250907200123083](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509072001216.png)\n\n##### 按需裁剪输入设备\n\n> 打开`lv_port_indev_template.c` 此处我们只需要触摸输入 所以把除了touchpad 其他都屏蔽或删去\n>\n> 注意：一定要把其他无关的屏蔽掉 否则会无法触摸\n\n##### 在`touchpad_init`函数中初始化触摸屏\n\n```C\nstatic void touchpad_init(void)\n{\n    /*Your code comes here*/\n    tp_dev.init();\n}\n```\n\n##### 修改`touchpad_is_pressed`函数\n\n```C\nstatic bool touchpad_is_pressed(void)\n{\n    /*Your code comes here*/\n    tp_dev.scan(0); // É¨ÃèÎïÀí×ø±ê\n    if (tp_dev.sta & TP_PRES_DOWN)\n    {\n        return true;\n    }\n    return false;\n}\n```\n\n##### 配置坐标获取函数\n\n```C\nstatic void touchpad_get_xy(lv_coord_t *x, lv_coord_t *y)\n{\n    /*Your code comes here*/\n\n    (*x) = tp_dev.x[0];\n    (*y) = tp_dev.y[0];\n}\n```\n\n#### 提供时基\n\n> - 使用CubeMX生成一个定时1ms的定时器\n> - 在`tim.c`中引用`#include \"lvgl.h\"`\n> - 在定时器中断回调函数中`lv_tick_inc(1);`\n\n![image-20250907201034944](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509072010067.png)\n\n![image-20250907200845233](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509072008331.png)\n\n#### `main`函数部分\n\n![image-20250907201115783](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509072011915.png)\n\n```C\n#include \"lvgl.h\"\n#include \"lv_port_disp_template.h\"\n#include \"lv_port_indev_template.h\"\n....\nint main(void)\n{\n    .....\n  HAL_TIM_Base_Start_IT(&htim3); // 启动定时器3中断 为lvgl提供时基\n  lv_init();                     // 初始化LVGL\n  lv_port_disp_init();           // 初始化显示接口\n  lv_port_indev_init();          // 初始化输入接口\n  while (1)\n  {\n    lv_timer_handler(); // 处理LVGL任务\n    delay_ms(5);\n  }\n}\n```\n","tags":["LVGL v8.2","RTOS","嵌入式基础"],"categories":["MCU"]},{"title":"freertos","url":"/2025/09/05/freertos/","content":"\n## FreeRTOS基础\n\n### 获取系统时间\n\n```C\nTickType_t currentTicks;\nwhile(1)\n{\n     currentTicks = xTaskGetTickCount();\n     printf(\"[%lu]dev:%u,name:%s\\r\\n\", currentTicks, data->dev, data->data);\n}\n```\n\n\n\n### 堆和栈\n\n堆：一块空闲的内存 可以使用`malloc`申请内存 使用完后用`free`释放内存\n\n> 堆也可以理解为就是定义了一个堆大小的数组 然后定义一个长度 每次动态改变长度来申请空间（链表）\n>\n> 在`FreeRTOSConfig.h`中就有定义堆大小的宏`configTOTAL_HEAP_SIZE` 他被引用到 `heap.c`中的 `static uint8_t ucHeap[configTOTAL_HEAP_SIZE];`\n\n栈：一块内存空间，CPU的SP寄存器指向它，它可以用于函数调用、局部变量、`多任务系统里保存现场`\n\n> 栈是`FreeRTOS`中非常重要的概念，每个任务都有自己的栈\n\n###  FreeRTOS源码概述\n\n#### 目录结构\n\n![img](https://photos.100ask.net/renesas-docs/DShanMCU_RA6M5/FreeRTOS/chapter-6/image1.png)\n\n> 主要涉及3个目录：\n>\n> - `ra\\aws\\FreeRTOS\\FreeRTOS\\Source`：存放的是FreeRTOS的核心文件\n> - `ra_gen`：从main.c可以看到创建任务的函数调用过程\n> - `src`：使用RASC创建任务时，在src目录下生成任务的入口函数\n\n#### 核心文件\n\n> FreeRTOS的最核心文件只有2个：\n>\n> - `FreeRTOS/Source/tasks.c`\n> - `FreeRTOS/Source/list.c`\n\n其他文件的作用也一起列表如下：\n\n| **`FreeRTOS/Source/`下的文件** | **作用**                                      |\n| ------------------------------ | --------------------------------------------- |\n| `tasks.c`                      | 必需，任务操作                                |\n| `list.c`                       | 必须，列表                                    |\n| `queue.c`                      | 基本必需，提供队列操作、信号量(semaphore)操作 |\n| `timer.c`                      | 可选，software timer                          |\n| `event_groups.c`               | 可选，提供event group功能                     |\n\n#### 头文件相关\n\n##### 头文件目录\n\n> FreeRTOS需要3个头文件目录：\n>\n> - FreeRTOS本身的头文件：`ra\\aws\\FreeRTOS\\FreeRTOS\\Source\\include`\n> - 移植时用到的头文件：`ra\\fsp\\src\\rm_freertos_port\\portmacro.h`\n> - 含有配置文件`FreeRTOSConfig.h`的目录：`ra_cfg\\aws`\n\n##### 头文件\n\n列表如下：\n\n| **头文件**         | **作用**                                                     |\n| ------------------ | ------------------------------------------------------------ |\n| `FreeRTOSConfig.h` | FreeRTOS的配置文件，比如选择调度算法：`configUSE_PREEMPTION` 每个工程都必定含有`FreeRTOSConfig.h` |\n| `FreeRTOS.h`       | 使用FreeRTOS API函数时，<span style=\"font-weight:bold;\">必须</span>包含此文件。 在`FreeRTOS.h`之后，再去包含其他头文件，比如： `task.h`、`queue.h`、`semphr.h`、`event_group.h` |\n\n#### 独属于FreeRTOS的数据类型和编程规范\n\n##### 数据类型\n\n每个移植的版本都含有自己的 **`portmacro.h`** 头文件，里面定义了2个数据类型：\n\n1. `TickType_t`：\n   - 时钟计数单位 （可以是uint16_t 也可以是uint32_t）\n     当`FreeRTOSConfig.h`中定义`configUSE_16_BIT_TICKS时 TickType_t`则为uint16_t\n\n> 对于32位架构，建议把TickType_t配置为uint32_t\n\n2. `BaseType_t`:这是该架构最高效的数据类型(取决于CPU是多少位的架构)\n   - `BaseType_t`通常用作简单的返回值的类型，还有逻辑值，比如 **pdTRUE/pdFALSE**\n\n#####  变量名\n\n变量名的前缀 对应其类型 如：`pcName` (代表着他是一个指向char类型的指针p)\n\n| **变量名前缀** | **含义**                                                     |\n| -------------- | ------------------------------------------------------------ |\n| c              | char                                                         |\n| s              | int16_t，short                                               |\n| l              | int32_t，long                                                |\n| x              | BaseType_t， 其他非标准的类型：结构体、task handle、queue handle等 |\n| u              | unsigned                                                     |\n| p              | 指针                                                         |\n| uc             | uint8_t，unsigned char                                       |\n| pc             | char指针                                                     |\n\n##### 函数名\n\n函数名的前缀有2部分：返回值类型、在哪个文件定义。\n\n| **函数名前缀**                                           | **含义**                                     |\n| -------------------------------------------------------- | -------------------------------------------- |\n| v<span style=\"font-weight:bold;\">Task</span>PrioritySet  | 返回值类型：void 在`task.c`中定义            |\n| x<span style=\"font-weight:bold;\">Queue</span>Receive     | 返回值类型：BaseType_t 在`queue.c`中定义     |\n| pv<span style=\"font-weight:bold;\">Timer</span>GetTimerID | 返回值类型：pointer to void 在`tmer.c`中定义 |\n\n##### 宏的名\n\n宏的名字是大小，可以添加小写的前缀。前缀是用来表示：宏在<span style=\"font-weight:bold;\">哪个文件</span>中定义。\n\n| **宏的前缀**                                                 | **含义：在哪个文件里定义**  |\n| ------------------------------------------------------------ | --------------------------- |\n| port (比如<span style=\"font-weight:bold;\">port</span>MAX_DELAY) | `portable.h`或`portmacro.h` |\n| task (比如<span style=\"font-weight:bold;\">task</span>ENTER_CRITICAL()) | `task.h`                    |\n| pd (比如<span style=\"font-weight:bold;\">pd</span>TRUE)       | `projdefs.h`                |\n| config (比如<span style=\"font-weight:bold;\">config</span>USE_PREEMPTION) | `FreeRTOSConfig.h`          |\n| err (比如<span style=\"font-weight:bold;\">err</span>QUEUE_FULL) | `projdefs.h`                |\n\n通用的宏定义如下：\n\n| **宏**    | **值** |\n| --------- | ------ |\n| `pdTRUE`  | 1      |\n| `pdFALSE` | 0      |\n| `pdPASS`  | 1      |\n| `pdFAIL`  | 0      |\n\n### 内存管理\n\n>  FreeRTOS中内存管理的接口函数为：`pvPortMalloc` 、`vPortFree`，对应于C库的`malloc`、`free`。 文件在`FreeRTOS/Source/portable/MemMang`下，它也是放在`portable目录`下，表示你可以提供自己的函数。\n>\n> 源码中默认提供了5个文件，对应内存管理的5种方法。\n\n| **文件**         | **优点**                                           | **缺点**                                             |\n| ---------------- | -------------------------------------------------- | ---------------------------------------------------- |\n| `heap_1.c`       | 分配简单，时间确定                                 | 只分配、<span style=\"color:#FF0000;\">不回收</span>   |\n| `heap_2.c`       | 动态分配、最佳匹配                                 | <span style=\"color:#FF0000;\">碎片</span>、时间不定   |\n| `heap_3.c`       | 调用<span style=\"color:#FF3333;\">标准库</span>函数 | <span style=\"color:#FF0000;\">速度慢</span>、时间不定 |\n| `heap_4.c`(常用) | 相邻空闲内存可合并                                 | 可解决碎片问题、时间不定                             |\n| `heap_5.c`       | 在heap_4基础上支持分隔的内存块                     | 可解决碎片问题、时间不定                             |\n\n#### Heap相关的函数\n\n#####  分配、释放内存\n\n函数原型：\n\n```c\nvoid * pvPortMalloc( size_t xWantedSize );\nvoid vPortFree( void * pv );\n```\n\n作用：分配内存、释放内存。\n\n如果分配内存不成功，则返回值为NULL。\n\n##### 检测剩余多少空闲内存\n\n函数原型：\n\n```c\nsize_t xPortGetFreeHeapSize( void );\n```\n\n> 当前还有多少空闲内存，这函数可以用来优化内存的使用情况。比如当所有内核对象都分配好后，执行此函数返回2000，那么`configTOTAL_HEAP_SIZE`就可减小2000。\n\n注意：在heap_3中无法使用。\n\n#####  获取空闲内存容量的最小值\n\n函数原型：\n\n```c\nsize_t xPortGetMinimumEverFreeHeapSize( void );\n```\n\n返回：程序运行过程中，空闲内存容量的最小值。\n\n注意：只有heap_4、heap_5支持此函数。\n\n##### `malloc失败的钩子函数`\n\n在pvPortMalloc函数内部：\n\n```c\nvoid * pvPortMalloc( size_t xWantedSize )vPortDefineHeapRegions\n{\n    ......\n    #if ( configUSE_MALLOC_FAILED_HOOK == 1 )\n        {\n            if( pvReturn == NULL )\n            {\n                extern void vApplicationMallocFailedHook( void );\n                vApplicationMallocFailedHook();\n            }\n        }\n    #endif\n    \n    return pvReturn;        \n}\n```\n\n所以，如果想使用这个钩子函数：\n\n- 在`FreeRTOSConfig.h`中，把`configUSE_MALLOC_FAILED_HOOK`定义为1\n- 提供`vApplicationMallocFailedHook`函数\n- `pvPortMalloc`失败时，才会调用此函数\n\n### 任务管理\n\n#### 任务创建与删除\n\n##### 什么是任务\n\n在FreeRTOS中，任务就是一个函数，原型如下：\n\n```c\nvoid ATaskFunction( void *pvParameters );\n```\n\n要注意的是：\n\n- 这个函数不能返回\n- 同一个函数，可以用来创建多个任务；换句话说，多个任务可以运行同一个函数\n- 函数内部，尽量使用局部变量：\n  - 每个任务都有自己的栈\n  - 每个任务运行这个函数时\n    - 任务A的局部变量放在任务A的栈里、任务B的局部变量放在任务B的栈里\n    - 不同任务的局部变量，有自己的副本\n  - 函数使用全局变量、静态变量的话\n    - 只有一个副本：多个任务使用的是同一个副本\n    - 要防止冲突(后续会讲) 下面是一个示例：\n\n```c\nvoid ATaskFunction( void *pvParameters )\n{\n\t/* 对于不同的任务，局部变量放在任务的栈里，有各自的副本 */\n\tint32_t lVariableExample = 0;\n\t\n    /* 任务函数通常实现为一个无限循环 */\n\tfor( ;; )\n\t{\n\t\t/* 任务的代码 */\n\t}\n\n    /* 如果程序从循环中退出，一定要使用vTaskDelete删除自己\n     * NULL表示删除的是自己\n     */\n\tvTaskDelete( NULL );\n    \n    /* 程序不会执行到这里, 如果执行到这里就出错了 */\n}\n```\n\n##### 创建任务\n\n创建任务时使用的函数如下：\n\n```c\nBaseType_t xTaskCreate( TaskFunction_t pxTaskCode, // 函数指针, 任务函数\n                        const char * const pcName, // 任务的名字\n                        const configSTACK_DEPTH_TYPE usStackDepth, // 栈大小,单位为word,10表示40字节\n                        void * const pvParameters, // 调用任务函数时传入的参数\n                        UBaseType_t uxPriority,    // 优先级\n                        TaskHandle_t * const pxCreatedTask ); // 任务句柄, 以后使用它来操作这个任务\n```\n\n参数说明：\n\n| **参数**      | **描述**                                                     |\n| ------------- | ------------------------------------------------------------ |\n| pvTaskCode    | 函数指针，任务对应的 C 函数。任务应该永远不退出，或者在退出时调用 \"`vTaskDelete(NULL)`\"。 |\n| pcName        | 任务的名称，仅用于调试目的，FreeRTOS 内部不使用。pcName 的长度为 `configMAX_TASK_NAME_LEN`。 |\n| usStackDepth  | 每个任务都有自己的栈，usStackDepth 指定了栈的大小，单位为 word。例如，如果传入 100，表示栈的大小为 100 word，即 400 字节。最大值为 uint16_t 的最大值。确定栈的大小并不容易，通常是根据估计来设定。精确的办法是查看反汇编代码。 |\n| pvParameters  | 调用 pvTaskCode 函数指针时使用的参数：`pvTaskCode(pvParameters)`。 |\n| uxPriority    | 任务的优先级范围为 0~(`configMAX_PRIORITIES – 1`)。数值越小，优先级越低。如果传入的值过大，`xTaskCreate `会将其调整为 (`configMAX_PRIORITIES – 1`)。 |\n| pxCreatedTask | 用于保存 xTaskCreate 的输出结果，即任务的句柄（task handle）。如果以后需要对该任务进行操作，如修改优先级，则需要使用此句柄。如果不需要使用该句柄，可以传入 NULL。 |\n| 返回值        | 成功时返回 pdPASS，失败时返回 `errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY`（失败原因是内存不足）。请注意，文档中提到的失败返回值是 pdFAIL 是不正确的。pdFAIL 的值为 0，而 `errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY` 的值为 -1。 |\n\n使用静态分配内存的函数如下：\n\n```c\nTaskHandle_t xTaskCreateStatic ( \n    TaskFunction_t pxTaskCode,   // 函数指针, 任务函数\n    const char * const pcName,   // 任务的名字\n    const uint32_t ulStackDepth, // 栈大小,单位为word,10表示40字节\n    void * const pvParameters,   // 调用任务函数时传入的参数\n    UBaseType_t uxPriority,      // 优先级\n    StackType_t * const puxStackBuffer, // 静态分配的栈，就是一个buffer\n    StaticTask_t * const pxTaskBuffer // 静态分配的任务结构体的指针，用它来操作这个任务\n);\n```\n\n相比于使用动态分配内存创建任务的函数，最后2个参数不一样：\n\n| **参数**       | **描述**                                                     |\n| -------------- | ------------------------------------------------------------ |\n| pvTaskCode     | 函数指针，可以简单地认为任务就是一个C函数。 它稍微特殊一点：永远不退出，或者退出时要调用\"`vTaskDelete(NULL)`\" |\n| pcName         | 任务的名字，FreeRTOS内部不使用它，仅仅起调试作用。 长度为：`configMAX_TASK_NAME_LEN` |\n| usStackDepth   | 每个任务都有自己的栈，这里指定栈大小。 单位是word，比如传入100，表示栈大小为100 word，也就是400字节。 最大值为uint16_t的最大值。 怎么确定栈的大小，并不容易，很多时候是估计。 精确的办法是看反汇编码。 |\n| pvParameters   | 调用pvTaskCode函数指针时用到：pvTaskCode(pvParameters)       |\n| uxPriority     | 优先级范围：0~(`configMAX_PRIORITIES – 1`) 数值越小优先级越低， 如果传入过大的值，`xTaskCreate`会把它调整为(`configMAX_PRIORITIES – 1`) |\n| puxStackBuffer | 静态分配的栈内存，比如可以传入一个数组， 它的大小是`usStackDepth*4`。 |\n| pxTaskBuffer   | 静态分配的`StaticTask_t`结构体的指针                         |\n| 返回值         | 成功：返回任务句柄； 失败：NULL                              |\n\n#### 任务栈大小估算\n\n任务栈空间包含\n\n- 返回地址`LR`与其他寄存器：可以理解为<span style=\"color:#FF0000;\">函数调用深度</span>\n- 局部变量：如`char buff[1000]` 直接看类型 此处则可以算1个\n- 保留现场：可以理解为固定16个寄存器 即<span style=\"color:#FF3333;\">16 * 4 = 64b</span>\n\n> 公式如下：\n>\n> - （n层调用 * 36） + 局部变量 + 64b\n>\n> - 例如：\n>\n>   ![image-20250914221448446](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509142214793.png)\n\n#### 使用任务参数\n\n我们说过，多个任务可以使用同一个函数，怎么体现它们的差别？\n\n- 栈不同\n- 创建任务时可以传入不同的参数\n\n我们创建2个任务，使用同一个函数，但是在LCD上打印不一样的信息。\n\n```c\ntypedef struct{\n    int x;\n    int y;\n    const char *str;\n}DisplayInfo;\nvoid vTaskFunction( void *pvParameters )\n{\n\tDisplayInfo *info = pvParameters;\n\tuint32_t cnt = 0;\nuint32_t len;\n\t\n\t/* 任务函数的主体一般都是无限循环 */\n\tfor( ;; )\n\t{\n\t\t/* 打印任务的信息 */\n\t\tlen = LCD_PrintString(info->x, info->y, info->str);\n\t\tLCD_PrintSignedVal(len+1, info->y, cnt++);\n\n\t\tmdelay(500);\n\t}\n}\n```\n\n上述代码中的info来自参数pvParameters，pvParameters来自哪里？创建任务时传入的。\n\n代码如下：\n\n- 使用xTaskCreate创建任务时，第4个参数就是pvParameters\n- 不同的任务，pvParameters不一样\n\n```c\nDisplayInfo g_Task1Info ={0,0,\"task1\"};\nDisplayInfo g_Task2Info ={3,0,\"task2\"};\nDisplayInfo g_Task3Info ={6,0,\"task3\"};\n\n/* 使用同一个函数创建不同的任务 */\n  xTaskCreate(LcdPrintTask, \"task1\", 128, &g_Task1Info, osPriorityNormal, NULL);\n  xTaskCreate(LcdPrintTask, \"task2\", 128, &g_Task2Info, osPriorityNormal, NULL);\n  xTaskCreate(LcdPrintTask, \"task3\", 128, &g_Task3Info, osPriorityNormal, NULL);\n```\n\n#### 任务的删除\n\n删除任务时使用的函数如下：\n\n```c\nvoid vTaskDelete( TaskHandle_t xTaskToDelete );\n```\n\n参数说明：\n\n| **参数**   | **描述**                                                     |\n| ---------- | ------------------------------------------------------------ |\n| pvTaskCode | 任务句柄，使用xTaskCreate创建任务时可以得到一个句柄。 也可传入NULL，这表示删除自己。 |\n\n怎么删除任务？举个不好的例子：\n\n- 自杀：`vTaskDelete(NULL)`\n- 被杀：别的任务执行`vTaskDelete(pvTaskCode)`，`pvTaskCode`是自己的句柄\n- 杀人：执行`vTaskDelete(pvTaskCode)`，`pvTaskCode`是别的任务的句柄\n\n#### 任务管理与调度机制\n\n##### 调度机制\n\n> - 同等优先级的任务 轮流运行\n> - 最高优先级的任务先运行\n>   - 高优先级的任务未运行完，低优先级任务无法运行\n>   - 一旦高优先级任务就绪 马上运行\n>   - 最高优先级的任务有多个 他们轮流运行\n\n![img](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509151548547.png)\n\n##### 任务管理\n\n任务的切换通过链表操作进行切换 RTOS会创建3个链表 分别是就绪链表ReadyList、阻塞链表DelayTaskList、挂起链表\n\n- 先在优先级数组中按下标从大到小遍历，使用任务创建函数<span style=\"color:#33FFFF;\">本质其实是在对应优先级数组中创建TCB结构体，并且会有一个全局指针——当前执行TCB结构体pxCurrentTCB</span>，这就说明了为什么同等优先级下，最后创建的任务先运行（因为指针最终指向了最后一个任务链表，启动调度器后，开始运行）\n\n- 当调用`vTaskDelay`后会将当前任务链表丢到阻塞链表上，并根据`vTaskDelay`的参数等待`Tick中断`判断到达时间后，该任务链表才能再次回到原先链表上\n\n- 当任务调用`vTaskSuspend`后 当前任务会被丢到挂起链表，此任务只有调用`vTaskResume`才能回到原先链表，不能通过`Tick中断`回归\n\n> Tick中断是什么？他又做些什么？\n>\n> - Tick中断来源于\n>\n>   ![image-20250915160032344](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509151600535.png)\n>\n> - Tick中断做什么？\n>\n>   1. 有个计数器count，count一直执行++\n>   2. 判断DelayTaskList里任务是否可以恢复（可恢复则将其丢到ReadyList）\n>   3. 发起调度（遍历优先级数组，改变pxCurrentTCB指针指向）\n\n##### 空闲任务\n\n空闲任务是Freertos启动调度器时 会自动创建的一个最低优先级的任务`prvIdleTask`\n\n- 负责清理用户的自杀任务 如`vTaskDelete(NULL)`的内存释放\n- 由于优先级最低 所以当用户任务不释放CPU时，就会导致空闲任务不会运行，因而`vTaskDelete(NULL)`得不到释放\n- 因此尽量不要使用死延时，改用`vTaskDelay`释放CPU 或者不使用自杀函数`vTaskDelete(NULL)`\n\n> 此外 空闲任务中还有提供钩子函数 可以方便我们在里面打印调试信息\n>\n> 注意每个任务都要使用while(1)进行死循环\n>\n> - 如果有一个任务没有则会触发任务退出错误中断`prvTaskExitError`\n> - ![image-20250915163446773](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509151634028.png)\n\n### 同步与互斥\n\n#### 同步与互斥的概念\n\n一句话理解同步与互斥：我等你用完厕所，我再用厕所。\n\n- 什么叫同步？就是：哎哎哎，我正在用厕所，你等会。 \n- 什么叫互斥？就是：哎哎哎，我正在用厕所，你不能进来。\n\n同步与互斥经常放在一起讲，是因为它们之的关系很大，“互斥”操作可以使用“同步”来实现。我“等”你用完厕所，我再用厕所。这不就是用“同步”来实现“互斥”吗？\n\n再举一个例子。在团队活动里，同事A先写完报表，经理B才能拿去向领导汇报。经理B必须等同事A完成报表，AB之间有依赖，B必须放慢脚步，被称为同步。在团队活动中，同事A已经使用会议室了，经理B也想使用，即使经理B是领导，他也得等着，这就叫互斥。经理B跟同事A说：你用完会议室就提醒我。这就是使用\"同步\"来实现\"互斥\"。\n\n有时候看代码更容易理解，伪代码如下：\n\n```c\n void  抢厕所(void)\n {\n   if (有人在用) 我眯一会;\n   用厕所;\n   喂，醒醒，有人要用厕所吗;\n }\n```\n\n假设有A、B两人早起抢厕所，A先行一步占用了；B慢了一步，于是就眯一会；当A用完后叫醒B，B也就愉快地上厕所了。\n\n在这个过程中，A、B是互斥地访问“厕所”，“厕所”被称之为临界资源。我们使用了“休眠-唤醒”的同步机制实现了“临界资源”的“互斥访问”。\n\n同一时间只能有一个人使用的资源，被称为临界资源。比如任务A、B都要使用串口来打印，串口就是临界资源。如果A、B同时使用串口，那么打印出来的信息就是A、B混杂，无法分辨。所以使用串口时，应该是这样：A用完，B再用；B用完，A再用\n\n#### 各类方法的对比\n\n能实现同步、互斥的内核方法有：任务通知(task notification)、队列(queue)、事件组(event group)、信号量(semaphoe)、互斥量(mutex)。\n\n它们都有类似的操作方法：获取/释放、阻塞/唤醒、超时。比如：\n\n- 任务A获取资源，用完后任务A释放资源\n- 任务A获取不到资源则阻塞，任务B释放资源并把任务A唤醒\n- 任务A获取不到资源则阻塞，并定个闹钟；A要么超时返回，要么在这段时间内因为任务B释放资源而被唤醒。\n\n这些内核对象五花八门，记不住怎么办？我也记不住，通过对比的方法来区分它们。\n\n- 能否传信息？还是只能传递状态？\n- 为众生（所有任务都可以使用）？只为你（只能指定任务使用）？\n- 我生产，你们消费？\n- 我上锁，只能由我开锁\n\n| **内核对象** | **生产者** | **消费者** | **数据/状态**                                                | **说明**                                                     |\n| ------------ | ---------- | ---------- | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| 队列         | ALL        | ALL        | 数据：若干个数据 谁都可以往队列里扔数据， 谁都可以从队列里读数据 | 用来传递数据， 发送者、接收者无限制， 一个数据只能唤醒一个接收者 |\n| 事件组       | ALL        | ALL        | 多个位：或、与 谁都可以设置(生产)多个位， 谁都可以等待某个位、若干个位 | 用来传递事件， 可以是N个事件， 发送者、接受者无限制， 可以唤醒多个接收者：像广播 |\n| 信号量       | ALL        | ALL        | 数量：0~n 谁都可以增加一个数量， 谁都可消耗一个数量          | 用来维持资源的个数， 生产者、消费者无限制， 1个资源只能唤醒1个接收者 |\n| 任务通知     | ALL        | 只有我     | 数据、状态都可以传输， 使用任务通知时， 必须指定接受者       | N对1的关系： 发送者无限制， 接收者只能是这个任务             |\n| 互斥量       | 只能A开锁  | A上锁      | 位：0、1 我上锁：1变为0， 只能由我开锁：0变为1               | 就像一个空厕所， 谁使用谁上锁， 也只能由他开锁               |\n\n使用图形对比如下：\n\n- 队列：\n  - 里面可以放任意数据，可以放多个数据\n  - 任务、ISR都可以放入数据；任务、ISR都可以从中读出数据\n- 事件组：\n  - 一个事件用一bit表示，1表示事件发生了，0表示事件没发生\n  - 可以用来表示事件、事件的组合发生了，不能传递数据\n  - 有广播效果：事件或事件的组合发生了，等待它的多个任务都会被唤醒\n- 信号量：\n  - 核心是\"计数值\"\n  - 任务、ISR释放信号量时让计数值加1\n  - 任务、ISR获得信号量时，让计数值减1\n- 任务通知：\n  - 核心是任务的TCB里的数值\n  - 会被覆盖\n  - 发通知给谁？必须指定接收任务\n  - 只能由接收任务本身获取该通知\n- 互斥量：\n  - 数值只有0或1\n  - 谁获得互斥量，就必须由谁释放同一个互斥量\n\n![img](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509151740912.png)\n\n> 为何要引用这些机制呢？\n>\n> - 原本逻辑可以采用全局变量来进行传递信息，但在RTOS下，可能还未来得及改变全局变量的值就被切换到其他任务，这样就会发生全局变量未及时更新的问题\n> - 引入事件阻塞与唤醒大大提高了CPU的利用率\n>   - 当任务A计数1s，任务B负责打印任务A的最终计数值，就不会出现A运行，B也运行，而是等待A运行完后通知任务B，或大概估算任务A结束的时间，让B阻塞这么多的时间，这样就实现了整个时间轴都是任务A在运行\n\n### 队列\n\n#### 队列的本质\n\n队列中，数据的读写就是环形缓冲区，在这个基础上增加了互斥措施、阻塞-唤醒机制\n\n- 如果这个队列不传输数据，只调整“数据个数”，他就是信号量（semaphore）\n- 如果信号量中，限定“数据个数”最大值为1，他就是互斥量（mutex）\n\n#### 传输数据的两种方法\n\n使用队列传输数据时有两种方法：\n\n- 拷贝：把数据、把变量的值复制进队列里\n- 引用：把数据、把变量的地址复制进队列里\n\nFreeRTOS使用拷贝值的方法，这更简单：\n\n- 局部变量的值可以发送到队列中，后续即使函数退出、局部变量被回收，也不会影响队列中的数据\n- 无需分配buffer来保存数据，队列中有buffer\n- 局部变量可以马上再次使用\n- 发送任务、接收任务解耦：接收任务不需要知道这数据是谁的、也不需要发送任务来释放数据\n- 如果数据实在太大，你还是可以使用队列传输它的地址\n- 队列的空间有FreeRTOS内核分配，无需任务操心\n- 对于有内存保护功能的系统，如果队列使用引用方法，也就是使用地址，必须确保双方任务对这个地址都有访问权限。使用拷贝方法时，则无此限制：内核有足够的权限，把数据复制进队列、再把数据复制出队列。\n\n#### 队列的阻塞访问\n\n只要知道队列的句柄，谁都可以读、写该队列。任务、ISR都可读、写队列。可以多个任务读写队列。\n\n任务读写队列时，简单地说：如果读写不成功，则阻塞；可以指定超时时间。口语化地说，就是可以定个闹钟：如果能读写了就马上进入就绪态，否则就阻塞直到超时。\n\n某个任务读队列时，如果队列没有数据，则该任务可以进入阻塞状态：还可以指定阻塞的时间。如果队列有数据了，则该阻塞的任务会变为就绪态。如果一直都没有数据，则时间到之后它也会进入就绪态。\n\n既然读取队列的任务个数没有限制，那么当多个任务读取空队列时，这些任务都会进入阻塞状态：有多个任务在等待同一个队列的数据。当队列中有数据时，哪个任务会进入就绪态？\n\n- 优先级最高的任务\n- 如果大家的优先级相同，那等待时间最久的任务会进入就绪态\n\n跟读队列类似，一个任务要写队列时，如果队列满了，该任务也可以进入阻塞状态：还可以指定阻塞的时间。如果队列有空间了，则该阻塞的任务会变为就绪态。如果一直都没有空间，则时间到之后它也会进入就绪态。\n\n既然写队列的任务个数没有限制，那么当多个任务写\"满队列\"时，这些任务都会进入阻塞状态：有多个任务在等待同一个队列的空间。当队列中有空间时，哪个任务会进入就绪态？\n\n- 优先级最高的任务\n- 如果大家的优先级相同，那等待时间最久的任务会进入就绪态\n\n#### 队列函数\n\n##### 创建\n\n队列的创建有两种方法：动态分配内存、静态分配内存，\n\n- 动态分配内存：xQueueCreate，队列的内存在函数内部动态分配\n\n函数原型如下：\n\n```c\nQueueHandle_t xQueueCreate( UBaseType_t uxQueueLength, UBaseType_t uxItemSize );\n```\n\n| **参数**        | **说明**                                                     |\n| --------------- | ------------------------------------------------------------ |\n| `uxQueueLength` | 队列长度，最多能存放多少个数据(item)                         |\n| `uxItemSize`    | 每个数据(item)的大小：以字节为单位（可以定义一个结构体存放，然后sizeof(结构体)） |\n| 返回值          | 非0：成功，返回句柄，以后使用句柄来操作队列 NULL：失败，因为内存不足 |\n\n- 静态分配内存：`xQueueCreateStatic`，队列的内存要事先分配好\n\n函数原型如下：\n\n```c\nQueueHandle_t xQueueCreateStatic(*\n              \t\tUBaseType_t uxQueueLength,*\n              \t\tUBaseType_t uxItemSize,*\n              \t\tuint8_t *pucQueueStorageBuffer,*\n              \t\tStaticQueue_t *pxQueueBuffer*\n           \t\t );\n```\n\n| **参数**                | **说明**                                                     |\n| ----------------------- | ------------------------------------------------------------ |\n| `uxQueueLength`         | 队列长度，最多能存放多少个数据(item)                         |\n| `uxItemSize`            | 每个数据(item)的大小：以字节为单位                           |\n| `pucQueueStorageBuffer` | 如果uxItemSize非0，`pucQueueStorageBuffer`必须指向一个uint8_t数组， 此数组大小至少为\"uxQueueLength * uxItemSize\" |\n| `pxQueueBuffer`         | 必须执行一个`StaticQueue_t`结构体，用来保存队列的数据结构    |\n| 返回值                  | 非0：成功，返回句柄，以后使用句柄来操作队列 NULL：失败，因为`pxQueueBuffer`为NULL |\n\n##### 复位\n\n队列刚被创建时，里面没有数据；使用过程中可以调用 **xQueueReset()** 把队列恢复为初始状态，此函数原型为：\n\n```c\n/*  pxQueue : 复位哪个队列;\n * 返回值: pdPASS(必定成功)\n*/\nBaseType_t xQueueReset( QueueHandle_t pxQueue);\n```\n\n##### 删除\n\n删除队列的函数为 **vQueueDelete()** ，只能删除使用动态方法创建的队列，它会释放内存。原型如下：\n\n```c\nvoid vQueueDelete( QueueHandle_t xQueue );\n```\n\n##### 写队列\n\n可以把数据写到队列头部，也可以写到尾部，这些函数有两个版本：在任务中使用、在ISR中使用。函数原型如下：\n\n```c\n/* 等同于xQueueSendToBack\n * 往队列尾部写入数据，如果没有空间，阻塞时间为xTicksToWait\n */\nBaseType_t xQueueSend(\n                                QueueHandle_t    xQueue,\n                                const void       *pvItemToQueue,\n                                TickType_t       xTicksToWait\n                            );\n\n/* \n * 往队列尾部写入数据，如果没有空间，阻塞时间为xTicksToWait\n */\nBaseType_t xQueueSendToBack(\n                                QueueHandle_t    xQueue,\n                                const void       *pvItemToQueue,\n                                TickType_t       xTicksToWait\n                            );\n\n\n/* \n * 往队列尾部写入数据，此函数可以在中断函数中使用，不可阻塞\n */\nBaseType_t xQueueSendToBackFromISR(\n                                      QueueHandle_t xQueue,\n                                      const void *pvItemToQueue,\n                                      BaseType_t *pxHigherPriorityTaskWoken\n                                   );\n\n/* \n * 往队列头部写入数据，如果没有空间，阻塞时间为xTicksToWait\n */\nBaseType_t xQueueSendToFront(\n                                QueueHandle_t    xQueue,\n                                const void       *pvItemToQueue,\n                                TickType_t       xTicksToWait\n                            );\n\n/* \n * 往队列头部写入数据，此函数可以在中断函数中使用，不可阻塞\n */\nBaseType_t xQueueSendFromISR(\n                                      QueueHandle_t xQueue,\n                                      const void *pvItemToQueue,\n                                      BaseType_t *pxHigherPriorityTaskWoken\n                                   );\n```\n\n这些函数用到的参数是类似的，统一说明如下：\n\n| 参数            | 说明                                                         |\n| --------------- | ------------------------------------------------------------ |\n| `xQueue`        | 队列句柄，要写哪个队列                                       |\n| `pvItemToQueue` | 数据指针，这个数据的值会被复制进队列， 复制多大的数据？在创建队列时已经指定了数据大小 |\n| `xTicksToWait`  | 如果队列满则无法写入新数据，可以让任务进入阻塞状态， `xTicksToWait`表示阻塞的最大时间(Tick Count)。 如果被设为0，无法写入数据时函数会立刻返回； 如果被设为`portMAX_DELAY`，则会一直阻塞直到有空间可写 |\n| 返回值          | pdPASS：数据成功写入了队列 `errQUEUE_FULL`：写入失败，因为队列满了。 |\n\n##### 读队列\n\n使用 **xQueueReceive()** 函数读队列，读到一个数据后，队列中该数据会被移除。这个函数有两个版本：在任务中使用、在ISR中使用。函数原型如下：\n\n```c\nBaseType_t xQueueReceive( QueueHandle_t xQueue,\n                          void * const pvBuffer,\n                          TickType_t xTicksToWait );\n\nBaseType_t xQueueReceiveFromISR(\n                                    QueueHandle_t    xQueue,\n                                    void             *pvBuffer,\n                                    BaseType_t       *pxTaskWoken\n                                );\n```\n\n参数说明如下：\n\n| **参数**       | **说明**                                                     |\n| -------------- | ------------------------------------------------------------ |\n| `xQueue`       | 队列句柄，要读哪个队列                                       |\n| `pvBuffer`     | buffer指针，队列的数据会被复制到这个buffer 复制多大的数据？在创建队列时已经指定了数据大小 |\n| `xTicksToWait` | 果队列空则无法读出数据，可以让任务进入阻塞状态， xTicksToWait表示阻塞的最大时间(Tick Count)。 如果被设为0，无法读出数据时函数会立刻返回； 如果被设为portMAX_DELAY，则会一直阻塞直到有数据可写 |\n| 返回值         | pdPASS：从队列读出数据入 `errQUEUE_EMPTY`：读取失败，因为队列空了。 |\n\n##### 查询\n\n可以查询队列中有多少个数据、有多少空余空间。函数原型如下：\n\n```c\n/*\n * 返回队列中可用数据的个数\n */\nUBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue );\n\n/*\n * 返回队列中可用空间的个数\n */\nUBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue );\n```\n\n##### 覆盖/偷看\n\n当队列长度为1时，可以使用 **xQueueOverwrite()** 或 **xQueueOverwriteFromISR()** 来覆盖数据。\n\n注意，队列长度必须为1。当队列满时，这些函数会覆盖里面的数据，这也以为着这些函数不会被阻塞。\n\n函数原型如下：\n\n```c\n/* 覆盖队列\n * xQueue: 写哪个队列\n * pvItemToQueue: 数据地址\n * 返回值: pdTRUE表示成功, pdFALSE表示失败\n */\nBaseType_t xQueueOverwrite(\n                           QueueHandle_t xQueue,\n                           const void * pvItemToQueue\n                      );\n\nBaseType_t xQueueOverwriteFromISR(\n                           QueueHandle_t xQueue,\n                           const void * pvItemToQueue,\n                           BaseType_t *pxHigherPriorityTaskWoken\n                      );\n```\n\n如果想让队列中的数据供多方读取，也就是说读取时不要移除数据，要留给后来人。那么可以使用\"窥视\"，也就是**xQueuePeek()\\**或\\**xQueuePeekFromISR()**。这些函数会从队列中复制出数据，但是不移除数据。这也意味着，如果队列中没有数据，那么\"偷看\"时会导致阻塞；一旦队列中有数据，以后每次\"偷看\"都会成功。\n\n函数原型如下：\n\n```c\n/* 偷看队列\n * xQueue: 偷看哪个队列\n * pvItemToQueue: 数据地址, 用来保存复制出来的数据\n * xTicksToWait: 没有数据的话阻塞一会\n * 返回值: pdTRUE表示成功, pdFALSE表示失败\n */\nBaseType_t xQueuePeek(\n                          QueueHandle_t xQueue,\n                          void * const pvBuffer,\n                          TickType_t xTicksToWait\n                      );\n\nBaseType_t xQueuePeekFromISR(\n                                 QueueHandle_t xQueue,\n                                 void *pvBuffer,\n                             );\n```\n\n#### 使用队列时注意\n\n> 写队列与读队列 所传入的`buffer`一定要严格按照初始创建时的类型，否则就会出现死机\n>\n> - 情况一：创建时类型为指针（常用，可以接收多种类型）\n>\n> ```C\n> typedef struct\n> {\n>     uint8_t data[128];\n>     uint8_t index;\n> }Uart_RxTypeDef;\n> \n> Uart_RxTypeDef UartRx = {{0},0};\n> \n> void task(void *arg)\n> {\n>     Uart_RxTypeDef *data = &UartRx;\n>     debug_TX_QueueHandle = osMessageQueueNew(5, sizeof(void *), &debug_TX_Queue_attributes);\n>     xQueueSend(debug_TX_QueueHandle,&data,NULL);//此处一定要&data 因为创建队列的时候是指针 直接写data 相当于&UartRx 他并不是一个指针\n> }\n> \n> ```\n>\n> - 情况二：创建时类型为数据\n>\n> ```C\n> typedef struct\n> {\n>     uint8_t data[128];\n>     uint8_t index;\n> }Uart_RxTypeDef;\n> \n> Uart_RxTypeDef UartRx = {{0},0};\n> \n> void task(void *arg)\n> {\n>     Uart_RxTypeDef data = {{0},0};\n>     debug_TX_QueueHandle = osMessageQueueNew(5, sizeof(Uart_RxTypeDef), &debug_TX_Queue_attributes);\n>     xQueueSend(debug_TX_QueueHandle,&data,NULL);//此处的&data与情况一不一样 这个是参数要求要地址 所以需要将结构体的地址赋值过去\n> }\n> ```\n>\n> \n\n#### 队列集\n\n> 当多个队列需要上报到同一个处理任务时，队列集可以实现统合多个队列，再往上传递到同一个任务\n\n![image-20250915213146479](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509152131801.png)\n\n##### 创建队列集\n\n> 注意要使用队列集 需要先在`Core/inc/FreeRTOSConfig.h` 定义\n>\n> ```bash\n> #define configUSE_QUEUE_SETS 1\n> ```\n\n函数原型如下：\n\n```c\nQueueSetHandle_t xQueueCreateSet( const UBaseType_t uxEventQueueLength )\n```\n\n| **参数**      | **说明**                                                     |\n| ------------- | ------------------------------------------------------------ |\n| uxQueueLength | 队列集长度，最多能存放多少个数据(队列句柄)                   |\n| 返回值        | 非0：成功，返回句柄，以后使用句柄来操作队列NULL：失败，因为内存不足 |\n\n##### 把队列加入队列集\n\n函数原型如下：\n\n```c\nBaseType_t xQueueAddToSet( QueueSetMemberHandle_t xQueueOrSemaphore,\n\n                QueueSetHandle_t xQueueSet );\n\n \n```\n\n| **参数**          | **说明**                       |\n| ----------------- | ------------------------------ |\n| xQueueOrSemaphore | 队列句柄，这个队列要加入队列集 |\n| xQueueSet         | 队列集句柄                     |\n| 返回值            | pdTRUE：成功pdFALSE：失败      |\n\n##### 读取队列集\n\n函数原型如下：\n\n```c\nQueueSetMemberHandle_t xQueueSelectFromSet( QueueSetHandle_t xQueueSet,\n\n                        TickType_t const xTicksToWait );\n```\n\n| **参数**     | **说明**                                                     |\n| ------------ | ------------------------------------------------------------ |\n| xQueueSet    | 队列集句柄                                                   |\n| xTicksToWait | 如果队列集空则无法读出数据，可以让任务进入阻塞状态，xTicksToWait表示阻塞的最大时间(Tick Count)。如果被设为0，无法读出数据时函数会立刻返回；如果被设为portMAX_DELAY，则会一直阻塞直到有数据可写 |\n| 返回值       | NULL：失败，队列句柄：成功                                   |\n\n### 信号量\n\n前面介绍的队列(queue)可以用于传输数据：在任务之间、任务和中断之间。\n\n消息队列用于传输多个数据，但是有时候我们只需要传递状态，这个状态值需要用一个数值表示，比如：\n\n- 卖家：做好了1个包子！做好了2个包子！做好了3个包子！\n- 买家：买了1个包子，包子数量减1\n- 这个停车位我占了，停车位减1\n- 我开车走了，停车位加1\n\n在这种情况下我们只需要维护一个数值，使用信号量效率更高、更节省内存 本章涉及如下内容：\n\n- 怎么创建、删除信号量\n- 怎么发送、获得信号量\n- 什么是计数型信号量？什么是二进制信号量？\n\n####  信号量的特性\n\n##### 信号量的常规操作\n\n信号量这个名字很恰当：\n\n- 信号：起通知作用\n- 量：还可以用来表示资源的数量\n  - 当\"量\"没有限制时，它就是\"计数型信号量\"(Counting Semaphores)\n  - 当\"量\"只有0、1两个取值时，它就是\"二进制信号量\"(Binary Semaphores)\n- 支持的动作：\"give\"给出资源，计数值加1；\"take\"获得资源，计数值减1\n\n计数型信号量的典型场景是：\n\n- 计数：事件产生时\"give\"信号量，让计数值加1；处理事件时要先\"take\"信号量，就是获得信号量，让计数值减1。\n- 资源管理：要想访问资源需要先\"take\"信号量，让计数值减1；用完资源后\"give\"信号量，让计数值加1。 信号量的\"give\"、\"take\"双方并不需要相同，可以用于生产者-消费者场合：\n- 生产者为任务A、B，消费者为任务C、D\n- 一开始信号量的计数值为0，如果任务C、D想获得信号量，会有两种结果：\n  - 阻塞：买不到东西咱就等等吧，可以定个闹钟(超时时间)\n  - 即刻返回失败：不等\n- 任务A、B可以生产资源，就是让信号量的计数值增加1，并且把等待这个资源的顾客唤醒\n- 唤醒谁？谁优先级高就唤醒谁，如果大家优先级一样就唤醒等待时间最长的人\n\n二进制信号量跟计数型的唯一差别，就是计数值的最大值被限定为1。\n\n![img](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509161022312.png)\n\n##### 信号量跟队列的对比\n\n差异列表如下：\n\n| 队列                                                         | 信号量                                                       |\n| ------------------------------------------------------------ | ------------------------------------------------------------ |\n| 可以容纳多个数据， 创建队列时有2部分内存: 队列结构体、存储数据的空间 | 只有计数值，无法容纳其他数据。 创建信号量时，只需要分配信号量结构体 |\n| 生产者：没有空间存入数据时可以阻塞                           | 生产者：用于不阻塞，计数值已经达到最大时返回失败             |\n| 消费者：没有数据时可以阻塞                                   | 消费者：没有资源时可以阻塞                                   |\n\n##### 两种信号量的对比\n\n信号量的计数值都有限制：限定了最大值。如果最大值被限定为1，那么它就是二进制信号量；如果最大值不是1，它就是计数型信号量。\n\n差别列表如下：\n\n| 二进制信号量      | 计数型信号量           |\n| ----------------- | ---------------------- |\n| 被创建时初始值为0 | 被创建时初始值可以设定 |\n| 其他操作是一样的  | 其他操作是一样的       |\n\n#### 信号量函数\n\n使用信号量时，先创建、然后去添加资源、获得资源。使用句柄来表示一个信号量。\n\n##### 创建\n\n使用信号量之前，要先创建，得到一个句柄；使用信号量时，要使用句柄来表明使用哪个信号量。 对于二进制信号量、计数型信号量，它们的创建函数不一样：\n\n|          | 二进制信号量                                     | 计数型信号量                     |\n| -------- | ------------------------------------------------ | -------------------------------- |\n| 动态创建 | `xSemaphoreCreateBinary `计数值初始值为0         | `xSemaphoreCreateCounting`       |\n|          | `vSemaphoreCreateBinary`(过时了) 计数值初始值为1 |                                  |\n| 静态创建 | `xSemaphoreCreateBinaryStatic`                   | `xSemaphoreCreateCountingStatic` |\n\n创建二进制信号量的函数原型如下：\n\n```c\n/* 创建一个二进制信号量，返回它的句柄。\n * 此函数内部会分配信号量结构体 \n * 返回值: 返回句柄，非NULL表示成功\n */\nSemaphoreHandle_t xSemaphoreCreateBinary( void );\n\n/* 创建一个二进制信号量，返回它的句柄。\n * 此函数无需动态分配内存，所以需要先有一个StaticSemaphore_t结构体，并传入它的指针\n * 返回值: 返回句柄，非NULL表示成功\n */\nSemaphoreHandle_t xSemaphoreCreateBinaryStatic( StaticSemaphore_t *pxSemaphoreBuffer );\n```\n\n创建计数型信号量的函数原型如下：\n\n```c\n/* 创建一个计数型信号量，返回它的句柄。\n * 此函数内部会分配信号量结构体 \n * uxMaxCount: 最大计数值\n * uxInitialCount: 初始计数值\n * 返回值: 返回句柄，非NULL表示成功\n */\nSemaphoreHandle_t xSemaphoreCreateCounting(UBaseType_t uxMaxCount, UBaseType_t uxInitialCount);\n\n/* 创建一个计数型信号量，返回它的句柄。\n * 此函数无需动态分配内存，所以需要先有一个StaticSemaphore_t结构体，并传入它的指针\n * uxMaxCount: 最大计数值\n * uxInitialCount: 初始计数值\n * pxSemaphoreBuffer: StaticSemaphore_t结构体指针\n * 返回值: 返回句柄，非NULL表示成功\n */\nSemaphoreHandle_t xSemaphoreCreateCountingStatic( UBaseType_t uxMaxCount, \n                                                 UBaseType_t uxInitialCount, \n                                                 StaticSemaphore_t *pxSemaphoreBuffer );\n```\n\n##### 删除\n\n对于动态创建的信号量，不再需要它们时，可以删除它们以回收内存。\n\nvSemaphoreDelete可以用来删除二进制信号量、计数型信号量，函数原型如下：\n\n```c\n/*\n * xSemaphore: 信号量句柄，你要删除哪个信号量\n */\nvoid vSemaphoreDelete( SemaphoreHandle_t xSemaphore );\n```\n\n##### 释放/获取信号量\n\n二进制信号量、计数型信号量的give、take操作函数是一样的。这些函数也分为2个版本：给任务使用，给ISR使用。列表如下：\n\n|      | 在任务中使用     | 在ISR中使用             |\n| ---- | ---------------- | ----------------------- |\n| give | `xSemaphoreGive` | `xSemaphoreGiveFromISR` |\n| take | `xSemaphoreTake` | `xSemaphoreTakeFromISR` |\n\nxSemaphoreGive的函数原型如下：\n\n```c\nBaseType_t xSemaphoreGive( SemaphoreHandle_t xSemaphore );\n```\n\nxSemaphoreGive函数的参数与返回值列表如下：\n\n| 参数       | 说明                                                         |\n| ---------- | ------------------------------------------------------------ |\n| xSemaphore | 信号量句柄，释放哪个信号量                                   |\n| 返回值     | pdTRUE表示成功, 如果二进制信号量的计数值已经是1，再次调用此函数则返回失败； 如果计数型信号量的计数值已经是最大值，再次调用此函数则返回失败 |\n\npxHigherPriorityTaskWoken的函数原型如下：\n\n```c\nBaseType_t xSemaphoreGiveFromISR(\n                        SemaphoreHandle_t xSemaphore,\n                        BaseType_t *pxHigherPriorityTaskWoken\n                    );\n```\n\nxSemaphoreGiveFromISR函数的参数与返回值列表如下：\n\n| 参数                      | 说明                                                         |\n| ------------------------- | ------------------------------------------------------------ |\n| xSemaphore                | 信号量句柄，释放哪个信号量                                   |\n| pxHigherPriorityTaskWoken | 如果释放信号量导致更高优先级的任务变为了就绪态， 则*pxHigherPriorityTaskWoken = pdTRUE |\n| 返回值                    | pdTRUE表示成功, 如果二进制信号量的计数值已经是1，再次调用此函数则返回失败； 如果计数型信号量的计数值已经是最大值，再次调用此函数则返回失败 |\n\nxSemaphoreTake的函数原型如下：\n\n```c\nBaseType_t xSemaphoreTake(\n                   SemaphoreHandle_t xSemaphore,\n                   TickType_t xTicksToWait\n               );\n```\n\nxSemaphoreTake函数的参数与返回值列表如下：\n\n| 参数           | 说明                                                         |\n| -------------- | ------------------------------------------------------------ |\n| `xSemaphore`   | 信号量句柄，获取哪个信号量                                   |\n| `xTicksToWait` | 如果无法马上获得信号量，阻塞一会： 0：不阻塞，马上返回 `portMAX_DELAY`: 一直阻塞直到成功 其他值: 阻塞的Tick个数，可以使用*`pdMS_TO_TICKS`()*来指定阻塞时间为若干`ms` |\n| 返回值         | pdTRUE表示成功                                               |\n\nxSemaphoreTakeFromISR的函数原型如下：\n\n```c\nBaseType_t xSemaphoreTakeFromISR(\n                        SemaphoreHandle_t xSemaphore,\n                        BaseType_t *pxHigherPriorityTaskWoken\n                    );\n```\n\nxSemaphoreTakeFromISR函数的参数与返回值列表如下：\n\n| 参数                        | 说明                                                         |\n| --------------------------- | ------------------------------------------------------------ |\n| `xSemaphore`                | 信号量句柄，获取哪个信号量                                   |\n| `pxHigherPriorityTaskWoken` | 如果获取信号量导致更高优先级的任务变为了就绪态， 则`*pxHigherPriorityTaskWoken = pdTRUE` |\n| 返回值                      | pdTRUE表示成功                                               |\n\n#### 优先级反转\n\n信号量使用不当 就会出现优先级反转的问题——任务执行顺序：任务1、任务2、任务1、任务3\n\n即最高优先级的任务最后运行\n\n> 优先级反转：假设信号量值为1，同时创建了低、中等、高优先级任务\n>\n> - 低优先级任务获取信号量，中等优先级先阻塞一段时间，确保低优先级任务先成功获取到信号量\n> - 高优先级任务先阻塞一段时间，确保低优先级、中等优先级先完成任务，然后尝试获取信号量\n> - 此时由于低优先级获取了信号量，高优先级任务就会被阻塞\n> - 中等优先级不释放信号量，那么就会发生高优先级任务无法运行\n\n##### 示例\n\n```C\n#include \"uart.h\"\ntypedef struct __FILE FILE;\n\nstatic SemaphoreHandle_t task_mutex = NULL;\n\ntypedef struct\n{\n    uint8_t dev;\n    uint8_t *data;\n} uart_info_t;\n\nuart_info_t task1_data = {1, \"task1\"};\nuart_info_t task2_data = {2, \"task2\"};\nuart_info_t task3_data = {3, \"task3\"};\nint fputc(int ch, FILE *f)\n{\n    HAL_UART_Transmit(&huart1, (uint8_t *)&ch, 1, 0xFFFF);\n    return ch;\n}\n\nvoid task1(void *param)\n{\n    uint8_t cnt = 0;\n    xSemaphoreTake(task_mutex, portMAX_DELAY);\n    uart_info_t *data = param;\n    while (1)\n    {\n        printf(\"dev:%u,name:%s\\r\\n\", data->dev, data->data);\n        if (++cnt == 5)\n        {\n            xSemaphoreGive(task_mutex);\n        }\n        vTaskDelay(50);\n    }\n}\n\nvoid task2(void *param)\n{\n    uint8_t cnt = 0;\n    vTaskDelay(300);//先阻塞一段时间 确保任务1成功获取信号量且能够被切换为任务2\n    uart_info_t *data = param;\n    while (1)\n    {\n        printf(\"dev:%u,name:%s\\r\\n\", data->dev, data->data);\n        if (++cnt == 5)\n        {\n            vTaskDelete(NULL);\n        }\n        HAL_Delay(50);\n    }\n}\n\nvoid task3(void *param)\n{\n    uint8_t cnt = 0;\n    vTaskDelay(500);\t//先阻塞一段时间 确保任务1先成功获取信号量且能够被切换为任务2\n    xSemaphoreTake(task_mutex, portMAX_DELAY);\n    uart_info_t *data = param;\n    while (1)\n    {\n        printf(\"dev:%u,name:%s\\r\\n\", data->dev, data->data);\n        if (++cnt == 5)\n        {\n            vTaskDelete(NULL);\n        }\n    }\n}\n\nvoid uart_init(void)\n{\n    task_mutex = xSemaphoreCreateBinary();\n    xSemaphoreGive(task_mutex);\n    xTaskCreate(task1, \"task1\", 128, &task1_data, osPriorityNormal, NULL);\t//低优先级任务\n    xTaskCreate(task2, \"task2\", 128, &task2_data, osPriorityNormal1, NULL);\t//中等优先级任务\n    xTaskCreate(task3, \"task3\", 128, &task3_data, osPriorityNormal2, NULL);\t//高优先级任务\n}\n```\n\n![image-20250916160014655](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509161600972.png)\n\n#### 解决优先级反转\n\n> 使用互斥量 （实现优先级继承），当最高优先级任务等待互斥量时，可以将低优先级任务继承最高优先级，使得最高优先级任务也可以先运行\n>\n> 现象：任务1执行一小段时间被任务2抢占，当任务3时间到来，任务1继承任务3优先级，所以任务1运行释放后，任务1恢复原先优先级，任务3启动\n\n### 事件组\n\n> 上述任务同步与互斥的方法都是一对一通知，难以实现一对多通知（广播），因此引入了事件组\n\n#### 事件组的概念\n\n事件组可以简单地认为就是一个整数：\n\n- 的每一位表示一个事件\n- 每一位事件的含义由程序员决定，比如：Bit0表示用来串口是否就绪，Bit1表示按键是否被按下\n- 这些位，值为1表示事件发生了，值为0表示事件没发生\n- 一个或多个任务、ISR都可以去写这些位；一个或多个任务、ISR都可以去读这些位\n- 可以等待某一位、某些位中的任意一个，也可以等待多位\n\n![img](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509161809736.png)\n\n事件组用一个整数来表示，其中的高8位留给内核使用，只能用其他的位来表示事件。那么这个整数是多少位的？\n\n- 如果configUSE_16_BIT_TICKS是1，那么这个整数就是16位的，低8位用来表示事件\n- 如果configUSE_16_BIT_TICKS是0，那么这个整数就是32位的，低24位用来表示事件\n- configUSE_16_BIT_TICKS是用来表示Tick Count的，怎么会影响事件组？这只是基于效率来考虑\n  - 如果configUSE_16_BIT_TICKS是1，就表示该处理器使用16位更高效，所以事件组也使用16位\n  - 如果configUSE_16_BIT_TICKS是0，就表示该处理器使用32位更高效，所以事件组也使用32位\n\n#### 事件组的操作\n\n事件组和队列、信号量等不太一样，主要集中在2个地方：\n\n- 唤醒谁？\n  - 队列、信号量：事件发生时，只会唤醒一个任务\n  - 事件组：事件发生时，会唤醒所有符号条件的任务，简单地说它有\"广播\"的作用\n- 是否清除事件？\n  - 队列、信号量：是消耗型的资源，队列的数据被读走就没了；信号量被获取后就减少了\n  - 事件组：被唤醒的任务有两个选择，可以让事件保留不动，也可以清除事件\n\n以上图为列，事件组的常规操作如下：\n\n- 先创建事件组\n- 任务C、D等待事件：\n  - 等待什么事件？可以等待某一位、某些位中的任意一个，也可以等待多位。简单地说就是\"或\"、\"与\"的关系。\n  - 得到事件时，要不要清除？可选择清除、不清除。\n- 任务A、B产生事件：设置事件组里的某一位、某些位\n\n#### 事件组函数\n\n##### 创建\n\n使用事件组之前，要先创建，得到一个句柄；使用事件组时，要使用句柄来表明使用哪个事件组。\n\n有两种创建方法：动态分配内存、静态分配内存。函数原型如下：\n\n```c\n/* 创建一个事件组，返回它的句柄。\n * 此函数内部会分配事件组结构体 \n * 返回值: 返回句柄，非NULL表示成功\n */\nEventGroupHandle_t xEventGroupCreate( void );\n\n/* 创建一个事件组，返回它的句柄。\n * 此函数无需动态分配内存，所以需要先有一个StaticEventGroup_t结构体，并传入它的指针\n * 返回值: 返回句柄，非NULL表示成功\n */\nEventGroupHandle_t xEventGroupCreateStatic( StaticEventGroup_t * pxEventGroupBuffer );\n```\n\n##### 删除\n\n对于动态创建的事件组，不再需要它们时，可以删除它们以回收内存。\n\n**vEventGroupDelete**可以用来删除事件组，函数原型如下：\n\n```c\n/*\n * xEventGroup: 事件组句柄，你要删除哪个事件组\n */\nvoid vEventGroupDelete( EventGroupHandle_t xEventGroup )\n```\n\n##### 设置事件\n\n可以设置事件组的某个位、某些位，使用的函数有2个：\n\n- 在任务中使用**xEventGroupSetBits()**\n- 在ISR中使用**xEventGroupSetBitsFromISR()**\n\n有一个或多个任务在等待事件，如果这些事件符合这些任务的期望，那么任务还会被唤醒。\n\n函数原型如下：\n\n```c\n/* 设置事件组中的位\n * xEventGroup: 哪个事件组\n * uxBitsToSet: 设置哪些位? \n *              如果uxBitsToSet的bitX, bitY为1, 那么事件组中的bitX, bitY被设置为1\n *              可以用来设置多个位，比如 0x15 就表示设置bit4, bit2, bit0\n * 返回值: 返回原来的事件值(没什么意义, 因为很可能已经被其他任务修改了)\n */\nEventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup,\n                                    const EventBits_t uxBitsToSet );\n\n/* 设置事件组中的位\n * xEventGroup: 哪个事件组\n * uxBitsToSet: 设置哪些位? \n *              如果uxBitsToSet的bitX, bitY为1, 那么事件组中的bitX, bitY被设置为1\n *              可以用来设置多个位，比如 0x15 就表示设置bit4, bit2, bit0\n * pxHigherPriorityTaskWoken: 有没有导致更高优先级的任务进入就绪态? pdTRUE-有, pdFALSE-没有\n * 返回值: pdPASS-成功, pdFALSE-失败\n */\nBaseType_t xEventGroupSetBitsFromISR( EventGroupHandle_t xEventGroup,\n\t\t\t\t\t\t\t\t\t  const EventBits_t uxBitsToSet,\n\t\t\t\t\t\t\t\t\t  BaseType_t * pxHigherPriorityTaskWoken );\n```\n\n值得注意的是，ISR中的函数，比如队列函数**xQueueSendToBackFromISR**、信号量函数**xSemaphoreGiveFromISR**，它们会唤醒某个任务，最多只会唤醒1个任务。\n\n但是设置事件组时，有可能导致多个任务被唤醒，这会带来很大的不确定性。所以**xEventGroupSetBitsFromISR**函数不是直接去设置事件组，而是给一个FreeRTOS后台任务(daemon task)发送队列数据，由这个任务来设置事件组。\n\n如果后台任务的优先级比当前被中断的任务优先级高，**xEventGroupSetBitsFromISR**会设置**pxHigherPriorityTaskWoken**为pdTRUE。\n\n如果daemon task成功地把队列数据发送给了后台任务，那么**xEventGroupSetBitsFromISR**的返回值就是pdPASS。\n\n##### 等待事件\n\n使用**xEventGroupWaitBits**来等待事件，可以等待某一位、某些位中的任意一个，也可以等待多位；等到期望的事件后，还可以清除某些位。\n\n函数原型如下：\n\n```c\nEventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup,\n                                 const EventBits_t uxBitsToWaitFor,\n                                 const BaseType_t xClearOnExit,\n                                 const BaseType_t xWaitForAllBits,\n                                 TickType_t xTicksToWait );\n```\n\n先引入一个概念：unblock condition。一个任务在等待事件发生时，它处于阻塞状态；当期望的时间发生时，这个状态就叫\"unblock condition\"，非阻塞条件，或称为\"非阻塞条件成立\"；当\"非阻塞条件成立\"后，该任务就可以变为就绪态。\n\n函数参数说明列表如下：\n\n|    **参数**     | **说明**                                                     |\n| :-------------: | :----------------------------------------------------------- |\n|   xEventGroup   | 等待哪个事件组？                                             |\n| uxBitsToWaitFor | 等待哪些位？哪些位要被测试？                                 |\n| xWaitForAllBits | 怎么测试？是\"AND\"还是\"OR\"？ pdTRUE: 等待的位，全部为1; pdFALSE: 等待的位，某一个为1即可 |\n|  xClearOnExit   | 函数提出前是否要清除事件？ pdTRUE: 清除uxBitsToWaitFor指定的位 pdFALSE: 不清除 |\n|  xTicksToWait   | 如果期待的事件未发生，阻塞多久。 可以设置为0：判断后即刻返回； 可设置为portMAX_DELAY：一定等到成功才返回； 可以设置为期望的Tick Count，一般用*pdMS_TO_TICKS()*把ms转换为Tick Count |\n|     返回值      | 返回的是事件值， 如果期待的事件发生了，返回的是\"非阻塞条件成立\"时的事件值； 如果是超时退出，返回的是超时时刻的事件值。 |\n\n举例如下：\n\n| 事件组的值 | uxBitsToWaitFor | xWaitForAllBits | 说明                                                         |\n| :--------: | :-------------: | :-------------: | :----------------------------------------------------------- |\n|    0100    |      0101       |     pdTRUE      | 任务期望bit0,bit2都为1， 当前值只有bit2满足，任务进入阻塞态； 当事件组中bit0,bit2都为1时退出阻塞态 |\n|    0100    |      0110       |     pdFALSE     | 任务期望bit0,bit2某一个为1， 当前值满足，所以任务成功退出    |\n|    0100    |      0110       |     pdTRUE      | 任务期望bit1,bit2都为1， 当前值不满足，任务进入阻塞态； 当事件组中bit1,bit2都为1时退出阻塞态 |\n\n你可以使用*xEventGroupWaitBits()*等待期望的事件，它发生之后再使用*xEventGroupClearBits()*来清除。但是这两个函数之间，有可能被其他任务或中断抢占，它们可能会修改事件组。\n\n可以使用设置*xClearOnExit*为pdTRUE，使得对事件组的测试、清零都在*xEventGroupWaitBits()*函数内部完成，这是一个原子操作。\n\n##### 同步点\n\n有一个事情需要多个任务协同，比如：\n\n- 任务A：炒菜\n- 任务B：买酒\n- 任务C：摆台\n- A、B、C做好自己的事后，还要等别人做完；大家一起做完，才可开饭\n\n使用 **xEventGroupSync()** 函数可以同步多个任务：\n\n- 可以设置某位、某些位，表示自己做了什么事\n- 可以等待某位、某些位，表示要等等其他任务\n- 期望的时间发生后， **xEventGroupSync()** 才会成功返回。\n- **xEventGroupSync**成功返回后，会清除事件\n\n**xEventGroupSync** 函数原型如下：\n\n```text\nEventBits_t xEventGroupSync(    EventGroupHandle_t xEventGroup,\n                                const EventBits_t uxBitsToSet,\n                                const EventBits_t uxBitsToWaitFor,\n                                TickType_t xTicksToWait );\n```\n\n参数列表如下：\n\n|    **参数**     | **说明**                                                     |\n| :-------------: | ------------------------------------------------------------ |\n|   xEventGroup   | 哪个事件组？                                                 |\n|   uxBitsToSet   | 要设置哪些事件？我完成了哪些事件？ 比如0x05(二进制为0101)会导致事件组的bit0,bit2被设置为1 |\n| uxBitsToWaitFor | 等待那个位、哪些位？ 比如0x15(二级制10101)，表示要等待bit0,bit2,bit4都为1 |\n|  xTicksToWait   | 如果期待的事件未发生，阻塞多久。 可以设置为0：判断后即刻返回； 可设置为portMAX_DELAY：一定等到成功才返回； 可以设置为期望的Tick Count，一般用*pdMS_TO_TICKS()*把ms转换为Tick Count |\n|     返回值      | 返回的是事件值， 如果期待的事件发生了，返回的是\"非阻塞条件成立\"时的事件值； 如果是超时退出，返回的是超时时刻的事件值。 |\n\n参数列表如下：\n\n|    **参数**     | **说明**                                                     |\n| :-------------: | :----------------------------------------------------------- |\n|   xEventGroup   | 哪个事件组？                                                 |\n|   uxBitsToSet   | 要设置哪些事件？我完成了哪些事件？ 比如0x05(二进制为0101)会导致事件组的bit0,bit2被设置为1 |\n| uxBitsToWaitFor | 等待那个位、哪些位？ 比如0x15(二级制10101)，表示要等待bit0,bit2,bit4都为1 |\n|  xTicksToWait   | 如果期待的事件未发生，阻塞多久。 可以设置为0：判断后即刻返回； 可设置为portMAX_DELAY：一定等到成功才返回； 可以设置为期望的Tick Count，一般用*pdMS_TO_TICKS()*把ms转换为Tick Count |\n|     返回值      | 返回的是事件值， 如果期待的事件发生了，返回的是\"非阻塞条件成立\"时的事件值； 如果是超时退出，返回的是超时时刻的事件值。 |\n\n### 任务通知\n\n所谓\"任务通知\"，你可以反过来读\"通知任务\"。\n\n我们使用队列、信号量、事件组等等方法时，并不知道对方是谁。使用任务通知时，可以明确指定：通知哪个任务。\n\n使用队列、信号量、事件组时，我们都要事先创建对应的结构体，双方通过中间的结构体通信：\n\n![img](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509161952531.png)\n\n使用任务通知时，任务结构体TCB中就包含了内部对象，可以直接接收别人发过来的\"通知\"：\n\n![img](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509161952379.png)\n\n#### 任务通知的特性\n\n##### 优势及限制\n\n任务通知的优势：\n\n- 效率更高：使用任务通知来发送事件、数据给某个任务时，效率更高。比队列、信号量、事件组都有大的优势。\n- 更节省内存：使用其他方法时都要先创建对应的结构体，使用任务通知时无需额外创建结构体。\n\n任务通知的限制：\n\n- 不能发送数据给ISR：\n- ISR并没有任务结构体，所以无法使用任务通知的功能给ISR发送数据。但是ISR可以使用任务通知的功能，发数据给任务。\n- 数据只能给该任务独享\n- 使用队列、信号量、事件组时，数据保存在这些结构体中，其他任务、ISR都可以访问这些数据。使用任务通知时，数据存放入目标任务中，只有它可以访问这些数据。\n- 在日常工作中，这个限制影响不大。因为很多场合是从多个数据源把数据发给某个任务，而不是把一个数据源的数据发给多个任务。\n- 无法缓冲数据\n- 使用队列时，假设队列深度为N，那么它可以保持N个数据。\n- 使用任务通知时，任务结构体中只有一个任务通知值，只能保持一个数据。\n- <span style=\"color:#00FFFF;\">无法广播给多个任务</span>\n- 使用事件组可以同时给多个任务发送事件。\n- 使用任务通知，只能发个一个任务。\n- 如果发送受阻，发送方无法进入阻塞状态等待\n- 假设队列已经满了，使用 **xQueueSendToBack()** 给队列发送数据时，任务可以进入阻塞状态等待发送完成。\n- 使用任务通知时，即使对方无法接收数据，发送方也无法阻塞等待，只能即刻返回错误。\n\n#####  通知状态和通知值\n\n每个任务都有一个结构体：TCB(Task Control Block)，里面有2个成员：\n\n- 一个是uint8_t类型，用来表示通知状态\n- 一个是uint32_t类型，用来表示通知值\n\n```c\ntypedef struct tskTaskControlBlock\n{\n    ......\n    /* configTASK_NOTIFICATION_ARRAY_ENTRIES = 1 */\n    volatile uint32_t ulNotifiedValue[ configTASK_NOTIFICATION_ARRAY_ENTRIES ];\n    volatile uint8_t ucNotifyState[ configTASK_NOTIFICATION_ARRAY_ENTRIES ];\n    ......\n} tskTCB;\n```\n\n通知状态有3种取值：\n\n- taskNOT_WAITING_NOTIFICATION：任务没有在等待通知\n- taskWAITING_NOTIFICATION：任务在等待通知\n- taskNOTIFICATION_RECEIVED：任务接收到了通知，也被称为pending(有数据了，待处理)\n\n```c\n##define taskNOT_WAITING_NOTIFICATION              ( ( uint8_t ) 0 )  /* 也是初始状态 */\n##define taskWAITING_NOTIFICATION                  ( ( uint8_t ) 1 )\n##define taskNOTIFICATION_RECEIVED                 ( ( uint8_t ) 2 )\n```\n\n通知值可以有很多种类型：\n\n- 计数值\n- 位(类似事件组)\n- 任意数值\n\n#### 任务通知的使用\n\n使用任务通知，可以实现轻量级的队列(长度为1)、邮箱(覆盖的队列)、计数型信号量、二进制信号量、事件组。\n\n##### 两类函数\n\n任务通知有2套函数，简化版、专业版，列表如下：\n\n- 简化版函数的使用比较简单，它实际上也是使用专业版函数实现的\n- 专业版函数支持很多参数，可以实现很多功能\n\n|          | 简化版                                      | 专业版                              |\n| -------- | ------------------------------------------- | ----------------------------------- |\n| 发出通知 | `xTaskNotifyGive ` `vTaskNotifyGiveFromISR` | `xTaskNotify ` `xTaskNotifyFromISR` |\n| 取出通知 | `ulTaskNotifyTake`                          | `xTaskNotifyWait`                   |\n\n##### 简化版任务通知\n\n在任务中使用`xTaskNotifyGive`函数，在ISR中使用`vTaskNotifyGiveFromISR`函数，都是直接给其他任务发送通知：\n\n- 使得通知值加一\n- 并使得通知状态变为\"pending\"，也就是**taskNOTIFICATION_RECEIVED**，表示有数据了、待处理\n\n可以使用`ulTaskNotifyTake`函数来取出通知值：\n\n- 如果通知值等于0，则阻塞(可以指定超时时间)\n- 当通知值大于0时，任务从阻塞态进入就绪态\n- 在ulTaskNotifyTake返回之前，还可以做些清理工作：把通知值减一，或者把通知值清零\n\n使用ulTaskNotifyTake函数可以实现轻量级的、高效的二进制信号量、计数型信号量。\n\n这几个函数的原型如下：\n\n```c\nBaseType_t xTaskNotifyGive( TaskHandle_t xTaskToNotify );\n\nvoid vTaskNotifyGiveFromISR( TaskHandle_t xTaskHandle, BaseType_t *pxHigherPriorityTaskWoken );\n\nuint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait );\n```\n\n`xTaskNotifyGive`函数的参数说明如下：\n\n|    **参数**     | **说明**                                   |\n| :-------------: | ------------------------------------------ |\n| `xTaskToNotify` | 任务句柄(创建任务时得到)，给哪个任务发通知 |\n|     返回值      | 必定返回pdPASS                             |\n\n`vTaskNotifyGiveFromISR`函数的参数说明如下：\n\n|          **参数**           | **说明**                                                     |\n| :-------------------------: | ------------------------------------------------------------ |\n|        `xTaskHandle`        | 任务句柄(创建任务时得到)，给哪个任务发通知                   |\n| `pxHigherPriorityTaskWoken` | 被通知的任务，可能正处于阻塞状态。 此函数发出通知后，会把它从阻塞状态切换为就绪态。 如果被唤醒的任务的优先级，高于当前任务的优先级， 则\"*pxHigherPriorityTaskWoken\"被设置为pdTRUE， 这表示在中断返回之前要进行任务切换。 |\n\n`ulTaskNotifyTake`函数的参数说明如下：\n\n|      **参数**       | **说明**                                                     |\n| :-----------------: | ------------------------------------------------------------ |\n| `xClearCountOnExit` | 函数返回前是否清零： pdTRUE：把通知值清零 pdFALSE：如果通知值大于0，则把通知值减一 |\n|   `xTicksToWait`    | 任务进入阻塞态的超时时间，它在等待通知值大于0。 0：不等待，即刻返回； portMAX_DELAY：一直等待，直到通知值大于0； 其他值：Tick Count，可以用*pdMS_TO_TICKS()*把ms转换为Tick Count |\n|       返回值        | 函数返回之前，在清零或减一之前的通知值。 如果xTicksToWait非0，则返回值有2种情况： 1. 大于0：在超时前，通知值被增加了 2. 等于0：一直没有其他任务增加通知值，最后超时返回0 |\n\n##### 专业版任务通知\n\n**xTaskNotify** 函数功能更强大，可以使用不同参数实现各类功能，比如：\n\n- 让接收任务的通知值加一：这时 **xTaskNotify()** 等同于 **xTaskNotifyGive()**\n- 设置接收任务的通知值的某一位、某些位，这就是一个轻量级的、更高效的事件组\n- 把一个新值写入接收任务的通知值：上一次的通知值被读走后，写入才成功。这就是轻量级的、长度为1的队列\n- 用一个新值覆盖接收任务的通知值：无论上一次的通知值是否被读走，覆盖都成功。类似 **xQueueOverwrite()** 函数，这就是轻量级的邮箱。\n\n**xTaskNotify()** 比 **xTaskNotifyGive()** 更灵活、强大，使用上也就更复杂。**xTaskNotifyFromISR()** 是它对应的ISR版本。\n\n这两个函数用来发出任务通知，使用哪个函数来取出任务通知呢？\n\n使用 **xTaskNotifyWait()** 函数！它比 **ulTaskNotifyTake()** 更复杂：\n\n- 可以让任务等待(可以加上超时时间)，等到任务状态为\"pending\"(也就是有数据)\n- 还可以在函数进入、退出时，清除通知值的指定位\n\n这几个函数的原型如下：\n\n```c\nBaseType_t xTaskNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction );\n\nBaseType_t xTaskNotifyFromISR( TaskHandle_t xTaskToNotify,\n                               uint32_t ulValue, \n                               eNotifyAction eAction, \n                               BaseType_t *pxHigherPriorityTaskWoken );\n\nBaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, \n                            uint32_t ulBitsToClearOnExit, \n                            uint32_t *pulNotificationValue, \n                            TickType_t xTicksToWait );\n```\n\n`xTaskNotify`函数的参数说明如下：\n\n|    **参数**     | **说明**                                                     |\n| :-------------: | ------------------------------------------------------------ |\n| `xTaskToNotify` | 任务句柄(创建任务时得到)，给哪个任务发通知                   |\n|    `ulValue`    | 怎么使用ulValue，由eAction参数决定                           |\n|    `eAction`    | 见下表                                                       |\n|     返回值      | pdPASS：成功，大部分调用都会成功 pdFAIL：只有一种情况会失败，当eAction为eSetValueWithoutOverwrite， 并且通知状态为\"pending\"(表示有新数据未读)，这时就会失败。 |\n\n`eNotifyAction`参数说明：\n\n|   **eNotifyAction取值**   | **说明**                                                     |\n| :-----------------------: | ------------------------------------------------------------ |\n|        `eNoAction`        | 仅仅是更新通知状态为\"pending\"，未使用ulValue。 这个选项相当于轻量级的、更高效的二进制信号量。 |\n|        `eSetBits`         | 通知值 = 原来的通知值 \\| ulValue，按位或。 相当于轻量级的、更高效的事件组。 |\n|       `eIncrement`        | 通知值 = 原来的通知值 + 1，未使用ulValue。 相当于轻量级的、更高效的二进制信号量、计数型信号量。 相当于**xTaskNotifyGive()**函数。 |\n| eSetValueWithoutOverwrite | 不覆盖。 如果通知状态为\"pending\"(表示有数据未读)， 则此次调用xTaskNotify不做任何事，返回pdFAIL。 如果通知状态不是\"pending\"(表示没有新数据)， 则：通知值 = ulValue。 |\n|  eSetValueWithOverwrite   | 覆盖。 无论如何，不管通知状态是否为\"pendng\"， 通知值 = ulValue。 |\n\nxTaskNotifyFromISR函数跟xTaskNotify很类似，就多了最后一个参数**pxHigherPriorityTaskWoken**。在很多ISR函数中，这个参数的作用都是类似的，使用场景如下：\n\n- 被通知的任务，可能正处于阻塞状态\n- **xTaskNotifyFromISR**函数发出通知后，会把接收任务从阻塞状态切换为就绪态\n- 如果被唤醒的任务的优先级，高于当前任务的优先级，则\"*pxHigherPriorityTaskWoken\"被设置为pdTRUE，这表示在中断返回之前要进行任务切换。\n\nxTaskNotifyWait函数列表如下：\n\n|        **参数**        | **说明**                                                     |\n| :--------------------: | ------------------------------------------------------------ |\n| `ulBitsToClearOnEntry` | 在xTaskNotifyWait入口处，要清除通知值的哪些位？ 通知状态不是\"pending\"的情况下，才会清除。 它的本意是：我想等待某些事件发生，所以先把\"旧数据\"的某些位清零。 能清零的话：通知值 = 通知值 & ~(ulBitsToClearOnEntry)。 比如传入0x01，表示清除通知值的bit0； 传入0xffffffff即ULONG_MAX，表示清除所有位，即把值设置为0 |\n| `ulBitsToClearOnExit`  | 在xTaskNotifyWait出口处，如果不是因为超时推出，而是因为得到了数据而退出时： 通知值 = 通知值 & ~(ulBitsToClearOnExit)。 在清除某些位之前，通知值先被赋给\"*pulNotificationValue\"。 比如入0x03，表示清除通知值的bit0、bit1； 传入0xffffffff即ULONG_MAX，表示清除所有位，即把值设置为0 |\n| `pulNotificationValue` | 用来取出通知值。 在函数退出时，使用ulBitsToClearOnExit清除之前，把通知值赋给\"*pulNotificationValue\"。 如果不需要取出通知值，可以设为NULL。 |\n|     `xTicksToWait`     | 任务进入阻塞态的超时时间，它在等待通知状态变为\"pending\"。 0：不等待，即刻返回； portMAX_DELAY：一直等待，直到通知状态变为\"pending\"； 其他值：Tick Count，可以用*pdMS_TO_TICKS()*把ms转换为Tick Count |\n|         返回值         | 1. pdPASS：成功 这表示xTaskNotifyWait成功获得了通知： 可能是调用函数之前，通知状态就是\"pending\"； 也可能是在阻塞期间，通知状态变为了\"pending\"。 2. pdFAIL：没有得到通知。 |\n","tags":["RTOS","实时操作系统","FreeRTOS"],"categories":["MCU"]},{"title":"C语言高级","url":"/2025/09/02/C语言高级/","content":"\n## 关于const的进一步思考\n\n> 背景：在进行宿舍精灵项目的代码编写时， 我使用了映射表来表现楼栋，我使用了const来修饰 以稳定内容 \n>\n> 但是在我尝试将楼栋的内容分离出来时（例如中1C 在oled上需把中文提取出来 然后剩下用oled_print来显示在oled上） 但却出现了指针错误 \n\n分析了一下：const是将对应的字符数组存放在只读存储区中 而我因为想要分离 从而修改了指针的内容 故造成指针错误\n\n`解决措施`：通过malloc来申请内存，然后使用strcpy或者sprintf来存放在新申请的内存中\n\n```C\nchar *get_building_map_remain(void)\n{\n    char *map = get_building_map();\n    if (map == NULL)\n    {\n        return NULL;\n    }\n\n    size_t len = strlen(map);\n    if (len <= 3)\n    {\n        // 返回空字符串\n        char *result = malloc(1);\n        if (result)\n        {\n            result[0] = '\\0';\n        }\n        return result;\n    }\n\n    // 分配新内存并复制跳过前3字节的内容\n    char *result = malloc(len - 3 + 1);\n    if (result == NULL)\n    {\n        return NULL;\n    }\n\n    strcpy(result, map + 3);\n    return result;\n}\n```\n\n\n\n{% externalLinkCard \"freertos\" \"https://mextra.netlify.app/2025/09/05/freertos/\" \"https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509071511987.png\" %}\n\n## 二维数组高级应用\n\n> 背景：在进一步封装MP3_Test项目的时候，本身有个二维数组mp3Files用来存放MP3文件路径，在修饰为static保护变量时，遇到了不会返回的难题\n>\n> []优先级高于*\n\n`解决措施`：通过询问`AI`后，得出可以将其封装为`一个返回值为数组指针的函数`，然后定义一个数组指针来接收`原型为指针，但指向的是数组`\n\n### 函数封装\n\n```C\nstatic char mp3Files[100][64]; // 假设最多有100个MP3文件\n\nchar (*get_mp3_files(void)) [64]\n{\n    return mp3Files;\n}\n\nvoid task(void)\n{\n    char (*files)[64] = get_mp3_files();\n    for(int i = 0; i < 100 ;i++)\n        printf(\"file[%d]:%s\\r\\n\",i,files[i]);\n}\n```\n\n### 指针访问\n\n```C\nstatic char mp3Files[100][64]; // 假设最多有100个MP3文件\n\nvoid task(void)\n{\n    /*（1）指向数组的指针（按行访问） 即指针数组*/\n    char (*p)[64] = mp3Files;\n    /*（2）指向数组的指针（逐个访问）*/\n    char *p = &mp3Files[0][0];\n //或\tchar *p = mp3Files[0];\n}\n```\n\n","tags":["嵌入式基础","C语言高级"]},{"title":"电赛","url":"/2025/06/08/电赛/","content":"\n## PID\n\n![image-20250608132624784](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202506081334606.png)\n\n- 其中 e 为误差\n- P：正比  即控制摆动\n- I：积分 积累误差，可用来消除稳定误差 （比如无人机中，向下吹的风刚好是1米，但p中最后上升也是1米 即形成一种稳态）\n- D：微分 速度控制 可用来让系统快速停下来\n\n## 编码器\n\n### CubeMX配置\n\n![image-20250612212624882](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202506122126276.png)\n\n#### 参数解析\n\n1. Encoder Mode\n\n- `Encoder Mode TI1` ：只保留A相，滤除B相数据\n\n- `Encoder Mode TI2` ：只保留B相，滤除A相数据\n\n- `Encoder Mode TI1 and TI2`：A、B相都保留，数据波长会是第一、二模式的两倍\n\n  > 一般用于高精度场合 如小车\n\n### 代码编写\n\n#### 初始化\n\n```C\n  HAL_TIM_Encoder_Start(&htim3, TIM_CHANNEL_1); // 开启编码器A\n  HAL_TIM_Encoder_Start(&htim3, TIM_CHANNEL_2); // 开启编码器A\n```\n\n#### 获取编码器值\n\n> 记得先接上编码器的电源 他与电机是分开的电源  工作电压为3.3V~5V\n\n```C\ng_nMotor_Lef_Pulse = (short)(__HAL_TIM_GET_COUNTER(&htim3)); // 获取计数器值\n__HAL_TIM_SET_COUNTER(&htim3, 0);\t\t\t\t\t\t\t // 左编码器TIM3计数器清零\n```\n\n## 超声波\n\n### CubeMX配置\n\n![image-20250612213408605](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202506122134910.png)\n\n![image-20250612214851115](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202506122148018.png)\n\n### 初始化\n\n```C\nHcsr04Init(&htim11, TIM_CHANNEL_1); //  超声波模块初始化\n```\n\n### 注册回调函数与绑定定时器溢出回调函数\n\n```C\nvoid HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim)\n{\n\tif (htim->Instance == TIM11)\n\t\tHcsr04TimIcIsr(&htim11);\n}\n\nvoid HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)\n{\n  if (htim->Instance == TIM11)\n  {\n    Hcsr04TimOverflowIsr(&htim11);\n  }\n}\n```\n\n### 获取距离值\n\n```C\nHcsr04Start();\nprintf(\"distance:%.1f cm\\r\\n\", Hcsr04Read());\nHAL_Delay(300); // 可适当加些延时\n```\n\n## JY60陀螺仪\n\n### CubeMX配置\n\n![image-20250612215946547](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202506122159648.png)\n\n![image-20250612220017334](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202506122200718.png)\n\n### 初始化\n\n- 引入官方sdk `wit_c_sdk.h与wit_c_sdk.c`\n- 新建驱动文件 `jy60.c`与 `jy60.h`\n\n```C\njy60_init();\n/*\nvoid jy60_init(void)\n{\n\t\tWitInit(WIT_PROTOCOL_NORMAL, 0x50);\n\t\tWitSerialWriteRegister(SensorUartSend);\n\t\tWitRegisterCallBack(SensorDataUpdata);\n\t\tWitDelayMsRegister(Delayms);\n\t\tHAL_Delay(100);\n}\n*/\n```\n\n### 获取加速度、角速度、姿态角\n\n```C\njy60_read();\n/*\nvoid jy60_read(void)\n{\n\t\tif(s_cDataUpdate)\n\t\t{\n\t\t\tfor(uint8_t i = 0; i < 3; i++)\n\t\t\t{\n\t\t\t\tfAcc[i] = sReg[AX+i] / 32768.0f * 16.0f;\n\t\t\t\tfGyro[i] = sReg[GX+i] / 32768.0f * 2000.0f;\n\t\t\t\tfAngle[i] = sReg[Roll+i] / 32768.0f * 180.0f;\n\t\t\t}\n//\t\t\tuint8_t strff[21];\n//\t\t\t\n//\t\t\tsprintf(strff,\"%.2f\",fAngle[2]);\n//\t\t\t\n//\t\t\tOLED_ShowStr(0,3,strff,1);\n\t\t\tif(s_cDataUpdate & ACC_UPDATE)\n\t\t\t{\n//\t\t\t\tprintf(\"acc:%.3f %.3f %.3f\\r\\n\", fAcc[0], fAcc[1], fAcc[2]);\n\t\t\t\ts_cDataUpdate &= ~ACC_UPDATE;\n\t\t\t}\n\t\t\tif(s_cDataUpdate & GYRO_UPDATE)\n\t\t\t{\n//\t\t\t\tprintf(\"gyro:%.3f %.3f %.3f\\r\\n\", fGyro[0], fGyro[1], fGyro[2]);\n\t\t\t\ts_cDataUpdate &= ~GYRO_UPDATE;\n\t\t\t}\n\t\t\tif(s_cDataUpdate & ANGLE_UPDATE)\n\t\t\t{\n\t\t\t\tprintf(\"angle:%.3f %.3f %.3f\\r\\n\", fAngle[0], fAngle[1], fAngle[2]);\n\t\t\t\ts_cDataUpdate &= ~ANGLE_UPDATE;\n\t\t\t}\n\t\t\tif(s_cDataUpdate & MAG_UPDATE)\n\t\t\t{\n\t\t\t\t//printf(\"mag:%d %d %d\\r\\n\", sReg[HX], sReg[HY], sReg[HZ]);\n\t\t\t\ts_cDataUpdate &= ~MAG_UPDATE;\n\t\t\t}\n\t\t}\n\t\t\n}\n*/\n```\n\n| 变量名   | 含义                    | 单位            | 来源寄存器             |\n| -------- | ----------------------- | --------------- | ---------------------- |\n| `fAcc`   | 加速度（Accelerometer） | M/s²            | `AX`、`AY`、`AZ`       |\n| `fGyro`  | 角速度（Gyroscope）     | °/s（角度每秒） | `GX`、`GY`、`GZ`       |\n| `fAngle` | 姿态角（Angle）         | °（角度）       | `Roll`、`Pitch`、`Yaw` |\n\n| 下标 | fAcc       | fGyro      | fAngle          |\n| ---- | ---------- | ---------- | --------------- |\n| [0]  | X 轴加速度 | X 轴角速度 | 横滚角（Roll）  |\n| [1]  | Y 轴加速度 | Y 轴角速度 | 俯仰角（Pitch） |\n| [2]  | Z 轴加速度 | Z 轴角速度 | 偏航角（Yaw）   |\n\n### 数据分析\n\n```C\nfAcc[i] = sReg[AX+i] / 32768.0f * 16.0f;\nfGyro[i] = sReg[GX+i] / 32768.0f * 2000.0f;\nfAngle[i] = sReg[Roll+i] / 32768.0f * 180.0f;\n/*以上数据均来源于这里*/\n//后面的 * 16.0f 表示限幅 即 加速度范围为 ± 16M/s²\n```\n\n","tags":["电赛准备"]},{"title":"西门子嵌入式学习","url":"/2025/06/02/西门子/","content":"\n## 调度器模板\n\n```C\n#include \"scheduler.h\"\n// clang-format off\ntypedef struct\n{\n\tvoid (*task_func)(void);\n\tuint32_t rate_ms;\n\tuint32_t last_ms;\n} task_t;\n\ntask_t tasks[] = {\n};\n\nuint8_t task_count;\n\nvoid scheduler_init(void)\n{\n\ttask_count = sizeof(tasks) / sizeof(task_t);\n}\n\nvoid scheduler_run(void)\n{\n\tuint8_t i;\n\tfor (i = 0; i < task_count; i++)\n\t{\n\t\tuint32_t now_time = HAL_GetTick();\n\t\tif ((uint32_t)(now_time - tasks[i].last_ms) >= tasks[i].rate_ms)\n\t\t{\n\t\t\ttasks[i].last_ms = now_time;\n\t\t\ttasks[i].task_func();\n\t\t}\n\t}\n}\n\n```\n\n\n\n## 时钟配置栏\n\n### 模式设置\n\n![image-20250602161506934](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202506021615783.png)\n\n#### 高速时钟HSE\n\n- `Disable`：不启用外部时钟（默认使用内部时钟） <span style=\"color:#00FFFF;\">内部时钟（内部RC（电阻-电容）振荡器）提供了此便捷性 但精度不如外部时钟（外部低速晶振或陶瓷振荡器）</span>\n\n- `BYPASS Clock Source`：旁路模式，允许直接<span style=\"color:#00FFFF;\">从外部导入时钟信号，而不使用外部晶体</span>。这种模式适用于需要从外部系统或其他设备接收时钟信号的情况。\n\n- `Crystal/Ceramic Resonator`：将外部低速晶振或陶瓷谐振器作为时钟源，一般则是板载上的外部晶振\n\n#### 低速时钟LSE\n\n> 参数同上 通常用于<span style=\"color:#33FFFF;\">实时时钟（RTC</span>）等需要低频稳定时钟的应用。LSE的典型频率为32.768kHz\n\n#### **Master Clock Output**\n\n- 配置是否使能主时钟<span style=\"color:#33FFFF;\">输出到MCO引脚</span>，`即可以通过MCO引脚将时钟信号输出到外部，供其他设备使用`\n\n#### **Audio Clock Input (I2S_CKIN)**：\n\n- 此选项用于配置是否从<span style=\"color:#33FFFF;\">特定的引脚（如I2S_CKIN）输入音频时钟</span>。这对于需要精确音频时钟的音频应用非常重要，`例如I2S音频接口`。\n\n### 参数设置\n\n![image-20250602162859501](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202506021629990.png)\n\n- `TIM Prescaler Selection`：定时器预分频选择，`禁用时使用最大分频值。`\n\n- `HSE Startup Timeout Value (ms)`：HSE（高速外部时钟）启动超时时间，设置为100ms。这是外部晶振启动的最长等待时间，如果超出这个时间晶振还未启动，微控制器会认为启动失败。\n- `LSE Startup Timeout Value (ms)`：LSE（低速外部时钟）启动超时时间，设置为5000ms。这通常用于RTC的时钟源，如果超出这个时间晶振还未启动，微控制器会认为启动失败。\n\n- `Power Regulator Voltage Scale`：电源调节器电压等级，设置为`Power Regulator Voltage Scale 3`。这通常与微控制器的性能和功耗有关，不同的电压等级可以提供不同的性能和功耗平衡。\n\n- `Power Over Drive`：电源过驱，禁用。这通常用于在需要更高性能时<span style=\"color:#33FFFF;\">临时提高微控制器的电压</span>，以支持更高的时钟频率。\n\n### 在何处选择了HSI以及HSE\n\n![image-20250602181824740](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202506021818291.png)\n\n- 第一个框一定一定要看硬件上的晶振是多少频率，<span style=\"color:#00FFFF;\">一定要严格按照硬件资源给的 （不要无脑用默认的）</span>\n\n  > 否则可能会出现串口数据接收乱码\n\n- 第二个框选择了用`相位锁定环（PLL） 调整外部高速时钟（HSE）还是内部高速时钟（HSI）\n\n- 第三个框框则直接选择是否选择 经过PLL调整后的时钟，也可以选择不经过PLL的原生外部高速时钟（HSE），以及内部高速时钟（HSI）。\n\n## SYS调试接口选择\n\n![image-20250602182759796](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202506021828146.png)\n\n### Serial Wire (SW-DP)\n\n- 串口烧录 仅需要两个引脚\n  - `SWCLK`：主机到从机的时钟信号\n  - `SWDIO`：双向数据信号\n\n- 这种模式下，ST-Link工作最稳定，占用引脚少，是日常开发的首选。\n\n### JTAG(JTAG-DP)\n\n- J-Link烧录 需要4或5个引脚：\n  - **TCK：**测试时钟\n  - **TMS：**测试模式选择\n  - **TDI：**测试数据输入\n  - **TDO：**测试数据输出\n  - **TRST：**测试复位（可选，5pin模式才有）\n- JTAG适合复杂的调试场景，尤其是在使用J-Link调试器时。\n\n## LED\n\n### 驱动代码\n\n```C\n#include \"led_app.h\"\n\nuint8_t ucLed[6] = {0, 0, 1, 0, 1, 1};\n\nvoid Led_disp(uint8_t *ucLed)\n{\n\tuint8_t temp = 0x00, i;\n\tstatic uint8_t temp_old = 0xff;\n\tfor (i = 0; i < 6; i++)\n\t{\n\t\tif (ucLed[i])\n\t\t\ttemp |= (1 << i);\n\t}\n\tif (temp != temp_old)\n\t{\n\t\tHAL_GPIO_WritePin(LED1_GPIO_Port, LED1_Pin, (temp & 0x01) ? GPIO_PIN_SET : GPIO_PIN_RESET);\n\t\tHAL_GPIO_WritePin(LED2_GPIO_Port, LED2_Pin, (temp & 0x02) ? GPIO_PIN_SET : GPIO_PIN_RESET);\n\t\tHAL_GPIO_WritePin(LED3_GPIO_Port, LED3_Pin, (temp & 0x04) ? GPIO_PIN_SET : GPIO_PIN_RESET);\n\t\tHAL_GPIO_WritePin(LED4_GPIO_Port, LED4_Pin, (temp & 0x08) ? GPIO_PIN_SET : GPIO_PIN_RESET);\n\t\tHAL_GPIO_WritePin(LED5_GPIO_Port, LED5_Pin, (temp & 0x10) ? GPIO_PIN_SET : GPIO_PIN_RESET);\n\t\tHAL_GPIO_WritePin(LED6_GPIO_Port, LED6_Pin, (temp & 0x20) ? GPIO_PIN_SET : GPIO_PIN_RESET);\n\t\ttemp_old = temp;\n\t}\n}\n\nvoid led_task(void)\n{\n\tLed_disp(ucLed);\n}\n```\n\n### 软件PWM呼吸灯\n\n```C\nvoid led_task(void)\n{\n\tstatic uint32_t breath_counter = 0;\t\t\t// 呼吸效果内部计时器，模拟时间流逝\n\tstatic uint8_t pwm_counter = 0;\t\t\t\t// PWM内部计时器，用于生成PWM波形\n\tstatic uint8_t brightness = 0;\t\t\t\t// 当前的亮度值\n\tstatic const uint16_t breath_period = 2000; // 呼吸效果周期，单位ms 调小可增加速度\n\tstatic const uint16_t pwm_max = 10;\t\t\t// PWM最大计数值  调大会降低pwm频率\n\n\tbreath_counter = (++breath_counter) % breath_period;\n        //(2.0f * 3.14159f * breath_counter / breath_period) 将结果映射为0到2π\n        //sin(2.0f * 3.14159f * breath_counter / breath_period) 将结果映射为-1到1\n        //sin(2.0f * 3.14159f * breath_counter / breath_period) + 1.0f 将结果映射为0到2\n        //(sin(2.0f * 3.14159f * breath_counter / breath_period) + 1.0f) * pwm_max / 2.0f 将实际亮度计算出来 通过(uint8_t)强制类型转换\n\tbrightness = (uint8_t)((sin(2.0f * 3.14159f * breath_counter / breath_period) + 1.0f) * pwm_max / 2.0f);\n\tpwm_counter = (++pwm_counter) % pwm_max;\n\tfor (uint8_t i = 0; i < 6; i++)\n\t\tucLed[i] = (pwm_counter < brightness) ? 1 : 0; //将所有LED置为呼吸灯效果\n\tLed_disp(ucLed);\n}\n```\n\n> 如果是要实时调光，则直接赋值`brightness`即可 （即<span style=\"color:#FF3333;\">不需要</span>`breath_counter`和`breath_period`）\n\n## 按键\n\n> 常用工程上所用按键对比\n>\n> github仓库地址：[bobwenstudy/easy_button: 嵌入式按键处理驱动（Button Driver），支持单击、双击、多击、自动消抖、长按、长长按、超长按 | 低功耗支持 | 组合按键支持 | 静态/动态注册支持](https://github.com/bobwenstudy/easy_button)\n\n![image-20250606171853466](https://fastly.jsdelivr.net/gh/2250272571/tuchuang@main/img/202506061718736.png)\n\n> 整体框架：\n> easy_button\n>  ├── ebtn\n>  │   ├── bit_array.h\n>  │   ├── ebtn.c\n>  │   └── ebtn.h\n>  ├── build.mk\n>  ├── example_user.c\n>  └── example_test.c\n>  ├── main.c\n>  ├── Makefile\n>  └── README.md\n\n### 使用步骤\n\n#### 第一步：新建button_app.c并包含头文件\n\n```C\n#include \"ebtn.h\" // 包含 ebtn 库头文件\n// ... 可能还需要包含你的 HAL 库头文件 ...\n// #include \"stm32xxx_hal.h\"\n```\n\n#### 第二步：定义参数与按键列表\n\n1. **定义按键参数 (`ebtn_btn_param_t`):** 使用 `EBTN_PARAMS_INIT` 宏设定按键的各种时间阈值和行为。这些参数可以被多个按键共用。`可用默认参数 即如下default_param_normal`\n2. **定义按键实例数组 (`ebtn_btn_t`):** 使用 `EBTN_BUTTON_INIT` 宏创建每个物理按键的实例，并指定它的唯一 `key_id` 和使用的参数。\n3. **（可不加）定义组合按键实例数组 (`ebtn_btn_combo_t`, 可选):** 使用 `EBTN_BUTTON_COMBO_INIT` 创建组合键实例，同样指定 `key_id` 和参数。\n\n```C\n/* 1. 定义按键参数实例 */\n// 参数宏: EBTN_PARAMS_INIT(\n//     按下消抖时间ms, 释放消抖时间ms,\n//     单击有效最短按下时间ms, 单击有效最长按下时间ms,\n//     多次单击最大间隔时间ms,\n//     长按(KeepAlive)事件周期ms (0禁用),\n//     最大连续有效点击次数 (e.g., 1=单击, 2=双击, ...)\n// )\nconst ebtn_btn_param_t default_param_normal = EBTN_PARAMS_INIT(\n    20,     // time_debounce: 按下稳定 20ms(消抖)\n    20,     // time_debounce_release: 释放稳定 20ms\n    50,     // time_click_pressed_min: 最短单击按下 50ms\n    500,    // time_click_pressed_max: 最长单击按下 500ms (超过则不算单击)\n    300,    // time_click_multi_max: 多次单击最大间隔 300ms (两次点击间隔超过则重新计数)\n    500,    // time_keepalive_period: 长按事件周期 500ms (按下超过 500ms 后，每 500ms 触发一次)\n    5       // max_consecutive: 最多支持 5 连击\n);\n\n/* 2. 定义静态按键列表 */\n// 宏: EBTN_BUTTON_INIT(按键ID, 参数指针)\nebtn_btn_t static_buttons[] = {\n    EBTN_BUTTON_INIT(1, &default_param_normal), // KEY1, ID=1, 使用 'default_param_normal' 参数\n    EBTN_BUTTON_INIT(2, &default_param_normal), // KEY2, ID=2, 也使用 'default_param_normal' 参数\n};\n\n/* 3. 定义静态组合按键列表 (可选) */\n// 宏: EBTN_BUTTON_COMBO_INIT(按键ID, 参数指针)\nebtn_btn_combo_t static_combos[] = {\n    // 假设 KEY1+KEY2 组合键\n    EBTN_BUTTON_COMBO_INIT(101, &default_param_normal), // 组合键, ID=101 (必须与普通按键ID不同)\n};\n\n```\n\n#### 第三步：编写回调函数\n\n你需要提供两个函数给 `ebtn` 库，告诉它如何与你的硬件交互以及如何通知你事件：\n\n- **`get_state_fn` (状态获取):** 这个函数被 `ebtn` 调用，用于读取指定按键当前的物理电平。\n- **`evt_fn` (事件处理):** 当 `ebtn` 检测到一个有效的按键事件（按下、释放、单击、长按）时，会调用这个函数，并传入触发事件的按键信息和事件类型。\n\n```C\n/* 1. 实现获取按键状态的回调函数 */\n// 函数原型: uint8_t (*ebtn_get_state_fn)(struct ebtn_btn *btn);\nuint8_t my_get_key_state(struct ebtn_btn *btn) {\n    // 根据传入的按钮实例中的 key_id 判断是哪个物理按键\n    switch (btn->key_id) {\n        case 1: // 请求读取 KEY1 的状态\n            // 假设 KEY1 接在 PB0，按下为低电平 (返回 1 代表按下)\n            return (HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_0) == GPIO_PIN_RESET);\n        case 2: // 请求读取 KEY2 的状态\n            // 假设 KEY2 接在 PB1，按下为低电平\n            return (HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_1) == GPIO_PIN_RESET);\n        // ... 可以添加更多按键的读取逻辑 ...\n        default:\n            // 对于库内部处理组合键等情况，或者未知的 key_id，安全起见返回 0 (未按下)\n            return 0;\n    }\n    // 注意：返回值 1 表示 \"活动/按下\"，0 表示 \"非活动/释放\"\n}\n\n/* 2. 实现处理按键事件的回调函数 */\n// 函数原型: void (*ebtn_evt_fn)(struct ebtn_btn *btn, ebtn_evt_t evt);\nvoid my_handle_key_event(struct ebtn_btn *btn, ebtn_evt_t evt) {\n    uint16_t key_id = btn->key_id;                 // 获取触发事件的按键 ID\n    uint16_t click_cnt = ebtn_click_get_count(btn); // 获取连击次数 (仅在 ONCLICK 事件时有意义)\n    // uint16_t kalive_cnt = ebtn_keepalive_get_count(btn); // 获取长按计数 (仅在 KEEPALIVE 事件时有意义)\n\n    // 调试打印 (可选)\n    // printf(\"Key ID: %d, Event: %d\", key_id, evt);\n\n    // 根据事件类型进行处理\n    switch (evt) {\n        case EBTN_EVT_ONPRESS: // 按下事件 (消抖成功后触发一次)\n            // printf(\" - Pressed\\n\");\n            // 可以在这里处理按下即触发的操作，比如点亮提示灯\n            if (key_id == 1) { /* Do something for KEY1 press */ }\n            break;\n\n        case EBTN_EVT_ONRELEASE: // 释放事件 (消抖成功后触发一次)\n            // printf(\" - Released\\n\");\n            // 可以在这里处理释放时触发的操作\n             if (key_id == 1) { /* Do something for KEY1 release */ }\n            break;\n\n        case EBTN_EVT_ONCLICK: // 单击/连击事件 (在释放后，或达到最大连击数，或超时后触发)\n            // printf(\" - Clicked (%d times)\\n\", click_cnt);\n            // --- 根据 key_id 和 click_cnt 执行不同操作 ---\n            if (key_id == 1) { // 如果是 KEY1 触发的 CLICK\n                if (click_cnt == 1) {\n                    // KEY1 单击\n                    // printf(\"  Action: KEY1 Single Click - Toggle LED1\\n\");\n                    // HAL_GPIO_TogglePin(LED1_GPIO_Port, LED1_Pin);\n                } else if (click_cnt == 2) {\n                    // KEY1 双击\n                    // printf(\"  Action: KEY1 Double Click - Switch Mode\\n\");\n                }\n                // ... 可以继续判断 3击, 4击 ...\n            } else if (key_id == 2) { // 如果是 KEY2 触发的 CLICK\n                 if (click_cnt == 1) {\n                    // KEY2 单击\n                    // printf(\"  Action: KEY2 Single Click - Toggle LED2\\n\");\n                 }\n            } else if (key_id == 101) { // 如果是组合键 (KEY1+KEY2) 触发的 CLICK\n                if (click_cnt == 1) {\n                     // 组合键单击\n                     // printf(\"  Action: Combo Key 101 Single Click - Reset System\\n\");\n                }\n            }\n            break;\n\n        case EBTN_EVT_KEEPALIVE: // 保持活动/长按事件 (按下持续时间超过阈值后，按周期触发)\n            // printf(\" - Keep Alive (Long Press, Count: %d)\\n\", kalive_cnt);\n            if (key_id == 1) {\n                // KEY1 长按\n                // printf(\"  Action: KEY1 Long Press - Increase Volume\\n\");\n            }\n            break;\n\n        default: // 未知事件 (理论上不应发生)\n            // printf(\" - Unknown Event\\n\");\n            break;\n    }\n}\n```\n\n#### 第四步：初始化 ebtn 库\n\n在系统启动的初始化阶段（例如 `main` 函数开始处，或专门的初始化函数中），调用 `ebtn_init` 函数，将之前准备好的按键列表和回调函数\"注册\"给 `ebtn` 库。\n\n如果使用了组合按键，还需要在 `ebtn_init` **之后**，调用相关函数将普通按键绑定到组合键上。\n\n```C\nvoid button_init(void)\n{\n    ebtn_init(\n        static_buttons,                 // 静态按键数组的指针\n        EBTN_ARRAY_SIZE(static_buttons), // 静态按键数量 (用宏计算)\n        static_combos,                  // 静态组合按键数组的指针 (如果没有，传 NULL, 0)\n        EBTN_ARRAY_SIZE(static_combos), // 静态组合按键数量 (如果没有，传 0)\n        my_get_key_state,               // 你的状态获取回调函数\n        my_handle_key_event             // 你的事件处理回调函数\n    );\n}\n//下面这个函数可以在调度器中每5秒调用\nvoid button_task(void)\n{\n    ebtn_process(uwTick);\n}\n```\n\n## SD+FATFS\n\n### CubeMX配置\n\n![image-20250923205942773](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509232059309.png)\n\n![image-20250923210029131](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509232100265.png)\n\n![image-20250928114434875](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509281144270.png)\n\n> 注意：如果TF-CARD上的CD引脚有接入gpio的话 可以将platform设置为该引脚 即检测SD卡引脚\n>\n> - 当该引脚为低电平时，则检测到sd卡\n>\n> - 没有接gpio的话，platform不要设置 不然会读取不到卡\n>\n>   ![image-20250923210313143](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509232103277.png)\n>\n>   正点原子探索者v3没有设计该引脚 所以留空即可\n>\n>   ![image-20250923210355410](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202509232103527.png)\n\n### 使用步骤\n\n#### 初始化\n\n```C\n SD_Driver.disk_initialize(0); // SD_Driver已经被声明在FATFS/Target/sd_diskio.c\n```\n\n","tags":["嵌入式基础","GD32学习"],"categories":["MCU"]},{"title":"TI","url":"/2025/05/28/TI/","content":"\n## 初始化代码\n\n### 浮点单元（FPU）相关配置\n\n```C\nROM_FPUEnable(); / 使能浮点单元\nROM_FPULazyStackingEnable(); / 启用浮点延迟堆栈模式，减少中断响应延迟    \n```\n\n**浮点单元（FPU）**\n\n- 浮点单元是 Cortex-M4 芯片（如 Tiva-C）内的硬件模块，用于加速浮点运算（如浮点加法、乘法）。\n\n- 如果你的项目中使用了`带小数`的计算（如定点PID控制、FFT计算、浮点除法），硬件 FPU 的加速能力远远优于软件模拟。\n\n**Lazy Stacking 模式**\n\n- 启用延迟堆栈推入操作后，在中断期间，只有确实需要使用浮点硬件时，才会将浮点寄存器保存到堆栈，从而减少中断响应时间和堆栈占用空间。\n\n### **实际开发中怎么使用和修改**\n\n#### ?  启用还是禁用  FPU：\n\n- 如果项目中`不涉及浮点运算`，可以省略这两个函数的调用以节省资源\n\n#### 启用延迟堆栈的条件：\n\n- 如果中断中涉及浮点运算，建议`启用 Lazy Stacking` 优化性能。\n\n- 但需要注意堆栈深度：<span style=\"text-decoration:line-through;\">中断嵌套可能导致浮点堆栈溢出</span>，调试时<span style=\"color:#66FFFF;\">增加栈尺寸</span>。\n\n## 时钟系统配置\n\n```C\nROM_SysCtlClockSet(SYSCTL_SYSDIV_2_5 | SYSCTL_USE_PLL | SYSCTL_XTAL_16MHZ | SYSCTL_OSC_MAIN); / 配置系统时钟\n```\n\n- <span style=\"color:#3399FF;\">参数说明</span>：\n\n1. `SYSCTL_SYSDIV_2_5`：\n   - 设置系统分频比， 2.5 是分频因子。\n   - 假设外部晶振频率为 16MHz，PLL 经过倍频后输出为 400MHz， 2.5 分频下得到时钟频率：400 ÷ 2.5 = 80MHz 。\n\n2. `SYSCTL_USE_PLL`：\n   - 指定使用 PLL（锁相环）作为系统时钟的倍频源。\n\n3. `SYSCTL_XTAL_16MHZ`：\n   - 配置外部晶振的规格为 16MHz，这需要与硬件实际晶振频率相匹配。\n\n4. `SYSCTL_OSC_MAIN`：\n   - 指定使用外部主振荡器作为系统的时钟输入源。\n\n### 实际开发中怎么使用和修改\n\n#### **如何修改分频比和主频**：\n\n- 如果需要更改 MCU 的主频（系统时钟频率），只需调整分频因子：\n\n  ```C\n  ROM_SysCtlClockSet(SYSCTL_SYSDIV_4 | SYSCTL_USE_PLL | SYSCTL_XTAL_16MHZ | SYSCTL_OSC_MAIN);\n  ```\n\n  示例中，分频比改为 4 ，主频变为 400 ÷ 4 = 100MHz 。\n\n#### 如果硬件使用其他晶振\n\n- 如果使用 8MHz 的晶振，应修改 `SYSCTL_XTAL_16MHZ` 为 `SYSCTL_XTAL_8MHZ` ：\n\n  ```C\n  ROM_SysCtlClockSet(SYSCTL_SYSDIV_2_5 | SYSCTL_USE_PLL | SYSCTL_XTAL_8MHZ | SYSCTL_OSC_MAIN);\n  ```\n\n#### 切换时钟源\n\n- 如果不使用外部晶振，可以切换为 **内部振荡器** (Precision Internal Oscillator, PIOSC)：\n\n  ```C\n  ROM_SysCtlClockSet(SYSCTL_SYSDIV_2_5 | SYSCTL_USE_PLL | SYSCTL_OSC_INT);\n  ```\n\n## 外设（GPIO）启用和配置\n\n```C\nROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOF); / 启用 GPIOF 外设\nROM_GPIOPinTypeGPIOOutput(GPIO_PORTF_BASE, GPIO_PIN_5); / 配置 GPIOF 5 为推挽输出\nROM_GPIOPinTypeGPIOOutput(GPIO_PORTF_BASE, GPIO_PIN_6); / 配置 GPIOF 6 为推挽输出\nROM_GPIOPinTypeGPIOOutput(GPIO_PORTF_BASE, GPIO_PIN_4); / 配置 GPIOF 4 为推挽输出\n```\n\n#### **GPIO 配置解析**\n\n1. **使能时钟**：\n\n   ```C\n   ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOF);\n   ```\n\n- 使能`GPIOF`外设的时钟\n- 每个外设模块在使用前都必须先使能其时钟，否则无法访问寄存器\n\n2. **配置推挽输出**：\n\n   ```C\n   ROM_GPIOPinTypeGPIOOutput(GPIO_PORTF_BASE, GPIO_PIN_X);\n   ```\n\n- 将`GPIOF`的某个引脚配置为`推挽输出`\n\n3. **配置输入模式**\n\n   ```C\n   ROM_GPIOPinTypeGPIOInput(GPIO_PORTF_BASE, GPIO_PIN_5);\n   ```\n\n- 将`PF5`引脚配置为输入\n\n### 串口代码\n\n```C\nROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOA); / 启用 GPIOA 外设\nROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_UART0); / 启用 UART0 外设\n```\n\n#### 配置UART引脚模式\n\n```C\nROM_GPIOPinConfigure(GPIO_PA0_U0RX); / 配置 GPIOA 引脚 0 为 UART0 RX\nROM_GPIOPinConfigure(GPIO_PA1_U0TX); / 配置 GPIOA 引脚 1 为 UART0 TX\nROM_GPIOPinTypeUART(GPIO_PORTA_BASE, GPIO_PIN_0 | GPIO_PIN_1); / 配置 GPIO PA0 和 PA1 为UART 模式\n```\n\n- <span style=\"color:#3399FF;\">参数说明</span>：\n\n1. `ROM_GPIOPinConfigure(pinConfig)`：\n   - 将某个 GPIO 引脚映射为对应外设的功能模式，例如 UART RX（接收）或 UART TX（发送）模式\n   - `GPIO_PA0_U0RX`和 `GPIO_PA1_U0TX` 分别表示将 GPIOA 的 0 和 1 引脚映射到 UART0 的 RX 和 TX信号。\n\n2. `ROM_GPIOPinTypeUART()`：\n   - 配置对应引脚为 UART 模式（主功能），指示这些引脚负责 UART 的输入和输出。\n\n3. **引脚复用说明**：\n\n   - 某些 GPIO 引脚具备多种功能（如 UART、SPI、I2C 等），可以通过 `ROM_GPIOPinConfigure() `设置引脚的复用功能。\n\n   - 数据手册中会列出默认出厂配置（如 GPIOA0、GPIOA1 默认是普通 I/O）以及复用编号\n\n#### 配置UART0模块\n\n```C\nUARTStdioConfig(0, 115200, 16000000); / 配置 UART0，设置波特率为 115200，时钟频率为 16MHz\nUARTClockSourceSet(UART0_BASE, UART_CLOCK_PIOSC); / 将 UART0 的时钟源设为内部精确振荡器PIOSC\n```\n\n`UARTStdioConfig() 详解：`\n\n- 用于配置 UART 模块的一些核心参数，例如 UART 通信模块的编号、默认的通信波特率、UART 时钟频率。\n\n1. <span style=\"color:#3399FF;\">参数说明</span>：\n\n- `0` ：指定 UART 模块编号， 0 对应 UART0。\n- `115200` ：波特率，表示每秒传输 115200 个比特。\n- `16000000` ：UART 输入时钟频率（以 Hz 为单位），这里指定为 16MHz。\n\n2. 作用：\n   - 根据设置的波特率和时钟频率， `UARTStdioConfig` 会自动计算并配置 UART 波特率控制寄存器，从而实现正确的通信速率。\n3. **默认时钟源（**PIOSC **内部振荡器）**\n\n```C\nUARTClockSourceSet(UART0_BASE, UART_CLOCK_PIOSC); / 使用 PIOSC（16 MHz）作为时钟源\n```\n\n- PIOSC 是 Tiva-C 系统内置的精确振荡器，频率为 16 MHz。\n- 替代方案：你可以改用系统主时钟（如 PLL）作为 UART 的时钟源。\n\n","tags":["TI"],"categories":["MCU"]},{"title":"RT_Thread","url":"/2025/05/21/RT-Thread/","content":"\n## 时钟管理\n\n### 时钟节拍产生与获取\n\n时钟节拍依赖于硬件中的定时器。你可以把定时器看作是⼀个不停计时的装置，它每隔⼀段时间就会提醒系统“滴答”⼀次。<span style=\"text-decoration:underline;\">每当定时器中断发⽣时，RT-Thread 会调⽤ rt_tick_increase()函数，系统时间增加 1 个节拍</span>。`就像家中的闹钟响⼀次，时间就过去了⼀分钟⼀样。`\n\n> 其中rt_tick_increase()函数中有rt_tick类似于HAL库中的uwTick，可以直接调用 获取系统时间\n\n## 定时器管理\n\n### 硬件定时器 vs 软件定时器\n\n1. <span style=\"color:#FF3399;\">硬件定时器</span>：就像厨房⾥的倒计时器，它是由硬件直接提供的。硬件定时器精度⾮常⾼，可以达到纳秒级，适合⼀些对时间要求⾮常严格的任务，⽐如控制电机的旋转时间。\n2. <span style=\"color:#FF3399;\">软件定时器</span>：可以理解为⼿机上的计时 App。它依赖于操作系统的时钟节拍来⼯作，它的时间间隔精度由 OS Tick 决定。例如，如果 OS Tick 是 10ms，那么软件定时器只能精确到 10ms。虽然精度不如硬件定时器⾼，但它更灵活、容易使⽤。\n\n### RTT定时器分类\n\n- <span style=\"color:#FF3399;\">单次触发定时器</span>：就像倒计时⼀次的闹钟，响⼀次后就停⽌。例如，设定⼀个 5 秒的倒计时，时间到了闹钟响⼀次就结束了。\n- <span style=\"color:#FF3399;\">周期触发定时器</span>：就像那些每天早上 7 点重复响起的闹钟。每隔⼀段时间，它会周期性地触发事件，直到你⼿动关闭它。\n\n根据定时器回调函数执⾏的上下⽂环境，定时器还可以分为两种模式：\n\n- <span style=\"color:#FF3399;\">硬件模式 </span>(HARD_TIMER)：定时器的回调函数在<span style=\"text-decoration:underline;\">中断上下⽂</span>中执⾏`就像闹钟响起时你⽴刻跳起来⼀样`它反应⾮常快，但要求处理时间短。\n- <span style=\"color:#FF3399;\">软件模式</span> (SOFT_TIMER)：回调函数在<span style=\"text-decoration:underline;\">系统的 timer 线程中</span>执⾏，相当于`有⼈提醒你“闹钟响了”`，然后你再去执⾏⼀些动作。这个模式可以做更复杂的操作，因为它不是在中断中执⾏。\n\n### 控制定时器\n\n`通过该函数你可以随时改变定时器触发方式以及定时器时间`\n\n![image-20250521221429133](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505212214569.png)\n\n### 高精度延时\n\n`使用该函数可以实现微妙级的精确延时，适合高精度时间控制场合`\n\n![image-20250521221525259](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505212215044.png)\n\n## 线程创建\n\n![image-20250521203425658](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505212034310.png)\n\n- `name`：线程名字\n- `entry`：线程入口函数\n- `parameter`：传递给线程的参数\n- `stack_size`：线程栈大小\n- `priority`：线程优先级\n- `tick`：时间片\n\n### 详细步骤\n\n1. 声明一个pcb结构体 `static rt_thread_t tid1 = RT_NULL;`\n2. 编写线程入口函数 `static void thread1_entry(void *parameter)`，参数为必需，其为传递给线程的参数\n3. 利用`rt_thread_create`函数赋值给所声明的pcb结构体tid1\n4. 利用``rt_thread_startup(tid1)``函数启动线程\n\n### 实现示例\n\n```C\nstatic void thread1_proc(void *parameter)\n{\n    while(1)\n    {\n        /*实际功能*/\n        rt_thread_mdelay(1000);//休息1秒\n    }\n}\nint thread1_init(void)\n{\n    rt_thread_t tid1 =  rt_thread_create(\"thread1_proc\",thread1_proc,RT_NULL,1024,10,20);\n    if(tid1 != RT_NULL)\n    {\n        rt_thread_startup(tid1);\n    }\n    return RT_EOK;\n}\nINIT_COMPONENT_EXPORT(thread1_init);   //用这个宏就不需要另外再去注册\n```\n\n> <span style=\"font-style:italic;\">rt_thread_mdelay(1000)的工作机制：</span>\n>\n> <span style=\"font-style:italic;\">1、当 rt_thread_mdelay 被调⽤时，当前线程会进⼊ RT_THREAD_SUSPEND 状态（<span style=\"color:#CC00CC;\">挂起</span>状态）。</span>\n>\n> <span style=\"font-style:italic;\">2、调度器开始运⾏其他优先级相同或更⾼的线程。</span>\n>\n> <span style=\"font-style:italic;\">3、 <span style=\"text-decoration:underline;\">延时时间结束后，线程从 挂起状态 转变为 就绪状态</span> ，等待系统再次调度该线程。</span>\n>\n> <span style=\"font-style:italic;\">PS：若此时无其他线程，则CPU就处于释放状态</span>\n\n![image-20250521205640868](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505212056766.png)\n\n## 线程间同步\n\n### 信号量\n\n信号量可以理解为电影院的座位数（<span style=\"color:#FF0000;\">资源数量</span>）。当所有座位都满了，新的观众（线程）就需要等前⾯的观众离开（释放资源）才能进⼊。当有空位时，观众可以进⼊。`信号量通过控制资源的数量来管理多个线程对资源的访问`\n\n#### 工作机制\n\n- `获取信号量`：当资源可⽤时，线程可以获取信号量，<span style=\"color:#FF0000;\">信号量的值减1</span>。<span style=\"background:#66FFFF;\">如果信号量的值为0，线程就会等待，直到资源释放</span>\n\n- `释放信号量`：使⽤完资源后，线程释放信号量，<span style=\"color:#FF0000;\">信号量的值加1</span>，允许其他线程访问资源\n\n##### 创建信号量\n\n```c\n/*动态分配内存并创建信号量*/\nrt_sem_t rt_sem_create(const char *name, rt_uint32_t value, rt_uint8_t flag);\n/*静态分配内存并创建信号量*/\nrt_err_t rt_sem_init(rt_sem_t sem, const char *name, rt_uint32_t value,rt_uint8_t flag);\n```\n\n- <span style=\"color:#3399FF;\">参数说明</span>：\n\n- `name`：信号量的名字（可以为 `RT_NULL` 表⽰匿名信号量）。\n\n- `value`：信号量的初始值，表⽰信号量当前持有的资源数量（`例如初始值为 0 表⽰等待事件，为 1 表⽰互斥量，或者更⼤值表⽰资源计数`）。\n\n- `flag`：PC 对象的属性标志，常⽤值：\n- `RT_IPC_FLAG_PRIO` ：<span style=\"color:#FF0000;\">优先级</span>等待⽅式，等待线程按照优先级顺序排列。\n  \n- `RT_IPC_FLAG_FIFO` ：<span style=\"color:#FF0000;\">先⼊先出</span>等待⽅式，等待线程按照进⼊顺序排列。\n\n##### 获取信号量\n\n⽤于获取信号量（P 操作），线程会尝试获取信号量，`如果信号量的计数值为 0，线程会进⼊等待状态`，直到信号量被释放或超时。\n\n```c\nrt_err_t rt_sem_take(rt_sem_t sem, rt_int32_t time);\n```\n\n- <span style=\"color:#3399FF;\">参数说明</span>：\n\n- `sem`：信号量的句柄。\n\n- `time`：超时时间（单位为系统 tick），表⽰最⼤等待时间。如果设置为 `RT_WAITING_FOREVER` ，线程会⼀直等待\n\n##### 释放信号量\n\n⽤于释放信号量（V 操作），**增加**信号量的计数值，`并唤醒等待该信号量的线程`。\n\n```c\nrt_err_t rt_sem_release(rt_sem_t sem);\n```\n\n#### 应用示例\n\n```c\n#include <rtthread.h>\n\nrt_sem_t sem = RT_NULL;\n\nvoid thread1(void *parameter)\n{\n   rt_kprintf(\"线程1：等待线程2发送信号\\n\");\n\n   /*等待信号量，超时时间为永久等待*/\n   rt_sem_take(sem,RT_WAITING_FOREVER);\n\n   rt_kprintf(\"线程1：收到线程2的信号，继续执行....\\n\");\n}\n\nvoid thread2(void *parameter)\n{\n   rt_kprintf(\"线程2：执行一些操作\\n\");\n   /*模拟执行一些动作*/\n   rt_thread_mdelay(2000);\n   rt_kprintf(\"线程2：操作完成，发送信号给线程1\\n\");\n   /*释放信号量 通知线程1*/\n   rt_sem_release(sem);\n}\n\nint main(void)\n{\n    rt_thread_t tid1 = RT_NULL;\n    rt_thread_t tid2 = RT_NULL;\n\n    sem = rt_sem_create(\"sem\", 0, RT_IPC_FLAG_PRIO);\n    tid1 = rt_thread_create(\"tid1\", thread1, RT_NULL, 1024, 25, 100);\n    tid2 = rt_thread_create(\"tid2\", thread2, RT_NULL, 1024, 25, 100);\n\n    if(tid1 != RT_NULL) rt_thread_startup(tid1);\n    if(tid2 != RT_NULL) rt_thread_startup(tid2);\n    return 0;\n}\n```\n\n#### 使用场景\n\n1. 任务同步（多任务协调执行顺序）\n2. 任务互斥(使用`互斥量` 保证同一时间只有一个线程 访问公共资源)\n3. 事件触发\n4. 限量资源管理\n\n### **互斥量（Mutex）**\n\n#### **工作机制**\n\n互斥量确保同⼀时刻**只有⼀个线程能够访问共享资源**：\n\n- `获取互斥量`：当⼀个线程获取到互斥量时，其他线程不能访问该资源，直到互斥量被释放。\n- `释放互斥量`：当线程释放互斥量后，其他等待的线程才能访问资源\n\n##### **创建互斥量**\n\n```c\n/*动态创建一个互斥量*/\nrt_mutex_t rt_mutex_create(const char *name, rt_uint8_t flag);\n/*静态创建一个互斥量*/\nrt_err_t rt_mutex_init(rt_mutex_t mutex, const char *name, rt_uint8_t flag);\n```\n\n- <span style=\"color:#3399FF;\">参数说明</span>：\n- `name`：互斥量的名字（可以为 `RT_NULL` 表⽰匿名互斥量）。\n- `flag`：IPC 对象的属性标志，通常使⽤ `RT_IPC_FLAG_PRIO` 表⽰优先级等待。\n\n##### **获取互斥量**\n\n⽤于获取互斥量，线程通过调⽤此函数进⼊临界区。`如果互斥量已经被其他线程获取，当前线程会进⼊等待状态，直到获取成功或超时。`\n\n```c\nrt_err_t rt_mutex_take(rt_mutex_t mutex, rt_int32_t time);\n```\n\n- <span style=\"color:#3399FF;\">参数说明</span>：\n- `mutex`：互斥量的句柄。\n- `time`：超时时间（单位为系统 tick），可以指定等待时⻓或 `RT_WAITING_FOREVER`表⽰永远等待。\n\n##### 释放互斥量\n\n⽤于释放互斥量（V 操作），**增加**互斥量的计数值，并唤醒等待该互斥量的线程。\n\n```c\nrt_err_t rt_mutex_release(rt_mutex_t mutex);\n```\n\n#### **应用示例**\n\n```c\n#include <rtthread.h>\n\nrt_mutex_t mutex = RT_NULL;\nrt_uint32_t cnt = 0;\n\nvoid thread1(void *parameter)\n{\n   //rt_kprintf(\"线程1：等待线程2发送信号\\n\");\n   while(1)\n   {\n       rt_mutex_take(mutex,RT_WAITING_FOREVER);\n       cnt++;\n       rt_thread_mdelay(1000);\n       rt_kprintf(\"线程1 cnt = %d \\n\",cnt);\n       rt_mutex_release(mutex);\n   }\n}\n\nvoid thread2(void *parameter)\n{\n   //rt_kprintf(\"线程2：执行一些操作\\n\");\n    while(1)\n    {\n        rt_mutex_take(mutex,RT_WAITING_FOREVER);\n        cnt++;\n        rt_thread_mdelay(1000);\n        rt_kprintf(\"线程2 cnt = %d \\n\",cnt);\n        rt_mutex_release(mutex);\n    }\n}\n\nint main(void)\n{\n    rt_thread_t tid1 = RT_NULL;\n    rt_thread_t tid2 = RT_NULL;\n\n    mutex = rt_mutex_create(\"mutex\", RT_IPC_FLAG_PRIO);\n    tid1 = rt_thread_create(\"tid1\", thread1, RT_NULL, 1024, 25, 100);\n    tid2 = rt_thread_create(\"tid2\", thread2, RT_NULL, 1024, 25, 100);\n\n    if(tid1 != RT_NULL) rt_thread_startup(tid1);\n    if(tid2 != RT_NULL) rt_thread_startup(tid2);\n    return 0;\n}\n\n```\n\n### **任务同步与任务互斥差异**\n\n![image-20250522203011255](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505222030206.png)\n\n### **事件集**\n\n事件集可以看作公交⻋站的场景。线程可以等待多个事件发⽣，`⽐如等待公交⻋或等待同伴到达。如果满⾜某个或某⼏个条件，线程将被唤醒继续执⾏。`\n\n#### **工作机制**\n\n事件集⽤于线程间的同步，可以让线程等待⼀个或多个事件的触发：\n\n- `逻辑与（AND)`：线程等待多个事件同时发⽣才被唤醒。\n- `逻辑或（OR）`：线程只需等待其中⼀个事件发⽣即可被唤醒。 \n\n##### **创建事件对象**\n\n```c\n/*动态创建一个对象*/\nrt_event_t rt_event_create(const char *name, rt_uint8_t flag);\n/*静态创建一个对象*/\nrt_err_t rt_event_init(rt_event_t event, const char *name, rt_uint8_t flag); \n```\n\n- <span style=\"color:#3399FF;\">参数说明</span>：\n- `name`：事件对象的名字（可以为 `RT_NULL` 表⽰匿名事件对象）。\n- `flag`：IPC 对象的属性标志，⼀般使⽤ `RT_IPC_FLAG_PRIO` 表⽰优先级等待，或`RT_IPC_FLAG_FIFO` 表⽰先进先出等待。\n\n##### **发送(触发)事件**\n\n```c\nrt_err_t rt_event_send(rt_event_t event, rt_uint32_t set);\n```\n\n- <span style=\"color:#3399FF;\">参数说明</span>：\n- `event`：事件对象的句柄。\n- `set`：事件标志，设置哪⼏位事件标志被触发 `可以⽤ 1 << n 来表⽰第 n 位的事件。`\n\n##### **接收(等待)事件**\n\n```c\nrt_err_t rt_event_recv(rt_event_t event, rt_uint32_t set, rt_uint8_t option, rt_int32_t timeout, rt_uint32_t *recved);\n```\n\n- <span style=\"color:#3399FF;\">参数说明</span>：\n- `event`：事件对象的句柄。\n- `set`：需要等待的事件标志 `例如 1 << 3 | 1 << 5 表⽰同时等待第3位和第5位的事件`\n- `option` ：等待选项，常⻅选项包括：\n  - `RT_EVENT_FLAG_AND` ：<span style=\"color:#3399FF;\">所有</span>指定的事件标志都满⾜时才唤醒线程。\n  - `RT_EVENT_FLAG_OR` ：<span style=\"color:#3399FF;\">只要有⼀个</span>指定的事件标志满⾜就唤醒线程。\n  - `RT_EVENT_FLAG_CLEAR` ：<span style=\"color:#3399FF;\">收到</span>事件标志后<span style=\"color:#3399FF;\">清除</span>这些事件标志。\n- `timeout` ：超时时间（单位为系统 tick），可以为 `RT_WAITING_FOREVER` 表⽰永远等待。\n- `recved` ：输出参数，返回实际接收到的事件标志\n\n#### **应用示例**\n\n```c\n#include <rtthread.h>\n\nrt_event_t event = RT_NULL;\n/*线程1：等待事件*/\nvoid thread1(void *parameter)\n{\n   rt_uint32_t recei;\n   rt_kprintf(\"线程1：等待公交车3或5到来...\\n\");\n\n   rt_event_recv(event, (1 << 3 | 1 << 5), RT_EVENT_FLAG_OR | RT_EVENT_FLAG_CLEAR, RT_WAITING_FOREVER, &recei);\n\n   rt_kprintf(\"线程1：公交车 %d 到站，出发！....\\n\",recei);\n}\n/*线程2：发送事件（公交车到站）*/\nvoid thread2(void *parameter)\n{\n   rt_thread_mdelay(1000);//模拟公交车到站\n   rt_kprintf(\"线程2：公交车3到站\\n\");\n   rt_event_send(event, (1 << 3));\n}\n\nint main(void)\n{\n    rt_thread_t tid1 = RT_NULL;\n    rt_thread_t tid2 = RT_NULL;\n\n    event = rt_event_create(\"event\", RT_IPC_FLAG_PRIO);\n    tid1 = rt_thread_create(\"tid1\", thread1, RT_NULL, 1024, 25, 100);\n    tid2 = rt_thread_create(\"tid2\", thread2, RT_NULL, 1024, 25, 100);\n\n    if(tid1 != RT_NULL) rt_thread_startup(tid1);\n    if(tid2 != RT_NULL) rt_thread_startup(tid2);\n    return 0;\n}\n```\n\n## **线程间通信**\n\n裸机编程中经常使用全局变量进行功能间的通信（标志）：某些功能由于特定的操作改变全局变量的值，另一个功能对此全局变量进行读取，根据读取到的全局变量执行相应的操作来达到通信协作的目的。RTT提供了邮箱、消息队列和信号等工具来完成这样的类似操作\n\n### **邮箱**\n\n#### 工作机制\n\n邮箱的特点：开销低、效率高、支持一对多\n\n邮箱中一封邮件**只能容纳固定的4字节信息**（针对32位操作系统，指针大小为4字节，一封邮件恰好能容纳一个指针），所以典型的邮箱也被称为交换消息\n\n> 一般如果邮箱中<span style=\"color:#3399FF;\">存在邮件</span>且收取邮件时的<span style=\"color:#3399FF;\">超时时间为0</span>，邮件的收取过程是<span style=\"font-weight:bold;\">非阻塞</span>的\n>\n> 但邮箱中<span style=\"color:#3399FF;\">不存在邮件</span>且<span style=\"color:#3399FF;\">超时时间不为0</span>时，邮件收取过程就是<span style=\"font-weight:bold;\">阻塞</span>的，邮件收取阻塞的情况下只能由线程进行邮件的收取。\n\n- `邮件发送阻塞`：一个线程向邮箱发送邮件时：\n  - 如果邮箱未满，则把邮件复制到邮箱中\n  - 如果邮箱已满，则<span style=\"color:#3399FF;\">发送线程挂起</span>并等待邮箱有空间时将其唤醒再发送邮件 或 直接返回`-RT_EFULL`\n\n- `邮件接收阻塞`：一个线程从邮箱中接收邮件时：\n  - 如果邮箱已空，接收线程可以挂起直到收到新的邮件被唤醒 `也可以设置超时时间并进行等待`\n  - 如果达到设置的超时时间<span style=\"color:#00FFFF;\">但邮箱仍未收到邮件</span>时，超时线程将被唤醒并返回`-RT_ETIMEOUT`；\n  - 如果邮箱中存在邮件，则接收线程赋值邮箱中的邮件到接收缓存\n\n##### **创建邮箱**\n\n```C\n/*创建动态邮箱*/\nrt_mailbox_t rt_mb_create (const char* name, rt_size_t size, rt_uint8_t flag);\n/*创建静态邮箱*/\nrt_err_t rt_mb_init(rt_mailbox_t mb,const char* name,void* msgpool,rt_size_t size,rt_uint8_t flag)\n```\n\n- <span style=\"color:#3399FF;\">参数说明</span>：\n- `mb`：邮箱对象的句柄。\n- `name`：邮箱容量(几封邮件)\n- `size` ：邮箱容量(几封邮件)。\n- `flag` ：邮箱标志，它可以取如下数值：`一般除非应用程序非常在意先来后到，不然都采用PRIO确保线程实时性`\n  - `RT_IPC_FLAG_FIFO` ：非实时调度方式 先来后到\n  - `RT_IPC_FLAG_PRIO` ：实时调度方式 优先级\n- `msgpool` ：缓冲区指针。\n- `recved` ：输出参数，返回实际接收到的事件标志\n\n##### **删除或脱离邮箱**\n\n```C\n/*删除动态邮箱create*/\nrt_err_t rt_mb_delete (rt_mailbox_t mb);\n/*删除静态邮箱init*/\nrt_err_t rt_mb_detach(rt_mailbox_t mb);\n\n//返回值：RT_EOK 成功\n```\n\n- <span style=\"color:#3399FF;\">参数说明</span>：\n- `mb`：邮箱对象的句柄。\n\n> 调用删除函数时，内核会<span style=\"color:#00FFFF;\">先唤醒所有</span>挂在该邮箱上的线程（线程返回值是`RT_ERROR`），然后<span style=\"color:#00FFFF;\">再释放</span>邮箱使用的<span style=\"color:#00FFFF;\">内存</span>，最后<span style=\"color:#00FFFF;\">删除邮箱对象</span>\n\n##### **发送邮件**\n\n```c\n/*1.直接发送邮件*/\n/*！！！！！记得value需要强转rt_uint32_t！！！！！*/\nrt_err_t rt_mb_send (rt_mailbox_t mb, rt_uint32_t value);\n/**************返回值*****************/\nRT_EOK        发送成功\n-RT_EFULL      邮箱已经满了\n\n/*2.等待方式发送邮件*/\n/*@note 若邮箱已满，则根据设定的timeout等待邮箱中因为收取邮件而空出空间\n/*@note 若超时时间到达依然没有空出时间，此时发送线程被唤醒并返回错误码\n*/\nrt_err_t rt_mb_send_wait (rt_mailbox_t mb,rt_uint32_t value,rt_int32_t timeout);\n/**************返回值*****************/\nRT_EOK        发送成功\n-RT_ETIMEOUT     超时\n-RT_ERROR    失败，返回错误\n\n/*3.发送紧急邮件*/\n/*@note 发送紧急邮件时，邮件被直接插队放入了邮件队首,这样就能最优先接收到并做出处理\n*/\nrt_err_t rt_mb_urgent (rt_mailbox_t mb, rt_ubase_t value);\n/**************返回值*****************/\nRT_EOK       发送成功\n-RT_EFULL    邮箱已满\n```\n\n- <span style=\"color:#3399FF;\">参数说明</span>：\n- `mb`：邮箱对象的句柄。\n- `value` ：发送的邮件内容。\n- `timeout` ：超时时间。\n\n##### **接收邮件**\n\n```C\n/*@note 只有当接收者接收的邮箱中有邮件时，接收者才能立即取到邮件并返回 RT_EOK 的返回值\n否则接收线程会根据超时时间设置，或挂起在邮箱的等待线程队列上，或直接返回。\n！！！！！记得value需要强转rt_uint32_t！！！！！\n*/\nrt_err_t rt_mb_recv (rt_mailbox_t mb, rt_uint32_t* value, rt_int32_t timeout);\n/**************返回值*****************/\nRT_EOK        接收成功\n-RT_ETIMEOUT     超时\n-RT_ERROR    失败，返回错误\n```\n\n- <span style=\"color:#3399FF;\">参数说明</span>：\n- `mb`：邮箱对象的句柄。\n- `value` ：邮件内容`(定义一个变量来接收 记得强转)`\n- `timeout` ：超时时间。\n\n#### **应用示例**\n\n```C\n#include <rtthread.h>\n\n/*创建邮箱*/\nrt_mailbox_t mb;\n\n/*线程1：发送邮箱*/\nvoid thread_entry1(void *parameter)\n{\n    char msg = 'A';//发送'A'作为邮件\n    rt_kprintf(\"线程1：发送邮件...\\n\");\n    //发送邮件  因为邮箱固定4字节 所以需要强转\n    rt_mb_send(mb, (rt_uint32_t)msg);\n}\n/*线程2：接收邮件*/\nvoid thread_entry2(void *parameter)\n{\n   char msg;\n   rt_kprintf(\"线程2：等待接收邮件...\\n\");\n   //若邮箱内为空  则执行的是阻塞式的等待接收邮件\n   rt_mb_recv(mb, (rt_uint32_t)&msg, RT_WAITING_FOREVER);//接收邮件\n   rt_kprintf(\"线程2：收到邮件：%c\\n\",msg);\n}\n\nint main(void)\n{\n    /*创建一个容量为4的4封邮箱(大小为4*4)) */\n    mb = rt_mb_create(\"mb\", 4, RT_IPC_FLAG_PRIO);\n    /*创建两个线程 */\n    rt_thread_t tid1 = rt_thread_create(\"t1\", thread_entry1, RT_NULL, 1024, 10,\n    10);\n    rt_thread_t tid2 = rt_thread_create(\"t2\", thread_entry2, RT_NULL, 1024, 10,\n    10);\n    /* 启动线程 */\n    rt_thread_startup(tid1);\n    rt_thread_startup(tid2);\n    return 0;\n}\n```\n\n### **消息队列**\n\n消息队列是另一种常用的线程间通讯方式，是邮箱的扩展。他可以动态分配内存，对比邮箱局限的4字节存储特性，更适合用来传输复杂大量数据或进行任务队列管理\n\n#### **工作机制**\n\n##### **创建消息队列**\n\n```C\n/*创建动态消息队列*/\nrt_mq_t rt_mq_create(const char* name, rt_size_t msg_size,rt_size_t max_msgs, rt_uint8_t flag);\n\n/*创建静态消息队列*/\n/*@note 一般放于读数据段或未初始化数据段中。在使用这类静态消息队列对象前，需要进行初始化\n*/\nrt_err_t rt_mq_init(rt_mq_t mq, const char* name,void *msgpool,rt_size_t msg_size,rt_size_t pool_size, rt_uint8_t flag);\n```\n\n- <span style=\"color:#3399FF;\">参数说明</span>：\n\n- `name `：消息队列的名称。\n\n- `msg_size ` ：消息队列中一条消息的最大长度，<span style=\"color:#00FFFF;\">单位字节</span>。\n\n- `msg_msgs`：消息队列的最大个数(消息个数)。\n\n- `flag` ：消息队列采用的等待方式，它可以取如下数值：`一般除非应用程序非常在意先来后到，不然都采用PRIO确保线程实时性`\n\n  - `RT_IPC_FLAG_FIFO`：非实时调度方式 先来后到\n\n  - `RT_IPC_FLAG_PRIO`：实时调度方式 优先级\n\n- `mq` ：消息队列对象的句柄。\n\n- `msgpool`：指向存放消息的缓冲区的指针。\n\n- `pool_size` ：存放消息的缓冲区大小\n\n##### **删除或脱离消息队列**\n\n```C\n/*删除动态消息队列create*/\nrt_err_t rt_mq_delete(rt_mq_t mq);\n/*删除静态消息队列init*/\nrt_err_t rt_mq_detach(rt_mq_t mq);\n//返回值：RT_EOK 成功\n```\n\n- <span style=\"color:#3399FF;\">参数说明</span>：\n- `mq`：消息队列对象的句柄\n\n> 删除消息队列时，如果<span style=\"color:#00FFFF;\">有线程</span>被挂起在该消息队列等待队列上，则内核<span style=\"color:#00FFFF;\">先唤醒挂起</span>在该消息等待队列上的所有线程（线程返回值是 `- RT_ERROR`），然后再<span style=\"color:#00FFFF;\">释放</span>消息队列使用的内存，最后<span style=\"color:#00FFFF;\">删除</span>消息队列对象\n\n##### **发送消息**\n\n```C\n/*1.直接发送消息*/\nrt_err_t rt_mq_send (rt_mq_t mq, void* buffer, rt_size_t size);\n/**************返回值*****************/\nRT_EOK        发送成功\n-RT_EFULL      消息队列已经满了\n-RT_ERROR       失败(发送消息长度>队列的最大长度)\n\n/*2.等待方式发送消息*/\n/*@note 若消息队列已满，则根据设定的timeout等待\n/*@note 若超时时间到达依然没有空出时间，此时发送线程被唤醒并返回错误码\n*/\nrt_err_t rt_mq_send_wait(rt_mq_t mq,const void *buffer,rt_size_t size,rt_int32_t  timeout);\n/**************返回值*****************/\nRT_EOK        发送成功\n-RT_ETIMEOUT     超时\n-RT_ERROR    失败(发送消息长度>队列的最大长度)\n\n/*3.发送紧急消息*/\n/*@note 发送紧急消息时，邮件被直接插队放入了消息队列队首,这样就能最优先接收到并做出处理\n*/\nrt_err_t rt_mq_urgent(rt_mq_t mq, void* buffer, rt_size_t size);\n/**************返回值*****************/\nRT_EOK       发送成功\n-RT_EFULL    消息队列已经满了\n-RT_ERROR    失败(发送消息长度>队列的最大长度)\n```\n\n- <span style=\"color:#3399FF;\">参数说明</span>：\n- `mq`：消息队列对象的句柄\n- `buffer` ：发送的消息内容。\n- `size` ：消息大小。\n- `timeout` ：超时时间。\n\n##### **接收消息**\n\n```C\n/*@note 只有当消息队列中有消息时，接收者才能立即取到邮件并返回 RT_EOK 的返回值\n否则接收线程会根据超时时间设置，或挂起在邮箱的等待线程队列上，或直接返回。\n*/\nrt_ssize_t rt_mq_recv (rt_mq_t mq, void* buffer,rt_size_t size,rt_int32_t timeout);\n/**************返回值*****************/\nRT_EOK             成功收到\n-RT_ETIMEOUT             超时\n-RT_ERROR            失败，返回错误\n```\n\n- <span style=\"color:#3399FF;\">参数说明</span>：\n- `mq`：消息队列对象的句柄\n- `buffer` ：发送的消息内容。\n- `size` ：消息大小。\n- `timeout` ：超时时间\n\n#### **应用示例**\n\n```C\n#include <rtthread.h>\n\n/*创建消息队列*/\nrt_mq_t mq;\n\n/*线程1：发送消息*/\nvoid thread_entry1(void *parameter)\n{\n    char msg[] = \"Hello, RT-Thread!\";//发送'A'作为邮件\n    rt_kprintf(\"线程1：发送消息...\\n\");\n    //发送消息到消息队列\n    rt_mq_send(mq, msg,sizeof(msg));\n}\n/*线程2：接收邮件*/\nvoid thread_entry2(void *parameter)\n{\n   char buffer[32];\n   rt_kprintf(\"线程2：等待接收消息...\\n\");\n   //若消息队列内无消息  则执行的是阻塞式的等待接收消息\n   rt_mq_recv(mq, buffer,sizeof(buffer), RT_WAITING_FOREVER);//接收消息\n   rt_kprintf(\"线程2：收到消息：%s\\n\",buffer);\n}\n\nint main(void)\n{\n    /*创建一个消息队列，容量为4，消息大小为32字节 */\n    mq = rt_mq_create(\"mq\", 32, 4, RT_IPC_FLAG_PRIO);\n    /*创建两个线程 */\n    rt_thread_t tid1 = rt_thread_create(\"t1\", thread_entry1, RT_NULL, 1024, 10,\n    10);\n    rt_thread_t tid2 = rt_thread_create(\"t2\", thread_entry2, RT_NULL, 1024, 10,\n    10);\n    /* 启动线程 */\n    rt_thread_startup(tid1);\n    rt_thread_startup(tid2);\n    return 0;\n}\n\n```\n\n### **信号**\n\n`信号（又称为软中断信号）`，在软件层次上是对中断机制的一种模拟。常用于通知线程发生了某个事件。线程收到信号时会根据信号类型执行相应的操作\n\n- 与消息队列区别：\n\n1. <span style=\"color:#00FFFF;\">信号仅携带控制信息，不包含数据</span>\n\n2. 信号不保证顺序性，<span style=\"color:#00FFFF;\">信号发生时立即通知线程</span>\n\n3. 消息队列则有顺序性（通常是PRIO）\n\n#### **工作机制**\n\n##### **线程中安装信号**\n\n```C\n/*\nt_sighandler_t[] 表示一个函数指针数组\nt_sighandler_t handler[] 是一个 变量声明\n二者是不一样的！\n*/\nrt_sighandler_t rt_signal_install(int signo, rt_sighandler_t[] handler);\n/**************返回值*****************/\nSIG_ERR                错误的信号\n安装信号前的handler值    成功\n```\n\n- <span style=\"color:#3399FF;\">参数说明</span>：\n- `signo `：信号值（只有 `SIGUSR1` 和 `SIGUSR2` 是开放给用户使用的）。\n- `buffer` ：发送的消息内容。\n- `handler` ：设置对信号值的处理方式。\n\n>  在信号安装时设定 handler 参数，决定了该信号的不同的处理方法。处理方法可以分为三种：\n>\n> 1. 类似`中断`的处理方式，参数指向当信号发生时用户`自定义的处理函数`， 在内部写入处理方式，由该函数来处理。\n>\n> 2. 参数设为 `SIG_IGN`，忽略某个信号，`对该信号不做任何处理`，就像未发生过一样。\n>\n> 3. 参数设为 `SIG_DFL`，系统会调用默认的处理函数`_signal_default_handler()`。\n\n##### **阻塞信号与解除阻塞**\n\n```C\n/*信号阻塞(屏蔽信号) 该信号不会递答安装此信号的线程*/\nvoid rt_signal_mask(int signo);\n/*解除信号阻塞\n使用此函数可以对其中一些信号给予 “关注”，那么发送这些信号都会引发该线程的软中断\n*/\nvoid rt_signal_unmask(int signo);\n```\n\n- <span style=\"color:#3399FF;\">参数说明</span>：\n- `signo`：信号值\n\n##### **发送信号**\n\n```C\n/*需要异常处理时，可以给安装了信号的线程发送信号*/\nint rt_thread_kill(rt_thread_t tid, int sig);\n/**************返回值*****************/\nRT_EOK        发送成功\n-RT_EINVAL    参数错误\n```\n\n- <span style=\"color:#3399FF;\">参数说明</span>：\n- `tid`：接收信号的线程。\n- `sig `：信号值。\n\n#### **应用示例**\n\n```C\n#include <rtthread.h>\n\n#define THREAD_PRIORITY         25\n#define THREAD_STACK_SIZE       512\n#define THREAD_TIMESLICE        5\n\nstatic rt_thread_t tid1 = RT_NULL;\n\n/* 线程 1 的信号处理函数 */\nvoid thread1_signal_handler(int sig)\n{\n    rt_kprintf(\"thread1 received signal %d\\n\", sig);\n}\n\n/* 线程 1 的入口函数 */\nstatic void thread1_entry(void *parameter)\n{\n    int cnt = 0;\n\n    /* 安装信号 */\n    rt_signal_install(SIGUSR1, thread1_signal_handler);\n    rt_signal_unmask(SIGUSR1);\n\n    /* 运行 10 次 */\n    while (cnt < 10)\n    {\n        /* 线程 1 采用低优先级运行，一直打印计数值 */\n        rt_kprintf(\"thread1 count : %d\\n\", cnt);\n\n        cnt++;\n        rt_thread_mdelay(100);\n    }\n}\n\n/* 信号示例的初始化 */\nint signal_sample(void)\n{\n    /* 创建线程 1 */\n    tid1 = rt_thread_create(\"thread1\",thread1_entry, RT_NULL,THREAD_STACK_SIZE, THREAD_PRIORITY, THREAD_TIMESLICE);\n\n    if (tid1 != RT_NULL)\n        rt_thread_startup(tid1);\n\n    rt_thread_mdelay(300);\n\n    /* 发送信号 SIGUSR1 给线程 1 */\n    rt_thread_kill(tid1, SIGUSR1);\n\n    return 0;\n}\n\n```\n\n## **框架移植**\n\n```C\n//bsp_system.h中引入以下四个头文件\n#include <rtthread.h>\n#include <rtdevice.h>\n#include <drv_common.h>\n#include <board.h>\n```\n\n### **系统初始化宏定义**\n\n​    ![image-20250522214349807](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505222143758.png)\n\n```C\n/*1、板级初始化 fn为函数指针*/\nINIT_BOARD_EXPORT(fn)\n/*2、纯软件函数初始化 fn为函数指针*/\nINIT_PREV_EXPORT(fn)\n/*3、设备自动初始化，fn为函数指针*/\nINIT_DEVICE_EXPORT(fn)\n/*4、组件自动初始化，fn为函数指针*/\nINIT_COMPONENT_EXPORT(fn)\n/*5、系统环境自动初始化，fn为函数指针*/\nINIT_ENV_EXPORT(fn) \n/*6、应用自动初始化，fn为函数指针*/\nINIT_APP_EXPORT(fn)\n```\n\n### **ESP8266移植**\n\n> 将`uart_app.c`与`uart_app.h`移去 不使用！！！然后RTT打开控制台输出rt_kprintf，选择串口1\n\n   ![image-20250522214536841](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505222145092.png)\n\n![image-20250522220417747](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505222204947.png) ![image-20250522220447380](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505222204548.png)\n\n![image-20250522214750185](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505222147073.png)\n\n![image-20250522214705123](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505222147664.png)\n\n![image-20250522214840651](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505222148942.png)\n\n![image-20250522214859546](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505222149729.png)\n\n![image-20250522214917115](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505222149203.png)\n\n![image-20250522214947877](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505222149796.png)\n\n直接编译开启终端 下载观察现象，出现以下信息则连接成功\n\n​    ![image-20250522215015453](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505222150747.png)\n\n### **DHT11移植**\n\n#### **组件添加**\n\n​    ![image-20250522215146162](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505222151707.png)\n\n![image-20250522215207600](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505222152193.png)\n\n![image-20250522220342327](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505222203028.png)\n\n\n\n#### **proc代码构建**\n\n##### **创建sensor_app.c与.h**\n\n```C\n//引入必要库\n#include <sensor_app.h>\n#include <sensor.h>\n#include \"sensor_dallas_dht11.h\"\n```\n\n##### **注册设备**\n\n    ```C\n        rt_device_t dev = RT_NULL;\n        //创建传感器结构体对象\n        struct rt_sensor_data sensor_data;\n        rt_uint8_t get_data_freq = 1;///默认1hz\n        rt_size_t res;//返回值 如RT_EOK\n    \n        /*注册传感器*/\n        dev =  rt_device_find(\"temp_dht11\");//注意此处注册需要有前缀 如temp_(在sensor.c中)\n        if(dev == RT_NULL)\n        {\n            rt_kprintf(\"Not Found\\r\\n\");\n            return;\n        }\n        if(rt_device_open(dev, RT_DEVICE_FLAG_RDWR) != RT_EOK)\n        {\n            rt_kprintf(\"Open Error\\r\\n\");\n            return;\n        }\n    \n        rt_device_control(dev, RT_SENSOR_CTRL_SET_ODR, (void *)&get_data_freq);\n    ```\n\n##### **读取传感器数据**\n\n```C\n /*读取传感器*/\n    while(1)\n    {\n        res = rt_device_read(dev, 0, &sensor_data, 1);//第0位开始读一个\n        //读错了返回0\n        if(res == 0)\n        {\n            rt_kprintf(\"Read Error Res:%d\",res);//返回读取错误编号0\n            return;\n        }\n        else //读取成功\n        {\n            if(sensor_data.data.temp >= 0) //数据大于等于0 包括了温度与湿度\n            {\n                uint8_t temp = (sensor_data.data.temp & 0xffff);\n                uint8_t humi = (sensor_data.data.temp & 0xffff0000) >> 16;\n                rt_kprintf(\"temp:%d humi:%d\\r\\n\",temp,humi);\n            }\n        }\n        rt_thread_delay(1000);\n    }\n```\n\n##### **init代码构建**\n\n```C\nint sensor_init(void)\n{\n    struct rt_sensor_config cfg;//操作集结构体\n    /*注册设备 配置接口*/\n    cfg.intf.user_data = (void *)DHT11_PIN;//配置接口为IO口\n    rt_hw_dht11_init(\"dht11\", &cfg);\n\n    rt_thread_t sensor_thread = rt_thread_create(\"sensor_proc\", sensor_proc, RT_NULL, 1024, 10, 20);\n    if(sensor_thread != RT_NULL)\n    {\n        rt_thread_startup(sensor_thread);\n    }\n    return RT_EOK;\n}\nINIT_COMPONENT_EXPORT(sensor_init);\n```\n\n","tags":["RTOS","实时操作系统","RT_Thread"],"categories":["MCU"]},{"title":"git命令(用于hexo clean之后的处理)","url":"/2025/05/20/git/","content":"\n## 连接远程仓库\n\n```C\ngit init\ngit remote add origin [dizhi]\ngit checkout -b main                  \n```\n\n## 推送代码\n\n```c\ngit add .\ngit commit -m \"\"\ngit push --force origin main \t#后续可以直接用git push\n```\n\n## 如何建立一个多人写作的git仓库？\n\n### 1. **新建Git仓库**\n\n- **在本地创建仓库**：\n\n  ```bash\n  mkdir my_project\n  cd my_project\n  git init\n  ```\n\n- **或者在GitHub/GitLab等平台创建仓库**：如果你使用的是GitHub、GitLab等托管服务，可以直接在网页端创建仓库，然后克隆到本地：\n\n  ```bash\n  git clone https://github.com/your-username/my_project.git\n  cd my_project\n  ```\n\n### 2. **他人参与协作**\n\n- **邀请他人访问仓库**：\n\n  - 如果是GitHub，可以在仓库设置中添加协作者（Collaborator）。\n  - 如果是GitLab，可以在项目成员管理中添加成员。\n\n- **他人克隆仓库**：\n\n  ```bash\n  git clone https://github.com/your-username/my_project.git\n  cd my_project\n  ```\n\n### 3. **他人创建分支并上传代码**\n\n- **他人创建分支**：\n\n  ```bash\n  git checkout -b fenzhiname\n  ```\n\n  `fenzhinamme指的是自定义分支名`\n\n- **他人修改代码并提交**：\n\n  ```bash\n  git add .\n  git commit -m \"Add new feature\"\n  ```\n\n- **他人将分支推送到远程仓库**：\n\n  ```bash\n  git push origin fenzhiname\n  ```\n\n### 4. **你合并分支**\n\n- **同步并重置 main**：\n\n  ```bash\n  git fetch origin\n  git checkout main\n  git reset --hard origin/main\n  ```\n\n- **合并**：\n\n  ```bash\n  git merge origin/wpy_app --allow-unrelated-histories\n  ```\n\n- **解决冲突（如果有）并推送**：\n\n  ```bash\n  git push origin main\n  ```\n\n  \n","tags":["git"]},{"title":"音响实习の学习笔记","url":"/2025/05/19/音响实习/","content":"\n## 麦克风-话筒\n\n### 分类\n\n| 类型         | 优点                 | 缺点                 | 典型用途                 |\n| ------------ | -------------------- | -------------------- | ------------------------ |\n| **动圈话筒** | 耐用、抗啸叫、便宜   | 灵敏度低、高频细节少 | 现场演出、演讲、鼓麦克风 |\n| **电容话筒** | 高解析度、瞬态响应好 | 易受潮、需外部供电   | 录音棚、人声、乐器收音   |\n| **USB 话筒** | 即插即用、内置声卡   | 延迟较高、不可扩展   | 直播、播客、家庭录音     |\n| **领夹话筒** | 隐蔽、解放双手       | 易摩擦衣物产生噪音   | 视频拍摄、舞台剧         |\n| **枪式话筒** | 远距离定向拾音       | 环境反射影响音质     | 影视同期声、户外采访     |\n\n### 核心参数\n\n#### **频率响应（麦克风对不同频率声音的灵敏度变化曲线）：**\n\n- **理想范围**：人声录制建议 **80Hz-15kHz**，乐器需更宽（如 20Hz-20kHz）。\n- **曲线特性**：平直曲线适合真实还原，高频提升（如 AKG C414）可增强人声明亮度。\n\n#### **灵敏度（Sensitivity）**\n\n- 单位：**mV/Pa** 或 **dBV**（如-32dB > -40dB，<span style=\"color:#FF00FF;\">数值越高越灵敏</span>）。\n- **高灵敏度**：电容麦适合细节捕捉，但易收环境噪音；`一般在-30dB到-40dB`\n- **低灵敏度**：动圈麦抗噪强，适合现场演出。`一般在-54dB到-60dB`\n- **重要规律**：\n  ▶ 每增加 **6dB**，灵敏度翻倍（-38dB 比-44dB 灵敏 2 倍）\n\n#### **指向性（Polar Pattern)**\n\n- **心形（Cardioid）**：最常用，抑制后方噪音，适合独唱/演讲。`像\"手电筒光斑\"，正前方收音最强`\n- **超心形（Supercardioid）**：定向更强，适合嘈杂环境或远距离拾音。`光束更窄，但后方会出现\"小耳朵\"（微弱拾音区）`\n- **全向（Omni）**：360° 拾音，适合会议或合唱，但需安静环境。`像\"灯泡发光\"，360°均匀拾音`\n\n> 血泪教训：\n>\n> - 室内直播用 **心形**→ 抑制显示器风扇噪音\n> - 街头采访用 **超心形**→ 对抗环境噪音\n\n![0679D9F9](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505201936187.gif)\n\n#### **最大声压级（Max SPL）**\n\n- 动圈麦（如 Shure SM58）可承受 **150dB**，适合高音量乐器（如鼓）；电容麦通常 **120-130dB**，需注意过载。\n- 普通说话/弹唱：**100dB** 足够\n  **隐藏陷阱**：\n  某些电容麦标称高 SPL，但需要开启-10dB 衰减档（实质是压缩动态）\n\n![067E4DAE](https://cdn.jsdelivr.net/gh/2250272571/tuchuang@main/img/202505201939640.gif)\n\n#### **信噪比（SNR）**\n\n- 假设麦克风输出信号 **-32dB**，底噪 **-82dB**\n- 信噪比 = **50dB**（-32 - (-82)）\n- **>70dB** 为佳，数值越高背景噪音越少。`60dB以上：专业级（几乎无底噪）` `50dB以下：能听到明显\"嘶嘶\"声`\n\n#### **阻抗（Impedance）**\n\n- 麦克风输出阻抗 **≤200Ω** 为低阻（适合长线缆传输）`阻抗越低，音量越小，音质越好。阻抗越高，音量越大，但容易失真`\n- 输入设备阻抗需 ≥5 倍麦克风阻抗（如麦克风 200Ω→ 声卡输入要 1kΩ）\n  **常见翻车现场**：\n  高阻麦克风（600Ω）接普通声卡 → 声音发闷/音量小\n\n### **终极避坑口诀**\n\n> 频响看曲线，灵敏看负数\n> 指向分角度，声压看极限\n> 信噪比 60 起，阻抗要低阻\n> 找 U 型麦克风（低频不容易影响）\n\n### 采购清单\n\n- 阻抗300Ω      心形         \n\n  | 话筒链接                                                     | 频响范围（Hz） | 阻抗（单位Ω） | 指向性 | 信噪比(单位dB) | 灵敏度 | 续航时长(单位h) | 价格（一拖二）           |\n  | ------------------------------------------------------------ | -------------- | ------------- | ------ | -------------- | ------ | --------------- | ------------------------ |\n  | [2.4g无线麦克风万能防啸叫 舞台k歌充电话筒声卡直播麦克风跨境 - 阿里巴巴](https://detail.1688.com/offer/792895999197.html?spm=a262uh.11734178.favorite-offers-offer-list-offer4.2.52422ef6AHREZ4) | 100-20kHz      | 300           | 心形   | ≥75dB          |        | 12              | 102.7+3（109高配好音质） |\n  | [无线麦克风家用K歌金属U段一拖二音响直播声卡录音高音质充电话筒 - 阿里巴巴](https://detail.1688.com/offer/809251918462.html?spm=a262uh.11734178.favorite-offers-offer-list-offer3.2.52422ef6AHREZ4) | 100-20kHz      |               | 心形   | ≥70db          |        | 6-8h(含)        | 95+8                     |\n  | [跨境无线麦克风话筒U段直播防啸叫一拖二ktv家用唱歌专用无线话筒 - 阿里巴巴](https://detail.1688.com/offer/910830646473.html?spm=a262uh.11734178.favorite-offers-offer-list-offer5.2.52422ef6AHREZ4) | 100-20kHz      | 600Ω          | 心型   | ≥85dB          |        | 1-3h(含)        | 68+5                     |\n  | [<span style=\"color:#33FFFF;\">全金属U段无线话筒一拖二KTV家用唱歌声卡直播功放音响通用麦克风 - 阿里巴巴</span>](https://detail.1688.com/offer/731692801179.html?spm=a262uh.11734178.favorite-offers-offer-list-offer2.2.52422ef6AHREZ4) | 30-20kHz       |               | 心型   | >95dB          |        | 3-6h(含)        | 145+5                    |\n  | [无线麦克风充电防啸叫 户外声卡直播麦克风家用音响k歌舞台话筒 - 阿里巴巴](https://detail.1688.com/offer/683303536027.html?spm=a262uh.11734178.favorite-offers-offer-list-offer1.2.52422ef6AHREZ4) | 80Hz-15kHz     |               | 心型   | \\>60dB         | -70dB  |                 | 70.2+3（VHF方案）        |\n\n   \n","tags":["音响","实习","音频技术"],"categories":["实习知识"]}]